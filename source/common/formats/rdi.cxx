// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rdi.hxx"

// image_info_t
// 

const image_info_t::Study_Name_type& image_info_t::
Study_Name () const
{
  return this->Study_Name_.get ();
}

image_info_t::Study_Name_type& image_info_t::
Study_Name ()
{
  return this->Study_Name_.get ();
}

void image_info_t::
Study_Name (const Study_Name_type& x)
{
  this->Study_Name_.set (x);
}

void image_info_t::
Study_Name (::std::auto_ptr< Study_Name_type > x)
{
  this->Study_Name_.set (x);
}

const image_info_t::Image_Id_optional& image_info_t::
Image_Id () const
{
  return this->Image_Id_;
}

image_info_t::Image_Id_optional& image_info_t::
Image_Id ()
{
  return this->Image_Id_;
}

void image_info_t::
Image_Id (const Image_Id_type& x)
{
  this->Image_Id_.set (x);
}

void image_info_t::
Image_Id (const Image_Id_optional& x)
{
  this->Image_Id_ = x;
}

void image_info_t::
Image_Id (::std::auto_ptr< Image_Id_type > x)
{
  this->Image_Id_.set (x);
}

const image_info_t::Image_Label_type& image_info_t::
Image_Label () const
{
  return this->Image_Label_.get ();
}

image_info_t::Image_Label_type& image_info_t::
Image_Label ()
{
  return this->Image_Label_.get ();
}

void image_info_t::
Image_Label (const Image_Label_type& x)
{
  this->Image_Label_.set (x);
}

void image_info_t::
Image_Label (::std::auto_ptr< Image_Label_type > x)
{
  this->Image_Label_.set (x);
}

const image_info_t::Image_Frames_type& image_info_t::
Image_Frames () const
{
  return this->Image_Frames_.get ();
}

image_info_t::Image_Frames_type& image_info_t::
Image_Frames ()
{
  return this->Image_Frames_.get ();
}

void image_info_t::
Image_Frames (const Image_Frames_type& x)
{
  this->Image_Frames_.set (x);
}

const image_info_t::Image_Lines_type& image_info_t::
Image_Lines () const
{
  return this->Image_Lines_.get ();
}

image_info_t::Image_Lines_type& image_info_t::
Image_Lines ()
{
  return this->Image_Lines_.get ();
}

void image_info_t::
Image_Lines (const Image_Lines_type& x)
{
  this->Image_Lines_.set (x);
}

const image_info_t::Image_Acquisition_Per_Line_type& image_info_t::
Image_Acquisition_Per_Line () const
{
  return this->Image_Acquisition_Per_Line_.get ();
}

image_info_t::Image_Acquisition_Per_Line_type& image_info_t::
Image_Acquisition_Per_Line ()
{
  return this->Image_Acquisition_Per_Line_.get ();
}

void image_info_t::
Image_Acquisition_Per_Line (const Image_Acquisition_Per_Line_type& x)
{
  this->Image_Acquisition_Per_Line_.set (x);
}

const image_info_t::Image_Acquisition_Size_type& image_info_t::
Image_Acquisition_Size () const
{
  return this->Image_Acquisition_Size_.get ();
}

image_info_t::Image_Acquisition_Size_type& image_info_t::
Image_Acquisition_Size ()
{
  return this->Image_Acquisition_Size_.get ();
}

void image_info_t::
Image_Acquisition_Size (const Image_Acquisition_Size_type& x)
{
  this->Image_Acquisition_Size_.set (x);
}

const image_info_t::Animal_ID_type& image_info_t::
Animal_ID () const
{
  return this->Animal_ID_.get ();
}

image_info_t::Animal_ID_type& image_info_t::
Animal_ID ()
{
  return this->Animal_ID_.get ();
}

void image_info_t::
Animal_ID (const Animal_ID_type& x)
{
  this->Animal_ID_.set (x);
}

void image_info_t::
Animal_ID (::std::auto_ptr< Animal_ID_type > x)
{
  this->Animal_ID_.set (x);
}

const image_info_t::Acquisition_Mode_type& image_info_t::
Acquisition_Mode () const
{
  return this->Acquisition_Mode_.get ();
}

image_info_t::Acquisition_Mode_type& image_info_t::
Acquisition_Mode ()
{
  return this->Acquisition_Mode_.get ();
}

void image_info_t::
Acquisition_Mode (const Acquisition_Mode_type& x)
{
  this->Acquisition_Mode_.set (x);
}

void image_info_t::
Acquisition_Mode (::std::auto_ptr< Acquisition_Mode_type > x)
{
  this->Acquisition_Mode_.set (x);
}

const image_info_t::Acquisition_Date_type& image_info_t::
Acquisition_Date () const
{
  return this->Acquisition_Date_.get ();
}

image_info_t::Acquisition_Date_type& image_info_t::
Acquisition_Date ()
{
  return this->Acquisition_Date_.get ();
}

void image_info_t::
Acquisition_Date (const Acquisition_Date_type& x)
{
  this->Acquisition_Date_.set (x);
}

void image_info_t::
Acquisition_Date (::std::auto_ptr< Acquisition_Date_type > x)
{
  this->Acquisition_Date_.set (x);
}

const image_info_t::Acquisition_Time_type& image_info_t::
Acquisition_Time () const
{
  return this->Acquisition_Time_.get ();
}

image_info_t::Acquisition_Time_type& image_info_t::
Acquisition_Time ()
{
  return this->Acquisition_Time_.get ();
}

void image_info_t::
Acquisition_Time (const Acquisition_Time_type& x)
{
  this->Acquisition_Time_.set (x);
}

void image_info_t::
Acquisition_Time (::std::auto_ptr< Acquisition_Time_type > x)
{
  this->Acquisition_Time_.set (x);
}

const image_info_t::Acquisition_Operator_type& image_info_t::
Acquisition_Operator () const
{
  return this->Acquisition_Operator_.get ();
}

image_info_t::Acquisition_Operator_type& image_info_t::
Acquisition_Operator ()
{
  return this->Acquisition_Operator_.get ();
}

void image_info_t::
Acquisition_Operator (const Acquisition_Operator_type& x)
{
  this->Acquisition_Operator_.set (x);
}

void image_info_t::
Acquisition_Operator (::std::auto_ptr< Acquisition_Operator_type > x)
{
  this->Acquisition_Operator_.set (x);
}


// image_data_t
// 


// image_parameters_t
// 

const image_parameters_t::RF_Mode_type& image_parameters_t::
RF_Mode () const
{
  return this->RF_Mode_.get ();
}

image_parameters_t::RF_Mode_type& image_parameters_t::
RF_Mode ()
{
  return this->RF_Mode_.get ();
}

void image_parameters_t::
RF_Mode (const RF_Mode_type& x)
{
  this->RF_Mode_.set (x);
}

void image_parameters_t::
RF_Mode (::std::auto_ptr< RF_Mode_type > x)
{
  this->RF_Mode_.set (x);
}

const image_parameters_t::B_Mode_type& image_parameters_t::
B_Mode () const
{
  return this->B_Mode_.get ();
}

image_parameters_t::B_Mode_type& image_parameters_t::
B_Mode ()
{
  return this->B_Mode_.get ();
}

void image_parameters_t::
B_Mode (const B_Mode_type& x)
{
  this->B_Mode_.set (x);
}

void image_parameters_t::
B_Mode (::std::auto_ptr< B_Mode_type > x)
{
  this->B_Mode_.set (x);
}


// rdi_t
// 

const rdi_t::image_info_type& rdi_t::
image_info () const
{
  return this->image_info_.get ();
}

rdi_t::image_info_type& rdi_t::
image_info ()
{
  return this->image_info_.get ();
}

void rdi_t::
image_info (const image_info_type& x)
{
  this->image_info_.set (x);
}

void rdi_t::
image_info (::std::auto_ptr< image_info_type > x)
{
  this->image_info_.set (x);
}

const rdi_t::image_data_type& rdi_t::
image_data () const
{
  return this->image_data_.get ();
}

rdi_t::image_data_type& rdi_t::
image_data ()
{
  return this->image_data_.get ();
}

void rdi_t::
image_data (const image_data_type& x)
{
  this->image_data_.set (x);
}

void rdi_t::
image_data (::std::auto_ptr< image_data_type > x)
{
  this->image_data_.set (x);
}

const rdi_t::image_parameters_type& rdi_t::
image_parameters () const
{
  return this->image_parameters_.get ();
}

rdi_t::image_parameters_type& rdi_t::
image_parameters ()
{
  return this->image_parameters_.get ();
}

void rdi_t::
image_parameters (const image_parameters_type& x)
{
  this->image_parameters_.set (x);
}

void rdi_t::
image_parameters (::std::auto_ptr< image_parameters_type > x)
{
  this->image_parameters_.set (x);
}


// RF_Mode
// 

const RF_Mode::ActiveProbe_type& RF_Mode::
ActiveProbe () const
{
  return this->ActiveProbe_.get ();
}

RF_Mode::ActiveProbe_type& RF_Mode::
ActiveProbe ()
{
  return this->ActiveProbe_.get ();
}

void RF_Mode::
ActiveProbe (const ActiveProbe_type& x)
{
  this->ActiveProbe_.set (x);
}

void RF_Mode::
ActiveProbe (::std::auto_ptr< ActiveProbe_type > x)
{
  this->ActiveProbe_.set (x);
}

const RF_Mode::BModeSoft_type& RF_Mode::
BModeSoft () const
{
  return this->BModeSoft_.get ();
}

RF_Mode::BModeSoft_type& RF_Mode::
BModeSoft ()
{
  return this->BModeSoft_.get ();
}

void RF_Mode::
BModeSoft (const BModeSoft_type& x)
{
  this->BModeSoft_.set (x);
}

void RF_Mode::
BModeSoft (::std::auto_ptr< BModeSoft_type > x)
{
  this->BModeSoft_.set (x);
}

const RF_Mode::Sys_type& RF_Mode::
Sys () const
{
  return this->Sys_.get ();
}

RF_Mode::Sys_type& RF_Mode::
Sys ()
{
  return this->Sys_.get ();
}

void RF_Mode::
Sys (const Sys_type& x)
{
  this->Sys_.set (x);
}

void RF_Mode::
Sys (::std::auto_ptr< Sys_type > x)
{
  this->Sys_.set (x);
}

const RF_Mode::MIS_type& RF_Mode::
MIS () const
{
  return this->MIS_.get ();
}

RF_Mode::MIS_type& RF_Mode::
MIS ()
{
  return this->MIS_.get ();
}

void RF_Mode::
MIS (const MIS_type& x)
{
  this->MIS_.set (x);
}

void RF_Mode::
MIS (::std::auto_ptr< MIS_type > x)
{
  this->MIS_.set (x);
}

const RF_Mode::Scan_type& RF_Mode::
Scan () const
{
  return this->Scan_.get ();
}

RF_Mode::Scan_type& RF_Mode::
Scan ()
{
  return this->Scan_.get ();
}

void RF_Mode::
Scan (const Scan_type& x)
{
  this->Scan_.set (x);
}

void RF_Mode::
Scan (::std::auto_ptr< Scan_type > x)
{
  this->Scan_.set (x);
}

const RF_Mode::Motor_type& RF_Mode::
Motor () const
{
  return this->Motor_.get ();
}

RF_Mode::Motor_type& RF_Mode::
Motor ()
{
  return this->Motor_.get ();
}

void RF_Mode::
Motor (const Motor_type& x)
{
  this->Motor_.set (x);
}

void RF_Mode::
Motor (::std::auto_ptr< Motor_type > x)
{
  this->Motor_.set (x);
}

const RF_Mode::Diag_type& RF_Mode::
Diag () const
{
  return this->Diag_.get ();
}

RF_Mode::Diag_type& RF_Mode::
Diag ()
{
  return this->Diag_.get ();
}

void RF_Mode::
Diag (const Diag_type& x)
{
  this->Diag_.set (x);
}

void RF_Mode::
Diag (::std::auto_ptr< Diag_type > x)
{
  this->Diag_.set (x);
}

const RF_Mode::ECG_type& RF_Mode::
ECG () const
{
  return this->ECG_.get ();
}

RF_Mode::ECG_type& RF_Mode::
ECG ()
{
  return this->ECG_.get ();
}

void RF_Mode::
ECG (const ECG_type& x)
{
  this->ECG_.set (x);
}

void RF_Mode::
ECG (::std::auto_ptr< ECG_type > x)
{
  this->ECG_.set (x);
}

const RF_Mode::RfModeSoft_type& RF_Mode::
RfModeSoft () const
{
  return this->RfModeSoft_.get ();
}

RF_Mode::RfModeSoft_type& RF_Mode::
RfModeSoft ()
{
  return this->RfModeSoft_.get ();
}

void RF_Mode::
RfModeSoft (const RfModeSoft_type& x)
{
  this->RfModeSoft_.set (x);
}

void RF_Mode::
RfModeSoft (::std::auto_ptr< RfModeSoft_type > x)
{
  this->RfModeSoft_.set (x);
}

const RF_Mode::TX_type& RF_Mode::
TX () const
{
  return this->TX_.get ();
}

RF_Mode::TX_type& RF_Mode::
TX ()
{
  return this->TX_.get ();
}

void RF_Mode::
TX (const TX_type& x)
{
  this->TX_.set (x);
}

void RF_Mode::
TX (::std::auto_ptr< TX_type > x)
{
  this->TX_.set (x);
}

const RF_Mode::X_3D_type& RF_Mode::
X_3D () const
{
  return this->X_3D_.get ();
}

RF_Mode::X_3D_type& RF_Mode::
X_3D ()
{
  return this->X_3D_.get ();
}

void RF_Mode::
X_3D (const X_3D_type& x)
{
  this->X_3D_.set (x);
}

void RF_Mode::
X_3D (::std::auto_ptr< X_3D_type > x)
{
  this->X_3D_.set (x);
}

const RF_Mode::RfAnalysis_type& RF_Mode::
RfAnalysis () const
{
  return this->RfAnalysis_.get ();
}

RF_Mode::RfAnalysis_type& RF_Mode::
RfAnalysis ()
{
  return this->RfAnalysis_.get ();
}

void RF_Mode::
RfAnalysis (const RfAnalysis_type& x)
{
  this->RfAnalysis_.set (x);
}

void RF_Mode::
RfAnalysis (::std::auto_ptr< RfAnalysis_type > x)
{
  this->RfAnalysis_.set (x);
}

const RF_Mode::RX_type& RF_Mode::
RX () const
{
  return this->RX_.get ();
}

RF_Mode::RX_type& RF_Mode::
RX ()
{
  return this->RX_.get ();
}

void RF_Mode::
RX (const RX_type& x)
{
  this->RX_.set (x);
}

void RF_Mode::
RX (::std::auto_ptr< RX_type > x)
{
  this->RX_.set (x);
}

const RF_Mode::Display_type& RF_Mode::
Display () const
{
  return this->Display_.get ();
}

RF_Mode::Display_type& RF_Mode::
Display ()
{
  return this->Display_.get ();
}

void RF_Mode::
Display (const Display_type& x)
{
  this->Display_.set (x);
}

void RF_Mode::
Display (::std::auto_ptr< Display_type > x)
{
  this->Display_.set (x);
}

const RF_Mode::Acqiris_type& RF_Mode::
Acqiris () const
{
  return this->Acqiris_.get ();
}

RF_Mode::Acqiris_type& RF_Mode::
Acqiris ()
{
  return this->Acqiris_.get ();
}

void RF_Mode::
Acqiris (const Acqiris_type& x)
{
  this->Acqiris_.set (x);
}

void RF_Mode::
Acqiris (::std::auto_ptr< Acqiris_type > x)
{
  this->Acqiris_.set (x);
}


// B_Mode
// 

const B_Mode::ActiveProbe_type& B_Mode::
ActiveProbe () const
{
  return this->ActiveProbe_.get ();
}

B_Mode::ActiveProbe_type& B_Mode::
ActiveProbe ()
{
  return this->ActiveProbe_.get ();
}

void B_Mode::
ActiveProbe (const ActiveProbe_type& x)
{
  this->ActiveProbe_.set (x);
}

void B_Mode::
ActiveProbe (::std::auto_ptr< ActiveProbe_type > x)
{
  this->ActiveProbe_.set (x);
}

const B_Mode::BModeSoft_type& B_Mode::
BModeSoft () const
{
  return this->BModeSoft_.get ();
}

B_Mode::BModeSoft_type& B_Mode::
BModeSoft ()
{
  return this->BModeSoft_.get ();
}

void B_Mode::
BModeSoft (const BModeSoft_type& x)
{
  this->BModeSoft_.set (x);
}

void B_Mode::
BModeSoft (::std::auto_ptr< BModeSoft_type > x)
{
  this->BModeSoft_.set (x);
}

const B_Mode::Sys_type& B_Mode::
Sys () const
{
  return this->Sys_.get ();
}

B_Mode::Sys_type& B_Mode::
Sys ()
{
  return this->Sys_.get ();
}

void B_Mode::
Sys (const Sys_type& x)
{
  this->Sys_.set (x);
}

void B_Mode::
Sys (::std::auto_ptr< Sys_type > x)
{
  this->Sys_.set (x);
}

const B_Mode::Contrast_type& B_Mode::
Contrast () const
{
  return this->Contrast_.get ();
}

B_Mode::Contrast_type& B_Mode::
Contrast ()
{
  return this->Contrast_.get ();
}

void B_Mode::
Contrast (const Contrast_type& x)
{
  this->Contrast_.set (x);
}

void B_Mode::
Contrast (::std::auto_ptr< Contrast_type > x)
{
  this->Contrast_.set (x);
}

const B_Mode::MIS_type& B_Mode::
MIS () const
{
  return this->MIS_.get ();
}

B_Mode::MIS_type& B_Mode::
MIS ()
{
  return this->MIS_.get ();
}

void B_Mode::
MIS (const MIS_type& x)
{
  this->MIS_.set (x);
}

void B_Mode::
MIS (::std::auto_ptr< MIS_type > x)
{
  this->MIS_.set (x);
}

const B_Mode::Scan_type& B_Mode::
Scan () const
{
  return this->Scan_.get ();
}

B_Mode::Scan_type& B_Mode::
Scan ()
{
  return this->Scan_.get ();
}

void B_Mode::
Scan (const Scan_type& x)
{
  this->Scan_.set (x);
}

void B_Mode::
Scan (::std::auto_ptr< Scan_type > x)
{
  this->Scan_.set (x);
}

const B_Mode::Motor_type& B_Mode::
Motor () const
{
  return this->Motor_.get ();
}

B_Mode::Motor_type& B_Mode::
Motor ()
{
  return this->Motor_.get ();
}

void B_Mode::
Motor (const Motor_type& x)
{
  this->Motor_.set (x);
}

void B_Mode::
Motor (::std::auto_ptr< Motor_type > x)
{
  this->Motor_.set (x);
}

const B_Mode::ContrastDlg_type& B_Mode::
ContrastDlg () const
{
  return this->ContrastDlg_.get ();
}

B_Mode::ContrastDlg_type& B_Mode::
ContrastDlg ()
{
  return this->ContrastDlg_.get ();
}

void B_Mode::
ContrastDlg (const ContrastDlg_type& x)
{
  this->ContrastDlg_.set (x);
}

void B_Mode::
ContrastDlg (::std::auto_ptr< ContrastDlg_type > x)
{
  this->ContrastDlg_.set (x);
}

const B_Mode::Diag_type& B_Mode::
Diag () const
{
  return this->Diag_.get ();
}

B_Mode::Diag_type& B_Mode::
Diag ()
{
  return this->Diag_.get ();
}

void B_Mode::
Diag (const Diag_type& x)
{
  this->Diag_.set (x);
}

void B_Mode::
Diag (::std::auto_ptr< Diag_type > x)
{
  this->Diag_.set (x);
}

const B_Mode::ECG_type& B_Mode::
ECG () const
{
  return this->ECG_.get ();
}

B_Mode::ECG_type& B_Mode::
ECG ()
{
  return this->ECG_.get ();
}

void B_Mode::
ECG (const ECG_type& x)
{
  this->ECG_.set (x);
}

void B_Mode::
ECG (::std::auto_ptr< ECG_type > x)
{
  this->ECG_.set (x);
}

const B_Mode::TX_type& B_Mode::
TX () const
{
  return this->TX_.get ();
}

B_Mode::TX_type& B_Mode::
TX ()
{
  return this->TX_.get ();
}

void B_Mode::
TX (const TX_type& x)
{
  this->TX_.set (x);
}

void B_Mode::
TX (::std::auto_ptr< TX_type > x)
{
  this->TX_.set (x);
}

const B_Mode::ContrastDestroy_type& B_Mode::
ContrastDestroy () const
{
  return this->ContrastDestroy_.get ();
}

B_Mode::ContrastDestroy_type& B_Mode::
ContrastDestroy ()
{
  return this->ContrastDestroy_.get ();
}

void B_Mode::
ContrastDestroy (const ContrastDestroy_type& x)
{
  this->ContrastDestroy_.set (x);
}

void B_Mode::
ContrastDestroy (::std::auto_ptr< ContrastDestroy_type > x)
{
  this->ContrastDestroy_.set (x);
}

const B_Mode::X_3D_type& B_Mode::
X_3D () const
{
  return this->X_3D_.get ();
}

B_Mode::X_3D_type& B_Mode::
X_3D ()
{
  return this->X_3D_.get ();
}

void B_Mode::
X_3D (const X_3D_type& x)
{
  this->X_3D_.set (x);
}

void B_Mode::
X_3D (::std::auto_ptr< X_3D_type > x)
{
  this->X_3D_.set (x);
}

const B_Mode::X_3DSoft_type& B_Mode::
X_3DSoft () const
{
  return this->X_3DSoft_.get ();
}

B_Mode::X_3DSoft_type& B_Mode::
X_3DSoft ()
{
  return this->X_3DSoft_.get ();
}

void B_Mode::
X_3DSoft (const X_3DSoft_type& x)
{
  this->X_3DSoft_.set (x);
}

void B_Mode::
X_3DSoft (::std::auto_ptr< X_3DSoft_type > x)
{
  this->X_3DSoft_.set (x);
}

const B_Mode::RX_type& B_Mode::
RX () const
{
  return this->RX_.get ();
}

B_Mode::RX_type& B_Mode::
RX ()
{
  return this->RX_.get ();
}

void B_Mode::
RX (const RX_type& x)
{
  this->RX_.set (x);
}

void B_Mode::
RX (::std::auto_ptr< RX_type > x)
{
  this->RX_.set (x);
}

const B_Mode::Display_type& B_Mode::
Display () const
{
  return this->Display_.get ();
}

B_Mode::Display_type& B_Mode::
Display ()
{
  return this->Display_.get ();
}

void B_Mode::
Display (const Display_type& x)
{
  this->Display_.set (x);
}

void B_Mode::
Display (::std::auto_ptr< Display_type > x)
{
  this->Display_.set (x);
}

const B_Mode::EKVModeSoft_type& B_Mode::
EKVModeSoft () const
{
  return this->EKVModeSoft_.get ();
}

B_Mode::EKVModeSoft_type& B_Mode::
EKVModeSoft ()
{
  return this->EKVModeSoft_.get ();
}

void B_Mode::
EKVModeSoft (const EKVModeSoft_type& x)
{
  this->EKVModeSoft_.set (x);
}

void B_Mode::
EKVModeSoft (::std::auto_ptr< EKVModeSoft_type > x)
{
  this->EKVModeSoft_.set (x);
}

const B_Mode::BModeLVAnalysis_type& B_Mode::
BModeLVAnalysis () const
{
  return this->BModeLVAnalysis_.get ();
}

B_Mode::BModeLVAnalysis_type& B_Mode::
BModeLVAnalysis ()
{
  return this->BModeLVAnalysis_.get ();
}

void B_Mode::
BModeLVAnalysis (const BModeLVAnalysis_type& x)
{
  this->BModeLVAnalysis_.set (x);
}

void B_Mode::
BModeLVAnalysis (::std::auto_ptr< BModeLVAnalysis_type > x)
{
  this->BModeLVAnalysis_.set (x);
}


// ActiveProbe
// 

const ActiveProbe::Notes_type& ActiveProbe::
Notes () const
{
  return this->Notes_.get ();
}

ActiveProbe::Notes_type& ActiveProbe::
Notes ()
{
  return this->Notes_.get ();
}

void ActiveProbe::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void ActiveProbe::
Notes (::std::auto_ptr< Notes_type > x)
{
  this->Notes_.set (x);
}

const ActiveProbe::Sample_Time_type& ActiveProbe::
Sample_Time () const
{
  return this->Sample_Time_.get ();
}

ActiveProbe::Sample_Time_type& ActiveProbe::
Sample_Time ()
{
  return this->Sample_Time_.get ();
}

void ActiveProbe::
Sample_Time (const Sample_Time_type& x)
{
  this->Sample_Time_.set (x);
}

void ActiveProbe::
Sample_Time (::std::auto_ptr< Sample_Time_type > x)
{
  this->Sample_Time_.set (x);
}

const ActiveProbe::Focal_Length_type& ActiveProbe::
Focal_Length () const
{
  return this->Focal_Length_.get ();
}

ActiveProbe::Focal_Length_type& ActiveProbe::
Focal_Length ()
{
  return this->Focal_Length_.get ();
}

void ActiveProbe::
Focal_Length (const Focal_Length_type& x)
{
  this->Focal_Length_.set (x);
}

void ActiveProbe::
Focal_Length (::std::auto_ptr< Focal_Length_type > x)
{
  this->Focal_Length_.set (x);
}

const ActiveProbe::Acceleration_Limit_Slope_type& ActiveProbe::
Acceleration_Limit_Slope () const
{
  return this->Acceleration_Limit_Slope_.get ();
}

ActiveProbe::Acceleration_Limit_Slope_type& ActiveProbe::
Acceleration_Limit_Slope ()
{
  return this->Acceleration_Limit_Slope_.get ();
}

void ActiveProbe::
Acceleration_Limit_Slope (const Acceleration_Limit_Slope_type& x)
{
  this->Acceleration_Limit_Slope_.set (x);
}

void ActiveProbe::
Acceleration_Limit_Slope (::std::auto_ptr< Acceleration_Limit_Slope_type > x)
{
  this->Acceleration_Limit_Slope_.set (x);
}

const ActiveProbe::Type_type& ActiveProbe::
Type () const
{
  return this->Type_.get ();
}

ActiveProbe::Type_type& ActiveProbe::
Type ()
{
  return this->Type_.get ();
}

void ActiveProbe::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void ActiveProbe::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const ActiveProbe::Detect_Id_type& ActiveProbe::
Detect_Id () const
{
  return this->Detect_Id_.get ();
}

ActiveProbe::Detect_Id_type& ActiveProbe::
Detect_Id ()
{
  return this->Detect_Id_.get ();
}

void ActiveProbe::
Detect_Id (const Detect_Id_type& x)
{
  this->Detect_Id_.set (x);
}

void ActiveProbe::
Detect_Id (::std::auto_ptr< Detect_Id_type > x)
{
  this->Detect_Id_.set (x);
}

const ActiveProbe::Default_Scan_Speed_type& ActiveProbe::
Default_Scan_Speed () const
{
  return this->Default_Scan_Speed_.get ();
}

ActiveProbe::Default_Scan_Speed_type& ActiveProbe::
Default_Scan_Speed ()
{
  return this->Default_Scan_Speed_.get ();
}

void ActiveProbe::
Default_Scan_Speed (const Default_Scan_Speed_type& x)
{
  this->Default_Scan_Speed_.set (x);
}

void ActiveProbe::
Default_Scan_Speed (::std::auto_ptr< Default_Scan_Speed_type > x)
{
  this->Default_Scan_Speed_.set (x);
}

const ActiveProbe::K1_Power_type& ActiveProbe::
K1_Power () const
{
  return this->K1_Power_.get ();
}

ActiveProbe::K1_Power_type& ActiveProbe::
K1_Power ()
{
  return this->K1_Power_.get ();
}

void ActiveProbe::
K1_Power (const K1_Power_type& x)
{
  this->K1_Power_.set (x);
}

void ActiveProbe::
K1_Power (::std::auto_ptr< K1_Power_type > x)
{
  this->K1_Power_.set (x);
}

const ActiveProbe::Cutoff_Scan_Speed_type& ActiveProbe::
Cutoff_Scan_Speed () const
{
  return this->Cutoff_Scan_Speed_.get ();
}

ActiveProbe::Cutoff_Scan_Speed_type& ActiveProbe::
Cutoff_Scan_Speed ()
{
  return this->Cutoff_Scan_Speed_.get ();
}

void ActiveProbe::
Cutoff_Scan_Speed (const Cutoff_Scan_Speed_type& x)
{
  this->Cutoff_Scan_Speed_.set (x);
}

void ActiveProbe::
Cutoff_Scan_Speed (::std::auto_ptr< Cutoff_Scan_Speed_type > x)
{
  this->Cutoff_Scan_Speed_.set (x);
}

const ActiveProbe::Frequency_Low_type& ActiveProbe::
Frequency_Low () const
{
  return this->Frequency_Low_.get ();
}

ActiveProbe::Frequency_Low_type& ActiveProbe::
Frequency_Low ()
{
  return this->Frequency_Low_.get ();
}

void ActiveProbe::
Frequency_Low (const Frequency_Low_type& x)
{
  this->Frequency_Low_.set (x);
}

void ActiveProbe::
Frequency_Low (::std::auto_ptr< Frequency_Low_type > x)
{
  this->Frequency_Low_.set (x);
}

const ActiveProbe::Default_FOV_type& ActiveProbe::
Default_FOV () const
{
  return this->Default_FOV_.get ();
}

ActiveProbe::Default_FOV_type& ActiveProbe::
Default_FOV ()
{
  return this->Default_FOV_.get ();
}

void ActiveProbe::
Default_FOV (const Default_FOV_type& x)
{
  this->Default_FOV_.set (x);
}

void ActiveProbe::
Default_FOV (::std::auto_ptr< Default_FOV_type > x)
{
  this->Default_FOV_.set (x);
}

const ActiveProbe::Frequency_Doppler_Default_type& ActiveProbe::
Frequency_Doppler_Default () const
{
  return this->Frequency_Doppler_Default_.get ();
}

ActiveProbe::Frequency_Doppler_Default_type& ActiveProbe::
Frequency_Doppler_Default ()
{
  return this->Frequency_Doppler_Default_.get ();
}

void ActiveProbe::
Frequency_Doppler_Default (const Frequency_Doppler_Default_type& x)
{
  this->Frequency_Doppler_Default_.set (x);
}

void ActiveProbe::
Frequency_Doppler_Default (::std::auto_ptr< Frequency_Doppler_Default_type > x)
{
  this->Frequency_Doppler_Default_.set (x);
}

const ActiveProbe::Default_SvSize_MMode_type& ActiveProbe::
Default_SvSize_MMode () const
{
  return this->Default_SvSize_MMode_.get ();
}

ActiveProbe::Default_SvSize_MMode_type& ActiveProbe::
Default_SvSize_MMode ()
{
  return this->Default_SvSize_MMode_.get ();
}

void ActiveProbe::
Default_SvSize_MMode (const Default_SvSize_MMode_type& x)
{
  this->Default_SvSize_MMode_.set (x);
}

void ActiveProbe::
Default_SvSize_MMode (::std::auto_ptr< Default_SvSize_MMode_type > x)
{
  this->Default_SvSize_MMode_.set (x);
}

const ActiveProbe::Axial_Res_Factor_Target_type& ActiveProbe::
Axial_Res_Factor_Target () const
{
  return this->Axial_Res_Factor_Target_.get ();
}

ActiveProbe::Axial_Res_Factor_Target_type& ActiveProbe::
Axial_Res_Factor_Target ()
{
  return this->Axial_Res_Factor_Target_.get ();
}

void ActiveProbe::
Axial_Res_Factor_Target (const Axial_Res_Factor_Target_type& x)
{
  this->Axial_Res_Factor_Target_.set (x);
}

void ActiveProbe::
Axial_Res_Factor_Target (::std::auto_ptr< Axial_Res_Factor_Target_type > x)
{
  this->Axial_Res_Factor_Target_.set (x);
}

const ActiveProbe::F_Number_type& ActiveProbe::
F_Number () const
{
  return this->F_Number_.get ();
}

ActiveProbe::F_Number_type& ActiveProbe::
F_Number ()
{
  return this->F_Number_.get ();
}

void ActiveProbe::
F_Number (const F_Number_type& x)
{
  this->F_Number_.set (x);
}

void ActiveProbe::
F_Number (::std::auto_ptr< F_Number_type > x)
{
  this->F_Number_.set (x);
}

const ActiveProbe::Acc_Time_Factor_type& ActiveProbe::
Acc_Time_Factor () const
{
  return this->Acc_Time_Factor_.get ();
}

ActiveProbe::Acc_Time_Factor_type& ActiveProbe::
Acc_Time_Factor ()
{
  return this->Acc_Time_Factor_.get ();
}

void ActiveProbe::
Acc_Time_Factor (const Acc_Time_Factor_type& x)
{
  this->Acc_Time_Factor_.set (x);
}

void ActiveProbe::
Acc_Time_Factor (::std::auto_ptr< Acc_Time_Factor_type > x)
{
  this->Acc_Time_Factor_.set (x);
}

const ActiveProbe::Frequency_Doppler_type& ActiveProbe::
Frequency_Doppler () const
{
  return this->Frequency_Doppler_.get ();
}

ActiveProbe::Frequency_Doppler_type& ActiveProbe::
Frequency_Doppler ()
{
  return this->Frequency_Doppler_.get ();
}

void ActiveProbe::
Frequency_Doppler (const Frequency_Doppler_type& x)
{
  this->Frequency_Doppler_.set (x);
}

void ActiveProbe::
Frequency_Doppler (::std::auto_ptr< Frequency_Doppler_type > x)
{
  this->Frequency_Doppler_.set (x);
}

const ActiveProbe::Axial_Res_type& ActiveProbe::
Axial_Res () const
{
  return this->Axial_Res_.get ();
}

ActiveProbe::Axial_Res_type& ActiveProbe::
Axial_Res ()
{
  return this->Axial_Res_.get ();
}

void ActiveProbe::
Axial_Res (const Axial_Res_type& x)
{
  this->Axial_Res_.set (x);
}

void ActiveProbe::
Axial_Res (::std::auto_ptr< Axial_Res_type > x)
{
  this->Axial_Res_.set (x);
}

const ActiveProbe::Detect_Ratio_Min_type& ActiveProbe::
Detect_Ratio_Min () const
{
  return this->Detect_Ratio_Min_.get ();
}

ActiveProbe::Detect_Ratio_Min_type& ActiveProbe::
Detect_Ratio_Min ()
{
  return this->Detect_Ratio_Min_.get ();
}

void ActiveProbe::
Detect_Ratio_Min (const Detect_Ratio_Min_type& x)
{
  this->Detect_Ratio_Min_.set (x);
}

void ActiveProbe::
Detect_Ratio_Min (::std::auto_ptr< Detect_Ratio_Min_type > x)
{
  this->Detect_Ratio_Min_.set (x);
}

const ActiveProbe::Lateral_Res_Factor_Target_type& ActiveProbe::
Lateral_Res_Factor_Target () const
{
  return this->Lateral_Res_Factor_Target_.get ();
}

ActiveProbe::Lateral_Res_Factor_Target_type& ActiveProbe::
Lateral_Res_Factor_Target ()
{
  return this->Lateral_Res_Factor_Target_.get ();
}

void ActiveProbe::
Lateral_Res_Factor_Target (const Lateral_Res_Factor_Target_type& x)
{
  this->Lateral_Res_Factor_Target_.set (x);
}

void ActiveProbe::
Lateral_Res_Factor_Target (::std::auto_ptr< Lateral_Res_Factor_Target_type > x)
{
  this->Lateral_Res_Factor_Target_.set (x);
}

const ActiveProbe::Derivative_Time_type& ActiveProbe::
Derivative_Time () const
{
  return this->Derivative_Time_.get ();
}

ActiveProbe::Derivative_Time_type& ActiveProbe::
Derivative_Time ()
{
  return this->Derivative_Time_.get ();
}

void ActiveProbe::
Derivative_Time (const Derivative_Time_type& x)
{
  this->Derivative_Time_.set (x);
}

void ActiveProbe::
Derivative_Time (::std::auto_ptr< Derivative_Time_type > x)
{
  this->Derivative_Time_.set (x);
}

const ActiveProbe::Filter_High_type& ActiveProbe::
Filter_High () const
{
  return this->Filter_High_.get ();
}

ActiveProbe::Filter_High_type& ActiveProbe::
Filter_High ()
{
  return this->Filter_High_.get ();
}

void ActiveProbe::
Filter_High (const Filter_High_type& x)
{
  this->Filter_High_.set (x);
}

void ActiveProbe::
Filter_High (::std::auto_ptr< Filter_High_type > x)
{
  this->Filter_High_.set (x);
}

const ActiveProbe::Pivot_Encoder_Dist_type& ActiveProbe::
Pivot_Encoder_Dist () const
{
  return this->Pivot_Encoder_Dist_.get ();
}

ActiveProbe::Pivot_Encoder_Dist_type& ActiveProbe::
Pivot_Encoder_Dist ()
{
  return this->Pivot_Encoder_Dist_.get ();
}

void ActiveProbe::
Pivot_Encoder_Dist (const Pivot_Encoder_Dist_type& x)
{
  this->Pivot_Encoder_Dist_.set (x);
}

void ActiveProbe::
Pivot_Encoder_Dist (::std::auto_ptr< Pivot_Encoder_Dist_type > x)
{
  this->Pivot_Encoder_Dist_.set (x);
}

const ActiveProbe::Encoder_Range_Max_type& ActiveProbe::
Encoder_Range_Max () const
{
  return this->Encoder_Range_Max_.get ();
}

ActiveProbe::Encoder_Range_Max_type& ActiveProbe::
Encoder_Range_Max ()
{
  return this->Encoder_Range_Max_.get ();
}

void ActiveProbe::
Encoder_Range_Max (const Encoder_Range_Max_type& x)
{
  this->Encoder_Range_Max_.set (x);
}

void ActiveProbe::
Encoder_Range_Max (::std::auto_ptr< Encoder_Range_Max_type > x)
{
  this->Encoder_Range_Max_.set (x);
}

const ActiveProbe::Encoder_Range_Min_type& ActiveProbe::
Encoder_Range_Min () const
{
  return this->Encoder_Range_Min_.get ();
}

ActiveProbe::Encoder_Range_Min_type& ActiveProbe::
Encoder_Range_Min ()
{
  return this->Encoder_Range_Min_.get ();
}

void ActiveProbe::
Encoder_Range_Min (const Encoder_Range_Min_type& x)
{
  this->Encoder_Range_Min_.set (x);
}

void ActiveProbe::
Encoder_Range_Min (::std::auto_ptr< Encoder_Range_Min_type > x)
{
  this->Encoder_Range_Min_.set (x);
}

const ActiveProbe::Lateral_Res_type& ActiveProbe::
Lateral_Res () const
{
  return this->Lateral_Res_.get ();
}

ActiveProbe::Lateral_Res_type& ActiveProbe::
Lateral_Res ()
{
  return this->Lateral_Res_.get ();
}

void ActiveProbe::
Lateral_Res (const Lateral_Res_type& x)
{
  this->Lateral_Res_.set (x);
}

void ActiveProbe::
Lateral_Res (::std::auto_ptr< Lateral_Res_type > x)
{
  this->Lateral_Res_.set (x);
}

const ActiveProbe::Motor_Overhead_type& ActiveProbe::
Motor_Overhead () const
{
  return this->Motor_Overhead_.get ();
}

ActiveProbe::Motor_Overhead_type& ActiveProbe::
Motor_Overhead ()
{
  return this->Motor_Overhead_.get ();
}

void ActiveProbe::
Motor_Overhead (const Motor_Overhead_type& x)
{
  this->Motor_Overhead_.set (x);
}

void ActiveProbe::
Motor_Overhead (::std::auto_ptr< Motor_Overhead_type > x)
{
  this->Motor_Overhead_.set (x);
}

const ActiveProbe::Max_Scan_Distance_type& ActiveProbe::
Max_Scan_Distance () const
{
  return this->Max_Scan_Distance_.get ();
}

ActiveProbe::Max_Scan_Distance_type& ActiveProbe::
Max_Scan_Distance ()
{
  return this->Max_Scan_Distance_.get ();
}

void ActiveProbe::
Max_Scan_Distance (const Max_Scan_Distance_type& x)
{
  this->Max_Scan_Distance_.set (x);
}

void ActiveProbe::
Max_Scan_Distance (::std::auto_ptr< Max_Scan_Distance_type > x)
{
  this->Max_Scan_Distance_.set (x);
}

const ActiveProbe::Version_type& ActiveProbe::
Version () const
{
  return this->Version_.get ();
}

ActiveProbe::Version_type& ActiveProbe::
Version ()
{
  return this->Version_.get ();
}

void ActiveProbe::
Version (const Version_type& x)
{
  this->Version_.set (x);
}

void ActiveProbe::
Version (::std::auto_ptr< Version_type > x)
{
  this->Version_.set (x);
}

const ActiveProbe::Default_Rx_Gain_type& ActiveProbe::
Default_Rx_Gain () const
{
  return this->Default_Rx_Gain_.get ();
}

ActiveProbe::Default_Rx_Gain_type& ActiveProbe::
Default_Rx_Gain ()
{
  return this->Default_Rx_Gain_.get ();
}

void ActiveProbe::
Default_Rx_Gain (const Default_Rx_Gain_type& x)
{
  this->Default_Rx_Gain_.set (x);
}

void ActiveProbe::
Default_Rx_Gain (::std::auto_ptr< Default_Rx_Gain_type > x)
{
  this->Default_Rx_Gain_.set (x);
}

const ActiveProbe::Filter_Low_type& ActiveProbe::
Filter_Low () const
{
  return this->Filter_Low_.get ();
}

ActiveProbe::Filter_Low_type& ActiveProbe::
Filter_Low ()
{
  return this->Filter_Low_.get ();
}

void ActiveProbe::
Filter_Low (const Filter_Low_type& x)
{
  this->Filter_Low_.set (x);
}

void ActiveProbe::
Filter_Low (::std::auto_ptr< Filter_Low_type > x)
{
  this->Filter_Low_.set (x);
}

const ActiveProbe::PID_KD_High_type& ActiveProbe::
PID_KD_High () const
{
  return this->PID_KD_High_.get ();
}

ActiveProbe::PID_KD_High_type& ActiveProbe::
PID_KD_High ()
{
  return this->PID_KD_High_.get ();
}

void ActiveProbe::
PID_KD_High (const PID_KD_High_type& x)
{
  this->PID_KD_High_.set (x);
}

void ActiveProbe::
PID_KD_High (::std::auto_ptr< PID_KD_High_type > x)
{
  this->PID_KD_High_.set (x);
}

const ActiveProbe::PID_KI_High_type& ActiveProbe::
PID_KI_High () const
{
  return this->PID_KI_High_.get ();
}

ActiveProbe::PID_KI_High_type& ActiveProbe::
PID_KI_High ()
{
  return this->PID_KI_High_.get ();
}

void ActiveProbe::
PID_KI_High (const PID_KI_High_type& x)
{
  this->PID_KI_High_.set (x);
}

void ActiveProbe::
PID_KI_High (::std::auto_ptr< PID_KI_High_type > x)
{
  this->PID_KI_High_.set (x);
}

const ActiveProbe::PID_KP_High_type& ActiveProbe::
PID_KP_High () const
{
  return this->PID_KP_High_.get ();
}

ActiveProbe::PID_KP_High_type& ActiveProbe::
PID_KP_High ()
{
  return this->PID_KP_High_.get ();
}

void ActiveProbe::
PID_KP_High (const PID_KP_High_type& x)
{
  this->PID_KP_High_.set (x);
}

void ActiveProbe::
PID_KP_High (::std::auto_ptr< PID_KP_High_type > x)
{
  this->PID_KP_High_.set (x);
}

const ActiveProbe::Frequency_High_type& ActiveProbe::
Frequency_High () const
{
  return this->Frequency_High_.get ();
}

ActiveProbe::Frequency_High_type& ActiveProbe::
Frequency_High ()
{
  return this->Frequency_High_.get ();
}

void ActiveProbe::
Frequency_High (const Frequency_High_type& x)
{
  this->Frequency_High_.set (x);
}

void ActiveProbe::
Frequency_High (::std::auto_ptr< Frequency_High_type > x)
{
  this->Frequency_High_.set (x);
}

const ActiveProbe::Lateral_Res_Factor_Max_type& ActiveProbe::
Lateral_Res_Factor_Max () const
{
  return this->Lateral_Res_Factor_Max_.get ();
}

ActiveProbe::Lateral_Res_Factor_Max_type& ActiveProbe::
Lateral_Res_Factor_Max ()
{
  return this->Lateral_Res_Factor_Max_.get ();
}

void ActiveProbe::
Lateral_Res_Factor_Max (const Lateral_Res_Factor_Max_type& x)
{
  this->Lateral_Res_Factor_Max_.set (x);
}

void ActiveProbe::
Lateral_Res_Factor_Max (::std::auto_ptr< Lateral_Res_Factor_Max_type > x)
{
  this->Lateral_Res_Factor_Max_.set (x);
}

const ActiveProbe::Scan_Speeds_type& ActiveProbe::
Scan_Speeds () const
{
  return this->Scan_Speeds_.get ();
}

ActiveProbe::Scan_Speeds_type& ActiveProbe::
Scan_Speeds ()
{
  return this->Scan_Speeds_.get ();
}

void ActiveProbe::
Scan_Speeds (const Scan_Speeds_type& x)
{
  this->Scan_Speeds_.set (x);
}

void ActiveProbe::
Scan_Speeds (::std::auto_ptr< Scan_Speeds_type > x)
{
  this->Scan_Speeds_.set (x);
}

const ActiveProbe::Filter_Doppler_Cutoff_type& ActiveProbe::
Filter_Doppler_Cutoff () const
{
  return this->Filter_Doppler_Cutoff_.get ();
}

ActiveProbe::Filter_Doppler_Cutoff_type& ActiveProbe::
Filter_Doppler_Cutoff ()
{
  return this->Filter_Doppler_Cutoff_.get ();
}

void ActiveProbe::
Filter_Doppler_Cutoff (const Filter_Doppler_Cutoff_type& x)
{
  this->Filter_Doppler_Cutoff_.set (x);
}

void ActiveProbe::
Filter_Doppler_Cutoff (::std::auto_ptr< Filter_Doppler_Cutoff_type > x)
{
  this->Filter_Doppler_Cutoff_.set (x);
}

const ActiveProbe::Name_type& ActiveProbe::
Name () const
{
  return this->Name_.get ();
}

ActiveProbe::Name_type& ActiveProbe::
Name ()
{
  return this->Name_.get ();
}

void ActiveProbe::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ActiveProbe::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const ActiveProbe::PID_KD_Low_type& ActiveProbe::
PID_KD_Low () const
{
  return this->PID_KD_Low_.get ();
}

ActiveProbe::PID_KD_Low_type& ActiveProbe::
PID_KD_Low ()
{
  return this->PID_KD_Low_.get ();
}

void ActiveProbe::
PID_KD_Low (const PID_KD_Low_type& x)
{
  this->PID_KD_Low_.set (x);
}

void ActiveProbe::
PID_KD_Low (::std::auto_ptr< PID_KD_Low_type > x)
{
  this->PID_KD_Low_.set (x);
}

const ActiveProbe::PID_KI_Low_type& ActiveProbe::
PID_KI_Low () const
{
  return this->PID_KI_Low_.get ();
}

ActiveProbe::PID_KI_Low_type& ActiveProbe::
PID_KI_Low ()
{
  return this->PID_KI_Low_.get ();
}

void ActiveProbe::
PID_KI_Low (const PID_KI_Low_type& x)
{
  this->PID_KI_Low_.set (x);
}

void ActiveProbe::
PID_KI_Low (::std::auto_ptr< PID_KI_Low_type > x)
{
  this->PID_KI_Low_.set (x);
}

const ActiveProbe::PID_KP_Low_type& ActiveProbe::
PID_KP_Low () const
{
  return this->PID_KP_Low_.get ();
}

ActiveProbe::PID_KP_Low_type& ActiveProbe::
PID_KP_Low ()
{
  return this->PID_KP_Low_.get ();
}

void ActiveProbe::
PID_KP_Low (const PID_KP_Low_type& x)
{
  this->PID_KP_Low_.set (x);
}

void ActiveProbe::
PID_KP_Low (::std::auto_ptr< PID_KP_Low_type > x)
{
  this->PID_KP_Low_.set (x);
}

const ActiveProbe::Peak_Bandwidth_Correction_type& ActiveProbe::
Peak_Bandwidth_Correction () const
{
  return this->Peak_Bandwidth_Correction_.get ();
}

ActiveProbe::Peak_Bandwidth_Correction_type& ActiveProbe::
Peak_Bandwidth_Correction ()
{
  return this->Peak_Bandwidth_Correction_.get ();
}

void ActiveProbe::
Peak_Bandwidth_Correction (const Peak_Bandwidth_Correction_type& x)
{
  this->Peak_Bandwidth_Correction_.set (x);
}

void ActiveProbe::
Peak_Bandwidth_Correction (::std::auto_ptr< Peak_Bandwidth_Correction_type > x)
{
  this->Peak_Bandwidth_Correction_.set (x);
}

const ActiveProbe::Frequency_Doppler_Low_type& ActiveProbe::
Frequency_Doppler_Low () const
{
  return this->Frequency_Doppler_Low_.get ();
}

ActiveProbe::Frequency_Doppler_Low_type& ActiveProbe::
Frequency_Doppler_Low ()
{
  return this->Frequency_Doppler_Low_.get ();
}

void ActiveProbe::
Frequency_Doppler_Low (const Frequency_Doppler_Low_type& x)
{
  this->Frequency_Doppler_Low_.set (x);
}

void ActiveProbe::
Frequency_Doppler_Low (::std::auto_ptr< Frequency_Doppler_Low_type > x)
{
  this->Frequency_Doppler_Low_.set (x);
}

const ActiveProbe::Pivot_Transducer_Face_Dist_type& ActiveProbe::
Pivot_Transducer_Face_Dist () const
{
  return this->Pivot_Transducer_Face_Dist_.get ();
}

ActiveProbe::Pivot_Transducer_Face_Dist_type& ActiveProbe::
Pivot_Transducer_Face_Dist ()
{
  return this->Pivot_Transducer_Face_Dist_.get ();
}

void ActiveProbe::
Pivot_Transducer_Face_Dist (const Pivot_Transducer_Face_Dist_type& x)
{
  this->Pivot_Transducer_Face_Dist_.set (x);
}

void ActiveProbe::
Pivot_Transducer_Face_Dist (::std::auto_ptr< Pivot_Transducer_Face_Dist_type > x)
{
  this->Pivot_Transducer_Face_Dist_.set (x);
}

const ActiveProbe::Filter_Doppler_type& ActiveProbe::
Filter_Doppler () const
{
  return this->Filter_Doppler_.get ();
}

ActiveProbe::Filter_Doppler_type& ActiveProbe::
Filter_Doppler ()
{
  return this->Filter_Doppler_.get ();
}

void ActiveProbe::
Filter_Doppler (const Filter_Doppler_type& x)
{
  this->Filter_Doppler_.set (x);
}

void ActiveProbe::
Filter_Doppler (::std::auto_ptr< Filter_Doppler_type > x)
{
  this->Filter_Doppler_.set (x);
}

const ActiveProbe::Frequency_type& ActiveProbe::
Frequency () const
{
  return this->Frequency_.get ();
}

ActiveProbe::Frequency_type& ActiveProbe::
Frequency ()
{
  return this->Frequency_.get ();
}

void ActiveProbe::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void ActiveProbe::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const ActiveProbe::Integration_Limit_type& ActiveProbe::
Integration_Limit () const
{
  return this->Integration_Limit_.get ();
}

ActiveProbe::Integration_Limit_type& ActiveProbe::
Integration_Limit ()
{
  return this->Integration_Limit_.get ();
}

void ActiveProbe::
Integration_Limit (const Integration_Limit_type& x)
{
  this->Integration_Limit_.set (x);
}

void ActiveProbe::
Integration_Limit (::std::auto_ptr< Integration_Limit_type > x)
{
  this->Integration_Limit_.set (x);
}

const ActiveProbe::Encoder_Separation_type& ActiveProbe::
Encoder_Separation () const
{
  return this->Encoder_Separation_.get ();
}

ActiveProbe::Encoder_Separation_type& ActiveProbe::
Encoder_Separation ()
{
  return this->Encoder_Separation_.get ();
}

void ActiveProbe::
Encoder_Separation (const Encoder_Separation_type& x)
{
  this->Encoder_Separation_.set (x);
}

void ActiveProbe::
Encoder_Separation (::std::auto_ptr< Encoder_Separation_type > x)
{
  this->Encoder_Separation_.set (x);
}

const ActiveProbe::Overshoot_type& ActiveProbe::
Overshoot () const
{
  return this->Overshoot_.get ();
}

ActiveProbe::Overshoot_type& ActiveProbe::
Overshoot ()
{
  return this->Overshoot_.get ();
}

void ActiveProbe::
Overshoot (const Overshoot_type& x)
{
  this->Overshoot_.set (x);
}

void ActiveProbe::
Overshoot (::std::auto_ptr< Overshoot_type > x)
{
  this->Overshoot_.set (x);
}

const ActiveProbe::Attenuation_Shift_type& ActiveProbe::
Attenuation_Shift () const
{
  return this->Attenuation_Shift_.get ();
}

ActiveProbe::Attenuation_Shift_type& ActiveProbe::
Attenuation_Shift ()
{
  return this->Attenuation_Shift_.get ();
}

void ActiveProbe::
Attenuation_Shift (const Attenuation_Shift_type& x)
{
  this->Attenuation_Shift_.set (x);
}

void ActiveProbe::
Attenuation_Shift (::std::auto_ptr< Attenuation_Shift_type > x)
{
  this->Attenuation_Shift_.set (x);
}

const ActiveProbe::Filter_type& ActiveProbe::
Filter () const
{
  return this->Filter_.get ();
}

ActiveProbe::Filter_type& ActiveProbe::
Filter ()
{
  return this->Filter_.get ();
}

void ActiveProbe::
Filter (const Filter_type& x)
{
  this->Filter_.set (x);
}

void ActiveProbe::
Filter (::std::auto_ptr< Filter_type > x)
{
  this->Filter_.set (x);
}

const ActiveProbe::Default_Rx_Gain_Doppler_type& ActiveProbe::
Default_Rx_Gain_Doppler () const
{
  return this->Default_Rx_Gain_Doppler_.get ();
}

ActiveProbe::Default_Rx_Gain_Doppler_type& ActiveProbe::
Default_Rx_Gain_Doppler ()
{
  return this->Default_Rx_Gain_Doppler_.get ();
}

void ActiveProbe::
Default_Rx_Gain_Doppler (const Default_Rx_Gain_Doppler_type& x)
{
  this->Default_Rx_Gain_Doppler_.set (x);
}

void ActiveProbe::
Default_Rx_Gain_Doppler (::std::auto_ptr< Default_Rx_Gain_Doppler_type > x)
{
  this->Default_Rx_Gain_Doppler_.set (x);
}

const ActiveProbe::Peak_Vel_Correction_type& ActiveProbe::
Peak_Vel_Correction () const
{
  return this->Peak_Vel_Correction_.get ();
}

ActiveProbe::Peak_Vel_Correction_type& ActiveProbe::
Peak_Vel_Correction ()
{
  return this->Peak_Vel_Correction_.get ();
}

void ActiveProbe::
Peak_Vel_Correction (const Peak_Vel_Correction_type& x)
{
  this->Peak_Vel_Correction_.set (x);
}

void ActiveProbe::
Peak_Vel_Correction (::std::auto_ptr< Peak_Vel_Correction_type > x)
{
  this->Peak_Vel_Correction_.set (x);
}

const ActiveProbe::Detect_Ratio_Max_type& ActiveProbe::
Detect_Ratio_Max () const
{
  return this->Detect_Ratio_Max_.get ();
}

ActiveProbe::Detect_Ratio_Max_type& ActiveProbe::
Detect_Ratio_Max ()
{
  return this->Detect_Ratio_Max_.get ();
}

void ActiveProbe::
Detect_Ratio_Max (const Detect_Ratio_Max_type& x)
{
  this->Detect_Ratio_Max_.set (x);
}

void ActiveProbe::
Detect_Ratio_Max (::std::auto_ptr< Detect_Ratio_Max_type > x)
{
  this->Detect_Ratio_Max_.set (x);
}

const ActiveProbe::Acceleration_Limit_Constant_type& ActiveProbe::
Acceleration_Limit_Constant () const
{
  return this->Acceleration_Limit_Constant_.get ();
}

ActiveProbe::Acceleration_Limit_Constant_type& ActiveProbe::
Acceleration_Limit_Constant ()
{
  return this->Acceleration_Limit_Constant_.get ();
}

void ActiveProbe::
Acceleration_Limit_Constant (const Acceleration_Limit_Constant_type& x)
{
  this->Acceleration_Limit_Constant_.set (x);
}

void ActiveProbe::
Acceleration_Limit_Constant (::std::auto_ptr< Acceleration_Limit_Constant_type > x)
{
  this->Acceleration_Limit_Constant_.set (x);
}

const ActiveProbe::Filter_Doppler_Low_type& ActiveProbe::
Filter_Doppler_Low () const
{
  return this->Filter_Doppler_Low_.get ();
}

ActiveProbe::Filter_Doppler_Low_type& ActiveProbe::
Filter_Doppler_Low ()
{
  return this->Filter_Doppler_Low_.get ();
}

void ActiveProbe::
Filter_Doppler_Low (const Filter_Doppler_Low_type& x)
{
  this->Filter_Doppler_Low_.set (x);
}

void ActiveProbe::
Filter_Doppler_Low (::std::auto_ptr< Filter_Doppler_Low_type > x)
{
  this->Filter_Doppler_Low_.set (x);
}


// BModeSoft
// 

const BModeSoft::V_Relative_Frame_Rate_type& BModeSoft::
V_Relative_Frame_Rate () const
{
  return this->V_Relative_Frame_Rate_.get ();
}

BModeSoft::V_Relative_Frame_Rate_type& BModeSoft::
V_Relative_Frame_Rate ()
{
  return this->V_Relative_Frame_Rate_.get ();
}

void BModeSoft::
V_Relative_Frame_Rate (const V_Relative_Frame_Rate_type& x)
{
  this->V_Relative_Frame_Rate_.set (x);
}

void BModeSoft::
V_Relative_Frame_Rate (::std::auto_ptr< V_Relative_Frame_Rate_type > x)
{
  this->V_Relative_Frame_Rate_.set (x);
}

const BModeSoft::Max_Power_Size_Default_type& BModeSoft::
Max_Power_Size_Default () const
{
  return this->Max_Power_Size_Default_.get ();
}

BModeSoft::Max_Power_Size_Default_type& BModeSoft::
Max_Power_Size_Default ()
{
  return this->Max_Power_Size_Default_.get ();
}

void BModeSoft::
Max_Power_Size_Default (const Max_Power_Size_Default_type& x)
{
  this->Max_Power_Size_Default_.set (x);
}

void BModeSoft::
Max_Power_Size_Default (::std::auto_ptr< Max_Power_Size_Default_type > x)
{
  this->Max_Power_Size_Default_.set (x);
}

const BModeSoft::Buffer_Size_type& BModeSoft::
Buffer_Size () const
{
  return this->Buffer_Size_.get ();
}

BModeSoft::Buffer_Size_type& BModeSoft::
Buffer_Size ()
{
  return this->Buffer_Size_.get ();
}

void BModeSoft::
Buffer_Size (const Buffer_Size_type& x)
{
  this->Buffer_Size_.set (x);
}

void BModeSoft::
Buffer_Size (::std::auto_ptr< Buffer_Size_type > x)
{
  this->Buffer_Size_.set (x);
}

const BModeSoft::AVR_Factor_type& BModeSoft::
AVR_Factor () const
{
  return this->AVR_Factor_.get ();
}

BModeSoft::AVR_Factor_type& BModeSoft::
AVR_Factor ()
{
  return this->AVR_Factor_.get ();
}

void BModeSoft::
AVR_Factor (const AVR_Factor_type& x)
{
  this->AVR_Factor_.set (x);
}

void BModeSoft::
AVR_Factor (::std::auto_ptr< AVR_Factor_type > x)
{
  this->AVR_Factor_.set (x);
}

const BModeSoft::AVR_Startup_Frames_type& BModeSoft::
AVR_Startup_Frames () const
{
  return this->AVR_Startup_Frames_.get ();
}

BModeSoft::AVR_Startup_Frames_type& BModeSoft::
AVR_Startup_Frames ()
{
  return this->AVR_Startup_Frames_.get ();
}

void BModeSoft::
AVR_Startup_Frames (const AVR_Startup_Frames_type& x)
{
  this->AVR_Startup_Frames_.set (x);
}

void BModeSoft::
AVR_Startup_Frames (::std::auto_ptr< AVR_Startup_Frames_type > x)
{
  this->AVR_Startup_Frames_.set (x);
}

const BModeSoft::BMode_Size_Default_type& BModeSoft::
BMode_Size_Default () const
{
  return this->BMode_Size_Default_.get ();
}

BModeSoft::BMode_Size_Default_type& BModeSoft::
BMode_Size_Default ()
{
  return this->BMode_Size_Default_.get ();
}

void BModeSoft::
BMode_Size_Default (const BMode_Size_Default_type& x)
{
  this->BMode_Size_Default_.set (x);
}

void BModeSoft::
BMode_Size_Default (::std::auto_ptr< BMode_Size_Default_type > x)
{
  this->BMode_Size_Default_.set (x);
}

const BModeSoft::Relative_Frame_Rate_type& BModeSoft::
Relative_Frame_Rate () const
{
  return this->Relative_Frame_Rate_.get ();
}

BModeSoft::Relative_Frame_Rate_type& BModeSoft::
Relative_Frame_Rate ()
{
  return this->Relative_Frame_Rate_.get ();
}

void BModeSoft::
Relative_Frame_Rate (const Relative_Frame_Rate_type& x)
{
  this->Relative_Frame_Rate_.set (x);
}

void BModeSoft::
Relative_Frame_Rate (::std::auto_ptr< Relative_Frame_Rate_type > x)
{
  this->Relative_Frame_Rate_.set (x);
}

const BModeSoft::Refresh_Rate_type& BModeSoft::
Refresh_Rate () const
{
  return this->Refresh_Rate_.get ();
}

BModeSoft::Refresh_Rate_type& BModeSoft::
Refresh_Rate ()
{
  return this->Refresh_Rate_.get ();
}

void BModeSoft::
Refresh_Rate (const Refresh_Rate_type& x)
{
  this->Refresh_Rate_.set (x);
}

void BModeSoft::
Refresh_Rate (::std::auto_ptr< Refresh_Rate_type > x)
{
  this->Refresh_Rate_.set (x);
}

const BModeSoft::Acquire_Both_Directions_type& BModeSoft::
Acquire_Both_Directions () const
{
  return this->Acquire_Both_Directions_.get ();
}

BModeSoft::Acquire_Both_Directions_type& BModeSoft::
Acquire_Both_Directions ()
{
  return this->Acquire_Both_Directions_.get ();
}

void BModeSoft::
Acquire_Both_Directions (const Acquire_Both_Directions_type& x)
{
  this->Acquire_Both_Directions_.set (x);
}

void BModeSoft::
Acquire_Both_Directions (::std::auto_ptr< Acquire_Both_Directions_type > x)
{
  this->Acquire_Both_Directions_.set (x);
}

const BModeSoft::Acquire_Persist_AVR_type& BModeSoft::
Acquire_Persist_AVR () const
{
  return this->Acquire_Persist_AVR_.get ();
}

BModeSoft::Acquire_Persist_AVR_type& BModeSoft::
Acquire_Persist_AVR ()
{
  return this->Acquire_Persist_AVR_.get ();
}

void BModeSoft::
Acquire_Persist_AVR (const Acquire_Persist_AVR_type& x)
{
  this->Acquire_Persist_AVR_.set (x);
}

void BModeSoft::
Acquire_Persist_AVR (::std::auto_ptr< Acquire_Persist_AVR_type > x)
{
  this->Acquire_Persist_AVR_.set (x);
}

const BModeSoft::Power_Size_Default_type& BModeSoft::
Power_Size_Default () const
{
  return this->Power_Size_Default_.get ();
}

BModeSoft::Power_Size_Default_type& BModeSoft::
Power_Size_Default ()
{
  return this->Power_Size_Default_.get ();
}

void BModeSoft::
Power_Size_Default (const Power_Size_Default_type& x)
{
  this->Power_Size_Default_.set (x);
}

void BModeSoft::
Power_Size_Default (::std::auto_ptr< Power_Size_Default_type > x)
{
  this->Power_Size_Default_.set (x);
}

const BModeSoft::Max_BMode_Size_Default_type& BModeSoft::
Max_BMode_Size_Default () const
{
  return this->Max_BMode_Size_Default_.get ();
}

BModeSoft::Max_BMode_Size_Default_type& BModeSoft::
Max_BMode_Size_Default ()
{
  return this->Max_BMode_Size_Default_.get ();
}

void BModeSoft::
Max_BMode_Size_Default (const Max_BMode_Size_Default_type& x)
{
  this->Max_BMode_Size_Default_.set (x);
}

void BModeSoft::
Max_BMode_Size_Default (::std::auto_ptr< Max_BMode_Size_Default_type > x)
{
  this->Max_BMode_Size_Default_.set (x);
}

const BModeSoft::Target_Field_Of_View_type& BModeSoft::
Target_Field_Of_View () const
{
  return this->Target_Field_Of_View_.get ();
}

BModeSoft::Target_Field_Of_View_type& BModeSoft::
Target_Field_Of_View ()
{
  return this->Target_Field_Of_View_.get ();
}

void BModeSoft::
Target_Field_Of_View (const Target_Field_Of_View_type& x)
{
  this->Target_Field_Of_View_.set (x);
}

void BModeSoft::
Target_Field_Of_View (::std::auto_ptr< Target_Field_Of_View_type > x)
{
  this->Target_Field_Of_View_.set (x);
}

const BModeSoft::Processing_Command_type& BModeSoft::
Processing_Command () const
{
  return this->Processing_Command_.get ();
}

BModeSoft::Processing_Command_type& BModeSoft::
Processing_Command ()
{
  return this->Processing_Command_.get ();
}

void BModeSoft::
Processing_Command (const Processing_Command_type& x)
{
  this->Processing_Command_.set (x);
}

void BModeSoft::
Processing_Command (::std::auto_ptr< Processing_Command_type > x)
{
  this->Processing_Command_.set (x);
}


// Sys
// 

const Sys::Query_Discard_Loop_On_Save_Frame_type& Sys::
Query_Discard_Loop_On_Save_Frame () const
{
  return this->Query_Discard_Loop_On_Save_Frame_.get ();
}

Sys::Query_Discard_Loop_On_Save_Frame_type& Sys::
Query_Discard_Loop_On_Save_Frame ()
{
  return this->Query_Discard_Loop_On_Save_Frame_.get ();
}

void Sys::
Query_Discard_Loop_On_Save_Frame (const Query_Discard_Loop_On_Save_Frame_type& x)
{
  this->Query_Discard_Loop_On_Save_Frame_.set (x);
}

void Sys::
Query_Discard_Loop_On_Save_Frame (::std::auto_ptr< Query_Discard_Loop_On_Save_Frame_type > x)
{
  this->Query_Discard_Loop_On_Save_Frame_.set (x);
}

const Sys::Sound_Speed_type& Sys::
Sound_Speed () const
{
  return this->Sound_Speed_.get ();
}

Sys::Sound_Speed_type& Sys::
Sound_Speed ()
{
  return this->Sound_Speed_.get ();
}

void Sys::
Sound_Speed (const Sound_Speed_type& x)
{
  this->Sound_Speed_.set (x);
}

void Sys::
Sound_Speed (::std::auto_ptr< Sound_Speed_type > x)
{
  this->Sound_Speed_.set (x);
}

const Sys::SubMode_type& Sys::
SubMode () const
{
  return this->SubMode_.get ();
}

Sys::SubMode_type& Sys::
SubMode ()
{
  return this->SubMode_.get ();
}

void Sys::
SubMode (const SubMode_type& x)
{
  this->SubMode_.set (x);
}

void Sys::
SubMode (::std::auto_ptr< SubMode_type > x)
{
  this->SubMode_.set (x);
}

const Sys::Interrupt_Mask_type& Sys::
Interrupt_Mask () const
{
  return this->Interrupt_Mask_.get ();
}

Sys::Interrupt_Mask_type& Sys::
Interrupt_Mask ()
{
  return this->Interrupt_Mask_.get ();
}

void Sys::
Interrupt_Mask (const Interrupt_Mask_type& x)
{
  this->Interrupt_Mask_.set (x);
}

void Sys::
Interrupt_Mask (::std::auto_ptr< Interrupt_Mask_type > x)
{
  this->Interrupt_Mask_.set (x);
}

const Sys::Calculation_Instances_type& Sys::
Calculation_Instances () const
{
  return this->Calculation_Instances_.get ();
}

Sys::Calculation_Instances_type& Sys::
Calculation_Instances ()
{
  return this->Calculation_Instances_.get ();
}

void Sys::
Calculation_Instances (const Calculation_Instances_type& x)
{
  this->Calculation_Instances_.set (x);
}

void Sys::
Calculation_Instances (::std::auto_ptr< Calculation_Instances_type > x)
{
  this->Calculation_Instances_.set (x);
}

const Sys::Start_Licence_Date_type& Sys::
Start_Licence_Date () const
{
  return this->Start_Licence_Date_.get ();
}

Sys::Start_Licence_Date_type& Sys::
Start_Licence_Date ()
{
  return this->Start_Licence_Date_.get ();
}

void Sys::
Start_Licence_Date (const Start_Licence_Date_type& x)
{
  this->Start_Licence_Date_.set (x);
}

void Sys::
Start_Licence_Date (::std::auto_ptr< Start_Licence_Date_type > x)
{
  this->Start_Licence_Date_.set (x);
}

const Sys::End_Licence_Date_type& Sys::
End_Licence_Date () const
{
  return this->End_Licence_Date_.get ();
}

Sys::End_Licence_Date_type& Sys::
End_Licence_Date ()
{
  return this->End_Licence_Date_.get ();
}

void Sys::
End_Licence_Date (const End_Licence_Date_type& x)
{
  this->End_Licence_Date_.set (x);
}

void Sys::
End_Licence_Date (::std::auto_ptr< End_Licence_Date_type > x)
{
  this->End_Licence_Date_.set (x);
}

const Sys::Auto_Save_PreTrig_Loop_type& Sys::
Auto_Save_PreTrig_Loop () const
{
  return this->Auto_Save_PreTrig_Loop_.get ();
}

Sys::Auto_Save_PreTrig_Loop_type& Sys::
Auto_Save_PreTrig_Loop ()
{
  return this->Auto_Save_PreTrig_Loop_.get ();
}

void Sys::
Auto_Save_PreTrig_Loop (const Auto_Save_PreTrig_Loop_type& x)
{
  this->Auto_Save_PreTrig_Loop_.set (x);
}

void Sys::
Auto_Save_PreTrig_Loop (::std::auto_ptr< Auto_Save_PreTrig_Loop_type > x)
{
  this->Auto_Save_PreTrig_Loop_.set (x);
}

const Sys::Feature_type& Sys::
Feature () const
{
  return this->Feature_.get ();
}

Sys::Feature_type& Sys::
Feature ()
{
  return this->Feature_.get ();
}

void Sys::
Feature (const Feature_type& x)
{
  this->Feature_.set (x);
}

void Sys::
Feature (::std::auto_ptr< Feature_type > x)
{
  this->Feature_.set (x);
}

const Sys::Review_Setup_Dialog_type& Sys::
Review_Setup_Dialog () const
{
  return this->Review_Setup_Dialog_.get ();
}

Sys::Review_Setup_Dialog_type& Sys::
Review_Setup_Dialog ()
{
  return this->Review_Setup_Dialog_.get ();
}

void Sys::
Review_Setup_Dialog (const Review_Setup_Dialog_type& x)
{
  this->Review_Setup_Dialog_.set (x);
}

void Sys::
Review_Setup_Dialog (::std::auto_ptr< Review_Setup_Dialog_type > x)
{
  this->Review_Setup_Dialog_.set (x);
}

const Sys::Acq_Setup_Dialog_type& Sys::
Acq_Setup_Dialog () const
{
  return this->Acq_Setup_Dialog_.get ();
}

Sys::Acq_Setup_Dialog_type& Sys::
Acq_Setup_Dialog ()
{
  return this->Acq_Setup_Dialog_.get ();
}

void Sys::
Acq_Setup_Dialog (const Acq_Setup_Dialog_type& x)
{
  this->Acq_Setup_Dialog_.set (x);
}

void Sys::
Acq_Setup_Dialog (::std::auto_ptr< Acq_Setup_Dialog_type > x)
{
  this->Acq_Setup_Dialog_.set (x);
}

const Sys::Interrupt_Clear_type& Sys::
Interrupt_Clear () const
{
  return this->Interrupt_Clear_.get ();
}

Sys::Interrupt_Clear_type& Sys::
Interrupt_Clear ()
{
  return this->Interrupt_Clear_.get ();
}

void Sys::
Interrupt_Clear (const Interrupt_Clear_type& x)
{
  this->Interrupt_Clear_.set (x);
}

void Sys::
Interrupt_Clear (::std::auto_ptr< Interrupt_Clear_type > x)
{
  this->Interrupt_Clear_.set (x);
}

const Sys::Interrupt_Status_type& Sys::
Interrupt_Status () const
{
  return this->Interrupt_Status_.get ();
}

Sys::Interrupt_Status_type& Sys::
Interrupt_Status ()
{
  return this->Interrupt_Status_.get ();
}

void Sys::
Interrupt_Status (const Interrupt_Status_type& x)
{
  this->Interrupt_Status_.set (x);
}

void Sys::
Interrupt_Status (::std::auto_ptr< Interrupt_Status_type > x)
{
  this->Interrupt_Status_.set (x);
}

const Sys::Auto_Save_Load_3D_type& Sys::
Auto_Save_Load_3D () const
{
  return this->Auto_Save_Load_3D_.get ();
}

Sys::Auto_Save_Load_3D_type& Sys::
Auto_Save_Load_3D ()
{
  return this->Auto_Save_Load_3D_.get ();
}

void Sys::
Auto_Save_Load_3D (const Auto_Save_Load_3D_type& x)
{
  this->Auto_Save_Load_3D_.set (x);
}

void Sys::
Auto_Save_Load_3D (::std::auto_ptr< Auto_Save_Load_3D_type > x)
{
  this->Auto_Save_Load_3D_.set (x);
}

const Sys::DICOM_Root_ID_type& Sys::
DICOM_Root_ID () const
{
  return this->DICOM_Root_ID_.get ();
}

Sys::DICOM_Root_ID_type& Sys::
DICOM_Root_ID ()
{
  return this->DICOM_Root_ID_.get ();
}

void Sys::
DICOM_Root_ID (const DICOM_Root_ID_type& x)
{
  this->DICOM_Root_ID_.set (x);
}

void Sys::
DICOM_Root_ID (::std::auto_ptr< DICOM_Root_ID_type > x)
{
  this->DICOM_Root_ID_.set (x);
}

const Sys::Company_Name_type& Sys::
Company_Name () const
{
  return this->Company_Name_.get ();
}

Sys::Company_Name_type& Sys::
Company_Name ()
{
  return this->Company_Name_.get ();
}

void Sys::
Company_Name (const Company_Name_type& x)
{
  this->Company_Name_.set (x);
}

void Sys::
Company_Name (::std::auto_ptr< Company_Name_type > x)
{
  this->Company_Name_.set (x);
}

const Sys::Image_To_Auto_Save_On_Label_type& Sys::
Image_To_Auto_Save_On_Label () const
{
  return this->Image_To_Auto_Save_On_Label_.get ();
}

Sys::Image_To_Auto_Save_On_Label_type& Sys::
Image_To_Auto_Save_On_Label ()
{
  return this->Image_To_Auto_Save_On_Label_.get ();
}

void Sys::
Image_To_Auto_Save_On_Label (const Image_To_Auto_Save_On_Label_type& x)
{
  this->Image_To_Auto_Save_On_Label_.set (x);
}

void Sys::
Image_To_Auto_Save_On_Label (::std::auto_ptr< Image_To_Auto_Save_On_Label_type > x)
{
  this->Image_To_Auto_Save_On_Label_.set (x);
}

const Sys::DICOM_Encode_Regions_type& Sys::
DICOM_Encode_Regions () const
{
  return this->DICOM_Encode_Regions_.get ();
}

Sys::DICOM_Encode_Regions_type& Sys::
DICOM_Encode_Regions ()
{
  return this->DICOM_Encode_Regions_.get ();
}

void Sys::
DICOM_Encode_Regions (const DICOM_Encode_Regions_type& x)
{
  this->DICOM_Encode_Regions_.set (x);
}

void Sys::
DICOM_Encode_Regions (::std::auto_ptr< DICOM_Encode_Regions_type > x)
{
  this->DICOM_Encode_Regions_.set (x);
}

const Sys::Pipeline_Delay_type& Sys::
Pipeline_Delay () const
{
  return this->Pipeline_Delay_.get ();
}

Sys::Pipeline_Delay_type& Sys::
Pipeline_Delay ()
{
  return this->Pipeline_Delay_.get ();
}

void Sys::
Pipeline_Delay (const Pipeline_Delay_type& x)
{
  this->Pipeline_Delay_.set (x);
}

void Sys::
Pipeline_Delay (::std::auto_ptr< Pipeline_Delay_type > x)
{
  this->Pipeline_Delay_.set (x);
}

const Sys::DDS_Control_type& Sys::
DDS_Control () const
{
  return this->DDS_Control_.get ();
}

Sys::DDS_Control_type& Sys::
DDS_Control ()
{
  return this->DDS_Control_.get ();
}

void Sys::
DDS_Control (const DDS_Control_type& x)
{
  this->DDS_Control_.set (x);
}

void Sys::
DDS_Control (::std::auto_ptr< DDS_Control_type > x)
{
  this->DDS_Control_.set (x);
}

const Sys::Mode_type& Sys::
Mode () const
{
  return this->Mode_.get ();
}

Sys::Mode_type& Sys::
Mode ()
{
  return this->Mode_.get ();
}

void Sys::
Mode (const Mode_type& x)
{
  this->Mode_.set (x);
}

void Sys::
Mode (::std::auto_ptr< Mode_type > x)
{
  this->Mode_.set (x);
}


// MIS
// 

const MIS::ECG_Gain_type& MIS::
ECG_Gain () const
{
  return this->ECG_Gain_.get ();
}

MIS::ECG_Gain_type& MIS::
ECG_Gain ()
{
  return this->ECG_Gain_.get ();
}

void MIS::
ECG_Gain (const ECG_Gain_type& x)
{
  this->ECG_Gain_.set (x);
}

void MIS::
ECG_Gain (::std::auto_ptr< ECG_Gain_type > x)
{
  this->ECG_Gain_.set (x);
}

const MIS::ECG_Available_type& MIS::
ECG_Available () const
{
  return this->ECG_Available_.get ();
}

MIS::ECG_Available_type& MIS::
ECG_Available ()
{
  return this->ECG_Available_.get ();
}

void MIS::
ECG_Available (const ECG_Available_type& x)
{
  this->ECG_Available_.set (x);
}

void MIS::
ECG_Available (::std::auto_ptr< ECG_Available_type > x)
{
  this->ECG_Available_.set (x);
}

const MIS::Blood_Pressure_Available_type& MIS::
Blood_Pressure_Available () const
{
  return this->Blood_Pressure_Available_.get ();
}

MIS::Blood_Pressure_Available_type& MIS::
Blood_Pressure_Available ()
{
  return this->Blood_Pressure_Available_.get ();
}

void MIS::
Blood_Pressure_Available (const Blood_Pressure_Available_type& x)
{
  this->Blood_Pressure_Available_.set (x);
}

void MIS::
Blood_Pressure_Available (::std::auto_ptr< Blood_Pressure_Available_type > x)
{
  this->Blood_Pressure_Available_.set (x);
}

const MIS::Respiration_Gating_type& MIS::
Respiration_Gating () const
{
  return this->Respiration_Gating_.get ();
}

MIS::Respiration_Gating_type& MIS::
Respiration_Gating ()
{
  return this->Respiration_Gating_.get ();
}

void MIS::
Respiration_Gating (const Respiration_Gating_type& x)
{
  this->Respiration_Gating_.set (x);
}

void MIS::
Respiration_Gating (::std::auto_ptr< Respiration_Gating_type > x)
{
  this->Respiration_Gating_.set (x);
}

const MIS::Respiration_Available_type& MIS::
Respiration_Available () const
{
  return this->Respiration_Available_.get ();
}

MIS::Respiration_Available_type& MIS::
Respiration_Available ()
{
  return this->Respiration_Available_.get ();
}

void MIS::
Respiration_Available (const Respiration_Available_type& x)
{
  this->Respiration_Available_.set (x);
}

void MIS::
Respiration_Available (::std::auto_ptr< Respiration_Available_type > x)
{
  this->Respiration_Available_.set (x);
}

const MIS::Control_type& MIS::
Control () const
{
  return this->Control_.get ();
}

MIS::Control_type& MIS::
Control ()
{
  return this->Control_.get ();
}

void MIS::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void MIS::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}

const MIS::BP_Gain_type& MIS::
BP_Gain () const
{
  return this->BP_Gain_.get ();
}

MIS::BP_Gain_type& MIS::
BP_Gain ()
{
  return this->BP_Gain_.get ();
}

void MIS::
BP_Gain (const BP_Gain_type& x)
{
  this->BP_Gain_.set (x);
}

void MIS::
BP_Gain (::std::auto_ptr< BP_Gain_type > x)
{
  this->BP_Gain_.set (x);
}

const MIS::Temperature_Available_type& MIS::
Temperature_Available () const
{
  return this->Temperature_Available_.get ();
}

MIS::Temperature_Available_type& MIS::
Temperature_Available ()
{
  return this->Temperature_Available_.get ();
}

void MIS::
Temperature_Available (const Temperature_Available_type& x)
{
  this->Temperature_Available_.set (x);
}

void MIS::
Temperature_Available (::std::auto_ptr< Temperature_Available_type > x)
{
  this->Temperature_Available_.set (x);
}


// Scan
// 

const Scan::Encoder_Position_type& Scan::
Encoder_Position () const
{
  return this->Encoder_Position_.get ();
}

Scan::Encoder_Position_type& Scan::
Encoder_Position ()
{
  return this->Encoder_Position_.get ();
}

void Scan::
Encoder_Position (const Encoder_Position_type& x)
{
  this->Encoder_Position_.set (x);
}

void Scan::
Encoder_Position (::std::auto_ptr< Encoder_Position_type > x)
{
  this->Encoder_Position_.set (x);
}

const Scan::Center_type& Scan::
Center () const
{
  return this->Center_.get ();
}

Scan::Center_type& Scan::
Center ()
{
  return this->Center_.get ();
}

void Scan::
Center (const Center_type& x)
{
  this->Center_.set (x);
}

void Scan::
Center (::std::auto_ptr< Center_type > x)
{
  this->Center_.set (x);
}

const Scan::Control_type& Scan::
Control () const
{
  return this->Control_.get ();
}

Scan::Control_type& Scan::
Control ()
{
  return this->Control_.get ();
}

void Scan::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void Scan::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}

const Scan::Probe_ID1_type& Scan::
Probe_ID1 () const
{
  return this->Probe_ID1_.get ();
}

Scan::Probe_ID1_type& Scan::
Probe_ID1 ()
{
  return this->Probe_ID1_.get ();
}

void Scan::
Probe_ID1 (const Probe_ID1_type& x)
{
  this->Probe_ID1_.set (x);
}

void Scan::
Probe_ID1 (::std::auto_ptr< Probe_ID1_type > x)
{
  this->Probe_ID1_.set (x);
}

const Scan::Probe_ID2_type& Scan::
Probe_ID2 () const
{
  return this->Probe_ID2_.get ();
}

Scan::Probe_ID2_type& Scan::
Probe_ID2 ()
{
  return this->Probe_ID2_.get ();
}

void Scan::
Probe_ID2 (const Probe_ID2_type& x)
{
  this->Probe_ID2_.set (x);
}

void Scan::
Probe_ID2 (::std::auto_ptr< Probe_ID2_type > x)
{
  this->Probe_ID2_.set (x);
}

const Scan::V_Scan_Speed_type& Scan::
V_Scan_Speed () const
{
  return this->V_Scan_Speed_.get ();
}

Scan::V_Scan_Speed_type& Scan::
V_Scan_Speed ()
{
  return this->V_Scan_Speed_.get ();
}

void Scan::
V_Scan_Speed (const V_Scan_Speed_type& x)
{
  this->V_Scan_Speed_.set (x);
}

void Scan::
V_Scan_Speed (::std::auto_ptr< V_Scan_Speed_type > x)
{
  this->V_Scan_Speed_.set (x);
}

const Scan::Probe_ID1_Reread_type& Scan::
Probe_ID1_Reread () const
{
  return this->Probe_ID1_Reread_.get ();
}

Scan::Probe_ID1_Reread_type& Scan::
Probe_ID1_Reread ()
{
  return this->Probe_ID1_Reread_.get ();
}

void Scan::
Probe_ID1_Reread (const Probe_ID1_Reread_type& x)
{
  this->Probe_ID1_Reread_.set (x);
}

void Scan::
Probe_ID1_Reread (::std::auto_ptr< Probe_ID1_Reread_type > x)
{
  this->Probe_ID1_Reread_.set (x);
}

const Scan::Probe_ID1_Valid_type& Scan::
Probe_ID1_Valid () const
{
  return this->Probe_ID1_Valid_.get ();
}

Scan::Probe_ID1_Valid_type& Scan::
Probe_ID1_Valid ()
{
  return this->Probe_ID1_Valid_.get ();
}

void Scan::
Probe_ID1_Valid (const Probe_ID1_Valid_type& x)
{
  this->Probe_ID1_Valid_.set (x);
}

void Scan::
Probe_ID1_Valid (::std::auto_ptr< Probe_ID1_Valid_type > x)
{
  this->Probe_ID1_Valid_.set (x);
}

const Scan::Probe_ID1_Voltage_type& Scan::
Probe_ID1_Voltage () const
{
  return this->Probe_ID1_Voltage_.get ();
}

Scan::Probe_ID1_Voltage_type& Scan::
Probe_ID1_Voltage ()
{
  return this->Probe_ID1_Voltage_.get ();
}

void Scan::
Probe_ID1_Voltage (const Probe_ID1_Voltage_type& x)
{
  this->Probe_ID1_Voltage_.set (x);
}

void Scan::
Probe_ID1_Voltage (::std::auto_ptr< Probe_ID1_Voltage_type > x)
{
  this->Probe_ID1_Voltage_.set (x);
}

const Scan::Probe_ID2_Reread_type& Scan::
Probe_ID2_Reread () const
{
  return this->Probe_ID2_Reread_.get ();
}

Scan::Probe_ID2_Reread_type& Scan::
Probe_ID2_Reread ()
{
  return this->Probe_ID2_Reread_.get ();
}

void Scan::
Probe_ID2_Reread (const Probe_ID2_Reread_type& x)
{
  this->Probe_ID2_Reread_.set (x);
}

void Scan::
Probe_ID2_Reread (::std::auto_ptr< Probe_ID2_Reread_type > x)
{
  this->Probe_ID2_Reread_.set (x);
}

const Scan::Probe_ID2_Valid_type& Scan::
Probe_ID2_Valid () const
{
  return this->Probe_ID2_Valid_.get ();
}

Scan::Probe_ID2_Valid_type& Scan::
Probe_ID2_Valid ()
{
  return this->Probe_ID2_Valid_.get ();
}

void Scan::
Probe_ID2_Valid (const Probe_ID2_Valid_type& x)
{
  this->Probe_ID2_Valid_.set (x);
}

void Scan::
Probe_ID2_Valid (::std::auto_ptr< Probe_ID2_Valid_type > x)
{
  this->Probe_ID2_Valid_.set (x);
}

const Scan::Probe_ID2_Voltage_type& Scan::
Probe_ID2_Voltage () const
{
  return this->Probe_ID2_Voltage_.get ();
}

Scan::Probe_ID2_Voltage_type& Scan::
Probe_ID2_Voltage ()
{
  return this->Probe_ID2_Voltage_.get ();
}

void Scan::
Probe_ID2_Voltage (const Probe_ID2_Voltage_type& x)
{
  this->Probe_ID2_Voltage_.set (x);
}

void Scan::
Probe_ID2_Voltage (::std::auto_ptr< Probe_ID2_Voltage_type > x)
{
  this->Probe_ID2_Voltage_.set (x);
}

const Scan::V_Scan_Rate_type& Scan::
V_Scan_Rate () const
{
  return this->V_Scan_Rate_.get ();
}

Scan::V_Scan_Rate_type& Scan::
V_Scan_Rate ()
{
  return this->V_Scan_Rate_.get ();
}

void Scan::
V_Scan_Rate (const V_Scan_Rate_type& x)
{
  this->V_Scan_Rate_.set (x);
}

void Scan::
V_Scan_Rate (::std::auto_ptr< V_Scan_Rate_type > x)
{
  this->V_Scan_Rate_.set (x);
}

const Scan::Position_Counter_Lock_type& Scan::
Position_Counter_Lock () const
{
  return this->Position_Counter_Lock_.get ();
}

Scan::Position_Counter_Lock_type& Scan::
Position_Counter_Lock ()
{
  return this->Position_Counter_Lock_.get ();
}

void Scan::
Position_Counter_Lock (const Position_Counter_Lock_type& x)
{
  this->Position_Counter_Lock_.set (x);
}

void Scan::
Position_Counter_Lock (::std::auto_ptr< Position_Counter_Lock_type > x)
{
  this->Position_Counter_Lock_.set (x);
}

const Scan::Scan_Width_type& Scan::
Scan_Width () const
{
  return this->Scan_Width_.get ();
}

Scan::Scan_Width_type& Scan::
Scan_Width ()
{
  return this->Scan_Width_.get ();
}

void Scan::
Scan_Width (const Scan_Width_type& x)
{
  this->Scan_Width_.set (x);
}

void Scan::
Scan_Width (::std::auto_ptr< Scan_Width_type > x)
{
  this->Scan_Width_.set (x);
}

const Scan::Position_Counter_Reset_type& Scan::
Position_Counter_Reset () const
{
  return this->Position_Counter_Reset_.get ();
}

Scan::Position_Counter_Reset_type& Scan::
Position_Counter_Reset ()
{
  return this->Position_Counter_Reset_.get ();
}

void Scan::
Position_Counter_Reset (const Position_Counter_Reset_type& x)
{
  this->Position_Counter_Reset_.set (x);
}

void Scan::
Position_Counter_Reset (::std::auto_ptr< Position_Counter_Reset_type > x)
{
  this->Position_Counter_Reset_.set (x);
}


// Motor
// 

const Motor::Settle_Time_3d_type& Motor::
Settle_Time_3d () const
{
  return this->Settle_Time_3d_.get ();
}

Motor::Settle_Time_3d_type& Motor::
Settle_Time_3d ()
{
  return this->Settle_Time_3d_.get ();
}

void Motor::
Settle_Time_3d (const Settle_Time_3d_type& x)
{
  this->Settle_Time_3d_.set (x);
}

void Motor::
Settle_Time_3d (::std::auto_ptr< Settle_Time_3d_type > x)
{
  this->Settle_Time_3d_.set (x);
}

const Motor::Position_type& Motor::
Position () const
{
  return this->Position_.get ();
}

Motor::Position_type& Motor::
Position ()
{
  return this->Position_.get ();
}

void Motor::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Motor::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const Motor::R_Scan_Move_No_Wait_type& Motor::
R_Scan_Move_No_Wait () const
{
  return this->R_Scan_Move_No_Wait_.get ();
}

Motor::R_Scan_Move_No_Wait_type& Motor::
R_Scan_Move_No_Wait ()
{
  return this->R_Scan_Move_No_Wait_.get ();
}

void Motor::
R_Scan_Move_No_Wait (const R_Scan_Move_No_Wait_type& x)
{
  this->R_Scan_Move_No_Wait_.set (x);
}

void Motor::
R_Scan_Move_No_Wait (::std::auto_ptr< R_Scan_Move_No_Wait_type > x)
{
  this->R_Scan_Move_No_Wait_.set (x);
}

const Motor::Motor_Mode_type& Motor::
Motor_Mode () const
{
  return this->Motor_Mode_.get ();
}

Motor::Motor_Mode_type& Motor::
Motor_Mode ()
{
  return this->Motor_Mode_.get ();
}

void Motor::
Motor_Mode (const Motor_Mode_type& x)
{
  this->Motor_Mode_.set (x);
}

void Motor::
Motor_Mode (::std::auto_ptr< Motor_Mode_type > x)
{
  this->Motor_Mode_.set (x);
}

const Motor::Acceleration_type& Motor::
Acceleration () const
{
  return this->Acceleration_.get ();
}

Motor::Acceleration_type& Motor::
Acceleration ()
{
  return this->Acceleration_.get ();
}

void Motor::
Acceleration (const Acceleration_type& x)
{
  this->Acceleration_.set (x);
}

void Motor::
Acceleration (::std::auto_ptr< Acceleration_type > x)
{
  this->Acceleration_.set (x);
}

const Motor::Serial_Port_Mode_type& Motor::
Serial_Port_Mode () const
{
  return this->Serial_Port_Mode_.get ();
}

Motor::Serial_Port_Mode_type& Motor::
Serial_Port_Mode ()
{
  return this->Serial_Port_Mode_.get ();
}

void Motor::
Serial_Port_Mode (const Serial_Port_Mode_type& x)
{
  this->Serial_Port_Mode_.set (x);
}

void Motor::
Serial_Port_Mode (::std::auto_ptr< Serial_Port_Mode_type > x)
{
  this->Serial_Port_Mode_.set (x);
}

const Motor::Limit_Switch_Mode_type& Motor::
Limit_Switch_Mode () const
{
  return this->Limit_Switch_Mode_.get ();
}

Motor::Limit_Switch_Mode_type& Motor::
Limit_Switch_Mode ()
{
  return this->Limit_Switch_Mode_.get ();
}

void Motor::
Limit_Switch_Mode (const Limit_Switch_Mode_type& x)
{
  this->Limit_Switch_Mode_.set (x);
}

void Motor::
Limit_Switch_Mode (::std::auto_ptr< Limit_Switch_Mode_type > x)
{
  this->Limit_Switch_Mode_.set (x);
}

const Motor::Breakpoint_type& Motor::
Breakpoint () const
{
  return this->Breakpoint_.get ();
}

Motor::Breakpoint_type& Motor::
Breakpoint ()
{
  return this->Breakpoint_.get ();
}

void Motor::
Breakpoint (const Breakpoint_type& x)
{
  this->Breakpoint_.set (x);
}

void Motor::
Breakpoint (::std::auto_ptr< Breakpoint_type > x)
{
  this->Breakpoint_.set (x);
}

const Motor::Update_type& Motor::
Update () const
{
  return this->Update_.get ();
}

Motor::Update_type& Motor::
Update ()
{
  return this->Update_.get ();
}

void Motor::
Update (const Update_type& x)
{
  this->Update_.set (x);
}

void Motor::
Update (::std::auto_ptr< Update_type > x)
{
  this->Update_.set (x);
}

const Motor::Breakpoint_Value_type& Motor::
Breakpoint_Value () const
{
  return this->Breakpoint_Value_.get ();
}

Motor::Breakpoint_Value_type& Motor::
Breakpoint_Value ()
{
  return this->Breakpoint_Value_.get ();
}

void Motor::
Breakpoint_Value (const Breakpoint_Value_type& x)
{
  this->Breakpoint_Value_.set (x);
}

void Motor::
Breakpoint_Value (::std::auto_ptr< Breakpoint_Value_type > x)
{
  this->Breakpoint_Value_.set (x);
}

const Motor::V_Switch_Limit_type& Motor::
V_Switch_Limit () const
{
  return this->V_Switch_Limit_.get ();
}

Motor::V_Switch_Limit_type& Motor::
V_Switch_Limit ()
{
  return this->V_Switch_Limit_.get ();
}

void Motor::
V_Switch_Limit (const V_Switch_Limit_type& x)
{
  this->V_Switch_Limit_.set (x);
}

void Motor::
V_Switch_Limit (::std::auto_ptr< V_Switch_Limit_type > x)
{
  this->V_Switch_Limit_.set (x);
}

const Motor::R_Retrieve_Trace_type& Motor::
R_Retrieve_Trace () const
{
  return this->R_Retrieve_Trace_.get ();
}

Motor::R_Retrieve_Trace_type& Motor::
R_Retrieve_Trace ()
{
  return this->R_Retrieve_Trace_.get ();
}

void Motor::
R_Retrieve_Trace (const R_Retrieve_Trace_type& x)
{
  this->R_Retrieve_Trace_.set (x);
}

void Motor::
R_Retrieve_Trace (::std::auto_ptr< R_Retrieve_Trace_type > x)
{
  this->R_Retrieve_Trace_.set (x);
}

const Motor::Velocity_Stationary_type& Motor::
Velocity_Stationary () const
{
  return this->Velocity_Stationary_.get ();
}

Motor::Velocity_Stationary_type& Motor::
Velocity_Stationary ()
{
  return this->Velocity_Stationary_.get ();
}

void Motor::
Velocity_Stationary (const Velocity_Stationary_type& x)
{
  this->Velocity_Stationary_.set (x);
}

void Motor::
Velocity_Stationary (::std::auto_ptr< Velocity_Stationary_type > x)
{
  this->Velocity_Stationary_.set (x);
}

const Motor::Reset_Event_Status_type& Motor::
Reset_Event_Status () const
{
  return this->Reset_Event_Status_.get ();
}

Motor::Reset_Event_Status_type& Motor::
Reset_Event_Status ()
{
  return this->Reset_Event_Status_.get ();
}

void Motor::
Reset_Event_Status (const Reset_Event_Status_type& x)
{
  this->Reset_Event_Status_.set (x);
}

void Motor::
Reset_Event_Status (::std::auto_ptr< Reset_Event_Status_type > x)
{
  this->Reset_Event_Status_.set (x);
}

const Motor::Actual_Position_type& Motor::
Actual_Position () const
{
  return this->Actual_Position_.get ();
}

Motor::Actual_Position_type& Motor::
Actual_Position ()
{
  return this->Actual_Position_.get ();
}

void Motor::
Actual_Position (const Actual_Position_type& x)
{
  this->Actual_Position_.set (x);
}

void Motor::
Actual_Position (::std::auto_ptr< Actual_Position_type > x)
{
  this->Actual_Position_.set (x);
}

const Motor::Buffer_Length_type& Motor::
Buffer_Length () const
{
  return this->Buffer_Length_.get ();
}

Motor::Buffer_Length_type& Motor::
Buffer_Length ()
{
  return this->Buffer_Length_.get ();
}

void Motor::
Buffer_Length (const Buffer_Length_type& x)
{
  this->Buffer_Length_.set (x);
}

void Motor::
Buffer_Length (::std::auto_ptr< Buffer_Length_type > x)
{
  this->Buffer_Length_.set (x);
}

const Motor::Event_Status_type& Motor::
Event_Status () const
{
  return this->Event_Status_.get ();
}

Motor::Event_Status_type& Motor::
Event_Status ()
{
  return this->Event_Status_.get ();
}

void Motor::
Event_Status (const Event_Status_type& x)
{
  this->Event_Status_.set (x);
}

void Motor::
Event_Status (::std::auto_ptr< Event_Status_type > x)
{
  this->Event_Status_.set (x);
}

const Motor::R_Scan_Move2_type& Motor::
R_Scan_Move2 () const
{
  return this->R_Scan_Move2_.get ();
}

Motor::R_Scan_Move2_type& Motor::
R_Scan_Move2 ()
{
  return this->R_Scan_Move2_.get ();
}

void Motor::
R_Scan_Move2 (const R_Scan_Move2_type& x)
{
  this->R_Scan_Move2_.set (x);
}

void Motor::
R_Scan_Move2 (::std::auto_ptr< R_Scan_Move2_type > x)
{
  this->R_Scan_Move2_.set (x);
}

const Motor::Kp_type& Motor::
Kp () const
{
  return this->Kp_.get ();
}

Motor::Kp_type& Motor::
Kp ()
{
  return this->Kp_.get ();
}

void Motor::
Kp (const Kp_type& x)
{
  this->Kp_.set (x);
}

void Motor::
Kp (::std::auto_ptr< Kp_type > x)
{
  this->Kp_.set (x);
}

const Motor::R_Wait_Finish_Scan_Move_type& Motor::
R_Wait_Finish_Scan_Move () const
{
  return this->R_Wait_Finish_Scan_Move_.get ();
}

Motor::R_Wait_Finish_Scan_Move_type& Motor::
R_Wait_Finish_Scan_Move ()
{
  return this->R_Wait_Finish_Scan_Move_.get ();
}

void Motor::
R_Wait_Finish_Scan_Move (const R_Wait_Finish_Scan_Move_type& x)
{
  this->R_Wait_Finish_Scan_Move_.set (x);
}

void Motor::
R_Wait_Finish_Scan_Move (::std::auto_ptr< R_Wait_Finish_Scan_Move_type > x)
{
  this->R_Wait_Finish_Scan_Move_.set (x);
}

const Motor::Settle_Time_type& Motor::
Settle_Time () const
{
  return this->Settle_Time_.get ();
}

Motor::Settle_Time_type& Motor::
Settle_Time ()
{
  return this->Settle_Time_.get ();
}

void Motor::
Settle_Time (const Settle_Time_type& x)
{
  this->Settle_Time_.set (x);
}

void Motor::
Settle_Time (::std::auto_ptr< Settle_Time_type > x)
{
  this->Settle_Time_.set (x);
}

const Motor::Acceleration_Stationary_type& Motor::
Acceleration_Stationary () const
{
  return this->Acceleration_Stationary_.get ();
}

Motor::Acceleration_Stationary_type& Motor::
Acceleration_Stationary ()
{
  return this->Acceleration_Stationary_.get ();
}

void Motor::
Acceleration_Stationary (const Acceleration_Stationary_type& x)
{
  this->Acceleration_Stationary_.set (x);
}

void Motor::
Acceleration_Stationary (::std::auto_ptr< Acceleration_Stationary_type > x)
{
  this->Acceleration_Stationary_.set (x);
}

const Motor::Trace_Mode_type& Motor::
Trace_Mode () const
{
  return this->Trace_Mode_.get ();
}

Motor::Trace_Mode_type& Motor::
Trace_Mode ()
{
  return this->Trace_Mode_.get ();
}

void Motor::
Trace_Mode (const Trace_Mode_type& x)
{
  this->Trace_Mode_.set (x);
}

void Motor::
Trace_Mode (::std::auto_ptr< Trace_Mode_type > x)
{
  this->Trace_Mode_.set (x);
}

const Motor::Trace_Period_type& Motor::
Trace_Period () const
{
  return this->Trace_Period_.get ();
}

Motor::Trace_Period_type& Motor::
Trace_Period ()
{
  return this->Trace_Period_.get ();
}

void Motor::
Trace_Period (const Trace_Period_type& x)
{
  this->Trace_Period_.set (x);
}

void Motor::
Trace_Period (::std::auto_ptr< Trace_Period_type > x)
{
  this->Trace_Period_.set (x);
}

const Motor::Trace_Start_type& Motor::
Trace_Start () const
{
  return this->Trace_Start_.get ();
}

Motor::Trace_Start_type& Motor::
Trace_Start ()
{
  return this->Trace_Start_.get ();
}

void Motor::
Trace_Start (const Trace_Start_type& x)
{
  this->Trace_Start_.set (x);
}

void Motor::
Trace_Start (::std::auto_ptr< Trace_Start_type > x)
{
  this->Trace_Start_.set (x);
}

const Motor::Position_Reverse_type& Motor::
Position_Reverse () const
{
  return this->Position_Reverse_.get ();
}

Motor::Position_Reverse_type& Motor::
Position_Reverse ()
{
  return this->Position_Reverse_.get ();
}

void Motor::
Position_Reverse (const Position_Reverse_type& x)
{
  this->Position_Reverse_.set (x);
}

void Motor::
Position_Reverse (::std::auto_ptr< Position_Reverse_type > x)
{
  this->Position_Reverse_.set (x);
}

const Motor::Reset_type& Motor::
Reset () const
{
  return this->Reset_.get ();
}

Motor::Reset_type& Motor::
Reset ()
{
  return this->Reset_.get ();
}

void Motor::
Reset (const Reset_type& x)
{
  this->Reset_.set (x);
}

void Motor::
Reset (::std::auto_ptr< Reset_type > x)
{
  this->Reset_.set (x);
}

const Motor::Trace_Count_type& Motor::
Trace_Count () const
{
  return this->Trace_Count_.get ();
}

Motor::Trace_Count_type& Motor::
Trace_Count ()
{
  return this->Trace_Count_.get ();
}

void Motor::
Trace_Count (const Trace_Count_type& x)
{
  this->Trace_Count_.set (x);
}

void Motor::
Trace_Count (::std::auto_ptr< Trace_Count_type > x)
{
  this->Trace_Count_.set (x);
}

const Motor::R_Initialize_type& Motor::
R_Initialize () const
{
  return this->R_Initialize_.get ();
}

Motor::R_Initialize_type& Motor::
R_Initialize ()
{
  return this->R_Initialize_.get ();
}

void Motor::
R_Initialize (const R_Initialize_type& x)
{
  this->R_Initialize_.set (x);
}

void Motor::
R_Initialize (::std::auto_ptr< R_Initialize_type > x)
{
  this->R_Initialize_.set (x);
}

const Motor::Output_Mode_type& Motor::
Output_Mode () const
{
  return this->Output_Mode_.get ();
}

Motor::Output_Mode_type& Motor::
Output_Mode ()
{
  return this->Output_Mode_.get ();
}

void Motor::
Output_Mode (const Output_Mode_type& x)
{
  this->Output_Mode_.set (x);
}

void Motor::
Output_Mode (::std::auto_ptr< Output_Mode_type > x)
{
  this->Output_Mode_.set (x);
}

const Motor::Position2_type& Motor::
Position2 () const
{
  return this->Position2_.get ();
}

Motor::Position2_type& Motor::
Position2 ()
{
  return this->Position2_.get ();
}

void Motor::
Position2 (const Position2_type& x)
{
  this->Position2_.set (x);
}

void Motor::
Position2 (::std::auto_ptr< Position2_type > x)
{
  this->Position2_.set (x);
}

const Motor::Integration_Limit_type& Motor::
Integration_Limit () const
{
  return this->Integration_Limit_.get ();
}

Motor::Integration_Limit_type& Motor::
Integration_Limit ()
{
  return this->Integration_Limit_.get ();
}

void Motor::
Integration_Limit (const Integration_Limit_type& x)
{
  this->Integration_Limit_.set (x);
}

void Motor::
Integration_Limit (::std::auto_ptr< Integration_Limit_type > x)
{
  this->Integration_Limit_.set (x);
}

const Motor::R_Home_type& Motor::
R_Home () const
{
  return this->R_Home_.get ();
}

Motor::R_Home_type& Motor::
R_Home ()
{
  return this->R_Home_.get ();
}

void Motor::
R_Home (const R_Home_type& x)
{
  this->R_Home_.set (x);
}

void Motor::
R_Home (::std::auto_ptr< R_Home_type > x)
{
  this->R_Home_.set (x);
}

const Motor::Error_type& Motor::
Error () const
{
  return this->Error_.get ();
}

Motor::Error_type& Motor::
Error ()
{
  return this->Error_.get ();
}

void Motor::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void Motor::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const Motor::R_Reset_Limit_Switch_type& Motor::
R_Reset_Limit_Switch () const
{
  return this->R_Reset_Limit_Switch_.get ();
}

Motor::R_Reset_Limit_Switch_type& Motor::
R_Reset_Limit_Switch ()
{
  return this->R_Reset_Limit_Switch_.get ();
}

void Motor::
R_Reset_Limit_Switch (const R_Reset_Limit_Switch_type& x)
{
  this->R_Reset_Limit_Switch_.set (x);
}

void Motor::
R_Reset_Limit_Switch (::std::auto_ptr< R_Reset_Limit_Switch_type > x)
{
  this->R_Reset_Limit_Switch_.set (x);
}

const Motor::Settle_Window_3d_type& Motor::
Settle_Window_3d () const
{
  return this->Settle_Window_3d_.get ();
}

Motor::Settle_Window_3d_type& Motor::
Settle_Window_3d ()
{
  return this->Settle_Window_3d_.get ();
}

void Motor::
Settle_Window_3d (const Settle_Window_3d_type& x)
{
  this->Settle_Window_3d_.set (x);
}

void Motor::
Settle_Window_3d (::std::auto_ptr< Settle_Window_3d_type > x)
{
  this->Settle_Window_3d_.set (x);
}

const Motor::Interrupt_Mask_type& Motor::
Interrupt_Mask () const
{
  return this->Interrupt_Mask_.get ();
}

Motor::Interrupt_Mask_type& Motor::
Interrupt_Mask ()
{
  return this->Interrupt_Mask_.get ();
}

void Motor::
Interrupt_Mask (const Interrupt_Mask_type& x)
{
  this->Interrupt_Mask_.set (x);
}

void Motor::
Interrupt_Mask (::std::auto_ptr< Interrupt_Mask_type > x)
{
  this->Interrupt_Mask_.set (x);
}

const Motor::Scan_Move_Control_type& Motor::
Scan_Move_Control () const
{
  return this->Scan_Move_Control_.get ();
}

Motor::Scan_Move_Control_type& Motor::
Scan_Move_Control ()
{
  return this->Scan_Move_Control_.get ();
}

void Motor::
Scan_Move_Control (const Scan_Move_Control_type& x)
{
  this->Scan_Move_Control_.set (x);
}

void Motor::
Scan_Move_Control (::std::auto_ptr< Scan_Move_Control_type > x)
{
  this->Scan_Move_Control_.set (x);
}

const Motor::Axis_Out_Source_type& Motor::
Axis_Out_Source () const
{
  return this->Axis_Out_Source_.get ();
}

Motor::Axis_Out_Source_type& Motor::
Axis_Out_Source ()
{
  return this->Axis_Out_Source_.get ();
}

void Motor::
Axis_Out_Source (const Axis_Out_Source_type& x)
{
  this->Axis_Out_Source_.set (x);
}

void Motor::
Axis_Out_Source (::std::auto_ptr< Axis_Out_Source_type > x)
{
  this->Axis_Out_Source_.set (x);
}

const Motor::Trace_Stop_type& Motor::
Trace_Stop () const
{
  return this->Trace_Stop_.get ();
}

Motor::Trace_Stop_type& Motor::
Trace_Stop ()
{
  return this->Trace_Stop_.get ();
}

void Motor::
Trace_Stop (const Trace_Stop_type& x)
{
  this->Trace_Stop_.set (x);
}

void Motor::
Trace_Stop (::std::auto_ptr< Trace_Stop_type > x)
{
  this->Trace_Stop_.set (x);
}

const Motor::Velocity_type& Motor::
Velocity () const
{
  return this->Velocity_.get ();
}

Motor::Velocity_type& Motor::
Velocity ()
{
  return this->Velocity_.get ();
}

void Motor::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void Motor::
Velocity (::std::auto_ptr< Velocity_type > x)
{
  this->Velocity_.set (x);
}

const Motor::R_Setup_type& Motor::
R_Setup () const
{
  return this->R_Setup_.get ();
}

Motor::R_Setup_type& Motor::
R_Setup ()
{
  return this->R_Setup_.get ();
}

void Motor::
R_Setup (const R_Setup_type& x)
{
  this->R_Setup_.set (x);
}

void Motor::
R_Setup (::std::auto_ptr< R_Setup_type > x)
{
  this->R_Setup_.set (x);
}

const Motor::Buffer_Start_type& Motor::
Buffer_Start () const
{
  return this->Buffer_Start_.get ();
}

Motor::Buffer_Start_type& Motor::
Buffer_Start ()
{
  return this->Buffer_Start_.get ();
}

void Motor::
Buffer_Start (const Buffer_Start_type& x)
{
  this->Buffer_Start_.set (x);
}

void Motor::
Buffer_Start (::std::auto_ptr< Buffer_Start_type > x)
{
  this->Buffer_Start_.set (x);
}

const Motor::Signal_Sense_type& Motor::
Signal_Sense () const
{
  return this->Signal_Sense_.get ();
}

Motor::Signal_Sense_type& Motor::
Signal_Sense ()
{
  return this->Signal_Sense_.get ();
}

void Motor::
Signal_Sense (const Signal_Sense_type& x)
{
  this->Signal_Sense_.set (x);
}

void Motor::
Signal_Sense (::std::auto_ptr< Signal_Sense_type > x)
{
  this->Signal_Sense_.set (x);
}

const Motor::R_Scan_Move_type& Motor::
R_Scan_Move () const
{
  return this->R_Scan_Move_.get ();
}

Motor::R_Scan_Move_type& Motor::
R_Scan_Move ()
{
  return this->R_Scan_Move_.get ();
}

void Motor::
R_Scan_Move (const R_Scan_Move_type& x)
{
  this->R_Scan_Move_.set (x);
}

void Motor::
R_Scan_Move (::std::auto_ptr< R_Scan_Move_type > x)
{
  this->R_Scan_Move_.set (x);
}

const Motor::Position_Forward_type& Motor::
Position_Forward () const
{
  return this->Position_Forward_.get ();
}

Motor::Position_Forward_type& Motor::
Position_Forward ()
{
  return this->Position_Forward_.get ();
}

void Motor::
Position_Forward (const Position_Forward_type& x)
{
  this->Position_Forward_.set (x);
}

void Motor::
Position_Forward (::std::auto_ptr< Position_Forward_type > x)
{
  this->Position_Forward_.set (x);
}

const Motor::Derivative_Time_type& Motor::
Derivative_Time () const
{
  return this->Derivative_Time_.get ();
}

Motor::Derivative_Time_type& Motor::
Derivative_Time ()
{
  return this->Derivative_Time_.get ();
}

void Motor::
Derivative_Time (const Derivative_Time_type& x)
{
  this->Derivative_Time_.set (x);
}

void Motor::
Derivative_Time (::std::auto_ptr< Derivative_Time_type > x)
{
  this->Derivative_Time_.set (x);
}

const Motor::Settle_Window_type& Motor::
Settle_Window () const
{
  return this->Settle_Window_.get ();
}

Motor::Settle_Window_type& Motor::
Settle_Window ()
{
  return this->Settle_Window_.get ();
}

void Motor::
Settle_Window (const Settle_Window_type& x)
{
  this->Settle_Window_.set (x);
}

void Motor::
Settle_Window (::std::auto_ptr< Settle_Window_type > x)
{
  this->Settle_Window_.set (x);
}

const Motor::Trace_Variable1_type& Motor::
Trace_Variable1 () const
{
  return this->Trace_Variable1_.get ();
}

Motor::Trace_Variable1_type& Motor::
Trace_Variable1 ()
{
  return this->Trace_Variable1_.get ();
}

void Motor::
Trace_Variable1 (const Trace_Variable1_type& x)
{
  this->Trace_Variable1_.set (x);
}

void Motor::
Trace_Variable1 (::std::auto_ptr< Trace_Variable1_type > x)
{
  this->Trace_Variable1_.set (x);
}

const Motor::Trace_Variable2_type& Motor::
Trace_Variable2 () const
{
  return this->Trace_Variable2_.get ();
}

Motor::Trace_Variable2_type& Motor::
Trace_Variable2 ()
{
  return this->Trace_Variable2_.get ();
}

void Motor::
Trace_Variable2 (const Trace_Variable2_type& x)
{
  this->Trace_Variable2_.set (x);
}

void Motor::
Trace_Variable2 (::std::auto_ptr< Trace_Variable2_type > x)
{
  this->Trace_Variable2_.set (x);
}

const Motor::Buffer_Read_Index_type& Motor::
Buffer_Read_Index () const
{
  return this->Buffer_Read_Index_.get ();
}

Motor::Buffer_Read_Index_type& Motor::
Buffer_Read_Index ()
{
  return this->Buffer_Read_Index_.get ();
}

void Motor::
Buffer_Read_Index (const Buffer_Read_Index_type& x)
{
  this->Buffer_Read_Index_.set (x);
}

void Motor::
Buffer_Read_Index (::std::auto_ptr< Buffer_Read_Index_type > x)
{
  this->Buffer_Read_Index_.set (x);
}

const Motor::Signal_Status_type& Motor::
Signal_Status () const
{
  return this->Signal_Status_.get ();
}

Motor::Signal_Status_type& Motor::
Signal_Status ()
{
  return this->Signal_Status_.get ();
}

void Motor::
Signal_Status (const Signal_Status_type& x)
{
  this->Signal_Status_.set (x);
}

void Motor::
Signal_Status (::std::auto_ptr< Signal_Status_type > x)
{
  this->Signal_Status_.set (x);
}

const Motor::Alarm_Clear_type& Motor::
Alarm_Clear () const
{
  return this->Alarm_Clear_.get ();
}

Motor::Alarm_Clear_type& Motor::
Alarm_Clear ()
{
  return this->Alarm_Clear_.get ();
}

void Motor::
Alarm_Clear (const Alarm_Clear_type& x)
{
  this->Alarm_Clear_.set (x);
}

void Motor::
Alarm_Clear (::std::auto_ptr< Alarm_Clear_type > x)
{
  this->Alarm_Clear_.set (x);
}

const Motor::Motion_Complete_Mode_type& Motor::
Motion_Complete_Mode () const
{
  return this->Motion_Complete_Mode_.get ();
}

Motor::Motion_Complete_Mode_type& Motor::
Motion_Complete_Mode ()
{
  return this->Motion_Complete_Mode_.get ();
}

void Motor::
Motion_Complete_Mode (const Motion_Complete_Mode_type& x)
{
  this->Motion_Complete_Mode_.set (x);
}

void Motor::
Motion_Complete_Mode (::std::auto_ptr< Motion_Complete_Mode_type > x)
{
  this->Motion_Complete_Mode_.set (x);
}

const Motor::R_Setup_Abort_type& Motor::
R_Setup_Abort () const
{
  return this->R_Setup_Abort_.get ();
}

Motor::R_Setup_Abort_type& Motor::
R_Setup_Abort ()
{
  return this->R_Setup_Abort_.get ();
}

void Motor::
R_Setup_Abort (const R_Setup_Abort_type& x)
{
  this->R_Setup_Abort_.set (x);
}

void Motor::
R_Setup_Abort (::std::auto_ptr< R_Setup_Abort_type > x)
{
  this->R_Setup_Abort_.set (x);
}

const Motor::Read_Buffer_type& Motor::
Read_Buffer () const
{
  return this->Read_Buffer_.get ();
}

Motor::Read_Buffer_type& Motor::
Read_Buffer ()
{
  return this->Read_Buffer_.get ();
}

void Motor::
Read_Buffer (const Read_Buffer_type& x)
{
  this->Read_Buffer_.set (x);
}

void Motor::
Read_Buffer (::std::auto_ptr< Read_Buffer_type > x)
{
  this->Read_Buffer_.set (x);
}

const Motor::Kd_type& Motor::
Kd () const
{
  return this->Kd_.get ();
}

Motor::Kd_type& Motor::
Kd ()
{
  return this->Kd_.get ();
}

void Motor::
Kd (const Kd_type& x)
{
  this->Kd_.set (x);
}

void Motor::
Kd (::std::auto_ptr< Kd_type > x)
{
  this->Kd_.set (x);
}

const Motor::Clear_Interrupt_type& Motor::
Clear_Interrupt () const
{
  return this->Clear_Interrupt_.get ();
}

Motor::Clear_Interrupt_type& Motor::
Clear_Interrupt ()
{
  return this->Clear_Interrupt_.get ();
}

void Motor::
Clear_Interrupt (const Clear_Interrupt_type& x)
{
  this->Clear_Interrupt_.set (x);
}

void Motor::
Clear_Interrupt (::std::auto_ptr< Clear_Interrupt_type > x)
{
  this->Clear_Interrupt_.set (x);
}

const Motor::Profile_Mode_type& Motor::
Profile_Mode () const
{
  return this->Profile_Mode_.get ();
}

Motor::Profile_Mode_type& Motor::
Profile_Mode ()
{
  return this->Profile_Mode_.get ();
}

void Motor::
Profile_Mode (const Profile_Mode_type& x)
{
  this->Profile_Mode_.set (x);
}

void Motor::
Profile_Mode (::std::auto_ptr< Profile_Mode_type > x)
{
  this->Profile_Mode_.set (x);
}

const Motor::R_Setup_Trace_type& Motor::
R_Setup_Trace () const
{
  return this->R_Setup_Trace_.get ();
}

Motor::R_Setup_Trace_type& Motor::
R_Setup_Trace ()
{
  return this->R_Setup_Trace_.get ();
}

void Motor::
R_Setup_Trace (const R_Setup_Trace_type& x)
{
  this->R_Setup_Trace_.set (x);
}

void Motor::
R_Setup_Trace (::std::auto_ptr< R_Setup_Trace_type > x)
{
  this->R_Setup_Trace_.set (x);
}

const Motor::No_Operation_type& Motor::
No_Operation () const
{
  return this->No_Operation_.get ();
}

Motor::No_Operation_type& Motor::
No_Operation ()
{
  return this->No_Operation_.get ();
}

void Motor::
No_Operation (const No_Operation_type& x)
{
  this->No_Operation_.set (x);
}

void Motor::
No_Operation (::std::auto_ptr< No_Operation_type > x)
{
  this->No_Operation_.set (x);
}

const Motor::Ki_type& Motor::
Ki () const
{
  return this->Ki_.get ();
}

Motor::Ki_type& Motor::
Ki ()
{
  return this->Ki_.get ();
}

void Motor::
Ki (const Ki_type& x)
{
  this->Ki_.set (x);
}

void Motor::
Ki (::std::auto_ptr< Ki_type > x)
{
  this->Ki_.set (x);
}

const Motor::Sample_Time_type& Motor::
Sample_Time () const
{
  return this->Sample_Time_.get ();
}

Motor::Sample_Time_type& Motor::
Sample_Time ()
{
  return this->Sample_Time_.get ();
}

void Motor::
Sample_Time (const Sample_Time_type& x)
{
  this->Sample_Time_.set (x);
}

void Motor::
Sample_Time (::std::auto_ptr< Sample_Time_type > x)
{
  this->Sample_Time_.set (x);
}


// Diag
// 

const Diag::Mem_Pagefile_type& Diag::
Mem_Pagefile () const
{
  return this->Mem_Pagefile_.get ();
}

Diag::Mem_Pagefile_type& Diag::
Mem_Pagefile ()
{
  return this->Mem_Pagefile_.get ();
}

void Diag::
Mem_Pagefile (const Mem_Pagefile_type& x)
{
  this->Mem_Pagefile_.set (x);
}

void Diag::
Mem_Pagefile (::std::auto_ptr< Mem_Pagefile_type > x)
{
  this->Mem_Pagefile_.set (x);
}

const Diag::Monitor_3point3V_type& Diag::
Monitor_3point3V () const
{
  return this->Monitor_3point3V_.get ();
}

Diag::Monitor_3point3V_type& Diag::
Monitor_3point3V ()
{
  return this->Monitor_3point3V_.get ();
}

void Diag::
Monitor_3point3V (const Monitor_3point3V_type& x)
{
  this->Monitor_3point3V_.set (x);
}

void Diag::
Monitor_3point3V (::std::auto_ptr< Monitor_3point3V_type > x)
{
  this->Monitor_3point3V_.set (x);
}

const Diag::USER_Objects_type& Diag::
USER_Objects () const
{
  return this->USER_Objects_.get ();
}

Diag::USER_Objects_type& Diag::
USER_Objects ()
{
  return this->USER_Objects_.get ();
}

void Diag::
USER_Objects (const USER_Objects_type& x)
{
  this->USER_Objects_.set (x);
}

void Diag::
USER_Objects (::std::auto_ptr< USER_Objects_type > x)
{
  this->USER_Objects_.set (x);
}

const Diag::Motor_FPGA_Revision_type& Diag::
Motor_FPGA_Revision () const
{
  return this->Motor_FPGA_Revision_.get ();
}

Diag::Motor_FPGA_Revision_type& Diag::
Motor_FPGA_Revision ()
{
  return this->Motor_FPGA_Revision_.get ();
}

void Diag::
Motor_FPGA_Revision (const Motor_FPGA_Revision_type& x)
{
  this->Motor_FPGA_Revision_.set (x);
}

void Diag::
Motor_FPGA_Revision (::std::auto_ptr< Motor_FPGA_Revision_type > x)
{
  this->Motor_FPGA_Revision_.set (x);
}

const Diag::Product_Name_type& Diag::
Product_Name () const
{
  return this->Product_Name_.get ();
}

Diag::Product_Name_type& Diag::
Product_Name ()
{
  return this->Product_Name_.get ();
}

void Diag::
Product_Name (const Product_Name_type& x)
{
  this->Product_Name_.set (x);
}

void Diag::
Product_Name (::std::auto_ptr< Product_Name_type > x)
{
  this->Product_Name_.set (x);
}

const Diag::Build_Version_type& Diag::
Build_Version () const
{
  return this->Build_Version_.get ();
}

Diag::Build_Version_type& Diag::
Build_Version ()
{
  return this->Build_Version_.get ();
}

void Diag::
Build_Version (const Build_Version_type& x)
{
  this->Build_Version_.set (x);
}

void Diag::
Build_Version (::std::auto_ptr< Build_Version_type > x)
{
  this->Build_Version_.set (x);
}

const Diag::ICB_PCB_ID_type& Diag::
ICB_PCB_ID () const
{
  return this->ICB_PCB_ID_.get ();
}

Diag::ICB_PCB_ID_type& Diag::
ICB_PCB_ID ()
{
  return this->ICB_PCB_ID_.get ();
}

void Diag::
ICB_PCB_ID (const ICB_PCB_ID_type& x)
{
  this->ICB_PCB_ID_.set (x);
}

void Diag::
ICB_PCB_ID (::std::auto_ptr< ICB_PCB_ID_type > x)
{
  this->ICB_PCB_ID_.set (x);
}

const Diag::Software_Version_type& Diag::
Software_Version () const
{
  return this->Software_Version_.get ();
}

Diag::Software_Version_type& Diag::
Software_Version ()
{
  return this->Software_Version_.get ();
}

void Diag::
Software_Version (const Software_Version_type& x)
{
  this->Software_Version_.set (x);
}

void Diag::
Software_Version (::std::auto_ptr< Software_Version_type > x)
{
  this->Software_Version_.set (x);
}

const Diag::Receive_PCB_ID_type& Diag::
Receive_PCB_ID () const
{
  return this->Receive_PCB_ID_.get ();
}

Diag::Receive_PCB_ID_type& Diag::
Receive_PCB_ID ()
{
  return this->Receive_PCB_ID_.get ();
}

void Diag::
Receive_PCB_ID (const Receive_PCB_ID_type& x)
{
  this->Receive_PCB_ID_.set (x);
}

void Diag::
Receive_PCB_ID (::std::auto_ptr< Receive_PCB_ID_type > x)
{
  this->Receive_PCB_ID_.set (x);
}

const Diag::Receive_FPGA_Revision_type& Diag::
Receive_FPGA_Revision () const
{
  return this->Receive_FPGA_Revision_.get ();
}

Diag::Receive_FPGA_Revision_type& Diag::
Receive_FPGA_Revision ()
{
  return this->Receive_FPGA_Revision_.get ();
}

void Diag::
Receive_FPGA_Revision (const Receive_FPGA_Revision_type& x)
{
  this->Receive_FPGA_Revision_.set (x);
}

void Diag::
Receive_FPGA_Revision (::std::auto_ptr< Receive_FPGA_Revision_type > x)
{
  this->Receive_FPGA_Revision_.set (x);
}

const Diag::Monitor_15V_type& Diag::
Monitor_15V () const
{
  return this->Monitor_15V_.get ();
}

Diag::Monitor_15V_type& Diag::
Monitor_15V ()
{
  return this->Monitor_15V_.get ();
}

void Diag::
Monitor_15V (const Monitor_15V_type& x)
{
  this->Monitor_15V_.set (x);
}

void Diag::
Monitor_15V (::std::auto_ptr< Monitor_15V_type > x)
{
  this->Monitor_15V_.set (x);
}

const Diag::ICB_FPGA_Revision_type& Diag::
ICB_FPGA_Revision () const
{
  return this->ICB_FPGA_Revision_.get ();
}

Diag::ICB_FPGA_Revision_type& Diag::
ICB_FPGA_Revision ()
{
  return this->ICB_FPGA_Revision_.get ();
}

void Diag::
ICB_FPGA_Revision (const ICB_FPGA_Revision_type& x)
{
  this->ICB_FPGA_Revision_.set (x);
}

void Diag::
ICB_FPGA_Revision (::std::auto_ptr< ICB_FPGA_Revision_type > x)
{
  this->ICB_FPGA_Revision_.set (x);
}

const Diag::GDI_Objects_type& Diag::
GDI_Objects () const
{
  return this->GDI_Objects_.get ();
}

Diag::GDI_Objects_type& Diag::
GDI_Objects ()
{
  return this->GDI_Objects_.get ();
}

void Diag::
GDI_Objects (const GDI_Objects_type& x)
{
  this->GDI_Objects_.set (x);
}

void Diag::
GDI_Objects (::std::auto_ptr< GDI_Objects_type > x)
{
  this->GDI_Objects_.set (x);
}

const Diag::Mem_WorkingSet_type& Diag::
Mem_WorkingSet () const
{
  return this->Mem_WorkingSet_.get ();
}

Diag::Mem_WorkingSet_type& Diag::
Mem_WorkingSet ()
{
  return this->Mem_WorkingSet_.get ();
}

void Diag::
Mem_WorkingSet (const Mem_WorkingSet_type& x)
{
  this->Mem_WorkingSet_.set (x);
}

void Diag::
Mem_WorkingSet (::std::auto_ptr< Mem_WorkingSet_type > x)
{
  this->Mem_WorkingSet_.set (x);
}

const Diag::Mem_Private_type& Diag::
Mem_Private () const
{
  return this->Mem_Private_.get ();
}

Diag::Mem_Private_type& Diag::
Mem_Private ()
{
  return this->Mem_Private_.get ();
}

void Diag::
Mem_Private (const Mem_Private_type& x)
{
  this->Mem_Private_.set (x);
}

void Diag::
Mem_Private (::std::auto_ptr< Mem_Private_type > x)
{
  this->Mem_Private_.set (x);
}

const Diag::Switch_PCB_ID_type& Diag::
Switch_PCB_ID () const
{
  return this->Switch_PCB_ID_.get ();
}

Diag::Switch_PCB_ID_type& Diag::
Switch_PCB_ID ()
{
  return this->Switch_PCB_ID_.get ();
}

void Diag::
Switch_PCB_ID (const Switch_PCB_ID_type& x)
{
  this->Switch_PCB_ID_.set (x);
}

void Diag::
Switch_PCB_ID (::std::auto_ptr< Switch_PCB_ID_type > x)
{
  this->Switch_PCB_ID_.set (x);
}

const Diag::Monitor_5V_type& Diag::
Monitor_5V () const
{
  return this->Monitor_5V_.get ();
}

Diag::Monitor_5V_type& Diag::
Monitor_5V ()
{
  return this->Monitor_5V_.get ();
}

void Diag::
Monitor_5V (const Monitor_5V_type& x)
{
  this->Monitor_5V_.set (x);
}

void Diag::
Monitor_5V (::std::auto_ptr< Monitor_5V_type > x)
{
  this->Monitor_5V_.set (x);
}

const Diag::Motor_PCB_Revision_type& Diag::
Motor_PCB_Revision () const
{
  return this->Motor_PCB_Revision_.get ();
}

Diag::Motor_PCB_Revision_type& Diag::
Motor_PCB_Revision ()
{
  return this->Motor_PCB_Revision_.get ();
}

void Diag::
Motor_PCB_Revision (const Motor_PCB_Revision_type& x)
{
  this->Motor_PCB_Revision_.set (x);
}

void Diag::
Motor_PCB_Revision (::std::auto_ptr< Motor_PCB_Revision_type > x)
{
  this->Motor_PCB_Revision_.set (x);
}

const Diag::NE1619_type& Diag::
NE1619 () const
{
  return this->NE1619_.get ();
}

Diag::NE1619_type& Diag::
NE1619 ()
{
  return this->NE1619_.get ();
}

void Diag::
NE1619 (const NE1619_type& x)
{
  this->NE1619_.set (x);
}

void Diag::
NE1619 (::std::auto_ptr< NE1619_type > x)
{
  this->NE1619_.set (x);
}

const Diag::Motor_PCB_ID_type& Diag::
Motor_PCB_ID () const
{
  return this->Motor_PCB_ID_.get ();
}

Diag::Motor_PCB_ID_type& Diag::
Motor_PCB_ID ()
{
  return this->Motor_PCB_ID_.get ();
}

void Diag::
Motor_PCB_ID (const Motor_PCB_ID_type& x)
{
  this->Motor_PCB_ID_.set (x);
}

void Diag::
Motor_PCB_ID (::std::auto_ptr< Motor_PCB_ID_type > x)
{
  this->Motor_PCB_ID_.set (x);
}

const Diag::Transmit_PCB_Revision_type& Diag::
Transmit_PCB_Revision () const
{
  return this->Transmit_PCB_Revision_.get ();
}

Diag::Transmit_PCB_Revision_type& Diag::
Transmit_PCB_Revision ()
{
  return this->Transmit_PCB_Revision_.get ();
}

void Diag::
Transmit_PCB_Revision (const Transmit_PCB_Revision_type& x)
{
  this->Transmit_PCB_Revision_.set (x);
}

void Diag::
Transmit_PCB_Revision (::std::auto_ptr< Transmit_PCB_Revision_type > x)
{
  this->Transmit_PCB_Revision_.set (x);
}

const Diag::MAX1137_type& Diag::
MAX1137 () const
{
  return this->MAX1137_.get ();
}

Diag::MAX1137_type& Diag::
MAX1137 ()
{
  return this->MAX1137_.get ();
}

void Diag::
MAX1137 (const MAX1137_type& x)
{
  this->MAX1137_.set (x);
}

void Diag::
MAX1137 (::std::auto_ptr< MAX1137_type > x)
{
  this->MAX1137_.set (x);
}

const Diag::Monitor_Neg15V_type& Diag::
Monitor_Neg15V () const
{
  return this->Monitor_Neg15V_.get ();
}

Diag::Monitor_Neg15V_type& Diag::
Monitor_Neg15V ()
{
  return this->Monitor_Neg15V_.get ();
}

void Diag::
Monitor_Neg15V (const Monitor_Neg15V_type& x)
{
  this->Monitor_Neg15V_.set (x);
}

void Diag::
Monitor_Neg15V (::std::auto_ptr< Monitor_Neg15V_type > x)
{
  this->Monitor_Neg15V_.set (x);
}

const Diag::Monitor_Neg5V_type& Diag::
Monitor_Neg5V () const
{
  return this->Monitor_Neg5V_.get ();
}

Diag::Monitor_Neg5V_type& Diag::
Monitor_Neg5V ()
{
  return this->Monitor_Neg5V_.get ();
}

void Diag::
Monitor_Neg5V (const Monitor_Neg5V_type& x)
{
  this->Monitor_Neg5V_.set (x);
}

void Diag::
Monitor_Neg5V (::std::auto_ptr< Monitor_Neg5V_type > x)
{
  this->Monitor_Neg5V_.set (x);
}

const Diag::Switch_PCB_Revision_type& Diag::
Switch_PCB_Revision () const
{
  return this->Switch_PCB_Revision_.get ();
}

Diag::Switch_PCB_Revision_type& Diag::
Switch_PCB_Revision ()
{
  return this->Switch_PCB_Revision_.get ();
}

void Diag::
Switch_PCB_Revision (const Switch_PCB_Revision_type& x)
{
  this->Switch_PCB_Revision_.set (x);
}

void Diag::
Switch_PCB_Revision (::std::auto_ptr< Switch_PCB_Revision_type > x)
{
  this->Switch_PCB_Revision_.set (x);
}

const Diag::Receive_PCB_Revision_type& Diag::
Receive_PCB_Revision () const
{
  return this->Receive_PCB_Revision_.get ();
}

Diag::Receive_PCB_Revision_type& Diag::
Receive_PCB_Revision ()
{
  return this->Receive_PCB_Revision_.get ();
}

void Diag::
Receive_PCB_Revision (const Receive_PCB_Revision_type& x)
{
  this->Receive_PCB_Revision_.set (x);
}

void Diag::
Receive_PCB_Revision (::std::auto_ptr< Receive_PCB_Revision_type > x)
{
  this->Receive_PCB_Revision_.set (x);
}

const Diag::ICB_PCB_Revision_type& Diag::
ICB_PCB_Revision () const
{
  return this->ICB_PCB_Revision_.get ();
}

Diag::ICB_PCB_Revision_type& Diag::
ICB_PCB_Revision ()
{
  return this->ICB_PCB_Revision_.get ();
}

void Diag::
ICB_PCB_Revision (const ICB_PCB_Revision_type& x)
{
  this->ICB_PCB_Revision_.set (x);
}

void Diag::
ICB_PCB_Revision (::std::auto_ptr< ICB_PCB_Revision_type > x)
{
  this->ICB_PCB_Revision_.set (x);
}

const Diag::Transmit_PCB_ID_type& Diag::
Transmit_PCB_ID () const
{
  return this->Transmit_PCB_ID_.get ();
}

Diag::Transmit_PCB_ID_type& Diag::
Transmit_PCB_ID ()
{
  return this->Transmit_PCB_ID_.get ();
}

void Diag::
Transmit_PCB_ID (const Transmit_PCB_ID_type& x)
{
  this->Transmit_PCB_ID_.set (x);
}

void Diag::
Transmit_PCB_ID (::std::auto_ptr< Transmit_PCB_ID_type > x)
{
  this->Transmit_PCB_ID_.set (x);
}

const Diag::Monitor_Temperature_type& Diag::
Monitor_Temperature () const
{
  return this->Monitor_Temperature_.get ();
}

Diag::Monitor_Temperature_type& Diag::
Monitor_Temperature ()
{
  return this->Monitor_Temperature_.get ();
}

void Diag::
Monitor_Temperature (const Monitor_Temperature_type& x)
{
  this->Monitor_Temperature_.set (x);
}

void Diag::
Monitor_Temperature (::std::auto_ptr< Monitor_Temperature_type > x)
{
  this->Monitor_Temperature_.set (x);
}


// ECG
// 

const ECG::Respiration_Threshold_Change_type& ECG::
Respiration_Threshold_Change () const
{
  return this->Respiration_Threshold_Change_.get ();
}

ECG::Respiration_Threshold_Change_type& ECG::
Respiration_Threshold_Change ()
{
  return this->Respiration_Threshold_Change_.get ();
}

void ECG::
Respiration_Threshold_Change (const Respiration_Threshold_Change_type& x)
{
  this->Respiration_Threshold_Change_.set (x);
}

void ECG::
Respiration_Threshold_Change (::std::auto_ptr< Respiration_Threshold_Change_type > x)
{
  this->Respiration_Threshold_Change_.set (x);
}

const ECG::Respiration_Threshold_type& ECG::
Respiration_Threshold () const
{
  return this->Respiration_Threshold_.get ();
}

ECG::Respiration_Threshold_type& ECG::
Respiration_Threshold ()
{
  return this->Respiration_Threshold_.get ();
}

void ECG::
Respiration_Threshold (const Respiration_Threshold_type& x)
{
  this->Respiration_Threshold_.set (x);
}

void ECG::
Respiration_Threshold (::std::auto_ptr< Respiration_Threshold_type > x)
{
  this->Respiration_Threshold_.set (x);
}

const ECG::Pressure_Range_type& ECG::
Pressure_Range () const
{
  return this->Pressure_Range_.get ();
}

ECG::Pressure_Range_type& ECG::
Pressure_Range ()
{
  return this->Pressure_Range_.get ();
}

void ECG::
Pressure_Range (const Pressure_Range_type& x)
{
  this->Pressure_Range_.set (x);
}

void ECG::
Pressure_Range (::std::auto_ptr< Pressure_Range_type > x)
{
  this->Pressure_Range_.set (x);
}

const ECG::Respiration_Gate_Delay_type& ECG::
Respiration_Gate_Delay () const
{
  return this->Respiration_Gate_Delay_.get ();
}

ECG::Respiration_Gate_Delay_type& ECG::
Respiration_Gate_Delay ()
{
  return this->Respiration_Gate_Delay_.get ();
}

void ECG::
Respiration_Gate_Delay (const Respiration_Gate_Delay_type& x)
{
  this->Respiration_Gate_Delay_.set (x);
}

void ECG::
Respiration_Gate_Delay (::std::auto_ptr< Respiration_Gate_Delay_type > x)
{
  this->Respiration_Gate_Delay_.set (x);
}

const ECG::Respiration_Timeout_type& ECG::
Respiration_Timeout () const
{
  return this->Respiration_Timeout_.get ();
}

ECG::Respiration_Timeout_type& ECG::
Respiration_Timeout ()
{
  return this->Respiration_Timeout_.get ();
}

void ECG::
Respiration_Timeout (const Respiration_Timeout_type& x)
{
  this->Respiration_Timeout_.set (x);
}

void ECG::
Respiration_Timeout (::std::auto_ptr< Respiration_Timeout_type > x)
{
  this->Respiration_Timeout_.set (x);
}

const ECG::RWave_Max_Change_Factor_Percent_type& ECG::
RWave_Max_Change_Factor_Percent () const
{
  return this->RWave_Max_Change_Factor_Percent_.get ();
}

ECG::RWave_Max_Change_Factor_Percent_type& ECG::
RWave_Max_Change_Factor_Percent ()
{
  return this->RWave_Max_Change_Factor_Percent_.get ();
}

void ECG::
RWave_Max_Change_Factor_Percent (const RWave_Max_Change_Factor_Percent_type& x)
{
  this->RWave_Max_Change_Factor_Percent_.set (x);
}

void ECG::
RWave_Max_Change_Factor_Percent (::std::auto_ptr< RWave_Max_Change_Factor_Percent_type > x)
{
  this->RWave_Max_Change_Factor_Percent_.set (x);
}

const ECG::Respiration_Period_type& ECG::
Respiration_Period () const
{
  return this->Respiration_Period_.get ();
}

ECG::Respiration_Period_type& ECG::
Respiration_Period ()
{
  return this->Respiration_Period_.get ();
}

void ECG::
Respiration_Period (const Respiration_Period_type& x)
{
  this->Respiration_Period_.set (x);
}

void ECG::
Respiration_Period (::std::auto_ptr< Respiration_Period_type > x)
{
  this->Respiration_Period_.set (x);
}

const ECG::Respiration_Subsample_Rate_type& ECG::
Respiration_Subsample_Rate () const
{
  return this->Respiration_Subsample_Rate_.get ();
}

ECG::Respiration_Subsample_Rate_type& ECG::
Respiration_Subsample_Rate ()
{
  return this->Respiration_Subsample_Rate_.get ();
}

void ECG::
Respiration_Subsample_Rate (const Respiration_Subsample_Rate_type& x)
{
  this->Respiration_Subsample_Rate_.set (x);
}

void ECG::
Respiration_Subsample_Rate (::std::auto_ptr< Respiration_Subsample_Rate_type > x)
{
  this->Respiration_Subsample_Rate_.set (x);
}

const ECG::Show_RWaves_type& ECG::
Show_RWaves () const
{
  return this->Show_RWaves_.get ();
}

ECG::Show_RWaves_type& ECG::
Show_RWaves ()
{
  return this->Show_RWaves_.get ();
}

void ECG::
Show_RWaves (const Show_RWaves_type& x)
{
  this->Show_RWaves_.set (x);
}

void ECG::
Show_RWaves (::std::auto_ptr< Show_RWaves_type > x)
{
  this->Show_RWaves_.set (x);
}

const ECG::Respiration_Minimal_Peak_2_Peak_type& ECG::
Respiration_Minimal_Peak_2_Peak () const
{
  return this->Respiration_Minimal_Peak_2_Peak_.get ();
}

ECG::Respiration_Minimal_Peak_2_Peak_type& ECG::
Respiration_Minimal_Peak_2_Peak ()
{
  return this->Respiration_Minimal_Peak_2_Peak_.get ();
}

void ECG::
Respiration_Minimal_Peak_2_Peak (const Respiration_Minimal_Peak_2_Peak_type& x)
{
  this->Respiration_Minimal_Peak_2_Peak_.set (x);
}

void ECG::
Respiration_Minimal_Peak_2_Peak (::std::auto_ptr< Respiration_Minimal_Peak_2_Peak_type > x)
{
  this->Respiration_Minimal_Peak_2_Peak_.set (x);
}

const ECG::Respiration_Window_type& ECG::
Respiration_Window () const
{
  return this->Respiration_Window_.get ();
}

ECG::Respiration_Window_type& ECG::
Respiration_Window ()
{
  return this->Respiration_Window_.get ();
}

void ECG::
Respiration_Window (const Respiration_Window_type& x)
{
  this->Respiration_Window_.set (x);
}

void ECG::
Respiration_Window (::std::auto_ptr< Respiration_Window_type > x)
{
  this->Respiration_Window_.set (x);
}

const ECG::Pressure_Zeroed_type& ECG::
Pressure_Zeroed () const
{
  return this->Pressure_Zeroed_.get ();
}

ECG::Pressure_Zeroed_type& ECG::
Pressure_Zeroed ()
{
  return this->Pressure_Zeroed_.get ();
}

void ECG::
Pressure_Zeroed (const Pressure_Zeroed_type& x)
{
  this->Pressure_Zeroed_.set (x);
}

void ECG::
Pressure_Zeroed (::std::auto_ptr< Pressure_Zeroed_type > x)
{
  this->Pressure_Zeroed_.set (x);
}

const ECG::Pressure_Systolic_type& ECG::
Pressure_Systolic () const
{
  return this->Pressure_Systolic_.get ();
}

ECG::Pressure_Systolic_type& ECG::
Pressure_Systolic ()
{
  return this->Pressure_Systolic_.get ();
}

void ECG::
Pressure_Systolic (const Pressure_Systolic_type& x)
{
  this->Pressure_Systolic_.set (x);
}

void ECG::
Pressure_Systolic (::std::auto_ptr< Pressure_Systolic_type > x)
{
  this->Pressure_Systolic_.set (x);
}

const ECG::Respiration_Show_Window_type& ECG::
Respiration_Show_Window () const
{
  return this->Respiration_Show_Window_.get ();
}

ECG::Respiration_Show_Window_type& ECG::
Respiration_Show_Window ()
{
  return this->Respiration_Show_Window_.get ();
}

void ECG::
Respiration_Show_Window (const Respiration_Show_Window_type& x)
{
  this->Respiration_Show_Window_.set (x);
}

void ECG::
Respiration_Show_Window (::std::auto_ptr< Respiration_Show_Window_type > x)
{
  this->Respiration_Show_Window_.set (x);
}

const ECG::Frequency_type& ECG::
Frequency () const
{
  return this->Frequency_.get ();
}

ECG::Frequency_type& ECG::
Frequency ()
{
  return this->Frequency_.get ();
}

void ECG::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void ECG::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const ECG::Respiration_Blank_Period_type& ECG::
Respiration_Blank_Period () const
{
  return this->Respiration_Blank_Period_.get ();
}

ECG::Respiration_Blank_Period_type& ECG::
Respiration_Blank_Period ()
{
  return this->Respiration_Blank_Period_.get ();
}

void ECG::
Respiration_Blank_Period (const Respiration_Blank_Period_type& x)
{
  this->Respiration_Blank_Period_.set (x);
}

void ECG::
Respiration_Blank_Period (::std::auto_ptr< Respiration_Blank_Period_type > x)
{
  this->Respiration_Blank_Period_.set (x);
}

const ECG::Respiration_Range_type& ECG::
Respiration_Range () const
{
  return this->Respiration_Range_.get ();
}

ECG::Respiration_Range_type& ECG::
Respiration_Range ()
{
  return this->Respiration_Range_.get ();
}

void ECG::
Respiration_Range (const Respiration_Range_type& x)
{
  this->Respiration_Range_.set (x);
}

void ECG::
Respiration_Range (::std::auto_ptr< Respiration_Range_type > x)
{
  this->Respiration_Range_.set (x);
}

const ECG::Pressure_Zero_type& ECG::
Pressure_Zero () const
{
  return this->Pressure_Zero_.get ();
}

ECG::Pressure_Zero_type& ECG::
Pressure_Zero ()
{
  return this->Pressure_Zero_.get ();
}

void ECG::
Pressure_Zero (const Pressure_Zero_type& x)
{
  this->Pressure_Zero_.set (x);
}

void ECG::
Pressure_Zero (::std::auto_ptr< Pressure_Zero_type > x)
{
  this->Pressure_Zero_.set (x);
}

const ECG::Temperature_Amplification_type& ECG::
Temperature_Amplification () const
{
  return this->Temperature_Amplification_.get ();
}

ECG::Temperature_Amplification_type& ECG::
Temperature_Amplification ()
{
  return this->Temperature_Amplification_.get ();
}

void ECG::
Temperature_Amplification (const Temperature_Amplification_type& x)
{
  this->Temperature_Amplification_.set (x);
}

void ECG::
Temperature_Amplification (::std::auto_ptr< Temperature_Amplification_type > x)
{
  this->Temperature_Amplification_.set (x);
}

const ECG::P_Wave_Start_type& ECG::
P_Wave_Start () const
{
  return this->P_Wave_Start_.get ();
}

ECG::P_Wave_Start_type& ECG::
P_Wave_Start ()
{
  return this->P_Wave_Start_.get ();
}

void ECG::
P_Wave_Start (const P_Wave_Start_type& x)
{
  this->P_Wave_Start_.set (x);
}

void ECG::
P_Wave_Start (::std::auto_ptr< P_Wave_Start_type > x)
{
  this->P_Wave_Start_.set (x);
}

const ECG::ECG_Filter_Taps_type& ECG::
ECG_Filter_Taps () const
{
  return this->ECG_Filter_Taps_.get ();
}

ECG::ECG_Filter_Taps_type& ECG::
ECG_Filter_Taps ()
{
  return this->ECG_Filter_Taps_.get ();
}

void ECG::
ECG_Filter_Taps (const ECG_Filter_Taps_type& x)
{
  this->ECG_Filter_Taps_.set (x);
}

void ECG::
ECG_Filter_Taps (::std::auto_ptr< ECG_Filter_Taps_type > x)
{
  this->ECG_Filter_Taps_.set (x);
}

const ECG::RWave_Future_Search_Time_type& ECG::
RWave_Future_Search_Time () const
{
  return this->RWave_Future_Search_Time_.get ();
}

ECG::RWave_Future_Search_Time_type& ECG::
RWave_Future_Search_Time ()
{
  return this->RWave_Future_Search_Time_.get ();
}

void ECG::
RWave_Future_Search_Time (const RWave_Future_Search_Time_type& x)
{
  this->RWave_Future_Search_Time_.set (x);
}

void ECG::
RWave_Future_Search_Time (::std::auto_ptr< RWave_Future_Search_Time_type > x)
{
  this->RWave_Future_Search_Time_.set (x);
}

const ECG::Respiration_Percent_Peak_type& ECG::
Respiration_Percent_Peak () const
{
  return this->Respiration_Percent_Peak_.get ();
}

ECG::Respiration_Percent_Peak_type& ECG::
Respiration_Percent_Peak ()
{
  return this->Respiration_Percent_Peak_.get ();
}

void ECG::
Respiration_Percent_Peak (const Respiration_Percent_Peak_type& x)
{
  this->Respiration_Percent_Peak_.set (x);
}

void ECG::
Respiration_Percent_Peak (::std::auto_ptr< Respiration_Percent_Peak_type > x)
{
  this->Respiration_Percent_Peak_.set (x);
}

const ECG::T_Wave_Start_type& ECG::
T_Wave_Start () const
{
  return this->T_Wave_Start_.get ();
}

ECG::T_Wave_Start_type& ECG::
T_Wave_Start ()
{
  return this->T_Wave_Start_.get ();
}

void ECG::
T_Wave_Start (const T_Wave_Start_type& x)
{
  this->T_Wave_Start_.set (x);
}

void ECG::
T_Wave_Start (::std::auto_ptr< T_Wave_Start_type > x)
{
  this->T_Wave_Start_.set (x);
}

const ECG::Strain_Rate_RR_Diff_Ratio_type& ECG::
Strain_Rate_RR_Diff_Ratio () const
{
  return this->Strain_Rate_RR_Diff_Ratio_.get ();
}

ECG::Strain_Rate_RR_Diff_Ratio_type& ECG::
Strain_Rate_RR_Diff_Ratio ()
{
  return this->Strain_Rate_RR_Diff_Ratio_.get ();
}

void ECG::
Strain_Rate_RR_Diff_Ratio (const Strain_Rate_RR_Diff_Ratio_type& x)
{
  this->Strain_Rate_RR_Diff_Ratio_.set (x);
}

void ECG::
Strain_Rate_RR_Diff_Ratio (::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type > x)
{
  this->Strain_Rate_RR_Diff_Ratio_.set (x);
}

const ECG::Pressure_Calibration_Min_Level_type& ECG::
Pressure_Calibration_Min_Level () const
{
  return this->Pressure_Calibration_Min_Level_.get ();
}

ECG::Pressure_Calibration_Min_Level_type& ECG::
Pressure_Calibration_Min_Level ()
{
  return this->Pressure_Calibration_Min_Level_.get ();
}

void ECG::
Pressure_Calibration_Min_Level (const Pressure_Calibration_Min_Level_type& x)
{
  this->Pressure_Calibration_Min_Level_.set (x);
}

void ECG::
Pressure_Calibration_Min_Level (::std::auto_ptr< Pressure_Calibration_Min_Level_type > x)
{
  this->Pressure_Calibration_Min_Level_.set (x);
}

const ECG::Pressure_Calibrated_type& ECG::
Pressure_Calibrated () const
{
  return this->Pressure_Calibrated_.get ();
}

ECG::Pressure_Calibrated_type& ECG::
Pressure_Calibrated ()
{
  return this->Pressure_Calibrated_.get ();
}

void ECG::
Pressure_Calibrated (const Pressure_Calibrated_type& x)
{
  this->Pressure_Calibrated_.set (x);
}

void ECG::
Pressure_Calibrated (::std::auto_ptr< Pressure_Calibrated_type > x)
{
  this->Pressure_Calibrated_.set (x);
}

const ECG::DPDT_Range_type& ECG::
DPDT_Range () const
{
  return this->DPDT_Range_.get ();
}

ECG::DPDT_Range_type& ECG::
DPDT_Range ()
{
  return this->DPDT_Range_.get ();
}

void ECG::
DPDT_Range (const DPDT_Range_type& x)
{
  this->DPDT_Range_.set (x);
}

void ECG::
DPDT_Range (::std::auto_ptr< DPDT_Range_type > x)
{
  this->DPDT_Range_.set (x);
}

const ECG::Respiration_Show_Event_type& ECG::
Respiration_Show_Event () const
{
  return this->Respiration_Show_Event_.get ();
}

ECG::Respiration_Show_Event_type& ECG::
Respiration_Show_Event ()
{
  return this->Respiration_Show_Event_.get ();
}

void ECG::
Respiration_Show_Event (const Respiration_Show_Event_type& x)
{
  this->Respiration_Show_Event_.set (x);
}

void ECG::
Respiration_Show_Event (::std::auto_ptr< Respiration_Show_Event_type > x)
{
  this->Respiration_Show_Event_.set (x);
}

const ECG::Pressure_Diastolic_type& ECG::
Pressure_Diastolic () const
{
  return this->Pressure_Diastolic_.get ();
}

ECG::Pressure_Diastolic_type& ECG::
Pressure_Diastolic ()
{
  return this->Pressure_Diastolic_.get ();
}

void ECG::
Pressure_Diastolic (const Pressure_Diastolic_type& x)
{
  this->Pressure_Diastolic_.set (x);
}

void ECG::
Pressure_Diastolic (::std::auto_ptr< Pressure_Diastolic_type > x)
{
  this->Pressure_Diastolic_.set (x);
}

const ECG::Temperature_Calibration_type& ECG::
Temperature_Calibration () const
{
  return this->Temperature_Calibration_.get ();
}

ECG::Temperature_Calibration_type& ECG::
Temperature_Calibration ()
{
  return this->Temperature_Calibration_.get ();
}

void ECG::
Temperature_Calibration (const Temperature_Calibration_type& x)
{
  this->Temperature_Calibration_.set (x);
}

void ECG::
Temperature_Calibration (::std::auto_ptr< Temperature_Calibration_type > x)
{
  this->Temperature_Calibration_.set (x);
}

const ECG::Temperature_type& ECG::
Temperature () const
{
  return this->Temperature_.get ();
}

ECG::Temperature_type& ECG::
Temperature ()
{
  return this->Temperature_.get ();
}

void ECG::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void ECG::
Temperature (::std::auto_ptr< Temperature_type > x)
{
  this->Temperature_.set (x);
}

const ECG::Respiration_Beats_To_Average_type& ECG::
Respiration_Beats_To_Average () const
{
  return this->Respiration_Beats_To_Average_.get ();
}

ECG::Respiration_Beats_To_Average_type& ECG::
Respiration_Beats_To_Average ()
{
  return this->Respiration_Beats_To_Average_.get ();
}

void ECG::
Respiration_Beats_To_Average (const Respiration_Beats_To_Average_type& x)
{
  this->Respiration_Beats_To_Average_.set (x);
}

void ECG::
Respiration_Beats_To_Average (::std::auto_ptr< Respiration_Beats_To_Average_type > x)
{
  this->Respiration_Beats_To_Average_.set (x);
}

const ECG::RWave_Thresh_Trigger_Percent_type& ECG::
RWave_Thresh_Trigger_Percent () const
{
  return this->RWave_Thresh_Trigger_Percent_.get ();
}

ECG::RWave_Thresh_Trigger_Percent_type& ECG::
RWave_Thresh_Trigger_Percent ()
{
  return this->RWave_Thresh_Trigger_Percent_.get ();
}

void ECG::
RWave_Thresh_Trigger_Percent (const RWave_Thresh_Trigger_Percent_type& x)
{
  this->RWave_Thresh_Trigger_Percent_.set (x);
}

void ECG::
RWave_Thresh_Trigger_Percent (::std::auto_ptr< RWave_Thresh_Trigger_Percent_type > x)
{
  this->RWave_Thresh_Trigger_Percent_.set (x);
}

const ECG::Respiration_Time_To_Average_type& ECG::
Respiration_Time_To_Average () const
{
  return this->Respiration_Time_To_Average_.get ();
}

ECG::Respiration_Time_To_Average_type& ECG::
Respiration_Time_To_Average ()
{
  return this->Respiration_Time_To_Average_.get ();
}

void ECG::
Respiration_Time_To_Average (const Respiration_Time_To_Average_type& x)
{
  this->Respiration_Time_To_Average_.set (x);
}

void ECG::
Respiration_Time_To_Average (::std::auto_ptr< Respiration_Time_To_Average_type > x)
{
  this->Respiration_Time_To_Average_.set (x);
}

const ECG::Pressure_Amplification_type& ECG::
Pressure_Amplification () const
{
  return this->Pressure_Amplification_.get ();
}

ECG::Pressure_Amplification_type& ECG::
Pressure_Amplification ()
{
  return this->Pressure_Amplification_.get ();
}

void ECG::
Pressure_Amplification (const Pressure_Amplification_type& x)
{
  this->Pressure_Amplification_.set (x);
}

void ECG::
Pressure_Amplification (::std::auto_ptr< Pressure_Amplification_type > x)
{
  this->Pressure_Amplification_.set (x);
}

const ECG::Heart_Period_type& ECG::
Heart_Period () const
{
  return this->Heart_Period_.get ();
}

ECG::Heart_Period_type& ECG::
Heart_Period ()
{
  return this->Heart_Period_.get ();
}

void ECG::
Heart_Period (const Heart_Period_type& x)
{
  this->Heart_Period_.set (x);
}

void ECG::
Heart_Period (::std::auto_ptr< Heart_Period_type > x)
{
  this->Heart_Period_.set (x);
}

const ECG::Pressure_Show_Event_type& ECG::
Pressure_Show_Event () const
{
  return this->Pressure_Show_Event_.get ();
}

ECG::Pressure_Show_Event_type& ECG::
Pressure_Show_Event ()
{
  return this->Pressure_Show_Event_.get ();
}

void ECG::
Pressure_Show_Event (const Pressure_Show_Event_type& x)
{
  this->Pressure_Show_Event_.set (x);
}

void ECG::
Pressure_Show_Event (::std::auto_ptr< Pressure_Show_Event_type > x)
{
  this->Pressure_Show_Event_.set (x);
}

const ECG::RWave_Default_Threshold_type& ECG::
RWave_Default_Threshold () const
{
  return this->RWave_Default_Threshold_.get ();
}

ECG::RWave_Default_Threshold_type& ECG::
RWave_Default_Threshold ()
{
  return this->RWave_Default_Threshold_.get ();
}

void ECG::
RWave_Default_Threshold (const RWave_Default_Threshold_type& x)
{
  this->RWave_Default_Threshold_.set (x);
}

void ECG::
RWave_Default_Threshold (::std::auto_ptr< RWave_Default_Threshold_type > x)
{
  this->RWave_Default_Threshold_.set (x);
}

const ECG::Show_Filtered_Data_type& ECG::
Show_Filtered_Data () const
{
  return this->Show_Filtered_Data_.get ();
}

ECG::Show_Filtered_Data_type& ECG::
Show_Filtered_Data ()
{
  return this->Show_Filtered_Data_.get ();
}

void ECG::
Show_Filtered_Data (const Show_Filtered_Data_type& x)
{
  this->Show_Filtered_Data_.set (x);
}

void ECG::
Show_Filtered_Data (::std::auto_ptr< Show_Filtered_Data_type > x)
{
  this->Show_Filtered_Data_.set (x);
}

const ECG::ECG_Range_type& ECG::
ECG_Range () const
{
  return this->ECG_Range_.get ();
}

ECG::ECG_Range_type& ECG::
ECG_Range ()
{
  return this->ECG_Range_.get ();
}

void ECG::
ECG_Range (const ECG_Range_type& x)
{
  this->ECG_Range_.set (x);
}

void ECG::
ECG_Range (::std::auto_ptr< ECG_Range_type > x)
{
  this->ECG_Range_.set (x);
}

const ECG::RWave_Maxima_Block_Time_type& ECG::
RWave_Maxima_Block_Time () const
{
  return this->RWave_Maxima_Block_Time_.get ();
}

ECG::RWave_Maxima_Block_Time_type& ECG::
RWave_Maxima_Block_Time ()
{
  return this->RWave_Maxima_Block_Time_.get ();
}

void ECG::
RWave_Maxima_Block_Time (const RWave_Maxima_Block_Time_type& x)
{
  this->RWave_Maxima_Block_Time_.set (x);
}

void ECG::
RWave_Maxima_Block_Time (::std::auto_ptr< RWave_Maxima_Block_Time_type > x)
{
  this->RWave_Maxima_Block_Time_.set (x);
}

const ECG::RWave_Noise_Threshold_type& ECG::
RWave_Noise_Threshold () const
{
  return this->RWave_Noise_Threshold_.get ();
}

ECG::RWave_Noise_Threshold_type& ECG::
RWave_Noise_Threshold ()
{
  return this->RWave_Noise_Threshold_.get ();
}

void ECG::
RWave_Noise_Threshold (const RWave_Noise_Threshold_type& x)
{
  this->RWave_Noise_Threshold_.set (x);
}

void ECG::
RWave_Noise_Threshold (::std::auto_ptr< RWave_Noise_Threshold_type > x)
{
  this->RWave_Noise_Threshold_.set (x);
}

const ECG::Pressure_Calibration_Level_type& ECG::
Pressure_Calibration_Level () const
{
  return this->Pressure_Calibration_Level_.get ();
}

ECG::Pressure_Calibration_Level_type& ECG::
Pressure_Calibration_Level ()
{
  return this->Pressure_Calibration_Level_.get ();
}

void ECG::
Pressure_Calibration_Level (const Pressure_Calibration_Level_type& x)
{
  this->Pressure_Calibration_Level_.set (x);
}

void ECG::
Pressure_Calibration_Level (::std::auto_ptr< Pressure_Calibration_Level_type > x)
{
  this->Pressure_Calibration_Level_.set (x);
}

const ECG::ECG_HP_Filter_type& ECG::
ECG_HP_Filter () const
{
  return this->ECG_HP_Filter_.get ();
}

ECG::ECG_HP_Filter_type& ECG::
ECG_HP_Filter ()
{
  return this->ECG_HP_Filter_.get ();
}

void ECG::
ECG_HP_Filter (const ECG_HP_Filter_type& x)
{
  this->ECG_HP_Filter_.set (x);
}

void ECG::
ECG_HP_Filter (::std::auto_ptr< ECG_HP_Filter_type > x)
{
  this->ECG_HP_Filter_.set (x);
}

const ECG::ECG_LP_Filter_type& ECG::
ECG_LP_Filter () const
{
  return this->ECG_LP_Filter_.get ();
}

ECG::ECG_LP_Filter_type& ECG::
ECG_LP_Filter ()
{
  return this->ECG_LP_Filter_.get ();
}

void ECG::
ECG_LP_Filter (const ECG_LP_Filter_type& x)
{
  this->ECG_LP_Filter_.set (x);
}

void ECG::
ECG_LP_Filter (::std::auto_ptr< ECG_LP_Filter_type > x)
{
  this->ECG_LP_Filter_.set (x);
}

const ECG::RWave_Max_Change_Period_type& ECG::
RWave_Max_Change_Period () const
{
  return this->RWave_Max_Change_Period_.get ();
}

ECG::RWave_Max_Change_Period_type& ECG::
RWave_Max_Change_Period ()
{
  return this->RWave_Max_Change_Period_.get ();
}

void ECG::
RWave_Max_Change_Period (const RWave_Max_Change_Period_type& x)
{
  this->RWave_Max_Change_Period_.set (x);
}

void ECG::
RWave_Max_Change_Period (::std::auto_ptr< RWave_Max_Change_Period_type > x)
{
  this->RWave_Max_Change_Period_.set (x);
}

const ECG::Pressure_Time_Out_type& ECG::
Pressure_Time_Out () const
{
  return this->Pressure_Time_Out_.get ();
}

ECG::Pressure_Time_Out_type& ECG::
Pressure_Time_Out ()
{
  return this->Pressure_Time_Out_.get ();
}

void ECG::
Pressure_Time_Out (const Pressure_Time_Out_type& x)
{
  this->Pressure_Time_Out_.set (x);
}

void ECG::
Pressure_Time_Out (::std::auto_ptr< Pressure_Time_Out_type > x)
{
  this->Pressure_Time_Out_.set (x);
}

const ECG::Pressure_Calibration_type& ECG::
Pressure_Calibration () const
{
  return this->Pressure_Calibration_.get ();
}

ECG::Pressure_Calibration_type& ECG::
Pressure_Calibration ()
{
  return this->Pressure_Calibration_.get ();
}

void ECG::
Pressure_Calibration (const Pressure_Calibration_type& x)
{
  this->Pressure_Calibration_.set (x);
}

void ECG::
Pressure_Calibration (::std::auto_ptr< Pressure_Calibration_type > x)
{
  this->Pressure_Calibration_.set (x);
}

const ECG::RWave_Blank_Time_type& ECG::
RWave_Blank_Time () const
{
  return this->RWave_Blank_Time_.get ();
}

ECG::RWave_Blank_Time_type& ECG::
RWave_Blank_Time ()
{
  return this->RWave_Blank_Time_.get ();
}

void ECG::
RWave_Blank_Time (const RWave_Blank_Time_type& x)
{
  this->RWave_Blank_Time_.set (x);
}

void ECG::
RWave_Blank_Time (::std::auto_ptr< RWave_Blank_Time_type > x)
{
  this->RWave_Blank_Time_.set (x);
}


// RfModeSoft
// 

const RfModeSoft::Amplitude_Height_type& RfModeSoft::
Amplitude_Height () const
{
  return this->Amplitude_Height_.get ();
}

RfModeSoft::Amplitude_Height_type& RfModeSoft::
Amplitude_Height ()
{
  return this->Amplitude_Height_.get ();
}

void RfModeSoft::
Amplitude_Height (const Amplitude_Height_type& x)
{
  this->Amplitude_Height_.set (x);
}

void RfModeSoft::
Amplitude_Height (::std::auto_ptr< Amplitude_Height_type > x)
{
  this->Amplitude_Height_.set (x);
}

const RfModeSoft::Magnitude_Origin_type& RfModeSoft::
Magnitude_Origin () const
{
  return this->Magnitude_Origin_.get ();
}

RfModeSoft::Magnitude_Origin_type& RfModeSoft::
Magnitude_Origin ()
{
  return this->Magnitude_Origin_.get ();
}

void RfModeSoft::
Magnitude_Origin (const Magnitude_Origin_type& x)
{
  this->Magnitude_Origin_.set (x);
}

void RfModeSoft::
Magnitude_Origin (::std::auto_ptr< Magnitude_Origin_type > x)
{
  this->Magnitude_Origin_.set (x);
}

const RfModeSoft::Frequency_Origin_type& RfModeSoft::
Frequency_Origin () const
{
  return this->Frequency_Origin_.get ();
}

RfModeSoft::Frequency_Origin_type& RfModeSoft::
Frequency_Origin ()
{
  return this->Frequency_Origin_.get ();
}

void RfModeSoft::
Frequency_Origin (const Frequency_Origin_type& x)
{
  this->Frequency_Origin_.set (x);
}

void RfModeSoft::
Frequency_Origin (::std::auto_ptr< Frequency_Origin_type > x)
{
  this->Frequency_Origin_.set (x);
}

const RfModeSoft::Samples_type& RfModeSoft::
Samples () const
{
  return this->Samples_.get ();
}

RfModeSoft::Samples_type& RfModeSoft::
Samples ()
{
  return this->Samples_.get ();
}

void RfModeSoft::
Samples (const Samples_type& x)
{
  this->Samples_.set (x);
}

void RfModeSoft::
Samples (::std::auto_ptr< Samples_type > x)
{
  this->Samples_.set (x);
}

const RfModeSoft::Saturation_Threshold_type& RfModeSoft::
Saturation_Threshold () const
{
  return this->Saturation_Threshold_.get ();
}

RfModeSoft::Saturation_Threshold_type& RfModeSoft::
Saturation_Threshold ()
{
  return this->Saturation_Threshold_.get ();
}

void RfModeSoft::
Saturation_Threshold (const Saturation_Threshold_type& x)
{
  this->Saturation_Threshold_.set (x);
}

void RfModeSoft::
Saturation_Threshold (::std::auto_ptr< Saturation_Threshold_type > x)
{
  this->Saturation_Threshold_.set (x);
}

const RfModeSoft::Amplitude_Origin_type& RfModeSoft::
Amplitude_Origin () const
{
  return this->Amplitude_Origin_.get ();
}

RfModeSoft::Amplitude_Origin_type& RfModeSoft::
Amplitude_Origin ()
{
  return this->Amplitude_Origin_.get ();
}

void RfModeSoft::
Amplitude_Origin (const Amplitude_Origin_type& x)
{
  this->Amplitude_Origin_.set (x);
}

void RfModeSoft::
Amplitude_Origin (::std::auto_ptr< Amplitude_Origin_type > x)
{
  this->Amplitude_Origin_.set (x);
}

const RfModeSoft::Frame_Selected_type& RfModeSoft::
Frame_Selected () const
{
  return this->Frame_Selected_.get ();
}

RfModeSoft::Frame_Selected_type& RfModeSoft::
Frame_Selected ()
{
  return this->Frame_Selected_.get ();
}

void RfModeSoft::
Frame_Selected (const Frame_Selected_type& x)
{
  this->Frame_Selected_.set (x);
}

void RfModeSoft::
Frame_Selected (::std::auto_ptr< Frame_Selected_type > x)
{
  this->Frame_Selected_.set (x);
}

const RfModeSoft::AcqPerLine_type& RfModeSoft::
AcqPerLine () const
{
  return this->AcqPerLine_.get ();
}

RfModeSoft::AcqPerLine_type& RfModeSoft::
AcqPerLine ()
{
  return this->AcqPerLine_.get ();
}

void RfModeSoft::
AcqPerLine (const AcqPerLine_type& x)
{
  this->AcqPerLine_.set (x);
}

void RfModeSoft::
AcqPerLine (::std::auto_ptr< AcqPerLine_type > x)
{
  this->AcqPerLine_.set (x);
}

const RfModeSoft::Lines_type& RfModeSoft::
Lines () const
{
  return this->Lines_.get ();
}

RfModeSoft::Lines_type& RfModeSoft::
Lines ()
{
  return this->Lines_.get ();
}

void RfModeSoft::
Lines (const Lines_type& x)
{
  this->Lines_.set (x);
}

void RfModeSoft::
Lines (::std::auto_ptr< Lines_type > x)
{
  this->Lines_.set (x);
}

const RfModeSoft::Windowing_Mode_type& RfModeSoft::
Windowing_Mode () const
{
  return this->Windowing_Mode_.get ();
}

RfModeSoft::Windowing_Mode_type& RfModeSoft::
Windowing_Mode ()
{
  return this->Windowing_Mode_.get ();
}

void RfModeSoft::
Windowing_Mode (const Windowing_Mode_type& x)
{
  this->Windowing_Mode_.set (x);
}

void RfModeSoft::
Windowing_Mode (::std::auto_ptr< Windowing_Mode_type > x)
{
  this->Windowing_Mode_.set (x);
}

const RfModeSoft::Length_Origin_type& RfModeSoft::
Length_Origin () const
{
  return this->Length_Origin_.get ();
}

RfModeSoft::Length_Origin_type& RfModeSoft::
Length_Origin ()
{
  return this->Length_Origin_.get ();
}

void RfModeSoft::
Length_Origin (const Length_Origin_type& x)
{
  this->Length_Origin_.set (x);
}

void RfModeSoft::
Length_Origin (::std::auto_ptr< Length_Origin_type > x)
{
  this->Length_Origin_.set (x);
}

const RfModeSoft::Line_Selected_type& RfModeSoft::
Line_Selected () const
{
  return this->Line_Selected_.get ();
}

RfModeSoft::Line_Selected_type& RfModeSoft::
Line_Selected ()
{
  return this->Line_Selected_.get ();
}

void RfModeSoft::
Line_Selected (const Line_Selected_type& x)
{
  this->Line_Selected_.set (x);
}

void RfModeSoft::
Line_Selected (::std::auto_ptr< Line_Selected_type > x)
{
  this->Line_Selected_.set (x);
}

const RfModeSoft::V_Lines_Pos_type& RfModeSoft::
V_Lines_Pos () const
{
  return this->V_Lines_Pos_.get ();
}

RfModeSoft::V_Lines_Pos_type& RfModeSoft::
V_Lines_Pos ()
{
  return this->V_Lines_Pos_.get ();
}

void RfModeSoft::
V_Lines_Pos (const V_Lines_Pos_type& x)
{
  this->V_Lines_Pos_.set (x);
}

void RfModeSoft::
V_Lines_Pos (::std::auto_ptr< V_Lines_Pos_type > x)
{
  this->V_Lines_Pos_.set (x);
}

const RfModeSoft::Bounce_Test_AscanData_type& RfModeSoft::
Bounce_Test_AscanData () const
{
  return this->Bounce_Test_AscanData_.get ();
}

RfModeSoft::Bounce_Test_AscanData_type& RfModeSoft::
Bounce_Test_AscanData ()
{
  return this->Bounce_Test_AscanData_.get ();
}

void RfModeSoft::
Bounce_Test_AscanData (const Bounce_Test_AscanData_type& x)
{
  this->Bounce_Test_AscanData_.set (x);
}

void RfModeSoft::
Bounce_Test_AscanData (::std::auto_ptr< Bounce_Test_AscanData_type > x)
{
  this->Bounce_Test_AscanData_.set (x);
}

const RfModeSoft::Vertical_Scale_type& RfModeSoft::
Vertical_Scale () const
{
  return this->Vertical_Scale_.get ();
}

RfModeSoft::Vertical_Scale_type& RfModeSoft::
Vertical_Scale ()
{
  return this->Vertical_Scale_.get ();
}

void RfModeSoft::
Vertical_Scale (const Vertical_Scale_type& x)
{
  this->Vertical_Scale_.set (x);
}

void RfModeSoft::
Vertical_Scale (::std::auto_ptr< Vertical_Scale_type > x)
{
  this->Vertical_Scale_.set (x);
}

const RfModeSoft::Bounce_Test_RFData_type& RfModeSoft::
Bounce_Test_RFData () const
{
  return this->Bounce_Test_RFData_.get ();
}

RfModeSoft::Bounce_Test_RFData_type& RfModeSoft::
Bounce_Test_RFData ()
{
  return this->Bounce_Test_RFData_.get ();
}

void RfModeSoft::
Bounce_Test_RFData (const Bounce_Test_RFData_type& x)
{
  this->Bounce_Test_RFData_.set (x);
}

void RfModeSoft::
Bounce_Test_RFData (::std::auto_ptr< Bounce_Test_RFData_type > x)
{
  this->Bounce_Test_RFData_.set (x);
}

const RfModeSoft::SamplesPerSec_type& RfModeSoft::
SamplesPerSec () const
{
  return this->SamplesPerSec_.get ();
}

RfModeSoft::SamplesPerSec_type& RfModeSoft::
SamplesPerSec ()
{
  return this->SamplesPerSec_.get ();
}

void RfModeSoft::
SamplesPerSec (const SamplesPerSec_type& x)
{
  this->SamplesPerSec_.set (x);
}

void RfModeSoft::
SamplesPerSec (::std::auto_ptr< SamplesPerSec_type > x)
{
  this->SamplesPerSec_.set (x);
}

const RfModeSoft::Frames_type& RfModeSoft::
Frames () const
{
  return this->Frames_.get ();
}

RfModeSoft::Frames_type& RfModeSoft::
Frames ()
{
  return this->Frames_.get ();
}

void RfModeSoft::
Frames (const Frames_type& x)
{
  this->Frames_.set (x);
}

void RfModeSoft::
Frames (::std::auto_ptr< Frames_type > x)
{
  this->Frames_.set (x);
}

const RfModeSoft::Digitizer_type& RfModeSoft::
Digitizer () const
{
  return this->Digitizer_.get ();
}

RfModeSoft::Digitizer_type& RfModeSoft::
Digitizer ()
{
  return this->Digitizer_.get ();
}

void RfModeSoft::
Digitizer (const Digitizer_type& x)
{
  this->Digitizer_.set (x);
}

void RfModeSoft::
Digitizer (::std::auto_ptr< Digitizer_type > x)
{
  this->Digitizer_.set (x);
}

const RfModeSoft::Magnitude_Height_type& RfModeSoft::
Magnitude_Height () const
{
  return this->Magnitude_Height_.get ();
}

RfModeSoft::Magnitude_Height_type& RfModeSoft::
Magnitude_Height ()
{
  return this->Magnitude_Height_.get ();
}

void RfModeSoft::
Magnitude_Height (const Magnitude_Height_type& x)
{
  this->Magnitude_Height_.set (x);
}

void RfModeSoft::
Magnitude_Height (::std::auto_ptr< Magnitude_Height_type > x)
{
  this->Magnitude_Height_.set (x);
}

const RfModeSoft::Saturation_type& RfModeSoft::
Saturation () const
{
  return this->Saturation_.get ();
}

RfModeSoft::Saturation_type& RfModeSoft::
Saturation ()
{
  return this->Saturation_.get ();
}

void RfModeSoft::
Saturation (const Saturation_type& x)
{
  this->Saturation_.set (x);
}

void RfModeSoft::
Saturation (::std::auto_ptr< Saturation_type > x)
{
  this->Saturation_.set (x);
}

const RfModeSoft::Length_Length_type& RfModeSoft::
Length_Length () const
{
  return this->Length_Length_.get ();
}

RfModeSoft::Length_Length_type& RfModeSoft::
Length_Length ()
{
  return this->Length_Length_.get ();
}

void RfModeSoft::
Length_Length (const Length_Length_type& x)
{
  this->Length_Length_.set (x);
}

void RfModeSoft::
Length_Length (::std::auto_ptr< Length_Length_type > x)
{
  this->Length_Length_.set (x);
}

const RfModeSoft::Frequency_Length_type& RfModeSoft::
Frequency_Length () const
{
  return this->Frequency_Length_.get ();
}

RfModeSoft::Frequency_Length_type& RfModeSoft::
Frequency_Length ()
{
  return this->Frequency_Length_.get ();
}

void RfModeSoft::
Frequency_Length (const Frequency_Length_type& x)
{
  this->Frequency_Length_.set (x);
}

void RfModeSoft::
Frequency_Length (::std::auto_ptr< Frequency_Length_type > x)
{
  this->Frequency_Length_.set (x);
}

const RfModeSoft::State_type& RfModeSoft::
State () const
{
  return this->State_.get ();
}

RfModeSoft::State_type& RfModeSoft::
State ()
{
  return this->State_.get ();
}

void RfModeSoft::
State (const State_type& x)
{
  this->State_.set (x);
}

void RfModeSoft::
State (::std::auto_ptr< State_type > x)
{
  this->State_.set (x);
}

const RfModeSoft::SV_Center_type& RfModeSoft::
SV_Center () const
{
  return this->SV_Center_.get ();
}

RfModeSoft::SV_Center_type& RfModeSoft::
SV_Center ()
{
  return this->SV_Center_.get ();
}

void RfModeSoft::
SV_Center (const SV_Center_type& x)
{
  this->SV_Center_.set (x);
}

void RfModeSoft::
SV_Center (::std::auto_ptr< SV_Center_type > x)
{
  this->SV_Center_.set (x);
}

const RfModeSoft::Continuous_RF_FrameRate_type& RfModeSoft::
Continuous_RF_FrameRate () const
{
  return this->Continuous_RF_FrameRate_.get ();
}

RfModeSoft::Continuous_RF_FrameRate_type& RfModeSoft::
Continuous_RF_FrameRate ()
{
  return this->Continuous_RF_FrameRate_.get ();
}

void RfModeSoft::
Continuous_RF_FrameRate (const Continuous_RF_FrameRate_type& x)
{
  this->Continuous_RF_FrameRate_.set (x);
}

void RfModeSoft::
Continuous_RF_FrameRate (::std::auto_ptr< Continuous_RF_FrameRate_type > x)
{
  this->Continuous_RF_FrameRate_.set (x);
}

const RfModeSoft::Quantify_Bounce_Test_type& RfModeSoft::
Quantify_Bounce_Test () const
{
  return this->Quantify_Bounce_Test_.get ();
}

RfModeSoft::Quantify_Bounce_Test_type& RfModeSoft::
Quantify_Bounce_Test ()
{
  return this->Quantify_Bounce_Test_.get ();
}

void RfModeSoft::
Quantify_Bounce_Test (const Quantify_Bounce_Test_type& x)
{
  this->Quantify_Bounce_Test_.set (x);
}

void RfModeSoft::
Quantify_Bounce_Test (::std::auto_ptr< Quantify_Bounce_Test_type > x)
{
  this->Quantify_Bounce_Test_.set (x);
}

const RfModeSoft::X_3D_Volume_type& RfModeSoft::
X_3D_Volume () const
{
  return this->X_3D_Volume_.get ();
}

RfModeSoft::X_3D_Volume_type& RfModeSoft::
X_3D_Volume ()
{
  return this->X_3D_Volume_.get ();
}

void RfModeSoft::
X_3D_Volume (const X_3D_Volume_type& x)
{
  this->X_3D_Volume_.set (x);
}

void RfModeSoft::
X_3D_Volume (::std::auto_ptr< X_3D_Volume_type > x)
{
  this->X_3D_Volume_.set (x);
}

const RfModeSoft::Shift_RF_Data_type& RfModeSoft::
Shift_RF_Data () const
{
  return this->Shift_RF_Data_.get ();
}

RfModeSoft::Shift_RF_Data_type& RfModeSoft::
Shift_RF_Data ()
{
  return this->Shift_RF_Data_.get ();
}

void RfModeSoft::
Shift_RF_Data (const Shift_RF_Data_type& x)
{
  this->Shift_RF_Data_.set (x);
}

void RfModeSoft::
Shift_RF_Data (::std::auto_ptr< Shift_RF_Data_type > x)
{
  this->Shift_RF_Data_.set (x);
}

const RfModeSoft::V_Lines_type& RfModeSoft::
V_Lines () const
{
  return this->V_Lines_.get ();
}

RfModeSoft::V_Lines_type& RfModeSoft::
V_Lines ()
{
  return this->V_Lines_.get ();
}

void RfModeSoft::
V_Lines (const V_Lines_type& x)
{
  this->V_Lines_.set (x);
}

void RfModeSoft::
V_Lines (::std::auto_ptr< V_Lines_type > x)
{
  this->V_Lines_.set (x);
}

const RfModeSoft::Graph_Mode_type& RfModeSoft::
Graph_Mode () const
{
  return this->Graph_Mode_.get ();
}

RfModeSoft::Graph_Mode_type& RfModeSoft::
Graph_Mode ()
{
  return this->Graph_Mode_.get ();
}

void RfModeSoft::
Graph_Mode (const Graph_Mode_type& x)
{
  this->Graph_Mode_.set (x);
}

void RfModeSoft::
Graph_Mode (::std::auto_ptr< Graph_Mode_type > x)
{
  this->Graph_Mode_.set (x);
}

const RfModeSoft::RF_Path_15Mhz_Time_Correction_type& RfModeSoft::
RF_Path_15Mhz_Time_Correction () const
{
  return this->RF_Path_15Mhz_Time_Correction_.get ();
}

RfModeSoft::RF_Path_15Mhz_Time_Correction_type& RfModeSoft::
RF_Path_15Mhz_Time_Correction ()
{
  return this->RF_Path_15Mhz_Time_Correction_.get ();
}

void RfModeSoft::
RF_Path_15Mhz_Time_Correction (const RF_Path_15Mhz_Time_Correction_type& x)
{
  this->RF_Path_15Mhz_Time_Correction_.set (x);
}

void RfModeSoft::
RF_Path_15Mhz_Time_Correction (::std::auto_ptr< RF_Path_15Mhz_Time_Correction_type > x)
{
  this->RF_Path_15Mhz_Time_Correction_.set (x);
}

const RfModeSoft::RF_Path_23Mhz_Time_Correction_type& RfModeSoft::
RF_Path_23Mhz_Time_Correction () const
{
  return this->RF_Path_23Mhz_Time_Correction_.get ();
}

RfModeSoft::RF_Path_23Mhz_Time_Correction_type& RfModeSoft::
RF_Path_23Mhz_Time_Correction ()
{
  return this->RF_Path_23Mhz_Time_Correction_.get ();
}

void RfModeSoft::
RF_Path_23Mhz_Time_Correction (const RF_Path_23Mhz_Time_Correction_type& x)
{
  this->RF_Path_23Mhz_Time_Correction_.set (x);
}

void RfModeSoft::
RF_Path_23Mhz_Time_Correction (::std::auto_ptr< RF_Path_23Mhz_Time_Correction_type > x)
{
  this->RF_Path_23Mhz_Time_Correction_.set (x);
}

const RfModeSoft::SV_Length_Limits_type& RfModeSoft::
SV_Length_Limits () const
{
  return this->SV_Length_Limits_.get ();
}

RfModeSoft::SV_Length_Limits_type& RfModeSoft::
SV_Length_Limits ()
{
  return this->SV_Length_Limits_.get ();
}

void RfModeSoft::
SV_Length_Limits (const SV_Length_Limits_type& x)
{
  this->SV_Length_Limits_.set (x);
}

void RfModeSoft::
SV_Length_Limits (::std::auto_ptr< SV_Length_Limits_type > x)
{
  this->SV_Length_Limits_.set (x);
}


// TX
// 

const TX::V_Position_Table_type& TX::
V_Position_Table () const
{
  return this->V_Position_Table_.get ();
}

TX::V_Position_Table_type& TX::
V_Position_Table ()
{
  return this->V_Position_Table_.get ();
}

void TX::
V_Position_Table (const V_Position_Table_type& x)
{
  this->V_Position_Table_.set (x);
}

void TX::
V_Position_Table (::std::auto_ptr< V_Position_Table_type > x)
{
  this->V_Position_Table_.set (x);
}

const TX::V_Transmit_Length_type& TX::
V_Transmit_Length () const
{
  return this->V_Transmit_Length_.get ();
}

TX::V_Transmit_Length_type& TX::
V_Transmit_Length ()
{
  return this->V_Transmit_Length_.get ();
}

void TX::
V_Transmit_Length (const V_Transmit_Length_type& x)
{
  this->V_Transmit_Length_.set (x);
}

void TX::
V_Transmit_Length (::std::auto_ptr< V_Transmit_Length_type > x)
{
  this->V_Transmit_Length_.set (x);
}

const TX::Trigger_Counter_Clear_type& TX::
Trigger_Counter_Clear () const
{
  return this->Trigger_Counter_Clear_.get ();
}

TX::Trigger_Counter_Clear_type& TX::
Trigger_Counter_Clear ()
{
  return this->Trigger_Counter_Clear_.get ();
}

void TX::
Trigger_Counter_Clear (const Trigger_Counter_Clear_type& x)
{
  this->Trigger_Counter_Clear_.set (x);
}

void TX::
Trigger_Counter_Clear (::std::auto_ptr< Trigger_Counter_Clear_type > x)
{
  this->Trigger_Counter_Clear_.set (x);
}

const TX::Trigger_Counter_type& TX::
Trigger_Counter () const
{
  return this->Trigger_Counter_.get ();
}

TX::Trigger_Counter_type& TX::
Trigger_Counter ()
{
  return this->Trigger_Counter_.get ();
}

void TX::
Trigger_Counter (const Trigger_Counter_type& x)
{
  this->Trigger_Counter_.set (x);
}

void TX::
Trigger_Counter (::std::auto_ptr< Trigger_Counter_type > x)
{
  this->Trigger_Counter_.set (x);
}

const TX::Multi_Trigger_Freq_type& TX::
Multi_Trigger_Freq () const
{
  return this->Multi_Trigger_Freq_.get ();
}

TX::Multi_Trigger_Freq_type& TX::
Multi_Trigger_Freq ()
{
  return this->Multi_Trigger_Freq_.get ();
}

void TX::
Multi_Trigger_Freq (const Multi_Trigger_Freq_type& x)
{
  this->Multi_Trigger_Freq_.set (x);
}

void TX::
Multi_Trigger_Freq (::std::auto_ptr< Multi_Trigger_Freq_type > x)
{
  this->Multi_Trigger_Freq_.set (x);
}

const TX::RF_Amp_type& TX::
RF_Amp () const
{
  return this->RF_Amp_.get ();
}

TX::RF_Amp_type& TX::
RF_Amp ()
{
  return this->RF_Amp_.get ();
}

void TX::
RF_Amp (const RF_Amp_type& x)
{
  this->RF_Amp_.set (x);
}

void TX::
RF_Amp (::std::auto_ptr< RF_Amp_type > x)
{
  this->RF_Amp_.set (x);
}

const TX::Trigger_Control_type& TX::
Trigger_Control () const
{
  return this->Trigger_Control_.get ();
}

TX::Trigger_Control_type& TX::
Trigger_Control ()
{
  return this->Trigger_Control_.get ();
}

void TX::
Trigger_Control (const Trigger_Control_type& x)
{
  this->Trigger_Control_.set (x);
}

void TX::
Trigger_Control (::std::auto_ptr< Trigger_Control_type > x)
{
  this->Trigger_Control_.set (x);
}

const TX::V_Pulse_Rep_Freq_type& TX::
V_Pulse_Rep_Freq () const
{
  return this->V_Pulse_Rep_Freq_.get ();
}

TX::V_Pulse_Rep_Freq_type& TX::
V_Pulse_Rep_Freq ()
{
  return this->V_Pulse_Rep_Freq_.get ();
}

void TX::
V_Pulse_Rep_Freq (const V_Pulse_Rep_Freq_type& x)
{
  this->V_Pulse_Rep_Freq_.set (x);
}

void TX::
V_Pulse_Rep_Freq (::std::auto_ptr< V_Pulse_Rep_Freq_type > x)
{
  this->V_Pulse_Rep_Freq_.set (x);
}

const TX::Phase_type& TX::
Phase () const
{
  return this->Phase_.get ();
}

TX::Phase_type& TX::
Phase ()
{
  return this->Phase_.get ();
}

void TX::
Phase (const Phase_type& x)
{
  this->Phase_.set (x);
}

void TX::
Phase (::std::auto_ptr< Phase_type > x)
{
  this->Phase_.set (x);
}

const TX::Frequency_type& TX::
Frequency () const
{
  return this->Frequency_.get ();
}

TX::Frequency_type& TX::
Frequency ()
{
  return this->Frequency_.get ();
}

void TX::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void TX::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const TX::V_Unblank_Time_type& TX::
V_Unblank_Time () const
{
  return this->V_Unblank_Time_.get ();
}

TX::V_Unblank_Time_type& TX::
V_Unblank_Time ()
{
  return this->V_Unblank_Time_.get ();
}

void TX::
V_Unblank_Time (const V_Unblank_Time_type& x)
{
  this->V_Unblank_Time_.set (x);
}

void TX::
V_Unblank_Time (::std::auto_ptr< V_Unblank_Time_type > x)
{
  this->V_Unblank_Time_.set (x);
}

const TX::V_Frequency_type& TX::
V_Frequency () const
{
  return this->V_Frequency_.get ();
}

TX::V_Frequency_type& TX::
V_Frequency ()
{
  return this->V_Frequency_.get ();
}

void TX::
V_Frequency (const V_Frequency_type& x)
{
  this->V_Frequency_.set (x);
}

void TX::
V_Frequency (::std::auto_ptr< V_Frequency_type > x)
{
  this->V_Frequency_.set (x);
}

const TX::Pulse_Rep_Frequency_type& TX::
Pulse_Rep_Frequency () const
{
  return this->Pulse_Rep_Frequency_.get ();
}

TX::Pulse_Rep_Frequency_type& TX::
Pulse_Rep_Frequency ()
{
  return this->Pulse_Rep_Frequency_.get ();
}

void TX::
Pulse_Rep_Frequency (const Pulse_Rep_Frequency_type& x)
{
  this->Pulse_Rep_Frequency_.set (x);
}

void TX::
Pulse_Rep_Frequency (::std::auto_ptr< Pulse_Rep_Frequency_type > x)
{
  this->Pulse_Rep_Frequency_.set (x);
}

const TX::Multi_Trigger_type& TX::
Multi_Trigger () const
{
  return this->Multi_Trigger_.get ();
}

TX::Multi_Trigger_type& TX::
Multi_Trigger ()
{
  return this->Multi_Trigger_.get ();
}

void TX::
Multi_Trigger (const Multi_Trigger_type& x)
{
  this->Multi_Trigger_.set (x);
}

void TX::
Multi_Trigger (::std::auto_ptr< Multi_Trigger_type > x)
{
  this->Multi_Trigger_.set (x);
}

const TX::Trig_Tbl_Trigs_type& TX::
Trig_Tbl_Trigs () const
{
  return this->Trig_Tbl_Trigs_.get ();
}

TX::Trig_Tbl_Trigs_type& TX::
Trig_Tbl_Trigs ()
{
  return this->Trig_Tbl_Trigs_.get ();
}

void TX::
Trig_Tbl_Trigs (const Trig_Tbl_Trigs_type& x)
{
  this->Trig_Tbl_Trigs_.set (x);
}

void TX::
Trig_Tbl_Trigs (::std::auto_ptr< Trig_Tbl_Trigs_type > x)
{
  this->Trig_Tbl_Trigs_.set (x);
}

const TX::Width_type& TX::
Width () const
{
  return this->Width_.get ();
}

TX::Width_type& TX::
Width ()
{
  return this->Width_.get ();
}

void TX::
Width (const Width_type& x)
{
  this->Width_.set (x);
}

void TX::
Width (::std::auto_ptr< Width_type > x)
{
  this->Width_.set (x);
}

const TX::Unblank_Cycles_type& TX::
Unblank_Cycles () const
{
  return this->Unblank_Cycles_.get ();
}

TX::Unblank_Cycles_type& TX::
Unblank_Cycles ()
{
  return this->Unblank_Cycles_.get ();
}

void TX::
Unblank_Cycles (const Unblank_Cycles_type& x)
{
  this->Unblank_Cycles_.set (x);
}

void TX::
Unblank_Cycles (::std::auto_ptr< Unblank_Cycles_type > x)
{
  this->Unblank_Cycles_.set (x);
}

const TX::V_Width_type& TX::
V_Width () const
{
  return this->V_Width_.get ();
}

TX::V_Width_type& TX::
V_Width ()
{
  return this->V_Width_.get ();
}

void TX::
V_Width (const V_Width_type& x)
{
  this->V_Width_.set (x);
}

void TX::
V_Width (::std::auto_ptr< V_Width_type > x)
{
  this->V_Width_.set (x);
}

const TX::Unblank_Time_type& TX::
Unblank_Time () const
{
  return this->Unblank_Time_.get ();
}

TX::Unblank_Time_type& TX::
Unblank_Time ()
{
  return this->Unblank_Time_.get ();
}

void TX::
Unblank_Time (const Unblank_Time_type& x)
{
  this->Unblank_Time_.set (x);
}

void TX::
Unblank_Time (::std::auto_ptr< Unblank_Time_type > x)
{
  this->Unblank_Time_.set (x);
}

const TX::Attenuation_type& TX::
Attenuation () const
{
  return this->Attenuation_.get ();
}

TX::Attenuation_type& TX::
Attenuation ()
{
  return this->Attenuation_.get ();
}

void TX::
Attenuation (const Attenuation_type& x)
{
  this->Attenuation_.set (x);
}

void TX::
Attenuation (::std::auto_ptr< Attenuation_type > x)
{
  this->Attenuation_.set (x);
}

const TX::V_Power_type& TX::
V_Power () const
{
  return this->V_Power_.get ();
}

TX::V_Power_type& TX::
V_Power ()
{
  return this->V_Power_.get ();
}

void TX::
V_Power (const V_Power_type& x)
{
  this->V_Power_.set (x);
}

void TX::
V_Power (::std::auto_ptr< V_Power_type > x)
{
  this->V_Power_.set (x);
}

const TX::Computer_Trigger_type& TX::
Computer_Trigger () const
{
  return this->Computer_Trigger_.get ();
}

TX::Computer_Trigger_type& TX::
Computer_Trigger ()
{
  return this->Computer_Trigger_.get ();
}

void TX::
Computer_Trigger (const Computer_Trigger_type& x)
{
  this->Computer_Trigger_.set (x);
}

void TX::
Computer_Trigger (::std::auto_ptr< Computer_Trigger_type > x)
{
  this->Computer_Trigger_.set (x);
}


// X_3D
// 

const X_3D::Speed_type& X_3D::
Speed () const
{
  return this->Speed_.get ();
}

X_3D::Speed_type& X_3D::
Speed ()
{
  return this->Speed_.get ();
}

void X_3D::
Speed (const Speed_type& x)
{
  this->Speed_.set (x);
}

void X_3D::
Speed (::std::auto_ptr< Speed_type > x)
{
  this->Speed_.set (x);
}

const X_3D::Status_type& X_3D::
Status () const
{
  return this->Status_.get ();
}

X_3D::Status_type& X_3D::
Status ()
{
  return this->Status_.get ();
}

void X_3D::
Status (const Status_type& x)
{
  this->Status_.set (x);
}

void X_3D::
Status (::std::auto_ptr< Status_type > x)
{
  this->Status_.set (x);
}

const X_3D::Motor_Enable_type& X_3D::
Motor_Enable () const
{
  return this->Motor_Enable_.get ();
}

X_3D::Motor_Enable_type& X_3D::
Motor_Enable ()
{
  return this->Motor_Enable_.get ();
}

void X_3D::
Motor_Enable (const Motor_Enable_type& x)
{
  this->Motor_Enable_.set (x);
}

void X_3D::
Motor_Enable (::std::auto_ptr< Motor_Enable_type > x)
{
  this->Motor_Enable_.set (x);
}

const X_3D::Scan_Distance_type& X_3D::
Scan_Distance () const
{
  return this->Scan_Distance_.get ();
}

X_3D::Scan_Distance_type& X_3D::
Scan_Distance ()
{
  return this->Scan_Distance_.get ();
}

void X_3D::
Scan_Distance (const Scan_Distance_type& x)
{
  this->Scan_Distance_.set (x);
}

void X_3D::
Scan_Distance (::std::auto_ptr< Scan_Distance_type > x)
{
  this->Scan_Distance_.set (x);
}

const X_3D::Error_type& X_3D::
Error () const
{
  return this->Error_.get ();
}

X_3D::Error_type& X_3D::
Error ()
{
  return this->Error_.get ();
}

void X_3D::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void X_3D::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const X_3D::Steps_type& X_3D::
Steps () const
{
  return this->Steps_.get ();
}

X_3D::Steps_type& X_3D::
Steps ()
{
  return this->Steps_.get ();
}

void X_3D::
Steps (const Steps_type& x)
{
  this->Steps_.set (x);
}

void X_3D::
Steps (::std::auto_ptr< Steps_type > x)
{
  this->Steps_.set (x);
}

const X_3D::Max_Scan_Steps_type& X_3D::
Max_Scan_Steps () const
{
  return this->Max_Scan_Steps_.get ();
}

X_3D::Max_Scan_Steps_type& X_3D::
Max_Scan_Steps ()
{
  return this->Max_Scan_Steps_.get ();
}

void X_3D::
Max_Scan_Steps (const Max_Scan_Steps_type& x)
{
  this->Max_Scan_Steps_.set (x);
}

void X_3D::
Max_Scan_Steps (::std::auto_ptr< Max_Scan_Steps_type > x)
{
  this->Max_Scan_Steps_.set (x);
}

const X_3D::Position_type& X_3D::
Position () const
{
  return this->Position_.get ();
}

X_3D::Position_type& X_3D::
Position ()
{
  return this->Position_.get ();
}

void X_3D::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void X_3D::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const X_3D::Action_type& X_3D::
Action () const
{
  return this->Action_.get ();
}

X_3D::Action_type& X_3D::
Action ()
{
  return this->Action_.get ();
}

void X_3D::
Action (const Action_type& x)
{
  this->Action_.set (x);
}

void X_3D::
Action (::std::auto_ptr< Action_type > x)
{
  this->Action_.set (x);
}

const X_3D::Clear_Error_type& X_3D::
Clear_Error () const
{
  return this->Clear_Error_.get ();
}

X_3D::Clear_Error_type& X_3D::
Clear_Error ()
{
  return this->Clear_Error_.get ();
}

void X_3D::
Clear_Error (const Clear_Error_type& x)
{
  this->Clear_Error_.set (x);
}

void X_3D::
Clear_Error (::std::auto_ptr< Clear_Error_type > x)
{
  this->Clear_Error_.set (x);
}

const X_3D::Direction_type& X_3D::
Direction () const
{
  return this->Direction_.get ();
}

X_3D::Direction_type& X_3D::
Direction ()
{
  return this->Direction_.get ();
}

void X_3D::
Direction (const Direction_type& x)
{
  this->Direction_.set (x);
}

void X_3D::
Direction (::std::auto_ptr< Direction_type > x)
{
  this->Direction_.set (x);
}

const X_3D::Step_Size_type& X_3D::
Step_Size () const
{
  return this->Step_Size_.get ();
}

X_3D::Step_Size_type& X_3D::
Step_Size ()
{
  return this->Step_Size_.get ();
}

void X_3D::
Step_Size (const Step_Size_type& x)
{
  this->Step_Size_.set (x);
}

void X_3D::
Step_Size (::std::auto_ptr< Step_Size_type > x)
{
  this->Step_Size_.set (x);
}


// RfAnalysis
// 

const RfAnalysis::Reference_type& RfAnalysis::
Reference () const
{
  return this->Reference_.get ();
}

RfAnalysis::Reference_type& RfAnalysis::
Reference ()
{
  return this->Reference_.get ();
}

void RfAnalysis::
Reference (const Reference_type& x)
{
  this->Reference_.set (x);
}

void RfAnalysis::
Reference (::std::auto_ptr< Reference_type > x)
{
  this->Reference_.set (x);
}

const RfAnalysis::Ref_Probe_F_Number_type& RfAnalysis::
Ref_Probe_F_Number () const
{
  return this->Ref_Probe_F_Number_.get ();
}

RfAnalysis::Ref_Probe_F_Number_type& RfAnalysis::
Ref_Probe_F_Number ()
{
  return this->Ref_Probe_F_Number_.get ();
}

void RfAnalysis::
Ref_Probe_F_Number (const Ref_Probe_F_Number_type& x)
{
  this->Ref_Probe_F_Number_.set (x);
}

void RfAnalysis::
Ref_Probe_F_Number (::std::auto_ptr< Ref_Probe_F_Number_type > x)
{
  this->Ref_Probe_F_Number_.set (x);
}

const RfAnalysis::Ref_Probe_Focal_Length_type& RfAnalysis::
Ref_Probe_Focal_Length () const
{
  return this->Ref_Probe_Focal_Length_.get ();
}

RfAnalysis::Ref_Probe_Focal_Length_type& RfAnalysis::
Ref_Probe_Focal_Length ()
{
  return this->Ref_Probe_Focal_Length_.get ();
}

void RfAnalysis::
Ref_Probe_Focal_Length (const Ref_Probe_Focal_Length_type& x)
{
  this->Ref_Probe_Focal_Length_.set (x);
}

void RfAnalysis::
Ref_Probe_Focal_Length (::std::auto_ptr< Ref_Probe_Focal_Length_type > x)
{
  this->Ref_Probe_Focal_Length_.set (x);
}

const RfAnalysis::Ref_Tx_Frequency_type& RfAnalysis::
Ref_Tx_Frequency () const
{
  return this->Ref_Tx_Frequency_.get ();
}

RfAnalysis::Ref_Tx_Frequency_type& RfAnalysis::
Ref_Tx_Frequency ()
{
  return this->Ref_Tx_Frequency_.get ();
}

void RfAnalysis::
Ref_Tx_Frequency (const Ref_Tx_Frequency_type& x)
{
  this->Ref_Tx_Frequency_.set (x);
}

void RfAnalysis::
Ref_Tx_Frequency (::std::auto_ptr< Ref_Tx_Frequency_type > x)
{
  this->Ref_Tx_Frequency_.set (x);
}

const RfAnalysis::Freq_Range_type& RfAnalysis::
Freq_Range () const
{
  return this->Freq_Range_.get ();
}

RfAnalysis::Freq_Range_type& RfAnalysis::
Freq_Range ()
{
  return this->Freq_Range_.get ();
}

void RfAnalysis::
Freq_Range (const Freq_Range_type& x)
{
  this->Freq_Range_.set (x);
}

void RfAnalysis::
Freq_Range (::std::auto_ptr< Freq_Range_type > x)
{
  this->Freq_Range_.set (x);
}

const RfAnalysis::Ref_Probe_Name_type& RfAnalysis::
Ref_Probe_Name () const
{
  return this->Ref_Probe_Name_.get ();
}

RfAnalysis::Ref_Probe_Name_type& RfAnalysis::
Ref_Probe_Name ()
{
  return this->Ref_Probe_Name_.get ();
}

void RfAnalysis::
Ref_Probe_Name (const Ref_Probe_Name_type& x)
{
  this->Ref_Probe_Name_.set (x);
}

void RfAnalysis::
Ref_Probe_Name (::std::auto_ptr< Ref_Probe_Name_type > x)
{
  this->Ref_Probe_Name_.set (x);
}

const RfAnalysis::Graph_Mode_type& RfAnalysis::
Graph_Mode () const
{
  return this->Graph_Mode_.get ();
}

RfAnalysis::Graph_Mode_type& RfAnalysis::
Graph_Mode ()
{
  return this->Graph_Mode_.get ();
}

void RfAnalysis::
Graph_Mode (const Graph_Mode_type& x)
{
  this->Graph_Mode_.set (x);
}

void RfAnalysis::
Graph_Mode (::std::auto_ptr< Graph_Mode_type > x)
{
  this->Graph_Mode_.set (x);
}

const RfAnalysis::Normalized_Height_type& RfAnalysis::
Normalized_Height () const
{
  return this->Normalized_Height_.get ();
}

RfAnalysis::Normalized_Height_type& RfAnalysis::
Normalized_Height ()
{
  return this->Normalized_Height_.get ();
}

void RfAnalysis::
Normalized_Height (const Normalized_Height_type& x)
{
  this->Normalized_Height_.set (x);
}

void RfAnalysis::
Normalized_Height (::std::auto_ptr< Normalized_Height_type > x)
{
  this->Normalized_Height_.set (x);
}

const RfAnalysis::Ref_Tx_Width_type& RfAnalysis::
Ref_Tx_Width () const
{
  return this->Ref_Tx_Width_.get ();
}

RfAnalysis::Ref_Tx_Width_type& RfAnalysis::
Ref_Tx_Width ()
{
  return this->Ref_Tx_Width_.get ();
}

void RfAnalysis::
Ref_Tx_Width (const Ref_Tx_Width_type& x)
{
  this->Ref_Tx_Width_.set (x);
}

void RfAnalysis::
Ref_Tx_Width (::std::auto_ptr< Ref_Tx_Width_type > x)
{
  this->Ref_Tx_Width_.set (x);
}

const RfAnalysis::Normalized_Origin_type& RfAnalysis::
Normalized_Origin () const
{
  return this->Normalized_Origin_.get ();
}

RfAnalysis::Normalized_Origin_type& RfAnalysis::
Normalized_Origin ()
{
  return this->Normalized_Origin_.get ();
}

void RfAnalysis::
Normalized_Origin (const Normalized_Origin_type& x)
{
  this->Normalized_Origin_.set (x);
}

void RfAnalysis::
Normalized_Origin (::std::auto_ptr< Normalized_Origin_type > x)
{
  this->Normalized_Origin_.set (x);
}

const RfAnalysis::Freq_Range_f_type& RfAnalysis::
Freq_Range_f () const
{
  return this->Freq_Range_f_.get ();
}

RfAnalysis::Freq_Range_f_type& RfAnalysis::
Freq_Range_f ()
{
  return this->Freq_Range_f_.get ();
}

void RfAnalysis::
Freq_Range_f (const Freq_Range_f_type& x)
{
  this->Freq_Range_f_.set (x);
}

void RfAnalysis::
Freq_Range_f (::std::auto_ptr< Freq_Range_f_type > x)
{
  this->Freq_Range_f_.set (x);
}

const RfAnalysis::FFT_Offset_type& RfAnalysis::
FFT_Offset () const
{
  return this->FFT_Offset_.get ();
}

RfAnalysis::FFT_Offset_type& RfAnalysis::
FFT_Offset ()
{
  return this->FFT_Offset_.get ();
}

void RfAnalysis::
FFT_Offset (const FFT_Offset_type& x)
{
  this->FFT_Offset_.set (x);
}

void RfAnalysis::
FFT_Offset (::std::auto_ptr< FFT_Offset_type > x)
{
  this->FFT_Offset_.set (x);
}

const RfAnalysis::Ref_Tx_Power_type& RfAnalysis::
Ref_Tx_Power () const
{
  return this->Ref_Tx_Power_.get ();
}

RfAnalysis::Ref_Tx_Power_type& RfAnalysis::
Ref_Tx_Power ()
{
  return this->Ref_Tx_Power_.get ();
}

void RfAnalysis::
Ref_Tx_Power (const Ref_Tx_Power_type& x)
{
  this->Ref_Tx_Power_.set (x);
}

void RfAnalysis::
Ref_Tx_Power (::std::auto_ptr< Ref_Tx_Power_type > x)
{
  this->Ref_Tx_Power_.set (x);
}

const RfAnalysis::Freq_Range_Max_type& RfAnalysis::
Freq_Range_Max () const
{
  return this->Freq_Range_Max_.get ();
}

RfAnalysis::Freq_Range_Max_type& RfAnalysis::
Freq_Range_Max ()
{
  return this->Freq_Range_Max_.get ();
}

void RfAnalysis::
Freq_Range_Max (const Freq_Range_Max_type& x)
{
  this->Freq_Range_Max_.set (x);
}

void RfAnalysis::
Freq_Range_Max (::std::auto_ptr< Freq_Range_Max_type > x)
{
  this->Freq_Range_Max_.set (x);
}

const RfAnalysis::Freq_Range_Min_type& RfAnalysis::
Freq_Range_Min () const
{
  return this->Freq_Range_Min_.get ();
}

RfAnalysis::Freq_Range_Min_type& RfAnalysis::
Freq_Range_Min ()
{
  return this->Freq_Range_Min_.get ();
}

void RfAnalysis::
Freq_Range_Min (const Freq_Range_Min_type& x)
{
  this->Freq_Range_Min_.set (x);
}

void RfAnalysis::
Freq_Range_Min (::std::auto_ptr< Freq_Range_Min_type > x)
{
  this->Freq_Range_Min_.set (x);
}

const RfAnalysis::Ref_Offset_type& RfAnalysis::
Ref_Offset () const
{
  return this->Ref_Offset_.get ();
}

RfAnalysis::Ref_Offset_type& RfAnalysis::
Ref_Offset ()
{
  return this->Ref_Offset_.get ();
}

void RfAnalysis::
Ref_Offset (const Ref_Offset_type& x)
{
  this->Ref_Offset_.set (x);
}

void RfAnalysis::
Ref_Offset (::std::auto_ptr< Ref_Offset_type > x)
{
  this->Ref_Offset_.set (x);
}


// RX
// 

const RX::AD_IF_type& RX::
AD_IF () const
{
  return this->AD_IF_.get ();
}

RX::AD_IF_type& RX::
AD_IF ()
{
  return this->AD_IF_.get ();
}

void RX::
AD_IF (const AD_IF_type& x)
{
  this->AD_IF_.set (x);
}

void RX::
AD_IF (::std::auto_ptr< AD_IF_type > x)
{
  this->AD_IF_.set (x);
}

const RX::Sector_Width_Target_type& RX::
Sector_Width_Target () const
{
  return this->Sector_Width_Target_.get ();
}

RX::Sector_Width_Target_type& RX::
Sector_Width_Target ()
{
  return this->Sector_Width_Target_.get ();
}

void RX::
Sector_Width_Target (const Sector_Width_Target_type& x)
{
  this->Sector_Width_Target_.set (x);
}

void RX::
Sector_Width_Target (::std::auto_ptr< Sector_Width_Target_type > x)
{
  this->Sector_Width_Target_.set (x);
}

const RX::RF_Gain_type& RX::
RF_Gain () const
{
  return this->RF_Gain_.get ();
}

RX::RF_Gain_type& RX::
RF_Gain ()
{
  return this->RF_Gain_.get ();
}

void RX::
RF_Gain (const RF_Gain_type& x)
{
  this->RF_Gain_.set (x);
}

void RX::
RF_Gain (::std::auto_ptr< RF_Gain_type > x)
{
  this->RF_Gain_.set (x);
}

const RX::TGC_Enable_type& RX::
TGC_Enable () const
{
  return this->TGC_Enable_.get ();
}

RX::TGC_Enable_type& RX::
TGC_Enable ()
{
  return this->TGC_Enable_.get ();
}

void RX::
TGC_Enable (const TGC_Enable_type& x)
{
  this->TGC_Enable_.set (x);
}

void RX::
TGC_Enable (::std::auto_ptr< TGC_Enable_type > x)
{
  this->TGC_Enable_.set (x);
}

const RX::V_Digi_Depth_Imaging_type& RX::
V_Digi_Depth_Imaging () const
{
  return this->V_Digi_Depth_Imaging_.get ();
}

RX::V_Digi_Depth_Imaging_type& RX::
V_Digi_Depth_Imaging ()
{
  return this->V_Digi_Depth_Imaging_.get ();
}

void RX::
V_Digi_Depth_Imaging (const V_Digi_Depth_Imaging_type& x)
{
  this->V_Digi_Depth_Imaging_.set (x);
}

void RX::
V_Digi_Depth_Imaging (::std::auto_ptr< V_Digi_Depth_Imaging_type > x)
{
  this->V_Digi_Depth_Imaging_.set (x);
}

const RX::RF_Bandwidth_type& RX::
RF_Bandwidth () const
{
  return this->RF_Bandwidth_.get ();
}

RX::RF_Bandwidth_type& RX::
RF_Bandwidth ()
{
  return this->RF_Bandwidth_.get ();
}

void RX::
RF_Bandwidth (const RF_Bandwidth_type& x)
{
  this->RF_Bandwidth_.set (x);
}

void RX::
RF_Bandwidth (::std::auto_ptr< RF_Bandwidth_type > x)
{
  this->RF_Bandwidth_.set (x);
}

const RX::Test_Freq_type& RX::
Test_Freq () const
{
  return this->Test_Freq_.get ();
}

RX::Test_Freq_type& RX::
Test_Freq ()
{
  return this->Test_Freq_.get ();
}

void RX::
Test_Freq (const Test_Freq_type& x)
{
  this->Test_Freq_.set (x);
}

void RX::
Test_Freq (::std::auto_ptr< Test_Freq_type > x)
{
  this->Test_Freq_.set (x);
}

const RX::Line_Number_type& RX::
Line_Number () const
{
  return this->Line_Number_.get ();
}

RX::Line_Number_type& RX::
Line_Number ()
{
  return this->Line_Number_.get ();
}

void RX::
Line_Number (const Line_Number_type& x)
{
  this->Line_Number_.set (x);
}

void RX::
Line_Number (::std::auto_ptr< Line_Number_type > x)
{
  this->Line_Number_.set (x);
}

const RX::V_TGC_type& RX::
V_TGC () const
{
  return this->V_TGC_.get ();
}

RX::V_TGC_type& RX::
V_TGC ()
{
  return this->V_TGC_.get ();
}

void RX::
V_TGC (const V_TGC_type& x)
{
  this->V_TGC_.set (x);
}

void RX::
V_TGC (::std::auto_ptr< V_TGC_type > x)
{
  this->V_TGC_.set (x);
}

const RX::IF_Filter_type& RX::
IF_Filter () const
{
  return this->IF_Filter_.get ();
}

RX::IF_Filter_type& RX::
IF_Filter ()
{
  return this->IF_Filter_.get ();
}

void RX::
IF_Filter (const IF_Filter_type& x)
{
  this->IF_Filter_.set (x);
}

void RX::
IF_Filter (::std::auto_ptr< IF_Filter_type > x)
{
  this->IF_Filter_.set (x);
}

const RX::Track_Width_type& RX::
Track_Width () const
{
  return this->Track_Width_.get ();
}

RX::Track_Width_type& RX::
Track_Width ()
{
  return this->Track_Width_.get ();
}

void RX::
Track_Width (const Track_Width_type& x)
{
  this->Track_Width_.set (x);
}

void RX::
Track_Width (::std::auto_ptr< Track_Width_type > x)
{
  this->Track_Width_.set (x);
}

const RX::DTB_Error_Clr_type& RX::
DTB_Error_Clr () const
{
  return this->DTB_Error_Clr_.get ();
}

RX::DTB_Error_Clr_type& RX::
DTB_Error_Clr ()
{
  return this->DTB_Error_Clr_.get ();
}

void RX::
DTB_Error_Clr (const DTB_Error_Clr_type& x)
{
  this->DTB_Error_Clr_.set (x);
}

void RX::
DTB_Error_Clr (::std::auto_ptr< DTB_Error_Clr_type > x)
{
  this->DTB_Error_Clr_.set (x);
}

const RX::Current_Channel_type& RX::
Current_Channel () const
{
  return this->Current_Channel_.get ();
}

RX::Current_Channel_type& RX::
Current_Channel ()
{
  return this->Current_Channel_.get ();
}

void RX::
Current_Channel (const Current_Channel_type& x)
{
  this->Current_Channel_.set (x);
}

void RX::
Current_Channel (::std::auto_ptr< Current_Channel_type > x)
{
  this->Current_Channel_.set (x);
}

const RX::V_IF_Filter_type& RX::
V_IF_Filter () const
{
  return this->V_IF_Filter_.get ();
}

RX::V_IF_Filter_type& RX::
V_IF_Filter ()
{
  return this->V_IF_Filter_.get ();
}

void RX::
V_IF_Filter (const V_IF_Filter_type& x)
{
  this->V_IF_Filter_.set (x);
}

void RX::
V_IF_Filter (::std::auto_ptr< V_IF_Filter_type > x)
{
  this->V_IF_Filter_.set (x);
}

const RX::IQ_Select_type& RX::
IQ_Select () const
{
  return this->IQ_Select_.get ();
}

RX::IQ_Select_type& RX::
IQ_Select ()
{
  return this->IQ_Select_.get ();
}

void RX::
IQ_Select (const IQ_Select_type& x)
{
  this->IQ_Select_.set (x);
}

void RX::
IQ_Select (::std::auto_ptr< IQ_Select_type > x)
{
  this->IQ_Select_.set (x);
}

const RX::HP_Clutter_type& RX::
HP_Clutter () const
{
  return this->HP_Clutter_.get ();
}

RX::HP_Clutter_type& RX::
HP_Clutter ()
{
  return this->HP_Clutter_.get ();
}

void RX::
HP_Clutter (const HP_Clutter_type& x)
{
  this->HP_Clutter_.set (x);
}

void RX::
HP_Clutter (::std::auto_ptr< HP_Clutter_type > x)
{
  this->HP_Clutter_.set (x);
}

const RX::AD_In_type& RX::
AD_In () const
{
  return this->AD_In_.get ();
}

RX::AD_In_type& RX::
AD_In ()
{
  return this->AD_In_.get ();
}

void RX::
AD_In (const AD_In_type& x)
{
  this->AD_In_.set (x);
}

void RX::
AD_In (::std::auto_ptr< AD_In_type > x)
{
  this->AD_In_.set (x);
}

const RX::V_TGC_Copy_type& RX::
V_TGC_Copy () const
{
  return this->V_TGC_Copy_.get ();
}

RX::V_TGC_Copy_type& RX::
V_TGC_Copy ()
{
  return this->V_TGC_Copy_.get ();
}

void RX::
V_TGC_Copy (const V_TGC_Copy_type& x)
{
  this->V_TGC_Copy_.set (x);
}

void RX::
V_TGC_Copy (::std::auto_ptr< V_TGC_Copy_type > x)
{
  this->V_TGC_Copy_.set (x);
}

const RX::Image_FIFO_Status_type& RX::
Image_FIFO_Status () const
{
  return this->Image_FIFO_Status_.get ();
}

RX::Image_FIFO_Status_type& RX::
Image_FIFO_Status ()
{
  return this->Image_FIFO_Status_.get ();
}

void RX::
Image_FIFO_Status (const Image_FIFO_Status_type& x)
{
  this->Image_FIFO_Status_.set (x);
}

void RX::
Image_FIFO_Status (::std::auto_ptr< Image_FIFO_Status_type > x)
{
  this->Image_FIFO_Status_.set (x);
}

const RX::RF_Filter_type& RX::
RF_Filter () const
{
  return this->RF_Filter_.get ();
}

RX::RF_Filter_type& RX::
RF_Filter ()
{
  return this->RF_Filter_.get ();
}

void RX::
RF_Filter (const RF_Filter_type& x)
{
  this->RF_Filter_.set (x);
}

void RX::
RF_Filter (::std::auto_ptr< RF_Filter_type > x)
{
  this->RF_Filter_.set (x);
}

const RX::DDRS_type& RX::
DDRS () const
{
  return this->DDRS_.get ();
}

RX::DDRS_type& RX::
DDRS ()
{
  return this->DDRS_.get ();
}

void RX::
DDRS (const DDRS_type& x)
{
  this->DDRS_.set (x);
}

void RX::
DDRS (::std::auto_ptr< DDRS_type > x)
{
  this->DDRS_.set (x);
}

const RX::ADCA_Out_type& RX::
ADCA_Out () const
{
  return this->ADCA_Out_.get ();
}

RX::ADCA_Out_type& RX::
ADCA_Out ()
{
  return this->ADCA_Out_.get ();
}

void RX::
ADCA_Out (const ADCA_Out_type& x)
{
  this->ADCA_Out_.set (x);
}

void RX::
ADCA_Out (::std::auto_ptr< ADCA_Out_type > x)
{
  this->ADCA_Out_.set (x);
}

const RX::AD_Clock_Div_type& RX::
AD_Clock_Div () const
{
  return this->AD_Clock_Div_.get ();
}

RX::AD_Clock_Div_type& RX::
AD_Clock_Div ()
{
  return this->AD_Clock_Div_.get ();
}

void RX::
AD_Clock_Div (const AD_Clock_Div_type& x)
{
  this->AD_Clock_Div_.set (x);
}

void RX::
AD_Clock_Div (::std::auto_ptr< AD_Clock_Div_type > x)
{
  this->AD_Clock_Div_.set (x);
}

const RX::Imaging_Mode_type& RX::
Imaging_Mode () const
{
  return this->Imaging_Mode_.get ();
}

RX::Imaging_Mode_type& RX::
Imaging_Mode ()
{
  return this->Imaging_Mode_.get ();
}

void RX::
Imaging_Mode (const Imaging_Mode_type& x)
{
  this->Imaging_Mode_.set (x);
}

void RX::
Imaging_Mode (::std::auto_ptr< Imaging_Mode_type > x)
{
  this->Imaging_Mode_.set (x);
}

const RX::V_RF_Filter_type& RX::
V_RF_Filter () const
{
  return this->V_RF_Filter_.get ();
}

RX::V_RF_Filter_type& RX::
V_RF_Filter ()
{
  return this->V_RF_Filter_.get ();
}

void RX::
V_RF_Filter (const V_RF_Filter_type& x)
{
  this->V_RF_Filter_.set (x);
}

void RX::
V_RF_Filter (::std::auto_ptr< V_RF_Filter_type > x)
{
  this->V_RF_Filter_.set (x);
}

const RX::ADCB_Out_type& RX::
ADCB_Out () const
{
  return this->ADCB_Out_.get ();
}

RX::ADCB_Out_type& RX::
ADCB_Out ()
{
  return this->ADCB_Out_.get ();
}

void RX::
ADCB_Out (const ADCB_Out_type& x)
{
  this->ADCB_Out_.set (x);
}

void RX::
ADCB_Out (::std::auto_ptr< ADCB_Out_type > x)
{
  this->ADCB_Out_.set (x);
}

const RX::Delay_type& RX::
Delay () const
{
  return this->Delay_.get ();
}

RX::Delay_type& RX::
Delay ()
{
  return this->Delay_.get ();
}

void RX::
Delay (const Delay_type& x)
{
  this->Delay_.set (x);
}

void RX::
Delay (::std::auto_ptr< Delay_type > x)
{
  this->Delay_.set (x);
}

const RX::AD_Gate_Width_type& RX::
AD_Gate_Width () const
{
  return this->AD_Gate_Width_.get ();
}

RX::AD_Gate_Width_type& RX::
AD_Gate_Width ()
{
  return this->AD_Gate_Width_.get ();
}

void RX::
AD_Gate_Width (const AD_Gate_Width_type& x)
{
  this->AD_Gate_Width_.set (x);
}

void RX::
AD_Gate_Width (::std::auto_ptr< AD_Gate_Width_type > x)
{
  this->AD_Gate_Width_.set (x);
}

const RX::Frequency_type& RX::
Frequency () const
{
  return this->Frequency_.get ();
}

RX::Frequency_type& RX::
Frequency ()
{
  return this->Frequency_.get ();
}

void RX::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void RX::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const RX::V_Frequency_type& RX::
V_Frequency () const
{
  return this->V_Frequency_.get ();
}

RX::V_Frequency_type& RX::
V_Frequency ()
{
  return this->V_Frequency_.get ();
}

void RX::
V_Frequency (const V_Frequency_type& x)
{
  this->V_Frequency_.set (x);
}

void RX::
V_Frequency (::std::auto_ptr< V_Frequency_type > x)
{
  this->V_Frequency_.set (x);
}

const RX::V_Field_Of_View_type& RX::
V_Field_Of_View () const
{
  return this->V_Field_Of_View_.get ();
}

RX::V_Field_Of_View_type& RX::
V_Field_Of_View ()
{
  return this->V_Field_Of_View_.get ();
}

void RX::
V_Field_Of_View (const V_Field_Of_View_type& x)
{
  this->V_Field_Of_View_.set (x);
}

void RX::
V_Field_Of_View (::std::auto_ptr< V_Field_Of_View_type > x)
{
  this->V_Field_Of_View_.set (x);
}

const RX::Packet_Format_type& RX::
Packet_Format () const
{
  return this->Packet_Format_.get ();
}

RX::Packet_Format_type& RX::
Packet_Format ()
{
  return this->Packet_Format_.get ();
}

void RX::
Packet_Format (const Packet_Format_type& x)
{
  this->Packet_Format_.set (x);
}

void RX::
Packet_Format (::std::auto_ptr< Packet_Format_type > x)
{
  this->Packet_Format_.set (x);
}

const RX::Sector_Height_Target_type& RX::
Sector_Height_Target () const
{
  return this->Sector_Height_Target_.get ();
}

RX::Sector_Height_Target_type& RX::
Sector_Height_Target ()
{
  return this->Sector_Height_Target_.get ();
}

void RX::
Sector_Height_Target (const Sector_Height_Target_type& x)
{
  this->Sector_Height_Target_.set (x);
}

void RX::
Sector_Height_Target (::std::auto_ptr< Sector_Height_Target_type > x)
{
  this->Sector_Height_Target_.set (x);
}

const RX::Low_Speed_FIFO_Status_type& RX::
Low_Speed_FIFO_Status () const
{
  return this->Low_Speed_FIFO_Status_.get ();
}

RX::Low_Speed_FIFO_Status_type& RX::
Low_Speed_FIFO_Status ()
{
  return this->Low_Speed_FIFO_Status_.get ();
}

void RX::
Low_Speed_FIFO_Status (const Low_Speed_FIFO_Status_type& x)
{
  this->Low_Speed_FIFO_Status_.set (x);
}

void RX::
Low_Speed_FIFO_Status (::std::auto_ptr< Low_Speed_FIFO_Status_type > x)
{
  this->Low_Speed_FIFO_Status_.set (x);
}

const RX::AD_TestIn_type& RX::
AD_TestIn () const
{
  return this->AD_TestIn_.get ();
}

RX::AD_TestIn_type& RX::
AD_TestIn ()
{
  return this->AD_TestIn_.get ();
}

void RX::
AD_TestIn (const AD_TestIn_type& x)
{
  this->AD_TestIn_.set (x);
}

void RX::
AD_TestIn (::std::auto_ptr< AD_TestIn_type > x)
{
  this->AD_TestIn_.set (x);
}

const RX::Error_type& RX::
Error () const
{
  return this->Error_.get ();
}

RX::Error_type& RX::
Error ()
{
  return this->Error_.get ();
}

void RX::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void RX::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const RX::Test_On_type& RX::
Test_On () const
{
  return this->Test_On_.get ();
}

RX::Test_On_type& RX::
Test_On ()
{
  return this->Test_On_.get ();
}

void RX::
Test_On (const Test_On_type& x)
{
  this->Test_On_.set (x);
}

void RX::
Test_On (::std::auto_ptr< Test_On_type > x)
{
  this->Test_On_.set (x);
}

const RX::AD_DCS_type& RX::
AD_DCS () const
{
  return this->AD_DCS_.get ();
}

RX::AD_DCS_type& RX::
AD_DCS ()
{
  return this->AD_DCS_.get ();
}

void RX::
AD_DCS (const AD_DCS_type& x)
{
  this->AD_DCS_.set (x);
}

void RX::
AD_DCS (::std::auto_ptr< AD_DCS_type > x)
{
  this->AD_DCS_.set (x);
}

const RX::DTB_Tfr_Enable_type& RX::
DTB_Tfr_Enable () const
{
  return this->DTB_Tfr_Enable_.get ();
}

RX::DTB_Tfr_Enable_type& RX::
DTB_Tfr_Enable ()
{
  return this->DTB_Tfr_Enable_.get ();
}

void RX::
DTB_Tfr_Enable (const DTB_Tfr_Enable_type& x)
{
  this->DTB_Tfr_Enable_.set (x);
}

void RX::
DTB_Tfr_Enable (::std::auto_ptr< DTB_Tfr_Enable_type > x)
{
  this->DTB_Tfr_Enable_.set (x);
}

const RX::DTB_Test_Enable_type& RX::
DTB_Test_Enable () const
{
  return this->DTB_Test_Enable_.get ();
}

RX::DTB_Test_Enable_type& RX::
DTB_Test_Enable ()
{
  return this->DTB_Test_Enable_.get ();
}

void RX::
DTB_Test_Enable (const DTB_Test_Enable_type& x)
{
  this->DTB_Test_Enable_.set (x);
}

void RX::
DTB_Test_Enable (::std::auto_ptr< DTB_Test_Enable_type > x)
{
  this->DTB_Test_Enable_.set (x);
}

const RX::V_Delay_Length_type& RX::
V_Delay_Length () const
{
  return this->V_Delay_Length_.get ();
}

RX::V_Delay_Length_type& RX::
V_Delay_Length ()
{
  return this->V_Delay_Length_.get ();
}

void RX::
V_Delay_Length (const V_Delay_Length_type& x)
{
  this->V_Delay_Length_.set (x);
}

void RX::
V_Delay_Length (::std::auto_ptr< V_Delay_Length_type > x)
{
  this->V_Delay_Length_.set (x);
}

const RX::Current_Mode_type& RX::
Current_Mode () const
{
  return this->Current_Mode_.get ();
}

RX::Current_Mode_type& RX::
Current_Mode ()
{
  return this->Current_Mode_.get ();
}

void RX::
Current_Mode (const Current_Mode_type& x)
{
  this->Current_Mode_.set (x);
}

void RX::
Current_Mode (::std::auto_ptr< Current_Mode_type > x)
{
  this->Current_Mode_.set (x);
}


// Display
// 

const Display::Direction_type& Display::
Direction () const
{
  return this->Direction_.get ();
}

Display::Direction_type& Display::
Direction ()
{
  return this->Direction_.get ();
}

void Display::
Direction (const Direction_type& x)
{
  this->Direction_.set (x);
}

void Display::
Direction (::std::auto_ptr< Direction_type > x)
{
  this->Direction_.set (x);
}

const Display::X_3D_Gain_type& Display::
X_3D_Gain () const
{
  return this->X_3D_Gain_.get ();
}

Display::X_3D_Gain_type& Display::
X_3D_Gain ()
{
  return this->X_3D_Gain_.get ();
}

void Display::
X_3D_Gain (const X_3D_Gain_type& x)
{
  this->X_3D_Gain_.set (x);
}

void Display::
X_3D_Gain (::std::auto_ptr< X_3D_Gain_type > x)
{
  this->X_3D_Gain_.set (x);
}

const Display::X_3D_Dynamic_Range_type& Display::
X_3D_Dynamic_Range () const
{
  return this->X_3D_Dynamic_Range_.get ();
}

Display::X_3D_Dynamic_Range_type& Display::
X_3D_Dynamic_Range ()
{
  return this->X_3D_Dynamic_Range_.get ();
}

void Display::
X_3D_Dynamic_Range (const X_3D_Dynamic_Range_type& x)
{
  this->X_3D_Dynamic_Range_.set (x);
}

void Display::
X_3D_Dynamic_Range (::std::auto_ptr< X_3D_Dynamic_Range_type > x)
{
  this->X_3D_Dynamic_Range_.set (x);
}

const Display::V_Selection_type& Display::
V_Selection () const
{
  return this->V_Selection_.get ();
}

Display::V_Selection_type& Display::
V_Selection ()
{
  return this->V_Selection_.get ();
}

void Display::
V_Selection (const V_Selection_type& x)
{
  this->V_Selection_.set (x);
}

void Display::
V_Selection (::std::auto_ptr< V_Selection_type > x)
{
  this->V_Selection_.set (x);
}

const Display::Gain_type& Display::
Gain () const
{
  return this->Gain_.get ();
}

Display::Gain_type& Display::
Gain ()
{
  return this->Gain_.get ();
}

void Display::
Gain (const Gain_type& x)
{
  this->Gain_.set (x);
}

void Display::
Gain (::std::auto_ptr< Gain_type > x)
{
  this->Gain_.set (x);
}

const Display::Dynamic_Range_type& Display::
Dynamic_Range () const
{
  return this->Dynamic_Range_.get ();
}

Display::Dynamic_Range_type& Display::
Dynamic_Range ()
{
  return this->Dynamic_Range_.get ();
}

void Display::
Dynamic_Range (const Dynamic_Range_type& x)
{
  this->Dynamic_Range_.set (x);
}

void Display::
Dynamic_Range (::std::auto_ptr< Dynamic_Range_type > x)
{
  this->Dynamic_Range_.set (x);
}

const Display::Window_Time_type& Display::
Window_Time () const
{
  return this->Window_Time_.get ();
}

Display::Window_Time_type& Display::
Window_Time ()
{
  return this->Window_Time_.get ();
}

void Display::
Window_Time (const Window_Time_type& x)
{
  this->Window_Time_.set (x);
}

void Display::
Window_Time (::std::auto_ptr< Window_Time_type > x)
{
  this->Window_Time_.set (x);
}


// Acqiris
// 

const Acqiris::SamplesNom_type& Acqiris::
SamplesNom () const
{
  return this->SamplesNom_.get ();
}

Acqiris::SamplesNom_type& Acqiris::
SamplesNom ()
{
  return this->SamplesNom_.get ();
}

void Acqiris::
SamplesNom (const SamplesNom_type& x)
{
  this->SamplesNom_.set (x);
}

void Acqiris::
SamplesNom (::std::auto_ptr< SamplesNom_type > x)
{
  this->SamplesNom_.set (x);
}

const Acqiris::V_Read_Data_type& Acqiris::
V_Read_Data () const
{
  return this->V_Read_Data_.get ();
}

Acqiris::V_Read_Data_type& Acqiris::
V_Read_Data ()
{
  return this->V_Read_Data_.get ();
}

void Acqiris::
V_Read_Data (const V_Read_Data_type& x)
{
  this->V_Read_Data_.set (x);
}

void Acqiris::
V_Read_Data (::std::auto_ptr< V_Read_Data_type > x)
{
  this->V_Read_Data_.set (x);
}

const Acqiris::Mode_type& Acqiris::
Mode () const
{
  return this->Mode_.get ();
}

Acqiris::Mode_type& Acqiris::
Mode ()
{
  return this->Mode_.get ();
}

void Acqiris::
Mode (const Mode_type& x)
{
  this->Mode_.set (x);
}

void Acqiris::
Mode (::std::auto_ptr< Mode_type > x)
{
  this->Mode_.set (x);
}

const Acqiris::Acquire_type& Acqiris::
Acquire () const
{
  return this->Acquire_.get ();
}

Acqiris::Acquire_type& Acqiris::
Acquire ()
{
  return this->Acquire_.get ();
}

void Acqiris::
Acquire (const Acquire_type& x)
{
  this->Acquire_.set (x);
}

void Acqiris::
Acquire (::std::auto_ptr< Acquire_type > x)
{
  this->Acquire_.set (x);
}

const Acqiris::Available_type& Acqiris::
Available () const
{
  return this->Available_.get ();
}

Acqiris::Available_type& Acqiris::
Available ()
{
  return this->Available_.get ();
}

void Acqiris::
Available (const Available_type& x)
{
  this->Available_.set (x);
}

void Acqiris::
Available (::std::auto_ptr< Available_type > x)
{
  this->Available_.set (x);
}

const Acqiris::Force_Trigger_type& Acqiris::
Force_Trigger () const
{
  return this->Force_Trigger_.get ();
}

Acqiris::Force_Trigger_type& Acqiris::
Force_Trigger ()
{
  return this->Force_Trigger_.get ();
}

void Acqiris::
Force_Trigger (const Force_Trigger_type& x)
{
  this->Force_Trigger_.set (x);
}

void Acqiris::
Force_Trigger (::std::auto_ptr< Force_Trigger_type > x)
{
  this->Force_Trigger_.set (x);
}

const Acqiris::Control_type& Acqiris::
Control () const
{
  return this->Control_.get ();
}

Acqiris::Control_type& Acqiris::
Control ()
{
  return this->Control_.get ();
}

void Acqiris::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void Acqiris::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}

const Acqiris::TbSegmentPad_type& Acqiris::
TbSegmentPad () const
{
  return this->TbSegmentPad_.get ();
}

Acqiris::TbSegmentPad_type& Acqiris::
TbSegmentPad ()
{
  return this->TbSegmentPad_.get ();
}

void Acqiris::
TbSegmentPad (const TbSegmentPad_type& x)
{
  this->TbSegmentPad_.set (x);
}

void Acqiris::
TbSegmentPad (::std::auto_ptr< TbSegmentPad_type > x)
{
  this->TbSegmentPad_.set (x);
}

const Acqiris::Wait_Acq_type& Acqiris::
Wait_Acq () const
{
  return this->Wait_Acq_.get ();
}

Acqiris::Wait_Acq_type& Acqiris::
Wait_Acq ()
{
  return this->Wait_Acq_.get ();
}

void Acqiris::
Wait_Acq (const Wait_Acq_type& x)
{
  this->Wait_Acq_.set (x);
}

void Acqiris::
Wait_Acq (::std::auto_ptr< Wait_Acq_type > x)
{
  this->Wait_Acq_.set (x);
}


// ActiveProbe1
// 

const ActiveProbe1::Notes_type& ActiveProbe1::
Notes () const
{
  return this->Notes_.get ();
}

ActiveProbe1::Notes_type& ActiveProbe1::
Notes ()
{
  return this->Notes_.get ();
}

void ActiveProbe1::
Notes (const Notes_type& x)
{
  this->Notes_.set (x);
}

void ActiveProbe1::
Notes (::std::auto_ptr< Notes_type > x)
{
  this->Notes_.set (x);
}

const ActiveProbe1::Sample_Time_type& ActiveProbe1::
Sample_Time () const
{
  return this->Sample_Time_.get ();
}

ActiveProbe1::Sample_Time_type& ActiveProbe1::
Sample_Time ()
{
  return this->Sample_Time_.get ();
}

void ActiveProbe1::
Sample_Time (const Sample_Time_type& x)
{
  this->Sample_Time_.set (x);
}

void ActiveProbe1::
Sample_Time (::std::auto_ptr< Sample_Time_type > x)
{
  this->Sample_Time_.set (x);
}

const ActiveProbe1::Focal_Length_type& ActiveProbe1::
Focal_Length () const
{
  return this->Focal_Length_.get ();
}

ActiveProbe1::Focal_Length_type& ActiveProbe1::
Focal_Length ()
{
  return this->Focal_Length_.get ();
}

void ActiveProbe1::
Focal_Length (const Focal_Length_type& x)
{
  this->Focal_Length_.set (x);
}

void ActiveProbe1::
Focal_Length (::std::auto_ptr< Focal_Length_type > x)
{
  this->Focal_Length_.set (x);
}

const ActiveProbe1::Acceleration_Limit_Slope_type& ActiveProbe1::
Acceleration_Limit_Slope () const
{
  return this->Acceleration_Limit_Slope_.get ();
}

ActiveProbe1::Acceleration_Limit_Slope_type& ActiveProbe1::
Acceleration_Limit_Slope ()
{
  return this->Acceleration_Limit_Slope_.get ();
}

void ActiveProbe1::
Acceleration_Limit_Slope (const Acceleration_Limit_Slope_type& x)
{
  this->Acceleration_Limit_Slope_.set (x);
}

void ActiveProbe1::
Acceleration_Limit_Slope (::std::auto_ptr< Acceleration_Limit_Slope_type > x)
{
  this->Acceleration_Limit_Slope_.set (x);
}

const ActiveProbe1::Type_type& ActiveProbe1::
Type () const
{
  return this->Type_.get ();
}

ActiveProbe1::Type_type& ActiveProbe1::
Type ()
{
  return this->Type_.get ();
}

void ActiveProbe1::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void ActiveProbe1::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const ActiveProbe1::Detect_Id_type& ActiveProbe1::
Detect_Id () const
{
  return this->Detect_Id_.get ();
}

ActiveProbe1::Detect_Id_type& ActiveProbe1::
Detect_Id ()
{
  return this->Detect_Id_.get ();
}

void ActiveProbe1::
Detect_Id (const Detect_Id_type& x)
{
  this->Detect_Id_.set (x);
}

void ActiveProbe1::
Detect_Id (::std::auto_ptr< Detect_Id_type > x)
{
  this->Detect_Id_.set (x);
}

const ActiveProbe1::Default_Scan_Speed_type& ActiveProbe1::
Default_Scan_Speed () const
{
  return this->Default_Scan_Speed_.get ();
}

ActiveProbe1::Default_Scan_Speed_type& ActiveProbe1::
Default_Scan_Speed ()
{
  return this->Default_Scan_Speed_.get ();
}

void ActiveProbe1::
Default_Scan_Speed (const Default_Scan_Speed_type& x)
{
  this->Default_Scan_Speed_.set (x);
}

void ActiveProbe1::
Default_Scan_Speed (::std::auto_ptr< Default_Scan_Speed_type > x)
{
  this->Default_Scan_Speed_.set (x);
}

const ActiveProbe1::K1_Power_type& ActiveProbe1::
K1_Power () const
{
  return this->K1_Power_.get ();
}

ActiveProbe1::K1_Power_type& ActiveProbe1::
K1_Power ()
{
  return this->K1_Power_.get ();
}

void ActiveProbe1::
K1_Power (const K1_Power_type& x)
{
  this->K1_Power_.set (x);
}

void ActiveProbe1::
K1_Power (::std::auto_ptr< K1_Power_type > x)
{
  this->K1_Power_.set (x);
}

const ActiveProbe1::Cutoff_Scan_Speed_type& ActiveProbe1::
Cutoff_Scan_Speed () const
{
  return this->Cutoff_Scan_Speed_.get ();
}

ActiveProbe1::Cutoff_Scan_Speed_type& ActiveProbe1::
Cutoff_Scan_Speed ()
{
  return this->Cutoff_Scan_Speed_.get ();
}

void ActiveProbe1::
Cutoff_Scan_Speed (const Cutoff_Scan_Speed_type& x)
{
  this->Cutoff_Scan_Speed_.set (x);
}

void ActiveProbe1::
Cutoff_Scan_Speed (::std::auto_ptr< Cutoff_Scan_Speed_type > x)
{
  this->Cutoff_Scan_Speed_.set (x);
}

const ActiveProbe1::Frequency_Low_type& ActiveProbe1::
Frequency_Low () const
{
  return this->Frequency_Low_.get ();
}

ActiveProbe1::Frequency_Low_type& ActiveProbe1::
Frequency_Low ()
{
  return this->Frequency_Low_.get ();
}

void ActiveProbe1::
Frequency_Low (const Frequency_Low_type& x)
{
  this->Frequency_Low_.set (x);
}

void ActiveProbe1::
Frequency_Low (::std::auto_ptr< Frequency_Low_type > x)
{
  this->Frequency_Low_.set (x);
}

const ActiveProbe1::Default_FOV_type& ActiveProbe1::
Default_FOV () const
{
  return this->Default_FOV_.get ();
}

ActiveProbe1::Default_FOV_type& ActiveProbe1::
Default_FOV ()
{
  return this->Default_FOV_.get ();
}

void ActiveProbe1::
Default_FOV (const Default_FOV_type& x)
{
  this->Default_FOV_.set (x);
}

void ActiveProbe1::
Default_FOV (::std::auto_ptr< Default_FOV_type > x)
{
  this->Default_FOV_.set (x);
}

const ActiveProbe1::Frequency_Doppler_Default_type& ActiveProbe1::
Frequency_Doppler_Default () const
{
  return this->Frequency_Doppler_Default_.get ();
}

ActiveProbe1::Frequency_Doppler_Default_type& ActiveProbe1::
Frequency_Doppler_Default ()
{
  return this->Frequency_Doppler_Default_.get ();
}

void ActiveProbe1::
Frequency_Doppler_Default (const Frequency_Doppler_Default_type& x)
{
  this->Frequency_Doppler_Default_.set (x);
}

void ActiveProbe1::
Frequency_Doppler_Default (::std::auto_ptr< Frequency_Doppler_Default_type > x)
{
  this->Frequency_Doppler_Default_.set (x);
}

const ActiveProbe1::Default_SvSize_MMode_type& ActiveProbe1::
Default_SvSize_MMode () const
{
  return this->Default_SvSize_MMode_.get ();
}

ActiveProbe1::Default_SvSize_MMode_type& ActiveProbe1::
Default_SvSize_MMode ()
{
  return this->Default_SvSize_MMode_.get ();
}

void ActiveProbe1::
Default_SvSize_MMode (const Default_SvSize_MMode_type& x)
{
  this->Default_SvSize_MMode_.set (x);
}

void ActiveProbe1::
Default_SvSize_MMode (::std::auto_ptr< Default_SvSize_MMode_type > x)
{
  this->Default_SvSize_MMode_.set (x);
}

const ActiveProbe1::Axial_Res_Factor_Target_type& ActiveProbe1::
Axial_Res_Factor_Target () const
{
  return this->Axial_Res_Factor_Target_.get ();
}

ActiveProbe1::Axial_Res_Factor_Target_type& ActiveProbe1::
Axial_Res_Factor_Target ()
{
  return this->Axial_Res_Factor_Target_.get ();
}

void ActiveProbe1::
Axial_Res_Factor_Target (const Axial_Res_Factor_Target_type& x)
{
  this->Axial_Res_Factor_Target_.set (x);
}

void ActiveProbe1::
Axial_Res_Factor_Target (::std::auto_ptr< Axial_Res_Factor_Target_type > x)
{
  this->Axial_Res_Factor_Target_.set (x);
}

const ActiveProbe1::F_Number_type& ActiveProbe1::
F_Number () const
{
  return this->F_Number_.get ();
}

ActiveProbe1::F_Number_type& ActiveProbe1::
F_Number ()
{
  return this->F_Number_.get ();
}

void ActiveProbe1::
F_Number (const F_Number_type& x)
{
  this->F_Number_.set (x);
}

void ActiveProbe1::
F_Number (::std::auto_ptr< F_Number_type > x)
{
  this->F_Number_.set (x);
}

const ActiveProbe1::Acc_Time_Factor_type& ActiveProbe1::
Acc_Time_Factor () const
{
  return this->Acc_Time_Factor_.get ();
}

ActiveProbe1::Acc_Time_Factor_type& ActiveProbe1::
Acc_Time_Factor ()
{
  return this->Acc_Time_Factor_.get ();
}

void ActiveProbe1::
Acc_Time_Factor (const Acc_Time_Factor_type& x)
{
  this->Acc_Time_Factor_.set (x);
}

void ActiveProbe1::
Acc_Time_Factor (::std::auto_ptr< Acc_Time_Factor_type > x)
{
  this->Acc_Time_Factor_.set (x);
}

const ActiveProbe1::Axial_Res_type& ActiveProbe1::
Axial_Res () const
{
  return this->Axial_Res_.get ();
}

ActiveProbe1::Axial_Res_type& ActiveProbe1::
Axial_Res ()
{
  return this->Axial_Res_.get ();
}

void ActiveProbe1::
Axial_Res (const Axial_Res_type& x)
{
  this->Axial_Res_.set (x);
}

void ActiveProbe1::
Axial_Res (::std::auto_ptr< Axial_Res_type > x)
{
  this->Axial_Res_.set (x);
}

const ActiveProbe1::Lateral_Res_Factor_Target_type& ActiveProbe1::
Lateral_Res_Factor_Target () const
{
  return this->Lateral_Res_Factor_Target_.get ();
}

ActiveProbe1::Lateral_Res_Factor_Target_type& ActiveProbe1::
Lateral_Res_Factor_Target ()
{
  return this->Lateral_Res_Factor_Target_.get ();
}

void ActiveProbe1::
Lateral_Res_Factor_Target (const Lateral_Res_Factor_Target_type& x)
{
  this->Lateral_Res_Factor_Target_.set (x);
}

void ActiveProbe1::
Lateral_Res_Factor_Target (::std::auto_ptr< Lateral_Res_Factor_Target_type > x)
{
  this->Lateral_Res_Factor_Target_.set (x);
}

const ActiveProbe1::Pivot_Encoder_Dist_type& ActiveProbe1::
Pivot_Encoder_Dist () const
{
  return this->Pivot_Encoder_Dist_.get ();
}

ActiveProbe1::Pivot_Encoder_Dist_type& ActiveProbe1::
Pivot_Encoder_Dist ()
{
  return this->Pivot_Encoder_Dist_.get ();
}

void ActiveProbe1::
Pivot_Encoder_Dist (const Pivot_Encoder_Dist_type& x)
{
  this->Pivot_Encoder_Dist_.set (x);
}

void ActiveProbe1::
Pivot_Encoder_Dist (::std::auto_ptr< Pivot_Encoder_Dist_type > x)
{
  this->Pivot_Encoder_Dist_.set (x);
}

const ActiveProbe1::Encoder_Range_Max_type& ActiveProbe1::
Encoder_Range_Max () const
{
  return this->Encoder_Range_Max_.get ();
}

ActiveProbe1::Encoder_Range_Max_type& ActiveProbe1::
Encoder_Range_Max ()
{
  return this->Encoder_Range_Max_.get ();
}

void ActiveProbe1::
Encoder_Range_Max (const Encoder_Range_Max_type& x)
{
  this->Encoder_Range_Max_.set (x);
}

void ActiveProbe1::
Encoder_Range_Max (::std::auto_ptr< Encoder_Range_Max_type > x)
{
  this->Encoder_Range_Max_.set (x);
}

const ActiveProbe1::Encoder_Range_Min_type& ActiveProbe1::
Encoder_Range_Min () const
{
  return this->Encoder_Range_Min_.get ();
}

ActiveProbe1::Encoder_Range_Min_type& ActiveProbe1::
Encoder_Range_Min ()
{
  return this->Encoder_Range_Min_.get ();
}

void ActiveProbe1::
Encoder_Range_Min (const Encoder_Range_Min_type& x)
{
  this->Encoder_Range_Min_.set (x);
}

void ActiveProbe1::
Encoder_Range_Min (::std::auto_ptr< Encoder_Range_Min_type > x)
{
  this->Encoder_Range_Min_.set (x);
}

const ActiveProbe1::Lateral_Res_type& ActiveProbe1::
Lateral_Res () const
{
  return this->Lateral_Res_.get ();
}

ActiveProbe1::Lateral_Res_type& ActiveProbe1::
Lateral_Res ()
{
  return this->Lateral_Res_.get ();
}

void ActiveProbe1::
Lateral_Res (const Lateral_Res_type& x)
{
  this->Lateral_Res_.set (x);
}

void ActiveProbe1::
Lateral_Res (::std::auto_ptr< Lateral_Res_type > x)
{
  this->Lateral_Res_.set (x);
}

const ActiveProbe1::Max_Scan_Distance_type& ActiveProbe1::
Max_Scan_Distance () const
{
  return this->Max_Scan_Distance_.get ();
}

ActiveProbe1::Max_Scan_Distance_type& ActiveProbe1::
Max_Scan_Distance ()
{
  return this->Max_Scan_Distance_.get ();
}

void ActiveProbe1::
Max_Scan_Distance (const Max_Scan_Distance_type& x)
{
  this->Max_Scan_Distance_.set (x);
}

void ActiveProbe1::
Max_Scan_Distance (::std::auto_ptr< Max_Scan_Distance_type > x)
{
  this->Max_Scan_Distance_.set (x);
}

const ActiveProbe1::Default_Rx_Gain_type& ActiveProbe1::
Default_Rx_Gain () const
{
  return this->Default_Rx_Gain_.get ();
}

ActiveProbe1::Default_Rx_Gain_type& ActiveProbe1::
Default_Rx_Gain ()
{
  return this->Default_Rx_Gain_.get ();
}

void ActiveProbe1::
Default_Rx_Gain (const Default_Rx_Gain_type& x)
{
  this->Default_Rx_Gain_.set (x);
}

void ActiveProbe1::
Default_Rx_Gain (::std::auto_ptr< Default_Rx_Gain_type > x)
{
  this->Default_Rx_Gain_.set (x);
}

const ActiveProbe1::PID_KD_High_type& ActiveProbe1::
PID_KD_High () const
{
  return this->PID_KD_High_.get ();
}

ActiveProbe1::PID_KD_High_type& ActiveProbe1::
PID_KD_High ()
{
  return this->PID_KD_High_.get ();
}

void ActiveProbe1::
PID_KD_High (const PID_KD_High_type& x)
{
  this->PID_KD_High_.set (x);
}

void ActiveProbe1::
PID_KD_High (::std::auto_ptr< PID_KD_High_type > x)
{
  this->PID_KD_High_.set (x);
}

const ActiveProbe1::PID_KI_High_type& ActiveProbe1::
PID_KI_High () const
{
  return this->PID_KI_High_.get ();
}

ActiveProbe1::PID_KI_High_type& ActiveProbe1::
PID_KI_High ()
{
  return this->PID_KI_High_.get ();
}

void ActiveProbe1::
PID_KI_High (const PID_KI_High_type& x)
{
  this->PID_KI_High_.set (x);
}

void ActiveProbe1::
PID_KI_High (::std::auto_ptr< PID_KI_High_type > x)
{
  this->PID_KI_High_.set (x);
}

const ActiveProbe1::PID_KP_High_type& ActiveProbe1::
PID_KP_High () const
{
  return this->PID_KP_High_.get ();
}

ActiveProbe1::PID_KP_High_type& ActiveProbe1::
PID_KP_High ()
{
  return this->PID_KP_High_.get ();
}

void ActiveProbe1::
PID_KP_High (const PID_KP_High_type& x)
{
  this->PID_KP_High_.set (x);
}

void ActiveProbe1::
PID_KP_High (::std::auto_ptr< PID_KP_High_type > x)
{
  this->PID_KP_High_.set (x);
}

const ActiveProbe1::Frequency_High_type& ActiveProbe1::
Frequency_High () const
{
  return this->Frequency_High_.get ();
}

ActiveProbe1::Frequency_High_type& ActiveProbe1::
Frequency_High ()
{
  return this->Frequency_High_.get ();
}

void ActiveProbe1::
Frequency_High (const Frequency_High_type& x)
{
  this->Frequency_High_.set (x);
}

void ActiveProbe1::
Frequency_High (::std::auto_ptr< Frequency_High_type > x)
{
  this->Frequency_High_.set (x);
}

const ActiveProbe1::Lateral_Res_Factor_Max_type& ActiveProbe1::
Lateral_Res_Factor_Max () const
{
  return this->Lateral_Res_Factor_Max_.get ();
}

ActiveProbe1::Lateral_Res_Factor_Max_type& ActiveProbe1::
Lateral_Res_Factor_Max ()
{
  return this->Lateral_Res_Factor_Max_.get ();
}

void ActiveProbe1::
Lateral_Res_Factor_Max (const Lateral_Res_Factor_Max_type& x)
{
  this->Lateral_Res_Factor_Max_.set (x);
}

void ActiveProbe1::
Lateral_Res_Factor_Max (::std::auto_ptr< Lateral_Res_Factor_Max_type > x)
{
  this->Lateral_Res_Factor_Max_.set (x);
}

const ActiveProbe1::Scan_Speeds_type& ActiveProbe1::
Scan_Speeds () const
{
  return this->Scan_Speeds_.get ();
}

ActiveProbe1::Scan_Speeds_type& ActiveProbe1::
Scan_Speeds ()
{
  return this->Scan_Speeds_.get ();
}

void ActiveProbe1::
Scan_Speeds (const Scan_Speeds_type& x)
{
  this->Scan_Speeds_.set (x);
}

void ActiveProbe1::
Scan_Speeds (::std::auto_ptr< Scan_Speeds_type > x)
{
  this->Scan_Speeds_.set (x);
}

const ActiveProbe1::Filter_Doppler_Cutoff_type& ActiveProbe1::
Filter_Doppler_Cutoff () const
{
  return this->Filter_Doppler_Cutoff_.get ();
}

ActiveProbe1::Filter_Doppler_Cutoff_type& ActiveProbe1::
Filter_Doppler_Cutoff ()
{
  return this->Filter_Doppler_Cutoff_.get ();
}

void ActiveProbe1::
Filter_Doppler_Cutoff (const Filter_Doppler_Cutoff_type& x)
{
  this->Filter_Doppler_Cutoff_.set (x);
}

void ActiveProbe1::
Filter_Doppler_Cutoff (::std::auto_ptr< Filter_Doppler_Cutoff_type > x)
{
  this->Filter_Doppler_Cutoff_.set (x);
}

const ActiveProbe1::Name_type& ActiveProbe1::
Name () const
{
  return this->Name_.get ();
}

ActiveProbe1::Name_type& ActiveProbe1::
Name ()
{
  return this->Name_.get ();
}

void ActiveProbe1::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ActiveProbe1::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const ActiveProbe1::PID_KD_Low_type& ActiveProbe1::
PID_KD_Low () const
{
  return this->PID_KD_Low_.get ();
}

ActiveProbe1::PID_KD_Low_type& ActiveProbe1::
PID_KD_Low ()
{
  return this->PID_KD_Low_.get ();
}

void ActiveProbe1::
PID_KD_Low (const PID_KD_Low_type& x)
{
  this->PID_KD_Low_.set (x);
}

void ActiveProbe1::
PID_KD_Low (::std::auto_ptr< PID_KD_Low_type > x)
{
  this->PID_KD_Low_.set (x);
}

const ActiveProbe1::PID_KI_Low_type& ActiveProbe1::
PID_KI_Low () const
{
  return this->PID_KI_Low_.get ();
}

ActiveProbe1::PID_KI_Low_type& ActiveProbe1::
PID_KI_Low ()
{
  return this->PID_KI_Low_.get ();
}

void ActiveProbe1::
PID_KI_Low (const PID_KI_Low_type& x)
{
  this->PID_KI_Low_.set (x);
}

void ActiveProbe1::
PID_KI_Low (::std::auto_ptr< PID_KI_Low_type > x)
{
  this->PID_KI_Low_.set (x);
}

const ActiveProbe1::PID_KP_Low_type& ActiveProbe1::
PID_KP_Low () const
{
  return this->PID_KP_Low_.get ();
}

ActiveProbe1::PID_KP_Low_type& ActiveProbe1::
PID_KP_Low ()
{
  return this->PID_KP_Low_.get ();
}

void ActiveProbe1::
PID_KP_Low (const PID_KP_Low_type& x)
{
  this->PID_KP_Low_.set (x);
}

void ActiveProbe1::
PID_KP_Low (::std::auto_ptr< PID_KP_Low_type > x)
{
  this->PID_KP_Low_.set (x);
}

const ActiveProbe1::Peak_Bandwidth_Correction_type& ActiveProbe1::
Peak_Bandwidth_Correction () const
{
  return this->Peak_Bandwidth_Correction_.get ();
}

ActiveProbe1::Peak_Bandwidth_Correction_type& ActiveProbe1::
Peak_Bandwidth_Correction ()
{
  return this->Peak_Bandwidth_Correction_.get ();
}

void ActiveProbe1::
Peak_Bandwidth_Correction (const Peak_Bandwidth_Correction_type& x)
{
  this->Peak_Bandwidth_Correction_.set (x);
}

void ActiveProbe1::
Peak_Bandwidth_Correction (::std::auto_ptr< Peak_Bandwidth_Correction_type > x)
{
  this->Peak_Bandwidth_Correction_.set (x);
}

const ActiveProbe1::Frequency_Doppler_Low_type& ActiveProbe1::
Frequency_Doppler_Low () const
{
  return this->Frequency_Doppler_Low_.get ();
}

ActiveProbe1::Frequency_Doppler_Low_type& ActiveProbe1::
Frequency_Doppler_Low ()
{
  return this->Frequency_Doppler_Low_.get ();
}

void ActiveProbe1::
Frequency_Doppler_Low (const Frequency_Doppler_Low_type& x)
{
  this->Frequency_Doppler_Low_.set (x);
}

void ActiveProbe1::
Frequency_Doppler_Low (::std::auto_ptr< Frequency_Doppler_Low_type > x)
{
  this->Frequency_Doppler_Low_.set (x);
}

const ActiveProbe1::Pivot_Transducer_Face_Dist_type& ActiveProbe1::
Pivot_Transducer_Face_Dist () const
{
  return this->Pivot_Transducer_Face_Dist_.get ();
}

ActiveProbe1::Pivot_Transducer_Face_Dist_type& ActiveProbe1::
Pivot_Transducer_Face_Dist ()
{
  return this->Pivot_Transducer_Face_Dist_.get ();
}

void ActiveProbe1::
Pivot_Transducer_Face_Dist (const Pivot_Transducer_Face_Dist_type& x)
{
  this->Pivot_Transducer_Face_Dist_.set (x);
}

void ActiveProbe1::
Pivot_Transducer_Face_Dist (::std::auto_ptr< Pivot_Transducer_Face_Dist_type > x)
{
  this->Pivot_Transducer_Face_Dist_.set (x);
}

const ActiveProbe1::Filter_Doppler_type& ActiveProbe1::
Filter_Doppler () const
{
  return this->Filter_Doppler_.get ();
}

ActiveProbe1::Filter_Doppler_type& ActiveProbe1::
Filter_Doppler ()
{
  return this->Filter_Doppler_.get ();
}

void ActiveProbe1::
Filter_Doppler (const Filter_Doppler_type& x)
{
  this->Filter_Doppler_.set (x);
}

void ActiveProbe1::
Filter_Doppler (::std::auto_ptr< Filter_Doppler_type > x)
{
  this->Filter_Doppler_.set (x);
}

const ActiveProbe1::Frequency_type& ActiveProbe1::
Frequency () const
{
  return this->Frequency_.get ();
}

ActiveProbe1::Frequency_type& ActiveProbe1::
Frequency ()
{
  return this->Frequency_.get ();
}

void ActiveProbe1::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void ActiveProbe1::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const ActiveProbe1::Integration_Limit_type& ActiveProbe1::
Integration_Limit () const
{
  return this->Integration_Limit_.get ();
}

ActiveProbe1::Integration_Limit_type& ActiveProbe1::
Integration_Limit ()
{
  return this->Integration_Limit_.get ();
}

void ActiveProbe1::
Integration_Limit (const Integration_Limit_type& x)
{
  this->Integration_Limit_.set (x);
}

void ActiveProbe1::
Integration_Limit (::std::auto_ptr< Integration_Limit_type > x)
{
  this->Integration_Limit_.set (x);
}

const ActiveProbe1::Encoder_Separation_type& ActiveProbe1::
Encoder_Separation () const
{
  return this->Encoder_Separation_.get ();
}

ActiveProbe1::Encoder_Separation_type& ActiveProbe1::
Encoder_Separation ()
{
  return this->Encoder_Separation_.get ();
}

void ActiveProbe1::
Encoder_Separation (const Encoder_Separation_type& x)
{
  this->Encoder_Separation_.set (x);
}

void ActiveProbe1::
Encoder_Separation (::std::auto_ptr< Encoder_Separation_type > x)
{
  this->Encoder_Separation_.set (x);
}

const ActiveProbe1::Overshoot_type& ActiveProbe1::
Overshoot () const
{
  return this->Overshoot_.get ();
}

ActiveProbe1::Overshoot_type& ActiveProbe1::
Overshoot ()
{
  return this->Overshoot_.get ();
}

void ActiveProbe1::
Overshoot (const Overshoot_type& x)
{
  this->Overshoot_.set (x);
}

void ActiveProbe1::
Overshoot (::std::auto_ptr< Overshoot_type > x)
{
  this->Overshoot_.set (x);
}

const ActiveProbe1::Attenuation_Shift_type& ActiveProbe1::
Attenuation_Shift () const
{
  return this->Attenuation_Shift_.get ();
}

ActiveProbe1::Attenuation_Shift_type& ActiveProbe1::
Attenuation_Shift ()
{
  return this->Attenuation_Shift_.get ();
}

void ActiveProbe1::
Attenuation_Shift (const Attenuation_Shift_type& x)
{
  this->Attenuation_Shift_.set (x);
}

void ActiveProbe1::
Attenuation_Shift (::std::auto_ptr< Attenuation_Shift_type > x)
{
  this->Attenuation_Shift_.set (x);
}

const ActiveProbe1::Filter_type& ActiveProbe1::
Filter () const
{
  return this->Filter_.get ();
}

ActiveProbe1::Filter_type& ActiveProbe1::
Filter ()
{
  return this->Filter_.get ();
}

void ActiveProbe1::
Filter (const Filter_type& x)
{
  this->Filter_.set (x);
}

void ActiveProbe1::
Filter (::std::auto_ptr< Filter_type > x)
{
  this->Filter_.set (x);
}

const ActiveProbe1::Default_Rx_Gain_Doppler_type& ActiveProbe1::
Default_Rx_Gain_Doppler () const
{
  return this->Default_Rx_Gain_Doppler_.get ();
}

ActiveProbe1::Default_Rx_Gain_Doppler_type& ActiveProbe1::
Default_Rx_Gain_Doppler ()
{
  return this->Default_Rx_Gain_Doppler_.get ();
}

void ActiveProbe1::
Default_Rx_Gain_Doppler (const Default_Rx_Gain_Doppler_type& x)
{
  this->Default_Rx_Gain_Doppler_.set (x);
}

void ActiveProbe1::
Default_Rx_Gain_Doppler (::std::auto_ptr< Default_Rx_Gain_Doppler_type > x)
{
  this->Default_Rx_Gain_Doppler_.set (x);
}

const ActiveProbe1::Peak_Vel_Correction_type& ActiveProbe1::
Peak_Vel_Correction () const
{
  return this->Peak_Vel_Correction_.get ();
}

ActiveProbe1::Peak_Vel_Correction_type& ActiveProbe1::
Peak_Vel_Correction ()
{
  return this->Peak_Vel_Correction_.get ();
}

void ActiveProbe1::
Peak_Vel_Correction (const Peak_Vel_Correction_type& x)
{
  this->Peak_Vel_Correction_.set (x);
}

void ActiveProbe1::
Peak_Vel_Correction (::std::auto_ptr< Peak_Vel_Correction_type > x)
{
  this->Peak_Vel_Correction_.set (x);
}

const ActiveProbe1::Detect_Ratio_Max_type& ActiveProbe1::
Detect_Ratio_Max () const
{
  return this->Detect_Ratio_Max_.get ();
}

ActiveProbe1::Detect_Ratio_Max_type& ActiveProbe1::
Detect_Ratio_Max ()
{
  return this->Detect_Ratio_Max_.get ();
}

void ActiveProbe1::
Detect_Ratio_Max (const Detect_Ratio_Max_type& x)
{
  this->Detect_Ratio_Max_.set (x);
}

void ActiveProbe1::
Detect_Ratio_Max (::std::auto_ptr< Detect_Ratio_Max_type > x)
{
  this->Detect_Ratio_Max_.set (x);
}

const ActiveProbe1::Acceleration_Limit_Constant_type& ActiveProbe1::
Acceleration_Limit_Constant () const
{
  return this->Acceleration_Limit_Constant_.get ();
}

ActiveProbe1::Acceleration_Limit_Constant_type& ActiveProbe1::
Acceleration_Limit_Constant ()
{
  return this->Acceleration_Limit_Constant_.get ();
}

void ActiveProbe1::
Acceleration_Limit_Constant (const Acceleration_Limit_Constant_type& x)
{
  this->Acceleration_Limit_Constant_.set (x);
}

void ActiveProbe1::
Acceleration_Limit_Constant (::std::auto_ptr< Acceleration_Limit_Constant_type > x)
{
  this->Acceleration_Limit_Constant_.set (x);
}

const ActiveProbe1::Filter_Doppler_Low_type& ActiveProbe1::
Filter_Doppler_Low () const
{
  return this->Filter_Doppler_Low_.get ();
}

ActiveProbe1::Filter_Doppler_Low_type& ActiveProbe1::
Filter_Doppler_Low ()
{
  return this->Filter_Doppler_Low_.get ();
}

void ActiveProbe1::
Filter_Doppler_Low (const Filter_Doppler_Low_type& x)
{
  this->Filter_Doppler_Low_.set (x);
}

void ActiveProbe1::
Filter_Doppler_Low (::std::auto_ptr< Filter_Doppler_Low_type > x)
{
  this->Filter_Doppler_Low_.set (x);
}

const ActiveProbe1::Frequency_Doppler_type& ActiveProbe1::
Frequency_Doppler () const
{
  return this->Frequency_Doppler_.get ();
}

ActiveProbe1::Frequency_Doppler_type& ActiveProbe1::
Frequency_Doppler ()
{
  return this->Frequency_Doppler_.get ();
}

void ActiveProbe1::
Frequency_Doppler (const Frequency_Doppler_type& x)
{
  this->Frequency_Doppler_.set (x);
}

void ActiveProbe1::
Frequency_Doppler (::std::auto_ptr< Frequency_Doppler_type > x)
{
  this->Frequency_Doppler_.set (x);
}

const ActiveProbe1::Detect_Ratio_Min_type& ActiveProbe1::
Detect_Ratio_Min () const
{
  return this->Detect_Ratio_Min_.get ();
}

ActiveProbe1::Detect_Ratio_Min_type& ActiveProbe1::
Detect_Ratio_Min ()
{
  return this->Detect_Ratio_Min_.get ();
}

void ActiveProbe1::
Detect_Ratio_Min (const Detect_Ratio_Min_type& x)
{
  this->Detect_Ratio_Min_.set (x);
}

void ActiveProbe1::
Detect_Ratio_Min (::std::auto_ptr< Detect_Ratio_Min_type > x)
{
  this->Detect_Ratio_Min_.set (x);
}

const ActiveProbe1::Derivative_Time_type& ActiveProbe1::
Derivative_Time () const
{
  return this->Derivative_Time_.get ();
}

ActiveProbe1::Derivative_Time_type& ActiveProbe1::
Derivative_Time ()
{
  return this->Derivative_Time_.get ();
}

void ActiveProbe1::
Derivative_Time (const Derivative_Time_type& x)
{
  this->Derivative_Time_.set (x);
}

void ActiveProbe1::
Derivative_Time (::std::auto_ptr< Derivative_Time_type > x)
{
  this->Derivative_Time_.set (x);
}

const ActiveProbe1::Filter_High_type& ActiveProbe1::
Filter_High () const
{
  return this->Filter_High_.get ();
}

ActiveProbe1::Filter_High_type& ActiveProbe1::
Filter_High ()
{
  return this->Filter_High_.get ();
}

void ActiveProbe1::
Filter_High (const Filter_High_type& x)
{
  this->Filter_High_.set (x);
}

void ActiveProbe1::
Filter_High (::std::auto_ptr< Filter_High_type > x)
{
  this->Filter_High_.set (x);
}

const ActiveProbe1::Motor_Overhead_type& ActiveProbe1::
Motor_Overhead () const
{
  return this->Motor_Overhead_.get ();
}

ActiveProbe1::Motor_Overhead_type& ActiveProbe1::
Motor_Overhead ()
{
  return this->Motor_Overhead_.get ();
}

void ActiveProbe1::
Motor_Overhead (const Motor_Overhead_type& x)
{
  this->Motor_Overhead_.set (x);
}

void ActiveProbe1::
Motor_Overhead (::std::auto_ptr< Motor_Overhead_type > x)
{
  this->Motor_Overhead_.set (x);
}

const ActiveProbe1::Version_type& ActiveProbe1::
Version () const
{
  return this->Version_.get ();
}

ActiveProbe1::Version_type& ActiveProbe1::
Version ()
{
  return this->Version_.get ();
}

void ActiveProbe1::
Version (const Version_type& x)
{
  this->Version_.set (x);
}

void ActiveProbe1::
Version (::std::auto_ptr< Version_type > x)
{
  this->Version_.set (x);
}

const ActiveProbe1::Filter_Low_type& ActiveProbe1::
Filter_Low () const
{
  return this->Filter_Low_.get ();
}

ActiveProbe1::Filter_Low_type& ActiveProbe1::
Filter_Low ()
{
  return this->Filter_Low_.get ();
}

void ActiveProbe1::
Filter_Low (const Filter_Low_type& x)
{
  this->Filter_Low_.set (x);
}

void ActiveProbe1::
Filter_Low (::std::auto_ptr< Filter_Low_type > x)
{
  this->Filter_Low_.set (x);
}


// BModeSoft1
// 

const BModeSoft1::Anti_Aliasing_type& BModeSoft1::
Anti_Aliasing () const
{
  return this->Anti_Aliasing_.get ();
}

BModeSoft1::Anti_Aliasing_type& BModeSoft1::
Anti_Aliasing ()
{
  return this->Anti_Aliasing_.get ();
}

void BModeSoft1::
Anti_Aliasing (const Anti_Aliasing_type& x)
{
  this->Anti_Aliasing_.set (x);
}

void BModeSoft1::
Anti_Aliasing (::std::auto_ptr< Anti_Aliasing_type > x)
{
  this->Anti_Aliasing_.set (x);
}

const BModeSoft1::V_Relative_Frame_Rate_type& BModeSoft1::
V_Relative_Frame_Rate () const
{
  return this->V_Relative_Frame_Rate_.get ();
}

BModeSoft1::V_Relative_Frame_Rate_type& BModeSoft1::
V_Relative_Frame_Rate ()
{
  return this->V_Relative_Frame_Rate_.get ();
}

void BModeSoft1::
V_Relative_Frame_Rate (const V_Relative_Frame_Rate_type& x)
{
  this->V_Relative_Frame_Rate_.set (x);
}

void BModeSoft1::
V_Relative_Frame_Rate (::std::auto_ptr< V_Relative_Frame_Rate_type > x)
{
  this->V_Relative_Frame_Rate_.set (x);
}

const BModeSoft1::Max_Power_Size_Default_type& BModeSoft1::
Max_Power_Size_Default () const
{
  return this->Max_Power_Size_Default_.get ();
}

BModeSoft1::Max_Power_Size_Default_type& BModeSoft1::
Max_Power_Size_Default ()
{
  return this->Max_Power_Size_Default_.get ();
}

void BModeSoft1::
Max_Power_Size_Default (const Max_Power_Size_Default_type& x)
{
  this->Max_Power_Size_Default_.set (x);
}

void BModeSoft1::
Max_Power_Size_Default (::std::auto_ptr< Max_Power_Size_Default_type > x)
{
  this->Max_Power_Size_Default_.set (x);
}

const BModeSoft1::Buffer_Size_type& BModeSoft1::
Buffer_Size () const
{
  return this->Buffer_Size_.get ();
}

BModeSoft1::Buffer_Size_type& BModeSoft1::
Buffer_Size ()
{
  return this->Buffer_Size_.get ();
}

void BModeSoft1::
Buffer_Size (const Buffer_Size_type& x)
{
  this->Buffer_Size_.set (x);
}

void BModeSoft1::
Buffer_Size (::std::auto_ptr< Buffer_Size_type > x)
{
  this->Buffer_Size_.set (x);
}

const BModeSoft1::Sector_Convert_type& BModeSoft1::
Sector_Convert () const
{
  return this->Sector_Convert_.get ();
}

BModeSoft1::Sector_Convert_type& BModeSoft1::
Sector_Convert ()
{
  return this->Sector_Convert_.get ();
}

void BModeSoft1::
Sector_Convert (const Sector_Convert_type& x)
{
  this->Sector_Convert_.set (x);
}

void BModeSoft1::
Sector_Convert (::std::auto_ptr< Sector_Convert_type > x)
{
  this->Sector_Convert_.set (x);
}

const BModeSoft1::AVR_Factor_type& BModeSoft1::
AVR_Factor () const
{
  return this->AVR_Factor_.get ();
}

BModeSoft1::AVR_Factor_type& BModeSoft1::
AVR_Factor ()
{
  return this->AVR_Factor_.get ();
}

void BModeSoft1::
AVR_Factor (const AVR_Factor_type& x)
{
  this->AVR_Factor_.set (x);
}

void BModeSoft1::
AVR_Factor (::std::auto_ptr< AVR_Factor_type > x)
{
  this->AVR_Factor_.set (x);
}

const BModeSoft1::Flip_Image_type& BModeSoft1::
Flip_Image () const
{
  return this->Flip_Image_.get ();
}

BModeSoft1::Flip_Image_type& BModeSoft1::
Flip_Image ()
{
  return this->Flip_Image_.get ();
}

void BModeSoft1::
Flip_Image (const Flip_Image_type& x)
{
  this->Flip_Image_.set (x);
}

void BModeSoft1::
Flip_Image (::std::auto_ptr< Flip_Image_type > x)
{
  this->Flip_Image_.set (x);
}

const BModeSoft1::AVR_Startup_Frames_type& BModeSoft1::
AVR_Startup_Frames () const
{
  return this->AVR_Startup_Frames_.get ();
}

BModeSoft1::AVR_Startup_Frames_type& BModeSoft1::
AVR_Startup_Frames ()
{
  return this->AVR_Startup_Frames_.get ();
}

void BModeSoft1::
AVR_Startup_Frames (const AVR_Startup_Frames_type& x)
{
  this->AVR_Startup_Frames_.set (x);
}

void BModeSoft1::
AVR_Startup_Frames (::std::auto_ptr< AVR_Startup_Frames_type > x)
{
  this->AVR_Startup_Frames_.set (x);
}

const BModeSoft1::BMode_Size_Default_type& BModeSoft1::
BMode_Size_Default () const
{
  return this->BMode_Size_Default_.get ();
}

BModeSoft1::BMode_Size_Default_type& BModeSoft1::
BMode_Size_Default ()
{
  return this->BMode_Size_Default_.get ();
}

void BModeSoft1::
BMode_Size_Default (const BMode_Size_Default_type& x)
{
  this->BMode_Size_Default_.set (x);
}

void BModeSoft1::
BMode_Size_Default (::std::auto_ptr< BMode_Size_Default_type > x)
{
  this->BMode_Size_Default_.set (x);
}

const BModeSoft1::Relative_Frame_Rate_type& BModeSoft1::
Relative_Frame_Rate () const
{
  return this->Relative_Frame_Rate_.get ();
}

BModeSoft1::Relative_Frame_Rate_type& BModeSoft1::
Relative_Frame_Rate ()
{
  return this->Relative_Frame_Rate_.get ();
}

void BModeSoft1::
Relative_Frame_Rate (const Relative_Frame_Rate_type& x)
{
  this->Relative_Frame_Rate_.set (x);
}

void BModeSoft1::
Relative_Frame_Rate (::std::auto_ptr< Relative_Frame_Rate_type > x)
{
  this->Relative_Frame_Rate_.set (x);
}

const BModeSoft1::Overlay_Mode_type& BModeSoft1::
Overlay_Mode () const
{
  return this->Overlay_Mode_.get ();
}

BModeSoft1::Overlay_Mode_type& BModeSoft1::
Overlay_Mode ()
{
  return this->Overlay_Mode_.get ();
}

void BModeSoft1::
Overlay_Mode (const Overlay_Mode_type& x)
{
  this->Overlay_Mode_.set (x);
}

void BModeSoft1::
Overlay_Mode (::std::auto_ptr< Overlay_Mode_type > x)
{
  this->Overlay_Mode_.set (x);
}

const BModeSoft1::Refresh_Rate_type& BModeSoft1::
Refresh_Rate () const
{
  return this->Refresh_Rate_.get ();
}

BModeSoft1::Refresh_Rate_type& BModeSoft1::
Refresh_Rate ()
{
  return this->Refresh_Rate_.get ();
}

void BModeSoft1::
Refresh_Rate (const Refresh_Rate_type& x)
{
  this->Refresh_Rate_.set (x);
}

void BModeSoft1::
Refresh_Rate (::std::auto_ptr< Refresh_Rate_type > x)
{
  this->Refresh_Rate_.set (x);
}

const BModeSoft1::Acquisition_Mode_type& BModeSoft1::
Acquisition_Mode () const
{
  return this->Acquisition_Mode_.get ();
}

BModeSoft1::Acquisition_Mode_type& BModeSoft1::
Acquisition_Mode ()
{
  return this->Acquisition_Mode_.get ();
}

void BModeSoft1::
Acquisition_Mode (const Acquisition_Mode_type& x)
{
  this->Acquisition_Mode_.set (x);
}

void BModeSoft1::
Acquisition_Mode (::std::auto_ptr< Acquisition_Mode_type > x)
{
  this->Acquisition_Mode_.set (x);
}

const BModeSoft1::Acquire_Both_Directions_type& BModeSoft1::
Acquire_Both_Directions () const
{
  return this->Acquire_Both_Directions_.get ();
}

BModeSoft1::Acquire_Both_Directions_type& BModeSoft1::
Acquire_Both_Directions ()
{
  return this->Acquire_Both_Directions_.get ();
}

void BModeSoft1::
Acquire_Both_Directions (const Acquire_Both_Directions_type& x)
{
  this->Acquire_Both_Directions_.set (x);
}

void BModeSoft1::
Acquire_Both_Directions (::std::auto_ptr< Acquire_Both_Directions_type > x)
{
  this->Acquire_Both_Directions_.set (x);
}

const BModeSoft1::Actual_Scan_Rate_type& BModeSoft1::
Actual_Scan_Rate () const
{
  return this->Actual_Scan_Rate_.get ();
}

BModeSoft1::Actual_Scan_Rate_type& BModeSoft1::
Actual_Scan_Rate ()
{
  return this->Actual_Scan_Rate_.get ();
}

void BModeSoft1::
Actual_Scan_Rate (const Actual_Scan_Rate_type& x)
{
  this->Actual_Scan_Rate_.set (x);
}

void BModeSoft1::
Actual_Scan_Rate (::std::auto_ptr< Actual_Scan_Rate_type > x)
{
  this->Actual_Scan_Rate_.set (x);
}

const BModeSoft1::Acquire_Persist_AVR_type& BModeSoft1::
Acquire_Persist_AVR () const
{
  return this->Acquire_Persist_AVR_.get ();
}

BModeSoft1::Acquire_Persist_AVR_type& BModeSoft1::
Acquire_Persist_AVR ()
{
  return this->Acquire_Persist_AVR_.get ();
}

void BModeSoft1::
Acquire_Persist_AVR (const Acquire_Persist_AVR_type& x)
{
  this->Acquire_Persist_AVR_.set (x);
}

void BModeSoft1::
Acquire_Persist_AVR (::std::auto_ptr< Acquire_Persist_AVR_type > x)
{
  this->Acquire_Persist_AVR_.set (x);
}

const BModeSoft1::Sector_X_Res_type& BModeSoft1::
Sector_X_Res () const
{
  return this->Sector_X_Res_.get ();
}

BModeSoft1::Sector_X_Res_type& BModeSoft1::
Sector_X_Res ()
{
  return this->Sector_X_Res_.get ();
}

void BModeSoft1::
Sector_X_Res (const Sector_X_Res_type& x)
{
  this->Sector_X_Res_.set (x);
}

void BModeSoft1::
Sector_X_Res (::std::auto_ptr< Sector_X_Res_type > x)
{
  this->Sector_X_Res_.set (x);
}

const BModeSoft1::Sector_Y_Res_type& BModeSoft1::
Sector_Y_Res () const
{
  return this->Sector_Y_Res_.get ();
}

BModeSoft1::Sector_Y_Res_type& BModeSoft1::
Sector_Y_Res ()
{
  return this->Sector_Y_Res_.get ();
}

void BModeSoft1::
Sector_Y_Res (const Sector_Y_Res_type& x)
{
  this->Sector_Y_Res_.set (x);
}

void BModeSoft1::
Sector_Y_Res (::std::auto_ptr< Sector_Y_Res_type > x)
{
  this->Sector_Y_Res_.set (x);
}

const BModeSoft1::Power_Size_Default_type& BModeSoft1::
Power_Size_Default () const
{
  return this->Power_Size_Default_.get ();
}

BModeSoft1::Power_Size_Default_type& BModeSoft1::
Power_Size_Default ()
{
  return this->Power_Size_Default_.get ();
}

void BModeSoft1::
Power_Size_Default (const Power_Size_Default_type& x)
{
  this->Power_Size_Default_.set (x);
}

void BModeSoft1::
Power_Size_Default (::std::auto_ptr< Power_Size_Default_type > x)
{
  this->Power_Size_Default_.set (x);
}

const BModeSoft1::Sector_X_Start_type& BModeSoft1::
Sector_X_Start () const
{
  return this->Sector_X_Start_.get ();
}

BModeSoft1::Sector_X_Start_type& BModeSoft1::
Sector_X_Start ()
{
  return this->Sector_X_Start_.get ();
}

void BModeSoft1::
Sector_X_Start (const Sector_X_Start_type& x)
{
  this->Sector_X_Start_.set (x);
}

void BModeSoft1::
Sector_X_Start (::std::auto_ptr< Sector_X_Start_type > x)
{
  this->Sector_X_Start_.set (x);
}

const BModeSoft1::Sector_Y_Start_type& BModeSoft1::
Sector_Y_Start () const
{
  return this->Sector_Y_Start_.get ();
}

BModeSoft1::Sector_Y_Start_type& BModeSoft1::
Sector_Y_Start ()
{
  return this->Sector_Y_Start_.get ();
}

void BModeSoft1::
Sector_Y_Start (const Sector_Y_Start_type& x)
{
  this->Sector_Y_Start_.set (x);
}

void BModeSoft1::
Sector_Y_Start (::std::auto_ptr< Sector_Y_Start_type > x)
{
  this->Sector_Y_Start_.set (x);
}

const BModeSoft1::Max_BMode_Size_Default_type& BModeSoft1::
Max_BMode_Size_Default () const
{
  return this->Max_BMode_Size_Default_.get ();
}

BModeSoft1::Max_BMode_Size_Default_type& BModeSoft1::
Max_BMode_Size_Default ()
{
  return this->Max_BMode_Size_Default_.get ();
}

void BModeSoft1::
Max_BMode_Size_Default (const Max_BMode_Size_Default_type& x)
{
  this->Max_BMode_Size_Default_.set (x);
}

void BModeSoft1::
Max_BMode_Size_Default (::std::auto_ptr< Max_BMode_Size_Default_type > x)
{
  this->Max_BMode_Size_Default_.set (x);
}

const BModeSoft1::Target_Field_Of_View_type& BModeSoft1::
Target_Field_Of_View () const
{
  return this->Target_Field_Of_View_.get ();
}

BModeSoft1::Target_Field_Of_View_type& BModeSoft1::
Target_Field_Of_View ()
{
  return this->Target_Field_Of_View_.get ();
}

void BModeSoft1::
Target_Field_Of_View (const Target_Field_Of_View_type& x)
{
  this->Target_Field_Of_View_.set (x);
}

void BModeSoft1::
Target_Field_Of_View (::std::auto_ptr< Target_Field_Of_View_type > x)
{
  this->Target_Field_Of_View_.set (x);
}

const BModeSoft1::Processing_Command_type& BModeSoft1::
Processing_Command () const
{
  return this->Processing_Command_.get ();
}

BModeSoft1::Processing_Command_type& BModeSoft1::
Processing_Command ()
{
  return this->Processing_Command_.get ();
}

void BModeSoft1::
Processing_Command (const Processing_Command_type& x)
{
  this->Processing_Command_.set (x);
}

void BModeSoft1::
Processing_Command (::std::auto_ptr< Processing_Command_type > x)
{
  this->Processing_Command_.set (x);
}


// Sys1
// 

const Sys1::Query_Discard_Loop_On_Save_Frame_type& Sys1::
Query_Discard_Loop_On_Save_Frame () const
{
  return this->Query_Discard_Loop_On_Save_Frame_.get ();
}

Sys1::Query_Discard_Loop_On_Save_Frame_type& Sys1::
Query_Discard_Loop_On_Save_Frame ()
{
  return this->Query_Discard_Loop_On_Save_Frame_.get ();
}

void Sys1::
Query_Discard_Loop_On_Save_Frame (const Query_Discard_Loop_On_Save_Frame_type& x)
{
  this->Query_Discard_Loop_On_Save_Frame_.set (x);
}

void Sys1::
Query_Discard_Loop_On_Save_Frame (::std::auto_ptr< Query_Discard_Loop_On_Save_Frame_type > x)
{
  this->Query_Discard_Loop_On_Save_Frame_.set (x);
}

const Sys1::Sound_Speed_type& Sys1::
Sound_Speed () const
{
  return this->Sound_Speed_.get ();
}

Sys1::Sound_Speed_type& Sys1::
Sound_Speed ()
{
  return this->Sound_Speed_.get ();
}

void Sys1::
Sound_Speed (const Sound_Speed_type& x)
{
  this->Sound_Speed_.set (x);
}

void Sys1::
Sound_Speed (::std::auto_ptr< Sound_Speed_type > x)
{
  this->Sound_Speed_.set (x);
}

const Sys1::SubMode_type& Sys1::
SubMode () const
{
  return this->SubMode_.get ();
}

Sys1::SubMode_type& Sys1::
SubMode ()
{
  return this->SubMode_.get ();
}

void Sys1::
SubMode (const SubMode_type& x)
{
  this->SubMode_.set (x);
}

void Sys1::
SubMode (::std::auto_ptr< SubMode_type > x)
{
  this->SubMode_.set (x);
}

const Sys1::Interrupt_Mask_type& Sys1::
Interrupt_Mask () const
{
  return this->Interrupt_Mask_.get ();
}

Sys1::Interrupt_Mask_type& Sys1::
Interrupt_Mask ()
{
  return this->Interrupt_Mask_.get ();
}

void Sys1::
Interrupt_Mask (const Interrupt_Mask_type& x)
{
  this->Interrupt_Mask_.set (x);
}

void Sys1::
Interrupt_Mask (::std::auto_ptr< Interrupt_Mask_type > x)
{
  this->Interrupt_Mask_.set (x);
}

const Sys1::Calculation_Instances_type& Sys1::
Calculation_Instances () const
{
  return this->Calculation_Instances_.get ();
}

Sys1::Calculation_Instances_type& Sys1::
Calculation_Instances ()
{
  return this->Calculation_Instances_.get ();
}

void Sys1::
Calculation_Instances (const Calculation_Instances_type& x)
{
  this->Calculation_Instances_.set (x);
}

void Sys1::
Calculation_Instances (::std::auto_ptr< Calculation_Instances_type > x)
{
  this->Calculation_Instances_.set (x);
}

const Sys1::Start_Licence_Date_type& Sys1::
Start_Licence_Date () const
{
  return this->Start_Licence_Date_.get ();
}

Sys1::Start_Licence_Date_type& Sys1::
Start_Licence_Date ()
{
  return this->Start_Licence_Date_.get ();
}

void Sys1::
Start_Licence_Date (const Start_Licence_Date_type& x)
{
  this->Start_Licence_Date_.set (x);
}

void Sys1::
Start_Licence_Date (::std::auto_ptr< Start_Licence_Date_type > x)
{
  this->Start_Licence_Date_.set (x);
}

const Sys1::End_Licence_Date_type& Sys1::
End_Licence_Date () const
{
  return this->End_Licence_Date_.get ();
}

Sys1::End_Licence_Date_type& Sys1::
End_Licence_Date ()
{
  return this->End_Licence_Date_.get ();
}

void Sys1::
End_Licence_Date (const End_Licence_Date_type& x)
{
  this->End_Licence_Date_.set (x);
}

void Sys1::
End_Licence_Date (::std::auto_ptr< End_Licence_Date_type > x)
{
  this->End_Licence_Date_.set (x);
}

const Sys1::Auto_Save_PreTrig_Loop_type& Sys1::
Auto_Save_PreTrig_Loop () const
{
  return this->Auto_Save_PreTrig_Loop_.get ();
}

Sys1::Auto_Save_PreTrig_Loop_type& Sys1::
Auto_Save_PreTrig_Loop ()
{
  return this->Auto_Save_PreTrig_Loop_.get ();
}

void Sys1::
Auto_Save_PreTrig_Loop (const Auto_Save_PreTrig_Loop_type& x)
{
  this->Auto_Save_PreTrig_Loop_.set (x);
}

void Sys1::
Auto_Save_PreTrig_Loop (::std::auto_ptr< Auto_Save_PreTrig_Loop_type > x)
{
  this->Auto_Save_PreTrig_Loop_.set (x);
}

const Sys1::Feature_type& Sys1::
Feature () const
{
  return this->Feature_.get ();
}

Sys1::Feature_type& Sys1::
Feature ()
{
  return this->Feature_.get ();
}

void Sys1::
Feature (const Feature_type& x)
{
  this->Feature_.set (x);
}

void Sys1::
Feature (::std::auto_ptr< Feature_type > x)
{
  this->Feature_.set (x);
}

const Sys1::Acq_Setup_Dialog_type& Sys1::
Acq_Setup_Dialog () const
{
  return this->Acq_Setup_Dialog_.get ();
}

Sys1::Acq_Setup_Dialog_type& Sys1::
Acq_Setup_Dialog ()
{
  return this->Acq_Setup_Dialog_.get ();
}

void Sys1::
Acq_Setup_Dialog (const Acq_Setup_Dialog_type& x)
{
  this->Acq_Setup_Dialog_.set (x);
}

void Sys1::
Acq_Setup_Dialog (::std::auto_ptr< Acq_Setup_Dialog_type > x)
{
  this->Acq_Setup_Dialog_.set (x);
}

const Sys1::Interrupt_Clear_type& Sys1::
Interrupt_Clear () const
{
  return this->Interrupt_Clear_.get ();
}

Sys1::Interrupt_Clear_type& Sys1::
Interrupt_Clear ()
{
  return this->Interrupt_Clear_.get ();
}

void Sys1::
Interrupt_Clear (const Interrupt_Clear_type& x)
{
  this->Interrupt_Clear_.set (x);
}

void Sys1::
Interrupt_Clear (::std::auto_ptr< Interrupt_Clear_type > x)
{
  this->Interrupt_Clear_.set (x);
}

const Sys1::Interrupt_Status_type& Sys1::
Interrupt_Status () const
{
  return this->Interrupt_Status_.get ();
}

Sys1::Interrupt_Status_type& Sys1::
Interrupt_Status ()
{
  return this->Interrupt_Status_.get ();
}

void Sys1::
Interrupt_Status (const Interrupt_Status_type& x)
{
  this->Interrupt_Status_.set (x);
}

void Sys1::
Interrupt_Status (::std::auto_ptr< Interrupt_Status_type > x)
{
  this->Interrupt_Status_.set (x);
}

const Sys1::Auto_Save_Load_3D_type& Sys1::
Auto_Save_Load_3D () const
{
  return this->Auto_Save_Load_3D_.get ();
}

Sys1::Auto_Save_Load_3D_type& Sys1::
Auto_Save_Load_3D ()
{
  return this->Auto_Save_Load_3D_.get ();
}

void Sys1::
Auto_Save_Load_3D (const Auto_Save_Load_3D_type& x)
{
  this->Auto_Save_Load_3D_.set (x);
}

void Sys1::
Auto_Save_Load_3D (::std::auto_ptr< Auto_Save_Load_3D_type > x)
{
  this->Auto_Save_Load_3D_.set (x);
}

const Sys1::DICOM_Root_ID_type& Sys1::
DICOM_Root_ID () const
{
  return this->DICOM_Root_ID_.get ();
}

Sys1::DICOM_Root_ID_type& Sys1::
DICOM_Root_ID ()
{
  return this->DICOM_Root_ID_.get ();
}

void Sys1::
DICOM_Root_ID (const DICOM_Root_ID_type& x)
{
  this->DICOM_Root_ID_.set (x);
}

void Sys1::
DICOM_Root_ID (::std::auto_ptr< DICOM_Root_ID_type > x)
{
  this->DICOM_Root_ID_.set (x);
}

const Sys1::Company_Name_type& Sys1::
Company_Name () const
{
  return this->Company_Name_.get ();
}

Sys1::Company_Name_type& Sys1::
Company_Name ()
{
  return this->Company_Name_.get ();
}

void Sys1::
Company_Name (const Company_Name_type& x)
{
  this->Company_Name_.set (x);
}

void Sys1::
Company_Name (::std::auto_ptr< Company_Name_type > x)
{
  this->Company_Name_.set (x);
}

const Sys1::Image_To_Auto_Save_On_Label_type& Sys1::
Image_To_Auto_Save_On_Label () const
{
  return this->Image_To_Auto_Save_On_Label_.get ();
}

Sys1::Image_To_Auto_Save_On_Label_type& Sys1::
Image_To_Auto_Save_On_Label ()
{
  return this->Image_To_Auto_Save_On_Label_.get ();
}

void Sys1::
Image_To_Auto_Save_On_Label (const Image_To_Auto_Save_On_Label_type& x)
{
  this->Image_To_Auto_Save_On_Label_.set (x);
}

void Sys1::
Image_To_Auto_Save_On_Label (::std::auto_ptr< Image_To_Auto_Save_On_Label_type > x)
{
  this->Image_To_Auto_Save_On_Label_.set (x);
}

const Sys1::DICOM_Encode_Regions_type& Sys1::
DICOM_Encode_Regions () const
{
  return this->DICOM_Encode_Regions_.get ();
}

Sys1::DICOM_Encode_Regions_type& Sys1::
DICOM_Encode_Regions ()
{
  return this->DICOM_Encode_Regions_.get ();
}

void Sys1::
DICOM_Encode_Regions (const DICOM_Encode_Regions_type& x)
{
  this->DICOM_Encode_Regions_.set (x);
}

void Sys1::
DICOM_Encode_Regions (::std::auto_ptr< DICOM_Encode_Regions_type > x)
{
  this->DICOM_Encode_Regions_.set (x);
}

const Sys1::Pipeline_Delay_type& Sys1::
Pipeline_Delay () const
{
  return this->Pipeline_Delay_.get ();
}

Sys1::Pipeline_Delay_type& Sys1::
Pipeline_Delay ()
{
  return this->Pipeline_Delay_.get ();
}

void Sys1::
Pipeline_Delay (const Pipeline_Delay_type& x)
{
  this->Pipeline_Delay_.set (x);
}

void Sys1::
Pipeline_Delay (::std::auto_ptr< Pipeline_Delay_type > x)
{
  this->Pipeline_Delay_.set (x);
}

const Sys1::DDS_Control_type& Sys1::
DDS_Control () const
{
  return this->DDS_Control_.get ();
}

Sys1::DDS_Control_type& Sys1::
DDS_Control ()
{
  return this->DDS_Control_.get ();
}

void Sys1::
DDS_Control (const DDS_Control_type& x)
{
  this->DDS_Control_.set (x);
}

void Sys1::
DDS_Control (::std::auto_ptr< DDS_Control_type > x)
{
  this->DDS_Control_.set (x);
}

const Sys1::Mode_type& Sys1::
Mode () const
{
  return this->Mode_.get ();
}

Sys1::Mode_type& Sys1::
Mode ()
{
  return this->Mode_.get ();
}

void Sys1::
Mode (const Mode_type& x)
{
  this->Mode_.set (x);
}

void Sys1::
Mode (::std::auto_ptr< Mode_type > x)
{
  this->Mode_.set (x);
}

const Sys1::Review_Setup_Dialog_type& Sys1::
Review_Setup_Dialog () const
{
  return this->Review_Setup_Dialog_.get ();
}

Sys1::Review_Setup_Dialog_type& Sys1::
Review_Setup_Dialog ()
{
  return this->Review_Setup_Dialog_.get ();
}

void Sys1::
Review_Setup_Dialog (const Review_Setup_Dialog_type& x)
{
  this->Review_Setup_Dialog_.set (x);
}

void Sys1::
Review_Setup_Dialog (::std::auto_ptr< Review_Setup_Dialog_type > x)
{
  this->Review_Setup_Dialog_.set (x);
}


// Contrast
// 

const Contrast::Acquisition_3D_Volume_type& Contrast::
Acquisition_3D_Volume () const
{
  return this->Acquisition_3D_Volume_.get ();
}

Contrast::Acquisition_3D_Volume_type& Contrast::
Acquisition_3D_Volume ()
{
  return this->Acquisition_3D_Volume_.get ();
}

void Contrast::
Acquisition_3D_Volume (const Acquisition_3D_Volume_type& x)
{
  this->Acquisition_3D_Volume_.set (x);
}

void Contrast::
Acquisition_3D_Volume (::std::auto_ptr< Acquisition_3D_Volume_type > x)
{
  this->Acquisition_3D_Volume_.set (x);
}

const Contrast::Contrast_Linear_Scale_type& Contrast::
Contrast_Linear_Scale () const
{
  return this->Contrast_Linear_Scale_.get ();
}

Contrast::Contrast_Linear_Scale_type& Contrast::
Contrast_Linear_Scale ()
{
  return this->Contrast_Linear_Scale_.get ();
}

void Contrast::
Contrast_Linear_Scale (const Contrast_Linear_Scale_type& x)
{
  this->Contrast_Linear_Scale_.set (x);
}

void Contrast::
Contrast_Linear_Scale (::std::auto_ptr< Contrast_Linear_Scale_type > x)
{
  this->Contrast_Linear_Scale_.set (x);
}

const Contrast::Reference_3D_Step_Size_type& Contrast::
Reference_3D_Step_Size () const
{
  return this->Reference_3D_Step_Size_.get ();
}

Contrast::Reference_3D_Step_Size_type& Contrast::
Reference_3D_Step_Size ()
{
  return this->Reference_3D_Step_Size_.get ();
}

void Contrast::
Reference_3D_Step_Size (const Reference_3D_Step_Size_type& x)
{
  this->Reference_3D_Step_Size_.set (x);
}

void Contrast::
Reference_3D_Step_Size (::std::auto_ptr< Reference_3D_Step_Size_type > x)
{
  this->Reference_3D_Step_Size_.set (x);
}

const Contrast::Remap_Color_type& Contrast::
Remap_Color () const
{
  return this->Remap_Color_.get ();
}

Contrast::Remap_Color_type& Contrast::
Remap_Color ()
{
  return this->Remap_Color_.get ();
}

void Contrast::
Remap_Color (const Remap_Color_type& x)
{
  this->Remap_Color_.set (x);
}

void Contrast::
Remap_Color (::std::auto_ptr< Remap_Color_type > x)
{
  this->Remap_Color_.set (x);
}

const Contrast::Display_Mode_type& Contrast::
Display_Mode () const
{
  return this->Display_Mode_.get ();
}

Contrast::Display_Mode_type& Contrast::
Display_Mode ()
{
  return this->Display_Mode_.get ();
}

void Contrast::
Display_Mode (const Display_Mode_type& x)
{
  this->Display_Mode_.set (x);
}

void Contrast::
Display_Mode (::std::auto_ptr< Display_Mode_type > x)
{
  this->Display_Mode_.set (x);
}

const Contrast::Contrast_Linear_Offset_type& Contrast::
Contrast_Linear_Offset () const
{
  return this->Contrast_Linear_Offset_.get ();
}

Contrast::Contrast_Linear_Offset_type& Contrast::
Contrast_Linear_Offset ()
{
  return this->Contrast_Linear_Offset_.get ();
}

void Contrast::
Contrast_Linear_Offset (const Contrast_Linear_Offset_type& x)
{
  this->Contrast_Linear_Offset_.set (x);
}

void Contrast::
Contrast_Linear_Offset (::std::auto_ptr< Contrast_Linear_Offset_type > x)
{
  this->Contrast_Linear_Offset_.set (x);
}

const Contrast::Contrast_Linear_Slope_type& Contrast::
Contrast_Linear_Slope () const
{
  return this->Contrast_Linear_Slope_.get ();
}

Contrast::Contrast_Linear_Slope_type& Contrast::
Contrast_Linear_Slope ()
{
  return this->Contrast_Linear_Slope_.get ();
}

void Contrast::
Contrast_Linear_Slope (const Contrast_Linear_Slope_type& x)
{
  this->Contrast_Linear_Slope_.set (x);
}

void Contrast::
Contrast_Linear_Slope (::std::auto_ptr< Contrast_Linear_Slope_type > x)
{
  this->Contrast_Linear_Slope_.set (x);
}

const Contrast::Median_Size_Perfusion_type& Contrast::
Median_Size_Perfusion () const
{
  return this->Median_Size_Perfusion_.get ();
}

Contrast::Median_Size_Perfusion_type& Contrast::
Median_Size_Perfusion ()
{
  return this->Median_Size_Perfusion_.get ();
}

void Contrast::
Median_Size_Perfusion (const Median_Size_Perfusion_type& x)
{
  this->Median_Size_Perfusion_.set (x);
}

void Contrast::
Median_Size_Perfusion (::std::auto_ptr< Median_Size_Perfusion_type > x)
{
  this->Median_Size_Perfusion_.set (x);
}

const Contrast::Contrast_Size_Default_type& Contrast::
Contrast_Size_Default () const
{
  return this->Contrast_Size_Default_.get ();
}

Contrast::Contrast_Size_Default_type& Contrast::
Contrast_Size_Default ()
{
  return this->Contrast_Size_Default_.get ();
}

void Contrast::
Contrast_Size_Default (const Contrast_Size_Default_type& x)
{
  this->Contrast_Size_Default_.set (x);
}

void Contrast::
Contrast_Size_Default (::std::auto_ptr< Contrast_Size_Default_type > x)
{
  this->Contrast_Size_Default_.set (x);
}

const Contrast::Median_Size_Default_type& Contrast::
Median_Size_Default () const
{
  return this->Median_Size_Default_.get ();
}

Contrast::Median_Size_Default_type& Contrast::
Median_Size_Default ()
{
  return this->Median_Size_Default_.get ();
}

void Contrast::
Median_Size_Default (const Median_Size_Default_type& x)
{
  this->Median_Size_Default_.set (x);
}

void Contrast::
Median_Size_Default (::std::auto_ptr< Median_Size_Default_type > x)
{
  this->Median_Size_Default_.set (x);
}

const Contrast::Use_ECG_Gate_type& Contrast::
Use_ECG_Gate () const
{
  return this->Use_ECG_Gate_.get ();
}

Contrast::Use_ECG_Gate_type& Contrast::
Use_ECG_Gate ()
{
  return this->Use_ECG_Gate_.get ();
}

void Contrast::
Use_ECG_Gate (const Use_ECG_Gate_type& x)
{
  this->Use_ECG_Gate_.set (x);
}

void Contrast::
Use_ECG_Gate (::std::auto_ptr< Use_ECG_Gate_type > x)
{
  this->Use_ECG_Gate_.set (x);
}

const Contrast::ECG_Gate_Range_type& Contrast::
ECG_Gate_Range () const
{
  return this->ECG_Gate_Range_.get ();
}

Contrast::ECG_Gate_Range_type& Contrast::
ECG_Gate_Range ()
{
  return this->ECG_Gate_Range_.get ();
}

void Contrast::
ECG_Gate_Range (const ECG_Gate_Range_type& x)
{
  this->ECG_Gate_Range_.set (x);
}

void Contrast::
ECG_Gate_Range (::std::auto_ptr< ECG_Gate_Range_type > x)
{
  this->ECG_Gate_Range_.set (x);
}

const Contrast::Filter_Size_Perfusion_type& Contrast::
Filter_Size_Perfusion () const
{
  return this->Filter_Size_Perfusion_.get ();
}

Contrast::Filter_Size_Perfusion_type& Contrast::
Filter_Size_Perfusion ()
{
  return this->Filter_Size_Perfusion_.get ();
}

void Contrast::
Filter_Size_Perfusion (const Filter_Size_Perfusion_type& x)
{
  this->Filter_Size_Perfusion_.set (x);
}

void Contrast::
Filter_Size_Perfusion (::std::auto_ptr< Filter_Size_Perfusion_type > x)
{
  this->Filter_Size_Perfusion_.set (x);
}

const Contrast::Max_Contrast_Size_Default_type& Contrast::
Max_Contrast_Size_Default () const
{
  return this->Max_Contrast_Size_Default_.get ();
}

Contrast::Max_Contrast_Size_Default_type& Contrast::
Max_Contrast_Size_Default ()
{
  return this->Max_Contrast_Size_Default_.get ();
}

void Contrast::
Max_Contrast_Size_Default (const Max_Contrast_Size_Default_type& x)
{
  this->Max_Contrast_Size_Default_.set (x);
}

void Contrast::
Max_Contrast_Size_Default (::std::auto_ptr< Max_Contrast_Size_Default_type > x)
{
  this->Max_Contrast_Size_Default_.set (x);
}

const Contrast::Filter_Size_Default_type& Contrast::
Filter_Size_Default () const
{
  return this->Filter_Size_Default_.get ();
}

Contrast::Filter_Size_Default_type& Contrast::
Filter_Size_Default ()
{
  return this->Filter_Size_Default_.get ();
}

void Contrast::
Filter_Size_Default (const Filter_Size_Default_type& x)
{
  this->Filter_Size_Default_.set (x);
}

void Contrast::
Filter_Size_Default (::std::auto_ptr< Filter_Size_Default_type > x)
{
  this->Filter_Size_Default_.set (x);
}

const Contrast::Cardiac_Divisions_type& Contrast::
Cardiac_Divisions () const
{
  return this->Cardiac_Divisions_.get ();
}

Contrast::Cardiac_Divisions_type& Contrast::
Cardiac_Divisions ()
{
  return this->Cardiac_Divisions_.get ();
}

void Contrast::
Cardiac_Divisions (const Cardiac_Divisions_type& x)
{
  this->Cardiac_Divisions_.set (x);
}

void Contrast::
Cardiac_Divisions (::std::auto_ptr< Cardiac_Divisions_type > x)
{
  this->Cardiac_Divisions_.set (x);
}

const Contrast::Reference_3D_Scan_Distance_type& Contrast::
Reference_3D_Scan_Distance () const
{
  return this->Reference_3D_Scan_Distance_.get ();
}

Contrast::Reference_3D_Scan_Distance_type& Contrast::
Reference_3D_Scan_Distance ()
{
  return this->Reference_3D_Scan_Distance_.get ();
}

void Contrast::
Reference_3D_Scan_Distance (const Reference_3D_Scan_Distance_type& x)
{
  this->Reference_3D_Scan_Distance_.set (x);
}

void Contrast::
Reference_3D_Scan_Distance (::std::auto_ptr< Reference_3D_Scan_Distance_type > x)
{
  this->Reference_3D_Scan_Distance_.set (x);
}

const Contrast::Median_Size_MIP_type& Contrast::
Median_Size_MIP () const
{
  return this->Median_Size_MIP_.get ();
}

Contrast::Median_Size_MIP_type& Contrast::
Median_Size_MIP ()
{
  return this->Median_Size_MIP_.get ();
}

void Contrast::
Median_Size_MIP (const Median_Size_MIP_type& x)
{
  this->Median_Size_MIP_.set (x);
}

void Contrast::
Median_Size_MIP (::std::auto_ptr< Median_Size_MIP_type > x)
{
  this->Median_Size_MIP_.set (x);
}

const Contrast::Acquire_Both_Directions_type& Contrast::
Acquire_Both_Directions () const
{
  return this->Acquire_Both_Directions_.get ();
}

Contrast::Acquire_Both_Directions_type& Contrast::
Acquire_Both_Directions ()
{
  return this->Acquire_Both_Directions_.get ();
}

void Contrast::
Acquire_Both_Directions (const Acquire_Both_Directions_type& x)
{
  this->Acquire_Both_Directions_.set (x);
}

void Contrast::
Acquire_Both_Directions (::std::auto_ptr< Acquire_Both_Directions_type > x)
{
  this->Acquire_Both_Directions_.set (x);
}

const Contrast::Data_Display_Scale_Shift_type& Contrast::
Data_Display_Scale_Shift () const
{
  return this->Data_Display_Scale_Shift_.get ();
}

Contrast::Data_Display_Scale_Shift_type& Contrast::
Data_Display_Scale_Shift ()
{
  return this->Data_Display_Scale_Shift_.get ();
}

void Contrast::
Data_Display_Scale_Shift (const Data_Display_Scale_Shift_type& x)
{
  this->Data_Display_Scale_Shift_.set (x);
}

void Contrast::
Data_Display_Scale_Shift (::std::auto_ptr< Data_Display_Scale_Shift_type > x)
{
  this->Data_Display_Scale_Shift_.set (x);
}

const Contrast::Reference_Label_type& Contrast::
Reference_Label () const
{
  return this->Reference_Label_.get ();
}

Contrast::Reference_Label_type& Contrast::
Reference_Label ()
{
  return this->Reference_Label_.get ();
}

void Contrast::
Reference_Label (const Reference_Label_type& x)
{
  this->Reference_Label_.set (x);
}

void Contrast::
Reference_Label (::std::auto_ptr< Reference_Label_type > x)
{
  this->Reference_Label_.set (x);
}

const Contrast::X_3D_Display_Mode_type& Contrast::
X_3D_Display_Mode () const
{
  return this->X_3D_Display_Mode_.get ();
}

Contrast::X_3D_Display_Mode_type& Contrast::
X_3D_Display_Mode ()
{
  return this->X_3D_Display_Mode_.get ();
}

void Contrast::
X_3D_Display_Mode (const X_3D_Display_Mode_type& x)
{
  this->X_3D_Display_Mode_.set (x);
}

void Contrast::
X_3D_Display_Mode (::std::auto_ptr< X_3D_Display_Mode_type > x)
{
  this->X_3D_Display_Mode_.set (x);
}

const Contrast::Filter_Size_MIP_type& Contrast::
Filter_Size_MIP () const
{
  return this->Filter_Size_MIP_.get ();
}

Contrast::Filter_Size_MIP_type& Contrast::
Filter_Size_MIP ()
{
  return this->Filter_Size_MIP_.get ();
}

void Contrast::
Filter_Size_MIP (const Filter_Size_MIP_type& x)
{
  this->Filter_Size_MIP_.set (x);
}

void Contrast::
Filter_Size_MIP (::std::auto_ptr< Filter_Size_MIP_type > x)
{
  this->Filter_Size_MIP_.set (x);
}

const Contrast::Contrast_Linear_Lock_Gain_type& Contrast::
Contrast_Linear_Lock_Gain () const
{
  return this->Contrast_Linear_Lock_Gain_.get ();
}

Contrast::Contrast_Linear_Lock_Gain_type& Contrast::
Contrast_Linear_Lock_Gain ()
{
  return this->Contrast_Linear_Lock_Gain_.get ();
}

void Contrast::
Contrast_Linear_Lock_Gain (const Contrast_Linear_Lock_Gain_type& x)
{
  this->Contrast_Linear_Lock_Gain_.set (x);
}

void Contrast::
Contrast_Linear_Lock_Gain (::std::auto_ptr< Contrast_Linear_Lock_Gain_type > x)
{
  this->Contrast_Linear_Lock_Gain_.set (x);
}

const Contrast::Persistence_Process_Frames_type& Contrast::
Persistence_Process_Frames () const
{
  return this->Persistence_Process_Frames_.get ();
}

Contrast::Persistence_Process_Frames_type& Contrast::
Persistence_Process_Frames ()
{
  return this->Persistence_Process_Frames_.get ();
}

void Contrast::
Persistence_Process_Frames (const Persistence_Process_Frames_type& x)
{
  this->Persistence_Process_Frames_.set (x);
}

void Contrast::
Persistence_Process_Frames (::std::auto_ptr< Persistence_Process_Frames_type > x)
{
  this->Persistence_Process_Frames_.set (x);
}

const Contrast::Reference_Range_Start_type& Contrast::
Reference_Range_Start () const
{
  return this->Reference_Range_Start_.get ();
}

Contrast::Reference_Range_Start_type& Contrast::
Reference_Range_Start ()
{
  return this->Reference_Range_Start_.get ();
}

void Contrast::
Reference_Range_Start (const Reference_Range_Start_type& x)
{
  this->Reference_Range_Start_.set (x);
}

void Contrast::
Reference_Range_Start (::std::auto_ptr< Reference_Range_Start_type > x)
{
  this->Reference_Range_Start_.set (x);
}

const Contrast::Blur_MIP_BoxSize_type& Contrast::
Blur_MIP_BoxSize () const
{
  return this->Blur_MIP_BoxSize_.get ();
}

Contrast::Blur_MIP_BoxSize_type& Contrast::
Blur_MIP_BoxSize ()
{
  return this->Blur_MIP_BoxSize_.get ();
}

void Contrast::
Blur_MIP_BoxSize (const Blur_MIP_BoxSize_type& x)
{
  this->Blur_MIP_BoxSize_.set (x);
}

void Contrast::
Blur_MIP_BoxSize (::std::auto_ptr< Blur_MIP_BoxSize_type > x)
{
  this->Blur_MIP_BoxSize_.set (x);
}

const Contrast::Threshold_type& Contrast::
Threshold () const
{
  return this->Threshold_.get ();
}

Contrast::Threshold_type& Contrast::
Threshold ()
{
  return this->Threshold_.get ();
}

void Contrast::
Threshold (const Threshold_type& x)
{
  this->Threshold_.set (x);
}

void Contrast::
Threshold (::std::auto_ptr< Threshold_type > x)
{
  this->Threshold_.set (x);
}

const Contrast::Process_Direction_type& Contrast::
Process_Direction () const
{
  return this->Process_Direction_.get ();
}

Contrast::Process_Direction_type& Contrast::
Process_Direction ()
{
  return this->Process_Direction_.get ();
}

void Contrast::
Process_Direction (const Process_Direction_type& x)
{
  this->Process_Direction_.set (x);
}

void Contrast::
Process_Direction (::std::auto_ptr< Process_Direction_type > x)
{
  this->Process_Direction_.set (x);
}

const Contrast::Reference_Range_Stop_type& Contrast::
Reference_Range_Stop () const
{
  return this->Reference_Range_Stop_.get ();
}

Contrast::Reference_Range_Stop_type& Contrast::
Reference_Range_Stop ()
{
  return this->Reference_Range_Stop_.get ();
}

void Contrast::
Reference_Range_Stop (const Reference_Range_Stop_type& x)
{
  this->Reference_Range_Stop_.set (x);
}

void Contrast::
Reference_Range_Stop (::std::auto_ptr< Reference_Range_Stop_type > x)
{
  this->Reference_Range_Stop_.set (x);
}

const Contrast::Blur_MIP_type& Contrast::
Blur_MIP () const
{
  return this->Blur_MIP_.get ();
}

Contrast::Blur_MIP_type& Contrast::
Blur_MIP ()
{
  return this->Blur_MIP_.get ();
}

void Contrast::
Blur_MIP (const Blur_MIP_type& x)
{
  this->Blur_MIP_.set (x);
}

void Contrast::
Blur_MIP (::std::auto_ptr< Blur_MIP_type > x)
{
  this->Blur_MIP_.set (x);
}

const Contrast::Persistence_Mode_type& Contrast::
Persistence_Mode () const
{
  return this->Persistence_Mode_.get ();
}

Contrast::Persistence_Mode_type& Contrast::
Persistence_Mode ()
{
  return this->Persistence_Mode_.get ();
}

void Contrast::
Persistence_Mode (const Persistence_Mode_type& x)
{
  this->Persistence_Mode_.set (x);
}

void Contrast::
Persistence_Mode (::std::auto_ptr< Persistence_Mode_type > x)
{
  this->Persistence_Mode_.set (x);
}

const Contrast::Reference_3D_Volume_type& Contrast::
Reference_3D_Volume () const
{
  return this->Reference_3D_Volume_.get ();
}

Contrast::Reference_3D_Volume_type& Contrast::
Reference_3D_Volume ()
{
  return this->Reference_3D_Volume_.get ();
}

void Contrast::
Reference_3D_Volume (const Reference_3D_Volume_type& x)
{
  this->Reference_3D_Volume_.set (x);
}

void Contrast::
Reference_3D_Volume (::std::auto_ptr< Reference_3D_Volume_type > x)
{
  this->Reference_3D_Volume_.set (x);
}

const Contrast::Gain_type& Contrast::
Gain () const
{
  return this->Gain_.get ();
}

Contrast::Gain_type& Contrast::
Gain ()
{
  return this->Gain_.get ();
}

void Contrast::
Gain (const Gain_type& x)
{
  this->Gain_.set (x);
}

void Contrast::
Gain (::std::auto_ptr< Gain_type > x)
{
  this->Gain_.set (x);
}

const Contrast::Acquire_Persist_MIP_type& Contrast::
Acquire_Persist_MIP () const
{
  return this->Acquire_Persist_MIP_.get ();
}

Contrast::Acquire_Persist_MIP_type& Contrast::
Acquire_Persist_MIP ()
{
  return this->Acquire_Persist_MIP_.get ();
}

void Contrast::
Acquire_Persist_MIP (const Acquire_Persist_MIP_type& x)
{
  this->Acquire_Persist_MIP_.set (x);
}

void Contrast::
Acquire_Persist_MIP (::std::auto_ptr< Acquire_Persist_MIP_type > x)
{
  this->Acquire_Persist_MIP_.set (x);
}

const Contrast::Dynamic_Range2_type& Contrast::
Dynamic_Range2 () const
{
  return this->Dynamic_Range2_.get ();
}

Contrast::Dynamic_Range2_type& Contrast::
Dynamic_Range2 ()
{
  return this->Dynamic_Range2_.get ();
}

void Contrast::
Dynamic_Range2 (const Dynamic_Range2_type& x)
{
  this->Dynamic_Range2_.set (x);
}

void Contrast::
Dynamic_Range2 (::std::auto_ptr< Dynamic_Range2_type > x)
{
  this->Dynamic_Range2_.set (x);
}

const Contrast::Contast_3D_Brightness_type& Contrast::
Contast_3D_Brightness () const
{
  return this->Contast_3D_Brightness_.get ();
}

Contrast::Contast_3D_Brightness_type& Contrast::
Contast_3D_Brightness ()
{
  return this->Contast_3D_Brightness_.get ();
}

void Contrast::
Contast_3D_Brightness (const Contast_3D_Brightness_type& x)
{
  this->Contast_3D_Brightness_.set (x);
}

void Contrast::
Contast_3D_Brightness (::std::auto_ptr< Contast_3D_Brightness_type > x)
{
  this->Contast_3D_Brightness_.set (x);
}

const Contrast::Reference_3D_Steps_type& Contrast::
Reference_3D_Steps () const
{
  return this->Reference_3D_Steps_.get ();
}

Contrast::Reference_3D_Steps_type& Contrast::
Reference_3D_Steps ()
{
  return this->Reference_3D_Steps_.get ();
}

void Contrast::
Reference_3D_Steps (const Reference_3D_Steps_type& x)
{
  this->Reference_3D_Steps_.set (x);
}

void Contrast::
Reference_3D_Steps (::std::auto_ptr< Reference_3D_Steps_type > x)
{
  this->Reference_3D_Steps_.set (x);
}


// MIS1
// 

const MIS1::ECG_Gain_type& MIS1::
ECG_Gain () const
{
  return this->ECG_Gain_.get ();
}

MIS1::ECG_Gain_type& MIS1::
ECG_Gain ()
{
  return this->ECG_Gain_.get ();
}

void MIS1::
ECG_Gain (const ECG_Gain_type& x)
{
  this->ECG_Gain_.set (x);
}

void MIS1::
ECG_Gain (::std::auto_ptr< ECG_Gain_type > x)
{
  this->ECG_Gain_.set (x);
}

const MIS1::ECG_Available_type& MIS1::
ECG_Available () const
{
  return this->ECG_Available_.get ();
}

MIS1::ECG_Available_type& MIS1::
ECG_Available ()
{
  return this->ECG_Available_.get ();
}

void MIS1::
ECG_Available (const ECG_Available_type& x)
{
  this->ECG_Available_.set (x);
}

void MIS1::
ECG_Available (::std::auto_ptr< ECG_Available_type > x)
{
  this->ECG_Available_.set (x);
}

const MIS1::Blood_Pressure_Available_type& MIS1::
Blood_Pressure_Available () const
{
  return this->Blood_Pressure_Available_.get ();
}

MIS1::Blood_Pressure_Available_type& MIS1::
Blood_Pressure_Available ()
{
  return this->Blood_Pressure_Available_.get ();
}

void MIS1::
Blood_Pressure_Available (const Blood_Pressure_Available_type& x)
{
  this->Blood_Pressure_Available_.set (x);
}

void MIS1::
Blood_Pressure_Available (::std::auto_ptr< Blood_Pressure_Available_type > x)
{
  this->Blood_Pressure_Available_.set (x);
}

const MIS1::Respiration_Gating_type& MIS1::
Respiration_Gating () const
{
  return this->Respiration_Gating_.get ();
}

MIS1::Respiration_Gating_type& MIS1::
Respiration_Gating ()
{
  return this->Respiration_Gating_.get ();
}

void MIS1::
Respiration_Gating (const Respiration_Gating_type& x)
{
  this->Respiration_Gating_.set (x);
}

void MIS1::
Respiration_Gating (::std::auto_ptr< Respiration_Gating_type > x)
{
  this->Respiration_Gating_.set (x);
}

const MIS1::BP_Gain_type& MIS1::
BP_Gain () const
{
  return this->BP_Gain_.get ();
}

MIS1::BP_Gain_type& MIS1::
BP_Gain ()
{
  return this->BP_Gain_.get ();
}

void MIS1::
BP_Gain (const BP_Gain_type& x)
{
  this->BP_Gain_.set (x);
}

void MIS1::
BP_Gain (::std::auto_ptr< BP_Gain_type > x)
{
  this->BP_Gain_.set (x);
}

const MIS1::Temperature_Available_type& MIS1::
Temperature_Available () const
{
  return this->Temperature_Available_.get ();
}

MIS1::Temperature_Available_type& MIS1::
Temperature_Available ()
{
  return this->Temperature_Available_.get ();
}

void MIS1::
Temperature_Available (const Temperature_Available_type& x)
{
  this->Temperature_Available_.set (x);
}

void MIS1::
Temperature_Available (::std::auto_ptr< Temperature_Available_type > x)
{
  this->Temperature_Available_.set (x);
}

const MIS1::Respiration_Available_type& MIS1::
Respiration_Available () const
{
  return this->Respiration_Available_.get ();
}

MIS1::Respiration_Available_type& MIS1::
Respiration_Available ()
{
  return this->Respiration_Available_.get ();
}

void MIS1::
Respiration_Available (const Respiration_Available_type& x)
{
  this->Respiration_Available_.set (x);
}

void MIS1::
Respiration_Available (::std::auto_ptr< Respiration_Available_type > x)
{
  this->Respiration_Available_.set (x);
}

const MIS1::Control_type& MIS1::
Control () const
{
  return this->Control_.get ();
}

MIS1::Control_type& MIS1::
Control ()
{
  return this->Control_.get ();
}

void MIS1::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void MIS1::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}


// Scan1
// 

const Scan1::Encoder_Position_type& Scan1::
Encoder_Position () const
{
  return this->Encoder_Position_.get ();
}

Scan1::Encoder_Position_type& Scan1::
Encoder_Position ()
{
  return this->Encoder_Position_.get ();
}

void Scan1::
Encoder_Position (const Encoder_Position_type& x)
{
  this->Encoder_Position_.set (x);
}

void Scan1::
Encoder_Position (::std::auto_ptr< Encoder_Position_type > x)
{
  this->Encoder_Position_.set (x);
}

const Scan1::Center_type& Scan1::
Center () const
{
  return this->Center_.get ();
}

Scan1::Center_type& Scan1::
Center ()
{
  return this->Center_.get ();
}

void Scan1::
Center (const Center_type& x)
{
  this->Center_.set (x);
}

void Scan1::
Center (::std::auto_ptr< Center_type > x)
{
  this->Center_.set (x);
}

const Scan1::Control_type& Scan1::
Control () const
{
  return this->Control_.get ();
}

Scan1::Control_type& Scan1::
Control ()
{
  return this->Control_.get ();
}

void Scan1::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void Scan1::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}

const Scan1::Probe_ID1_type& Scan1::
Probe_ID1 () const
{
  return this->Probe_ID1_.get ();
}

Scan1::Probe_ID1_type& Scan1::
Probe_ID1 ()
{
  return this->Probe_ID1_.get ();
}

void Scan1::
Probe_ID1 (const Probe_ID1_type& x)
{
  this->Probe_ID1_.set (x);
}

void Scan1::
Probe_ID1 (::std::auto_ptr< Probe_ID1_type > x)
{
  this->Probe_ID1_.set (x);
}

const Scan1::Probe_ID2_type& Scan1::
Probe_ID2 () const
{
  return this->Probe_ID2_.get ();
}

Scan1::Probe_ID2_type& Scan1::
Probe_ID2 ()
{
  return this->Probe_ID2_.get ();
}

void Scan1::
Probe_ID2 (const Probe_ID2_type& x)
{
  this->Probe_ID2_.set (x);
}

void Scan1::
Probe_ID2 (::std::auto_ptr< Probe_ID2_type > x)
{
  this->Probe_ID2_.set (x);
}

const Scan1::V_Scan_Speed_type& Scan1::
V_Scan_Speed () const
{
  return this->V_Scan_Speed_.get ();
}

Scan1::V_Scan_Speed_type& Scan1::
V_Scan_Speed ()
{
  return this->V_Scan_Speed_.get ();
}

void Scan1::
V_Scan_Speed (const V_Scan_Speed_type& x)
{
  this->V_Scan_Speed_.set (x);
}

void Scan1::
V_Scan_Speed (::std::auto_ptr< V_Scan_Speed_type > x)
{
  this->V_Scan_Speed_.set (x);
}

const Scan1::Probe_ID1_Reread_type& Scan1::
Probe_ID1_Reread () const
{
  return this->Probe_ID1_Reread_.get ();
}

Scan1::Probe_ID1_Reread_type& Scan1::
Probe_ID1_Reread ()
{
  return this->Probe_ID1_Reread_.get ();
}

void Scan1::
Probe_ID1_Reread (const Probe_ID1_Reread_type& x)
{
  this->Probe_ID1_Reread_.set (x);
}

void Scan1::
Probe_ID1_Reread (::std::auto_ptr< Probe_ID1_Reread_type > x)
{
  this->Probe_ID1_Reread_.set (x);
}

const Scan1::Probe_ID1_Valid_type& Scan1::
Probe_ID1_Valid () const
{
  return this->Probe_ID1_Valid_.get ();
}

Scan1::Probe_ID1_Valid_type& Scan1::
Probe_ID1_Valid ()
{
  return this->Probe_ID1_Valid_.get ();
}

void Scan1::
Probe_ID1_Valid (const Probe_ID1_Valid_type& x)
{
  this->Probe_ID1_Valid_.set (x);
}

void Scan1::
Probe_ID1_Valid (::std::auto_ptr< Probe_ID1_Valid_type > x)
{
  this->Probe_ID1_Valid_.set (x);
}

const Scan1::Probe_ID1_Voltage_type& Scan1::
Probe_ID1_Voltage () const
{
  return this->Probe_ID1_Voltage_.get ();
}

Scan1::Probe_ID1_Voltage_type& Scan1::
Probe_ID1_Voltage ()
{
  return this->Probe_ID1_Voltage_.get ();
}

void Scan1::
Probe_ID1_Voltage (const Probe_ID1_Voltage_type& x)
{
  this->Probe_ID1_Voltage_.set (x);
}

void Scan1::
Probe_ID1_Voltage (::std::auto_ptr< Probe_ID1_Voltage_type > x)
{
  this->Probe_ID1_Voltage_.set (x);
}

const Scan1::Probe_ID2_Reread_type& Scan1::
Probe_ID2_Reread () const
{
  return this->Probe_ID2_Reread_.get ();
}

Scan1::Probe_ID2_Reread_type& Scan1::
Probe_ID2_Reread ()
{
  return this->Probe_ID2_Reread_.get ();
}

void Scan1::
Probe_ID2_Reread (const Probe_ID2_Reread_type& x)
{
  this->Probe_ID2_Reread_.set (x);
}

void Scan1::
Probe_ID2_Reread (::std::auto_ptr< Probe_ID2_Reread_type > x)
{
  this->Probe_ID2_Reread_.set (x);
}

const Scan1::Probe_ID2_Valid_type& Scan1::
Probe_ID2_Valid () const
{
  return this->Probe_ID2_Valid_.get ();
}

Scan1::Probe_ID2_Valid_type& Scan1::
Probe_ID2_Valid ()
{
  return this->Probe_ID2_Valid_.get ();
}

void Scan1::
Probe_ID2_Valid (const Probe_ID2_Valid_type& x)
{
  this->Probe_ID2_Valid_.set (x);
}

void Scan1::
Probe_ID2_Valid (::std::auto_ptr< Probe_ID2_Valid_type > x)
{
  this->Probe_ID2_Valid_.set (x);
}

const Scan1::Probe_ID2_Voltage_type& Scan1::
Probe_ID2_Voltage () const
{
  return this->Probe_ID2_Voltage_.get ();
}

Scan1::Probe_ID2_Voltage_type& Scan1::
Probe_ID2_Voltage ()
{
  return this->Probe_ID2_Voltage_.get ();
}

void Scan1::
Probe_ID2_Voltage (const Probe_ID2_Voltage_type& x)
{
  this->Probe_ID2_Voltage_.set (x);
}

void Scan1::
Probe_ID2_Voltage (::std::auto_ptr< Probe_ID2_Voltage_type > x)
{
  this->Probe_ID2_Voltage_.set (x);
}

const Scan1::V_Scan_Rate_type& Scan1::
V_Scan_Rate () const
{
  return this->V_Scan_Rate_.get ();
}

Scan1::V_Scan_Rate_type& Scan1::
V_Scan_Rate ()
{
  return this->V_Scan_Rate_.get ();
}

void Scan1::
V_Scan_Rate (const V_Scan_Rate_type& x)
{
  this->V_Scan_Rate_.set (x);
}

void Scan1::
V_Scan_Rate (::std::auto_ptr< V_Scan_Rate_type > x)
{
  this->V_Scan_Rate_.set (x);
}

const Scan1::Position_Counter_Lock_type& Scan1::
Position_Counter_Lock () const
{
  return this->Position_Counter_Lock_.get ();
}

Scan1::Position_Counter_Lock_type& Scan1::
Position_Counter_Lock ()
{
  return this->Position_Counter_Lock_.get ();
}

void Scan1::
Position_Counter_Lock (const Position_Counter_Lock_type& x)
{
  this->Position_Counter_Lock_.set (x);
}

void Scan1::
Position_Counter_Lock (::std::auto_ptr< Position_Counter_Lock_type > x)
{
  this->Position_Counter_Lock_.set (x);
}

const Scan1::Scan_Width_type& Scan1::
Scan_Width () const
{
  return this->Scan_Width_.get ();
}

Scan1::Scan_Width_type& Scan1::
Scan_Width ()
{
  return this->Scan_Width_.get ();
}

void Scan1::
Scan_Width (const Scan_Width_type& x)
{
  this->Scan_Width_.set (x);
}

void Scan1::
Scan_Width (::std::auto_ptr< Scan_Width_type > x)
{
  this->Scan_Width_.set (x);
}

const Scan1::Position_Counter_Reset_type& Scan1::
Position_Counter_Reset () const
{
  return this->Position_Counter_Reset_.get ();
}

Scan1::Position_Counter_Reset_type& Scan1::
Position_Counter_Reset ()
{
  return this->Position_Counter_Reset_.get ();
}

void Scan1::
Position_Counter_Reset (const Position_Counter_Reset_type& x)
{
  this->Position_Counter_Reset_.set (x);
}

void Scan1::
Position_Counter_Reset (::std::auto_ptr< Position_Counter_Reset_type > x)
{
  this->Position_Counter_Reset_.set (x);
}


// Motor1
// 

const Motor1::Settle_Time_3d_type& Motor1::
Settle_Time_3d () const
{
  return this->Settle_Time_3d_.get ();
}

Motor1::Settle_Time_3d_type& Motor1::
Settle_Time_3d ()
{
  return this->Settle_Time_3d_.get ();
}

void Motor1::
Settle_Time_3d (const Settle_Time_3d_type& x)
{
  this->Settle_Time_3d_.set (x);
}

void Motor1::
Settle_Time_3d (::std::auto_ptr< Settle_Time_3d_type > x)
{
  this->Settle_Time_3d_.set (x);
}

const Motor1::Position_type& Motor1::
Position () const
{
  return this->Position_.get ();
}

Motor1::Position_type& Motor1::
Position ()
{
  return this->Position_.get ();
}

void Motor1::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Motor1::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const Motor1::R_Scan_Move_No_Wait_type& Motor1::
R_Scan_Move_No_Wait () const
{
  return this->R_Scan_Move_No_Wait_.get ();
}

Motor1::R_Scan_Move_No_Wait_type& Motor1::
R_Scan_Move_No_Wait ()
{
  return this->R_Scan_Move_No_Wait_.get ();
}

void Motor1::
R_Scan_Move_No_Wait (const R_Scan_Move_No_Wait_type& x)
{
  this->R_Scan_Move_No_Wait_.set (x);
}

void Motor1::
R_Scan_Move_No_Wait (::std::auto_ptr< R_Scan_Move_No_Wait_type > x)
{
  this->R_Scan_Move_No_Wait_.set (x);
}

const Motor1::Motor_Mode_type& Motor1::
Motor_Mode () const
{
  return this->Motor_Mode_.get ();
}

Motor1::Motor_Mode_type& Motor1::
Motor_Mode ()
{
  return this->Motor_Mode_.get ();
}

void Motor1::
Motor_Mode (const Motor_Mode_type& x)
{
  this->Motor_Mode_.set (x);
}

void Motor1::
Motor_Mode (::std::auto_ptr< Motor_Mode_type > x)
{
  this->Motor_Mode_.set (x);
}

const Motor1::Acceleration_type& Motor1::
Acceleration () const
{
  return this->Acceleration_.get ();
}

Motor1::Acceleration_type& Motor1::
Acceleration ()
{
  return this->Acceleration_.get ();
}

void Motor1::
Acceleration (const Acceleration_type& x)
{
  this->Acceleration_.set (x);
}

void Motor1::
Acceleration (::std::auto_ptr< Acceleration_type > x)
{
  this->Acceleration_.set (x);
}

const Motor1::Serial_Port_Mode_type& Motor1::
Serial_Port_Mode () const
{
  return this->Serial_Port_Mode_.get ();
}

Motor1::Serial_Port_Mode_type& Motor1::
Serial_Port_Mode ()
{
  return this->Serial_Port_Mode_.get ();
}

void Motor1::
Serial_Port_Mode (const Serial_Port_Mode_type& x)
{
  this->Serial_Port_Mode_.set (x);
}

void Motor1::
Serial_Port_Mode (::std::auto_ptr< Serial_Port_Mode_type > x)
{
  this->Serial_Port_Mode_.set (x);
}

const Motor1::Limit_Switch_Mode_type& Motor1::
Limit_Switch_Mode () const
{
  return this->Limit_Switch_Mode_.get ();
}

Motor1::Limit_Switch_Mode_type& Motor1::
Limit_Switch_Mode ()
{
  return this->Limit_Switch_Mode_.get ();
}

void Motor1::
Limit_Switch_Mode (const Limit_Switch_Mode_type& x)
{
  this->Limit_Switch_Mode_.set (x);
}

void Motor1::
Limit_Switch_Mode (::std::auto_ptr< Limit_Switch_Mode_type > x)
{
  this->Limit_Switch_Mode_.set (x);
}

const Motor1::Breakpoint_type& Motor1::
Breakpoint () const
{
  return this->Breakpoint_.get ();
}

Motor1::Breakpoint_type& Motor1::
Breakpoint ()
{
  return this->Breakpoint_.get ();
}

void Motor1::
Breakpoint (const Breakpoint_type& x)
{
  this->Breakpoint_.set (x);
}

void Motor1::
Breakpoint (::std::auto_ptr< Breakpoint_type > x)
{
  this->Breakpoint_.set (x);
}

const Motor1::Update_type& Motor1::
Update () const
{
  return this->Update_.get ();
}

Motor1::Update_type& Motor1::
Update ()
{
  return this->Update_.get ();
}

void Motor1::
Update (const Update_type& x)
{
  this->Update_.set (x);
}

void Motor1::
Update (::std::auto_ptr< Update_type > x)
{
  this->Update_.set (x);
}

const Motor1::Breakpoint_Value_type& Motor1::
Breakpoint_Value () const
{
  return this->Breakpoint_Value_.get ();
}

Motor1::Breakpoint_Value_type& Motor1::
Breakpoint_Value ()
{
  return this->Breakpoint_Value_.get ();
}

void Motor1::
Breakpoint_Value (const Breakpoint_Value_type& x)
{
  this->Breakpoint_Value_.set (x);
}

void Motor1::
Breakpoint_Value (::std::auto_ptr< Breakpoint_Value_type > x)
{
  this->Breakpoint_Value_.set (x);
}

const Motor1::V_Switch_Limit_type& Motor1::
V_Switch_Limit () const
{
  return this->V_Switch_Limit_.get ();
}

Motor1::V_Switch_Limit_type& Motor1::
V_Switch_Limit ()
{
  return this->V_Switch_Limit_.get ();
}

void Motor1::
V_Switch_Limit (const V_Switch_Limit_type& x)
{
  this->V_Switch_Limit_.set (x);
}

void Motor1::
V_Switch_Limit (::std::auto_ptr< V_Switch_Limit_type > x)
{
  this->V_Switch_Limit_.set (x);
}

const Motor1::R_Retrieve_Trace_type& Motor1::
R_Retrieve_Trace () const
{
  return this->R_Retrieve_Trace_.get ();
}

Motor1::R_Retrieve_Trace_type& Motor1::
R_Retrieve_Trace ()
{
  return this->R_Retrieve_Trace_.get ();
}

void Motor1::
R_Retrieve_Trace (const R_Retrieve_Trace_type& x)
{
  this->R_Retrieve_Trace_.set (x);
}

void Motor1::
R_Retrieve_Trace (::std::auto_ptr< R_Retrieve_Trace_type > x)
{
  this->R_Retrieve_Trace_.set (x);
}

const Motor1::Velocity_Stationary_type& Motor1::
Velocity_Stationary () const
{
  return this->Velocity_Stationary_.get ();
}

Motor1::Velocity_Stationary_type& Motor1::
Velocity_Stationary ()
{
  return this->Velocity_Stationary_.get ();
}

void Motor1::
Velocity_Stationary (const Velocity_Stationary_type& x)
{
  this->Velocity_Stationary_.set (x);
}

void Motor1::
Velocity_Stationary (::std::auto_ptr< Velocity_Stationary_type > x)
{
  this->Velocity_Stationary_.set (x);
}

const Motor1::Reset_Event_Status_type& Motor1::
Reset_Event_Status () const
{
  return this->Reset_Event_Status_.get ();
}

Motor1::Reset_Event_Status_type& Motor1::
Reset_Event_Status ()
{
  return this->Reset_Event_Status_.get ();
}

void Motor1::
Reset_Event_Status (const Reset_Event_Status_type& x)
{
  this->Reset_Event_Status_.set (x);
}

void Motor1::
Reset_Event_Status (::std::auto_ptr< Reset_Event_Status_type > x)
{
  this->Reset_Event_Status_.set (x);
}

const Motor1::Actual_Position_type& Motor1::
Actual_Position () const
{
  return this->Actual_Position_.get ();
}

Motor1::Actual_Position_type& Motor1::
Actual_Position ()
{
  return this->Actual_Position_.get ();
}

void Motor1::
Actual_Position (const Actual_Position_type& x)
{
  this->Actual_Position_.set (x);
}

void Motor1::
Actual_Position (::std::auto_ptr< Actual_Position_type > x)
{
  this->Actual_Position_.set (x);
}

const Motor1::Buffer_Length_type& Motor1::
Buffer_Length () const
{
  return this->Buffer_Length_.get ();
}

Motor1::Buffer_Length_type& Motor1::
Buffer_Length ()
{
  return this->Buffer_Length_.get ();
}

void Motor1::
Buffer_Length (const Buffer_Length_type& x)
{
  this->Buffer_Length_.set (x);
}

void Motor1::
Buffer_Length (::std::auto_ptr< Buffer_Length_type > x)
{
  this->Buffer_Length_.set (x);
}

const Motor1::R_Scan_Move2_type& Motor1::
R_Scan_Move2 () const
{
  return this->R_Scan_Move2_.get ();
}

Motor1::R_Scan_Move2_type& Motor1::
R_Scan_Move2 ()
{
  return this->R_Scan_Move2_.get ();
}

void Motor1::
R_Scan_Move2 (const R_Scan_Move2_type& x)
{
  this->R_Scan_Move2_.set (x);
}

void Motor1::
R_Scan_Move2 (::std::auto_ptr< R_Scan_Move2_type > x)
{
  this->R_Scan_Move2_.set (x);
}

const Motor1::Position_Reverse_type& Motor1::
Position_Reverse () const
{
  return this->Position_Reverse_.get ();
}

Motor1::Position_Reverse_type& Motor1::
Position_Reverse ()
{
  return this->Position_Reverse_.get ();
}

void Motor1::
Position_Reverse (const Position_Reverse_type& x)
{
  this->Position_Reverse_.set (x);
}

void Motor1::
Position_Reverse (::std::auto_ptr< Position_Reverse_type > x)
{
  this->Position_Reverse_.set (x);
}

const Motor1::Reset_type& Motor1::
Reset () const
{
  return this->Reset_.get ();
}

Motor1::Reset_type& Motor1::
Reset ()
{
  return this->Reset_.get ();
}

void Motor1::
Reset (const Reset_type& x)
{
  this->Reset_.set (x);
}

void Motor1::
Reset (::std::auto_ptr< Reset_type > x)
{
  this->Reset_.set (x);
}

const Motor1::Trace_Count_type& Motor1::
Trace_Count () const
{
  return this->Trace_Count_.get ();
}

Motor1::Trace_Count_type& Motor1::
Trace_Count ()
{
  return this->Trace_Count_.get ();
}

void Motor1::
Trace_Count (const Trace_Count_type& x)
{
  this->Trace_Count_.set (x);
}

void Motor1::
Trace_Count (::std::auto_ptr< Trace_Count_type > x)
{
  this->Trace_Count_.set (x);
}

const Motor1::R_Initialize_type& Motor1::
R_Initialize () const
{
  return this->R_Initialize_.get ();
}

Motor1::R_Initialize_type& Motor1::
R_Initialize ()
{
  return this->R_Initialize_.get ();
}

void Motor1::
R_Initialize (const R_Initialize_type& x)
{
  this->R_Initialize_.set (x);
}

void Motor1::
R_Initialize (::std::auto_ptr< R_Initialize_type > x)
{
  this->R_Initialize_.set (x);
}

const Motor1::Output_Mode_type& Motor1::
Output_Mode () const
{
  return this->Output_Mode_.get ();
}

Motor1::Output_Mode_type& Motor1::
Output_Mode ()
{
  return this->Output_Mode_.get ();
}

void Motor1::
Output_Mode (const Output_Mode_type& x)
{
  this->Output_Mode_.set (x);
}

void Motor1::
Output_Mode (::std::auto_ptr< Output_Mode_type > x)
{
  this->Output_Mode_.set (x);
}

const Motor1::Position2_type& Motor1::
Position2 () const
{
  return this->Position2_.get ();
}

Motor1::Position2_type& Motor1::
Position2 ()
{
  return this->Position2_.get ();
}

void Motor1::
Position2 (const Position2_type& x)
{
  this->Position2_.set (x);
}

void Motor1::
Position2 (::std::auto_ptr< Position2_type > x)
{
  this->Position2_.set (x);
}

const Motor1::Integration_Limit_type& Motor1::
Integration_Limit () const
{
  return this->Integration_Limit_.get ();
}

Motor1::Integration_Limit_type& Motor1::
Integration_Limit ()
{
  return this->Integration_Limit_.get ();
}

void Motor1::
Integration_Limit (const Integration_Limit_type& x)
{
  this->Integration_Limit_.set (x);
}

void Motor1::
Integration_Limit (::std::auto_ptr< Integration_Limit_type > x)
{
  this->Integration_Limit_.set (x);
}

const Motor1::R_Home_type& Motor1::
R_Home () const
{
  return this->R_Home_.get ();
}

Motor1::R_Home_type& Motor1::
R_Home ()
{
  return this->R_Home_.get ();
}

void Motor1::
R_Home (const R_Home_type& x)
{
  this->R_Home_.set (x);
}

void Motor1::
R_Home (::std::auto_ptr< R_Home_type > x)
{
  this->R_Home_.set (x);
}

const Motor1::Error_type& Motor1::
Error () const
{
  return this->Error_.get ();
}

Motor1::Error_type& Motor1::
Error ()
{
  return this->Error_.get ();
}

void Motor1::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void Motor1::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const Motor1::R_Reset_Limit_Switch_type& Motor1::
R_Reset_Limit_Switch () const
{
  return this->R_Reset_Limit_Switch_.get ();
}

Motor1::R_Reset_Limit_Switch_type& Motor1::
R_Reset_Limit_Switch ()
{
  return this->R_Reset_Limit_Switch_.get ();
}

void Motor1::
R_Reset_Limit_Switch (const R_Reset_Limit_Switch_type& x)
{
  this->R_Reset_Limit_Switch_.set (x);
}

void Motor1::
R_Reset_Limit_Switch (::std::auto_ptr< R_Reset_Limit_Switch_type > x)
{
  this->R_Reset_Limit_Switch_.set (x);
}

const Motor1::Settle_Window_3d_type& Motor1::
Settle_Window_3d () const
{
  return this->Settle_Window_3d_.get ();
}

Motor1::Settle_Window_3d_type& Motor1::
Settle_Window_3d ()
{
  return this->Settle_Window_3d_.get ();
}

void Motor1::
Settle_Window_3d (const Settle_Window_3d_type& x)
{
  this->Settle_Window_3d_.set (x);
}

void Motor1::
Settle_Window_3d (::std::auto_ptr< Settle_Window_3d_type > x)
{
  this->Settle_Window_3d_.set (x);
}

const Motor1::Interrupt_Mask_type& Motor1::
Interrupt_Mask () const
{
  return this->Interrupt_Mask_.get ();
}

Motor1::Interrupt_Mask_type& Motor1::
Interrupt_Mask ()
{
  return this->Interrupt_Mask_.get ();
}

void Motor1::
Interrupt_Mask (const Interrupt_Mask_type& x)
{
  this->Interrupt_Mask_.set (x);
}

void Motor1::
Interrupt_Mask (::std::auto_ptr< Interrupt_Mask_type > x)
{
  this->Interrupt_Mask_.set (x);
}

const Motor1::Scan_Move_Control_type& Motor1::
Scan_Move_Control () const
{
  return this->Scan_Move_Control_.get ();
}

Motor1::Scan_Move_Control_type& Motor1::
Scan_Move_Control ()
{
  return this->Scan_Move_Control_.get ();
}

void Motor1::
Scan_Move_Control (const Scan_Move_Control_type& x)
{
  this->Scan_Move_Control_.set (x);
}

void Motor1::
Scan_Move_Control (::std::auto_ptr< Scan_Move_Control_type > x)
{
  this->Scan_Move_Control_.set (x);
}

const Motor1::Axis_Out_Source_type& Motor1::
Axis_Out_Source () const
{
  return this->Axis_Out_Source_.get ();
}

Motor1::Axis_Out_Source_type& Motor1::
Axis_Out_Source ()
{
  return this->Axis_Out_Source_.get ();
}

void Motor1::
Axis_Out_Source (const Axis_Out_Source_type& x)
{
  this->Axis_Out_Source_.set (x);
}

void Motor1::
Axis_Out_Source (::std::auto_ptr< Axis_Out_Source_type > x)
{
  this->Axis_Out_Source_.set (x);
}

const Motor1::Trace_Stop_type& Motor1::
Trace_Stop () const
{
  return this->Trace_Stop_.get ();
}

Motor1::Trace_Stop_type& Motor1::
Trace_Stop ()
{
  return this->Trace_Stop_.get ();
}

void Motor1::
Trace_Stop (const Trace_Stop_type& x)
{
  this->Trace_Stop_.set (x);
}

void Motor1::
Trace_Stop (::std::auto_ptr< Trace_Stop_type > x)
{
  this->Trace_Stop_.set (x);
}

const Motor1::Velocity_type& Motor1::
Velocity () const
{
  return this->Velocity_.get ();
}

Motor1::Velocity_type& Motor1::
Velocity ()
{
  return this->Velocity_.get ();
}

void Motor1::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void Motor1::
Velocity (::std::auto_ptr< Velocity_type > x)
{
  this->Velocity_.set (x);
}

const Motor1::R_Setup_type& Motor1::
R_Setup () const
{
  return this->R_Setup_.get ();
}

Motor1::R_Setup_type& Motor1::
R_Setup ()
{
  return this->R_Setup_.get ();
}

void Motor1::
R_Setup (const R_Setup_type& x)
{
  this->R_Setup_.set (x);
}

void Motor1::
R_Setup (::std::auto_ptr< R_Setup_type > x)
{
  this->R_Setup_.set (x);
}

const Motor1::Buffer_Start_type& Motor1::
Buffer_Start () const
{
  return this->Buffer_Start_.get ();
}

Motor1::Buffer_Start_type& Motor1::
Buffer_Start ()
{
  return this->Buffer_Start_.get ();
}

void Motor1::
Buffer_Start (const Buffer_Start_type& x)
{
  this->Buffer_Start_.set (x);
}

void Motor1::
Buffer_Start (::std::auto_ptr< Buffer_Start_type > x)
{
  this->Buffer_Start_.set (x);
}

const Motor1::Signal_Sense_type& Motor1::
Signal_Sense () const
{
  return this->Signal_Sense_.get ();
}

Motor1::Signal_Sense_type& Motor1::
Signal_Sense ()
{
  return this->Signal_Sense_.get ();
}

void Motor1::
Signal_Sense (const Signal_Sense_type& x)
{
  this->Signal_Sense_.set (x);
}

void Motor1::
Signal_Sense (::std::auto_ptr< Signal_Sense_type > x)
{
  this->Signal_Sense_.set (x);
}

const Motor1::R_Scan_Move_type& Motor1::
R_Scan_Move () const
{
  return this->R_Scan_Move_.get ();
}

Motor1::R_Scan_Move_type& Motor1::
R_Scan_Move ()
{
  return this->R_Scan_Move_.get ();
}

void Motor1::
R_Scan_Move (const R_Scan_Move_type& x)
{
  this->R_Scan_Move_.set (x);
}

void Motor1::
R_Scan_Move (::std::auto_ptr< R_Scan_Move_type > x)
{
  this->R_Scan_Move_.set (x);
}

const Motor1::Position_Forward_type& Motor1::
Position_Forward () const
{
  return this->Position_Forward_.get ();
}

Motor1::Position_Forward_type& Motor1::
Position_Forward ()
{
  return this->Position_Forward_.get ();
}

void Motor1::
Position_Forward (const Position_Forward_type& x)
{
  this->Position_Forward_.set (x);
}

void Motor1::
Position_Forward (::std::auto_ptr< Position_Forward_type > x)
{
  this->Position_Forward_.set (x);
}

const Motor1::Derivative_Time_type& Motor1::
Derivative_Time () const
{
  return this->Derivative_Time_.get ();
}

Motor1::Derivative_Time_type& Motor1::
Derivative_Time ()
{
  return this->Derivative_Time_.get ();
}

void Motor1::
Derivative_Time (const Derivative_Time_type& x)
{
  this->Derivative_Time_.set (x);
}

void Motor1::
Derivative_Time (::std::auto_ptr< Derivative_Time_type > x)
{
  this->Derivative_Time_.set (x);
}

const Motor1::Settle_Window_type& Motor1::
Settle_Window () const
{
  return this->Settle_Window_.get ();
}

Motor1::Settle_Window_type& Motor1::
Settle_Window ()
{
  return this->Settle_Window_.get ();
}

void Motor1::
Settle_Window (const Settle_Window_type& x)
{
  this->Settle_Window_.set (x);
}

void Motor1::
Settle_Window (::std::auto_ptr< Settle_Window_type > x)
{
  this->Settle_Window_.set (x);
}

const Motor1::Trace_Variable1_type& Motor1::
Trace_Variable1 () const
{
  return this->Trace_Variable1_.get ();
}

Motor1::Trace_Variable1_type& Motor1::
Trace_Variable1 ()
{
  return this->Trace_Variable1_.get ();
}

void Motor1::
Trace_Variable1 (const Trace_Variable1_type& x)
{
  this->Trace_Variable1_.set (x);
}

void Motor1::
Trace_Variable1 (::std::auto_ptr< Trace_Variable1_type > x)
{
  this->Trace_Variable1_.set (x);
}

const Motor1::Trace_Variable2_type& Motor1::
Trace_Variable2 () const
{
  return this->Trace_Variable2_.get ();
}

Motor1::Trace_Variable2_type& Motor1::
Trace_Variable2 ()
{
  return this->Trace_Variable2_.get ();
}

void Motor1::
Trace_Variable2 (const Trace_Variable2_type& x)
{
  this->Trace_Variable2_.set (x);
}

void Motor1::
Trace_Variable2 (::std::auto_ptr< Trace_Variable2_type > x)
{
  this->Trace_Variable2_.set (x);
}

const Motor1::Buffer_Read_Index_type& Motor1::
Buffer_Read_Index () const
{
  return this->Buffer_Read_Index_.get ();
}

Motor1::Buffer_Read_Index_type& Motor1::
Buffer_Read_Index ()
{
  return this->Buffer_Read_Index_.get ();
}

void Motor1::
Buffer_Read_Index (const Buffer_Read_Index_type& x)
{
  this->Buffer_Read_Index_.set (x);
}

void Motor1::
Buffer_Read_Index (::std::auto_ptr< Buffer_Read_Index_type > x)
{
  this->Buffer_Read_Index_.set (x);
}

const Motor1::Signal_Status_type& Motor1::
Signal_Status () const
{
  return this->Signal_Status_.get ();
}

Motor1::Signal_Status_type& Motor1::
Signal_Status ()
{
  return this->Signal_Status_.get ();
}

void Motor1::
Signal_Status (const Signal_Status_type& x)
{
  this->Signal_Status_.set (x);
}

void Motor1::
Signal_Status (::std::auto_ptr< Signal_Status_type > x)
{
  this->Signal_Status_.set (x);
}

const Motor1::Alarm_Clear_type& Motor1::
Alarm_Clear () const
{
  return this->Alarm_Clear_.get ();
}

Motor1::Alarm_Clear_type& Motor1::
Alarm_Clear ()
{
  return this->Alarm_Clear_.get ();
}

void Motor1::
Alarm_Clear (const Alarm_Clear_type& x)
{
  this->Alarm_Clear_.set (x);
}

void Motor1::
Alarm_Clear (::std::auto_ptr< Alarm_Clear_type > x)
{
  this->Alarm_Clear_.set (x);
}

const Motor1::Motion_Complete_Mode_type& Motor1::
Motion_Complete_Mode () const
{
  return this->Motion_Complete_Mode_.get ();
}

Motor1::Motion_Complete_Mode_type& Motor1::
Motion_Complete_Mode ()
{
  return this->Motion_Complete_Mode_.get ();
}

void Motor1::
Motion_Complete_Mode (const Motion_Complete_Mode_type& x)
{
  this->Motion_Complete_Mode_.set (x);
}

void Motor1::
Motion_Complete_Mode (::std::auto_ptr< Motion_Complete_Mode_type > x)
{
  this->Motion_Complete_Mode_.set (x);
}

const Motor1::R_Setup_Abort_type& Motor1::
R_Setup_Abort () const
{
  return this->R_Setup_Abort_.get ();
}

Motor1::R_Setup_Abort_type& Motor1::
R_Setup_Abort ()
{
  return this->R_Setup_Abort_.get ();
}

void Motor1::
R_Setup_Abort (const R_Setup_Abort_type& x)
{
  this->R_Setup_Abort_.set (x);
}

void Motor1::
R_Setup_Abort (::std::auto_ptr< R_Setup_Abort_type > x)
{
  this->R_Setup_Abort_.set (x);
}

const Motor1::Read_Buffer_type& Motor1::
Read_Buffer () const
{
  return this->Read_Buffer_.get ();
}

Motor1::Read_Buffer_type& Motor1::
Read_Buffer ()
{
  return this->Read_Buffer_.get ();
}

void Motor1::
Read_Buffer (const Read_Buffer_type& x)
{
  this->Read_Buffer_.set (x);
}

void Motor1::
Read_Buffer (::std::auto_ptr< Read_Buffer_type > x)
{
  this->Read_Buffer_.set (x);
}

const Motor1::Kd_type& Motor1::
Kd () const
{
  return this->Kd_.get ();
}

Motor1::Kd_type& Motor1::
Kd ()
{
  return this->Kd_.get ();
}

void Motor1::
Kd (const Kd_type& x)
{
  this->Kd_.set (x);
}

void Motor1::
Kd (::std::auto_ptr< Kd_type > x)
{
  this->Kd_.set (x);
}

const Motor1::Clear_Interrupt_type& Motor1::
Clear_Interrupt () const
{
  return this->Clear_Interrupt_.get ();
}

Motor1::Clear_Interrupt_type& Motor1::
Clear_Interrupt ()
{
  return this->Clear_Interrupt_.get ();
}

void Motor1::
Clear_Interrupt (const Clear_Interrupt_type& x)
{
  this->Clear_Interrupt_.set (x);
}

void Motor1::
Clear_Interrupt (::std::auto_ptr< Clear_Interrupt_type > x)
{
  this->Clear_Interrupt_.set (x);
}

const Motor1::Profile_Mode_type& Motor1::
Profile_Mode () const
{
  return this->Profile_Mode_.get ();
}

Motor1::Profile_Mode_type& Motor1::
Profile_Mode ()
{
  return this->Profile_Mode_.get ();
}

void Motor1::
Profile_Mode (const Profile_Mode_type& x)
{
  this->Profile_Mode_.set (x);
}

void Motor1::
Profile_Mode (::std::auto_ptr< Profile_Mode_type > x)
{
  this->Profile_Mode_.set (x);
}

const Motor1::R_Setup_Trace_type& Motor1::
R_Setup_Trace () const
{
  return this->R_Setup_Trace_.get ();
}

Motor1::R_Setup_Trace_type& Motor1::
R_Setup_Trace ()
{
  return this->R_Setup_Trace_.get ();
}

void Motor1::
R_Setup_Trace (const R_Setup_Trace_type& x)
{
  this->R_Setup_Trace_.set (x);
}

void Motor1::
R_Setup_Trace (::std::auto_ptr< R_Setup_Trace_type > x)
{
  this->R_Setup_Trace_.set (x);
}

const Motor1::No_Operation_type& Motor1::
No_Operation () const
{
  return this->No_Operation_.get ();
}

Motor1::No_Operation_type& Motor1::
No_Operation ()
{
  return this->No_Operation_.get ();
}

void Motor1::
No_Operation (const No_Operation_type& x)
{
  this->No_Operation_.set (x);
}

void Motor1::
No_Operation (::std::auto_ptr< No_Operation_type > x)
{
  this->No_Operation_.set (x);
}

const Motor1::Ki_type& Motor1::
Ki () const
{
  return this->Ki_.get ();
}

Motor1::Ki_type& Motor1::
Ki ()
{
  return this->Ki_.get ();
}

void Motor1::
Ki (const Ki_type& x)
{
  this->Ki_.set (x);
}

void Motor1::
Ki (::std::auto_ptr< Ki_type > x)
{
  this->Ki_.set (x);
}

const Motor1::Sample_Time_type& Motor1::
Sample_Time () const
{
  return this->Sample_Time_.get ();
}

Motor1::Sample_Time_type& Motor1::
Sample_Time ()
{
  return this->Sample_Time_.get ();
}

void Motor1::
Sample_Time (const Sample_Time_type& x)
{
  this->Sample_Time_.set (x);
}

void Motor1::
Sample_Time (::std::auto_ptr< Sample_Time_type > x)
{
  this->Sample_Time_.set (x);
}

const Motor1::Event_Status_type& Motor1::
Event_Status () const
{
  return this->Event_Status_.get ();
}

Motor1::Event_Status_type& Motor1::
Event_Status ()
{
  return this->Event_Status_.get ();
}

void Motor1::
Event_Status (const Event_Status_type& x)
{
  this->Event_Status_.set (x);
}

void Motor1::
Event_Status (::std::auto_ptr< Event_Status_type > x)
{
  this->Event_Status_.set (x);
}

const Motor1::Kp_type& Motor1::
Kp () const
{
  return this->Kp_.get ();
}

Motor1::Kp_type& Motor1::
Kp ()
{
  return this->Kp_.get ();
}

void Motor1::
Kp (const Kp_type& x)
{
  this->Kp_.set (x);
}

void Motor1::
Kp (::std::auto_ptr< Kp_type > x)
{
  this->Kp_.set (x);
}

const Motor1::R_Wait_Finish_Scan_Move_type& Motor1::
R_Wait_Finish_Scan_Move () const
{
  return this->R_Wait_Finish_Scan_Move_.get ();
}

Motor1::R_Wait_Finish_Scan_Move_type& Motor1::
R_Wait_Finish_Scan_Move ()
{
  return this->R_Wait_Finish_Scan_Move_.get ();
}

void Motor1::
R_Wait_Finish_Scan_Move (const R_Wait_Finish_Scan_Move_type& x)
{
  this->R_Wait_Finish_Scan_Move_.set (x);
}

void Motor1::
R_Wait_Finish_Scan_Move (::std::auto_ptr< R_Wait_Finish_Scan_Move_type > x)
{
  this->R_Wait_Finish_Scan_Move_.set (x);
}

const Motor1::Settle_Time_type& Motor1::
Settle_Time () const
{
  return this->Settle_Time_.get ();
}

Motor1::Settle_Time_type& Motor1::
Settle_Time ()
{
  return this->Settle_Time_.get ();
}

void Motor1::
Settle_Time (const Settle_Time_type& x)
{
  this->Settle_Time_.set (x);
}

void Motor1::
Settle_Time (::std::auto_ptr< Settle_Time_type > x)
{
  this->Settle_Time_.set (x);
}

const Motor1::Acceleration_Stationary_type& Motor1::
Acceleration_Stationary () const
{
  return this->Acceleration_Stationary_.get ();
}

Motor1::Acceleration_Stationary_type& Motor1::
Acceleration_Stationary ()
{
  return this->Acceleration_Stationary_.get ();
}

void Motor1::
Acceleration_Stationary (const Acceleration_Stationary_type& x)
{
  this->Acceleration_Stationary_.set (x);
}

void Motor1::
Acceleration_Stationary (::std::auto_ptr< Acceleration_Stationary_type > x)
{
  this->Acceleration_Stationary_.set (x);
}

const Motor1::Trace_Mode_type& Motor1::
Trace_Mode () const
{
  return this->Trace_Mode_.get ();
}

Motor1::Trace_Mode_type& Motor1::
Trace_Mode ()
{
  return this->Trace_Mode_.get ();
}

void Motor1::
Trace_Mode (const Trace_Mode_type& x)
{
  this->Trace_Mode_.set (x);
}

void Motor1::
Trace_Mode (::std::auto_ptr< Trace_Mode_type > x)
{
  this->Trace_Mode_.set (x);
}

const Motor1::Trace_Period_type& Motor1::
Trace_Period () const
{
  return this->Trace_Period_.get ();
}

Motor1::Trace_Period_type& Motor1::
Trace_Period ()
{
  return this->Trace_Period_.get ();
}

void Motor1::
Trace_Period (const Trace_Period_type& x)
{
  this->Trace_Period_.set (x);
}

void Motor1::
Trace_Period (::std::auto_ptr< Trace_Period_type > x)
{
  this->Trace_Period_.set (x);
}

const Motor1::Trace_Start_type& Motor1::
Trace_Start () const
{
  return this->Trace_Start_.get ();
}

Motor1::Trace_Start_type& Motor1::
Trace_Start ()
{
  return this->Trace_Start_.get ();
}

void Motor1::
Trace_Start (const Trace_Start_type& x)
{
  this->Trace_Start_.set (x);
}

void Motor1::
Trace_Start (::std::auto_ptr< Trace_Start_type > x)
{
  this->Trace_Start_.set (x);
}


// ContrastDlg
// 

const ContrastDlg::Contrast_YAxis_Auto_Scale_type& ContrastDlg::
Contrast_YAxis_Auto_Scale () const
{
  return this->Contrast_YAxis_Auto_Scale_.get ();
}

ContrastDlg::Contrast_YAxis_Auto_Scale_type& ContrastDlg::
Contrast_YAxis_Auto_Scale ()
{
  return this->Contrast_YAxis_Auto_Scale_.get ();
}

void ContrastDlg::
Contrast_YAxis_Auto_Scale (const Contrast_YAxis_Auto_Scale_type& x)
{
  this->Contrast_YAxis_Auto_Scale_.set (x);
}

void ContrastDlg::
Contrast_YAxis_Auto_Scale (::std::auto_ptr< Contrast_YAxis_Auto_Scale_type > x)
{
  this->Contrast_YAxis_Auto_Scale_.set (x);
}

const ContrastDlg::Draw_Cardiac_Average_type& ContrastDlg::
Draw_Cardiac_Average () const
{
  return this->Draw_Cardiac_Average_.get ();
}

ContrastDlg::Draw_Cardiac_Average_type& ContrastDlg::
Draw_Cardiac_Average ()
{
  return this->Draw_Cardiac_Average_.get ();
}

void ContrastDlg::
Draw_Cardiac_Average (const Draw_Cardiac_Average_type& x)
{
  this->Draw_Cardiac_Average_.set (x);
}

void ContrastDlg::
Draw_Cardiac_Average (::std::auto_ptr< Draw_Cardiac_Average_type > x)
{
  this->Draw_Cardiac_Average_.set (x);
}

const ContrastDlg::Average_Frames_type& ContrastDlg::
Average_Frames () const
{
  return this->Average_Frames_.get ();
}

ContrastDlg::Average_Frames_type& ContrastDlg::
Average_Frames ()
{
  return this->Average_Frames_.get ();
}

void ContrastDlg::
Average_Frames (const Average_Frames_type& x)
{
  this->Average_Frames_.set (x);
}

void ContrastDlg::
Average_Frames (::std::auto_ptr< Average_Frames_type > x)
{
  this->Average_Frames_.set (x);
}

const ContrastDlg::Contrast_YAxis_Max_type& ContrastDlg::
Contrast_YAxis_Max () const
{
  return this->Contrast_YAxis_Max_.get ();
}

ContrastDlg::Contrast_YAxis_Max_type& ContrastDlg::
Contrast_YAxis_Max ()
{
  return this->Contrast_YAxis_Max_.get ();
}

void ContrastDlg::
Contrast_YAxis_Max (const Contrast_YAxis_Max_type& x)
{
  this->Contrast_YAxis_Max_.set (x);
}

void ContrastDlg::
Contrast_YAxis_Max (::std::auto_ptr< Contrast_YAxis_Max_type > x)
{
  this->Contrast_YAxis_Max_.set (x);
}

const ContrastDlg::Draw_Destroy_Markers_type& ContrastDlg::
Draw_Destroy_Markers () const
{
  return this->Draw_Destroy_Markers_.get ();
}

ContrastDlg::Draw_Destroy_Markers_type& ContrastDlg::
Draw_Destroy_Markers ()
{
  return this->Draw_Destroy_Markers_.get ();
}

void ContrastDlg::
Draw_Destroy_Markers (const Draw_Destroy_Markers_type& x)
{
  this->Draw_Destroy_Markers_.set (x);
}

void ContrastDlg::
Draw_Destroy_Markers (::std::auto_ptr< Draw_Destroy_Markers_type > x)
{
  this->Draw_Destroy_Markers_.set (x);
}

const ContrastDlg::Draw_Time_Axis_type& ContrastDlg::
Draw_Time_Axis () const
{
  return this->Draw_Time_Axis_.get ();
}

ContrastDlg::Draw_Time_Axis_type& ContrastDlg::
Draw_Time_Axis ()
{
  return this->Draw_Time_Axis_.get ();
}

void ContrastDlg::
Draw_Time_Axis (const Draw_Time_Axis_type& x)
{
  this->Draw_Time_Axis_.set (x);
}

void ContrastDlg::
Draw_Time_Axis (::std::auto_ptr< Draw_Time_Axis_type > x)
{
  this->Draw_Time_Axis_.set (x);
}

const ContrastDlg::Draw_Cardiac_Grayscale_type& ContrastDlg::
Draw_Cardiac_Grayscale () const
{
  return this->Draw_Cardiac_Grayscale_.get ();
}

ContrastDlg::Draw_Cardiac_Grayscale_type& ContrastDlg::
Draw_Cardiac_Grayscale ()
{
  return this->Draw_Cardiac_Grayscale_.get ();
}

void ContrastDlg::
Draw_Cardiac_Grayscale (const Draw_Cardiac_Grayscale_type& x)
{
  this->Draw_Cardiac_Grayscale_.set (x);
}

void ContrastDlg::
Draw_Cardiac_Grayscale (::std::auto_ptr< Draw_Cardiac_Grayscale_type > x)
{
  this->Draw_Cardiac_Grayscale_.set (x);
}

const ContrastDlg::Draw_Grayscale_type& ContrastDlg::
Draw_Grayscale () const
{
  return this->Draw_Grayscale_.get ();
}

ContrastDlg::Draw_Grayscale_type& ContrastDlg::
Draw_Grayscale ()
{
  return this->Draw_Grayscale_.get ();
}

void ContrastDlg::
Draw_Grayscale (const Draw_Grayscale_type& x)
{
  this->Draw_Grayscale_.set (x);
}

void ContrastDlg::
Draw_Grayscale (::std::auto_ptr< Draw_Grayscale_type > x)
{
  this->Draw_Grayscale_.set (x);
}

const ContrastDlg::Draw_Markers_type& ContrastDlg::
Draw_Markers () const
{
  return this->Draw_Markers_.get ();
}

ContrastDlg::Draw_Markers_type& ContrastDlg::
Draw_Markers ()
{
  return this->Draw_Markers_.get ();
}

void ContrastDlg::
Draw_Markers (const Draw_Markers_type& x)
{
  this->Draw_Markers_.set (x);
}

void ContrastDlg::
Draw_Markers (::std::auto_ptr< Draw_Markers_type > x)
{
  this->Draw_Markers_.set (x);
}

const ContrastDlg::Contrast_Linear_type& ContrastDlg::
Contrast_Linear () const
{
  return this->Contrast_Linear_.get ();
}

ContrastDlg::Contrast_Linear_type& ContrastDlg::
Contrast_Linear ()
{
  return this->Contrast_Linear_.get ();
}

void ContrastDlg::
Contrast_Linear (const Contrast_Linear_type& x)
{
  this->Contrast_Linear_.set (x);
}

void ContrastDlg::
Contrast_Linear (::std::auto_ptr< Contrast_Linear_type > x)
{
  this->Contrast_Linear_.set (x);
}

const ContrastDlg::Cardiac_YAxis_Max_type& ContrastDlg::
Cardiac_YAxis_Max () const
{
  return this->Cardiac_YAxis_Max_.get ();
}

ContrastDlg::Cardiac_YAxis_Max_type& ContrastDlg::
Cardiac_YAxis_Max ()
{
  return this->Cardiac_YAxis_Max_.get ();
}

void ContrastDlg::
Cardiac_YAxis_Max (const Cardiac_YAxis_Max_type& x)
{
  this->Cardiac_YAxis_Max_.set (x);
}

void ContrastDlg::
Cardiac_YAxis_Max (::std::auto_ptr< Cardiac_YAxis_Max_type > x)
{
  this->Cardiac_YAxis_Max_.set (x);
}

const ContrastDlg::Cardiac_YAxis_Auto_Scale_type& ContrastDlg::
Cardiac_YAxis_Auto_Scale () const
{
  return this->Cardiac_YAxis_Auto_Scale_.get ();
}

ContrastDlg::Cardiac_YAxis_Auto_Scale_type& ContrastDlg::
Cardiac_YAxis_Auto_Scale ()
{
  return this->Cardiac_YAxis_Auto_Scale_.get ();
}

void ContrastDlg::
Cardiac_YAxis_Auto_Scale (const Cardiac_YAxis_Auto_Scale_type& x)
{
  this->Cardiac_YAxis_Auto_Scale_.set (x);
}

void ContrastDlg::
Cardiac_YAxis_Auto_Scale (::std::auto_ptr< Cardiac_YAxis_Auto_Scale_type > x)
{
  this->Cardiac_YAxis_Auto_Scale_.set (x);
}

const ContrastDlg::Draw_Moving_Average_type& ContrastDlg::
Draw_Moving_Average () const
{
  return this->Draw_Moving_Average_.get ();
}

ContrastDlg::Draw_Moving_Average_type& ContrastDlg::
Draw_Moving_Average ()
{
  return this->Draw_Moving_Average_.get ();
}

void ContrastDlg::
Draw_Moving_Average (const Draw_Moving_Average_type& x)
{
  this->Draw_Moving_Average_.set (x);
}

void ContrastDlg::
Draw_Moving_Average (::std::auto_ptr< Draw_Moving_Average_type > x)
{
  this->Draw_Moving_Average_.set (x);
}

const ContrastDlg::Draw_Percent_Area_type& ContrastDlg::
Draw_Percent_Area () const
{
  return this->Draw_Percent_Area_.get ();
}

ContrastDlg::Draw_Percent_Area_type& ContrastDlg::
Draw_Percent_Area ()
{
  return this->Draw_Percent_Area_.get ();
}

void ContrastDlg::
Draw_Percent_Area (const Draw_Percent_Area_type& x)
{
  this->Draw_Percent_Area_.set (x);
}

void ContrastDlg::
Draw_Percent_Area (::std::auto_ptr< Draw_Percent_Area_type > x)
{
  this->Draw_Percent_Area_.set (x);
}

const ContrastDlg::Percent_Area_Thresh_type& ContrastDlg::
Percent_Area_Thresh () const
{
  return this->Percent_Area_Thresh_.get ();
}

ContrastDlg::Percent_Area_Thresh_type& ContrastDlg::
Percent_Area_Thresh ()
{
  return this->Percent_Area_Thresh_.get ();
}

void ContrastDlg::
Percent_Area_Thresh (const Percent_Area_Thresh_type& x)
{
  this->Percent_Area_Thresh_.set (x);
}

void ContrastDlg::
Percent_Area_Thresh (::std::auto_ptr< Percent_Area_Thresh_type > x)
{
  this->Percent_Area_Thresh_.set (x);
}

const ContrastDlg::Cardiac_Display_Frame_type& ContrastDlg::
Cardiac_Display_Frame () const
{
  return this->Cardiac_Display_Frame_.get ();
}

ContrastDlg::Cardiac_Display_Frame_type& ContrastDlg::
Cardiac_Display_Frame ()
{
  return this->Cardiac_Display_Frame_.get ();
}

void ContrastDlg::
Cardiac_Display_Frame (const Cardiac_Display_Frame_type& x)
{
  this->Cardiac_Display_Frame_.set (x);
}

void ContrastDlg::
Cardiac_Display_Frame (::std::auto_ptr< Cardiac_Display_Frame_type > x)
{
  this->Cardiac_Display_Frame_.set (x);
}


// Diag1
// 

const Diag1::Mem_Pagefile_type& Diag1::
Mem_Pagefile () const
{
  return this->Mem_Pagefile_.get ();
}

Diag1::Mem_Pagefile_type& Diag1::
Mem_Pagefile ()
{
  return this->Mem_Pagefile_.get ();
}

void Diag1::
Mem_Pagefile (const Mem_Pagefile_type& x)
{
  this->Mem_Pagefile_.set (x);
}

void Diag1::
Mem_Pagefile (::std::auto_ptr< Mem_Pagefile_type > x)
{
  this->Mem_Pagefile_.set (x);
}

const Diag1::Monitor_3point3V_type& Diag1::
Monitor_3point3V () const
{
  return this->Monitor_3point3V_.get ();
}

Diag1::Monitor_3point3V_type& Diag1::
Monitor_3point3V ()
{
  return this->Monitor_3point3V_.get ();
}

void Diag1::
Monitor_3point3V (const Monitor_3point3V_type& x)
{
  this->Monitor_3point3V_.set (x);
}

void Diag1::
Monitor_3point3V (::std::auto_ptr< Monitor_3point3V_type > x)
{
  this->Monitor_3point3V_.set (x);
}

const Diag1::USER_Objects_type& Diag1::
USER_Objects () const
{
  return this->USER_Objects_.get ();
}

Diag1::USER_Objects_type& Diag1::
USER_Objects ()
{
  return this->USER_Objects_.get ();
}

void Diag1::
USER_Objects (const USER_Objects_type& x)
{
  this->USER_Objects_.set (x);
}

void Diag1::
USER_Objects (::std::auto_ptr< USER_Objects_type > x)
{
  this->USER_Objects_.set (x);
}

const Diag1::Motor_FPGA_Revision_type& Diag1::
Motor_FPGA_Revision () const
{
  return this->Motor_FPGA_Revision_.get ();
}

Diag1::Motor_FPGA_Revision_type& Diag1::
Motor_FPGA_Revision ()
{
  return this->Motor_FPGA_Revision_.get ();
}

void Diag1::
Motor_FPGA_Revision (const Motor_FPGA_Revision_type& x)
{
  this->Motor_FPGA_Revision_.set (x);
}

void Diag1::
Motor_FPGA_Revision (::std::auto_ptr< Motor_FPGA_Revision_type > x)
{
  this->Motor_FPGA_Revision_.set (x);
}

const Diag1::Product_Name_type& Diag1::
Product_Name () const
{
  return this->Product_Name_.get ();
}

Diag1::Product_Name_type& Diag1::
Product_Name ()
{
  return this->Product_Name_.get ();
}

void Diag1::
Product_Name (const Product_Name_type& x)
{
  this->Product_Name_.set (x);
}

void Diag1::
Product_Name (::std::auto_ptr< Product_Name_type > x)
{
  this->Product_Name_.set (x);
}

const Diag1::Build_Version_type& Diag1::
Build_Version () const
{
  return this->Build_Version_.get ();
}

Diag1::Build_Version_type& Diag1::
Build_Version ()
{
  return this->Build_Version_.get ();
}

void Diag1::
Build_Version (const Build_Version_type& x)
{
  this->Build_Version_.set (x);
}

void Diag1::
Build_Version (::std::auto_ptr< Build_Version_type > x)
{
  this->Build_Version_.set (x);
}

const Diag1::ICB_PCB_ID_type& Diag1::
ICB_PCB_ID () const
{
  return this->ICB_PCB_ID_.get ();
}

Diag1::ICB_PCB_ID_type& Diag1::
ICB_PCB_ID ()
{
  return this->ICB_PCB_ID_.get ();
}

void Diag1::
ICB_PCB_ID (const ICB_PCB_ID_type& x)
{
  this->ICB_PCB_ID_.set (x);
}

void Diag1::
ICB_PCB_ID (::std::auto_ptr< ICB_PCB_ID_type > x)
{
  this->ICB_PCB_ID_.set (x);
}

const Diag1::Software_Version_type& Diag1::
Software_Version () const
{
  return this->Software_Version_.get ();
}

Diag1::Software_Version_type& Diag1::
Software_Version ()
{
  return this->Software_Version_.get ();
}

void Diag1::
Software_Version (const Software_Version_type& x)
{
  this->Software_Version_.set (x);
}

void Diag1::
Software_Version (::std::auto_ptr< Software_Version_type > x)
{
  this->Software_Version_.set (x);
}

const Diag1::Receive_PCB_ID_type& Diag1::
Receive_PCB_ID () const
{
  return this->Receive_PCB_ID_.get ();
}

Diag1::Receive_PCB_ID_type& Diag1::
Receive_PCB_ID ()
{
  return this->Receive_PCB_ID_.get ();
}

void Diag1::
Receive_PCB_ID (const Receive_PCB_ID_type& x)
{
  this->Receive_PCB_ID_.set (x);
}

void Diag1::
Receive_PCB_ID (::std::auto_ptr< Receive_PCB_ID_type > x)
{
  this->Receive_PCB_ID_.set (x);
}

const Diag1::Mem_Private_type& Diag1::
Mem_Private () const
{
  return this->Mem_Private_.get ();
}

Diag1::Mem_Private_type& Diag1::
Mem_Private ()
{
  return this->Mem_Private_.get ();
}

void Diag1::
Mem_Private (const Mem_Private_type& x)
{
  this->Mem_Private_.set (x);
}

void Diag1::
Mem_Private (::std::auto_ptr< Mem_Private_type > x)
{
  this->Mem_Private_.set (x);
}

const Diag1::Monitor_5V_type& Diag1::
Monitor_5V () const
{
  return this->Monitor_5V_.get ();
}

Diag1::Monitor_5V_type& Diag1::
Monitor_5V ()
{
  return this->Monitor_5V_.get ();
}

void Diag1::
Monitor_5V (const Monitor_5V_type& x)
{
  this->Monitor_5V_.set (x);
}

void Diag1::
Monitor_5V (::std::auto_ptr< Monitor_5V_type > x)
{
  this->Monitor_5V_.set (x);
}

const Diag1::Motor_PCB_Revision_type& Diag1::
Motor_PCB_Revision () const
{
  return this->Motor_PCB_Revision_.get ();
}

Diag1::Motor_PCB_Revision_type& Diag1::
Motor_PCB_Revision ()
{
  return this->Motor_PCB_Revision_.get ();
}

void Diag1::
Motor_PCB_Revision (const Motor_PCB_Revision_type& x)
{
  this->Motor_PCB_Revision_.set (x);
}

void Diag1::
Motor_PCB_Revision (::std::auto_ptr< Motor_PCB_Revision_type > x)
{
  this->Motor_PCB_Revision_.set (x);
}

const Diag1::NE1619_type& Diag1::
NE1619 () const
{
  return this->NE1619_.get ();
}

Diag1::NE1619_type& Diag1::
NE1619 ()
{
  return this->NE1619_.get ();
}

void Diag1::
NE1619 (const NE1619_type& x)
{
  this->NE1619_.set (x);
}

void Diag1::
NE1619 (::std::auto_ptr< NE1619_type > x)
{
  this->NE1619_.set (x);
}

const Diag1::Motor_PCB_ID_type& Diag1::
Motor_PCB_ID () const
{
  return this->Motor_PCB_ID_.get ();
}

Diag1::Motor_PCB_ID_type& Diag1::
Motor_PCB_ID ()
{
  return this->Motor_PCB_ID_.get ();
}

void Diag1::
Motor_PCB_ID (const Motor_PCB_ID_type& x)
{
  this->Motor_PCB_ID_.set (x);
}

void Diag1::
Motor_PCB_ID (::std::auto_ptr< Motor_PCB_ID_type > x)
{
  this->Motor_PCB_ID_.set (x);
}

const Diag1::Transmit_PCB_Revision_type& Diag1::
Transmit_PCB_Revision () const
{
  return this->Transmit_PCB_Revision_.get ();
}

Diag1::Transmit_PCB_Revision_type& Diag1::
Transmit_PCB_Revision ()
{
  return this->Transmit_PCB_Revision_.get ();
}

void Diag1::
Transmit_PCB_Revision (const Transmit_PCB_Revision_type& x)
{
  this->Transmit_PCB_Revision_.set (x);
}

void Diag1::
Transmit_PCB_Revision (::std::auto_ptr< Transmit_PCB_Revision_type > x)
{
  this->Transmit_PCB_Revision_.set (x);
}

const Diag1::MAX1137_type& Diag1::
MAX1137 () const
{
  return this->MAX1137_.get ();
}

Diag1::MAX1137_type& Diag1::
MAX1137 ()
{
  return this->MAX1137_.get ();
}

void Diag1::
MAX1137 (const MAX1137_type& x)
{
  this->MAX1137_.set (x);
}

void Diag1::
MAX1137 (::std::auto_ptr< MAX1137_type > x)
{
  this->MAX1137_.set (x);
}

const Diag1::Monitor_Neg15V_type& Diag1::
Monitor_Neg15V () const
{
  return this->Monitor_Neg15V_.get ();
}

Diag1::Monitor_Neg15V_type& Diag1::
Monitor_Neg15V ()
{
  return this->Monitor_Neg15V_.get ();
}

void Diag1::
Monitor_Neg15V (const Monitor_Neg15V_type& x)
{
  this->Monitor_Neg15V_.set (x);
}

void Diag1::
Monitor_Neg15V (::std::auto_ptr< Monitor_Neg15V_type > x)
{
  this->Monitor_Neg15V_.set (x);
}

const Diag1::Monitor_Neg5V_type& Diag1::
Monitor_Neg5V () const
{
  return this->Monitor_Neg5V_.get ();
}

Diag1::Monitor_Neg5V_type& Diag1::
Monitor_Neg5V ()
{
  return this->Monitor_Neg5V_.get ();
}

void Diag1::
Monitor_Neg5V (const Monitor_Neg5V_type& x)
{
  this->Monitor_Neg5V_.set (x);
}

void Diag1::
Monitor_Neg5V (::std::auto_ptr< Monitor_Neg5V_type > x)
{
  this->Monitor_Neg5V_.set (x);
}

const Diag1::Switch_PCB_Revision_type& Diag1::
Switch_PCB_Revision () const
{
  return this->Switch_PCB_Revision_.get ();
}

Diag1::Switch_PCB_Revision_type& Diag1::
Switch_PCB_Revision ()
{
  return this->Switch_PCB_Revision_.get ();
}

void Diag1::
Switch_PCB_Revision (const Switch_PCB_Revision_type& x)
{
  this->Switch_PCB_Revision_.set (x);
}

void Diag1::
Switch_PCB_Revision (::std::auto_ptr< Switch_PCB_Revision_type > x)
{
  this->Switch_PCB_Revision_.set (x);
}

const Diag1::Receive_PCB_Revision_type& Diag1::
Receive_PCB_Revision () const
{
  return this->Receive_PCB_Revision_.get ();
}

Diag1::Receive_PCB_Revision_type& Diag1::
Receive_PCB_Revision ()
{
  return this->Receive_PCB_Revision_.get ();
}

void Diag1::
Receive_PCB_Revision (const Receive_PCB_Revision_type& x)
{
  this->Receive_PCB_Revision_.set (x);
}

void Diag1::
Receive_PCB_Revision (::std::auto_ptr< Receive_PCB_Revision_type > x)
{
  this->Receive_PCB_Revision_.set (x);
}

const Diag1::ICB_PCB_Revision_type& Diag1::
ICB_PCB_Revision () const
{
  return this->ICB_PCB_Revision_.get ();
}

Diag1::ICB_PCB_Revision_type& Diag1::
ICB_PCB_Revision ()
{
  return this->ICB_PCB_Revision_.get ();
}

void Diag1::
ICB_PCB_Revision (const ICB_PCB_Revision_type& x)
{
  this->ICB_PCB_Revision_.set (x);
}

void Diag1::
ICB_PCB_Revision (::std::auto_ptr< ICB_PCB_Revision_type > x)
{
  this->ICB_PCB_Revision_.set (x);
}

const Diag1::Transmit_PCB_ID_type& Diag1::
Transmit_PCB_ID () const
{
  return this->Transmit_PCB_ID_.get ();
}

Diag1::Transmit_PCB_ID_type& Diag1::
Transmit_PCB_ID ()
{
  return this->Transmit_PCB_ID_.get ();
}

void Diag1::
Transmit_PCB_ID (const Transmit_PCB_ID_type& x)
{
  this->Transmit_PCB_ID_.set (x);
}

void Diag1::
Transmit_PCB_ID (::std::auto_ptr< Transmit_PCB_ID_type > x)
{
  this->Transmit_PCB_ID_.set (x);
}

const Diag1::Monitor_Temperature_type& Diag1::
Monitor_Temperature () const
{
  return this->Monitor_Temperature_.get ();
}

Diag1::Monitor_Temperature_type& Diag1::
Monitor_Temperature ()
{
  return this->Monitor_Temperature_.get ();
}

void Diag1::
Monitor_Temperature (const Monitor_Temperature_type& x)
{
  this->Monitor_Temperature_.set (x);
}

void Diag1::
Monitor_Temperature (::std::auto_ptr< Monitor_Temperature_type > x)
{
  this->Monitor_Temperature_.set (x);
}

const Diag1::Receive_FPGA_Revision_type& Diag1::
Receive_FPGA_Revision () const
{
  return this->Receive_FPGA_Revision_.get ();
}

Diag1::Receive_FPGA_Revision_type& Diag1::
Receive_FPGA_Revision ()
{
  return this->Receive_FPGA_Revision_.get ();
}

void Diag1::
Receive_FPGA_Revision (const Receive_FPGA_Revision_type& x)
{
  this->Receive_FPGA_Revision_.set (x);
}

void Diag1::
Receive_FPGA_Revision (::std::auto_ptr< Receive_FPGA_Revision_type > x)
{
  this->Receive_FPGA_Revision_.set (x);
}

const Diag1::Monitor_15V_type& Diag1::
Monitor_15V () const
{
  return this->Monitor_15V_.get ();
}

Diag1::Monitor_15V_type& Diag1::
Monitor_15V ()
{
  return this->Monitor_15V_.get ();
}

void Diag1::
Monitor_15V (const Monitor_15V_type& x)
{
  this->Monitor_15V_.set (x);
}

void Diag1::
Monitor_15V (::std::auto_ptr< Monitor_15V_type > x)
{
  this->Monitor_15V_.set (x);
}

const Diag1::ICB_FPGA_Revision_type& Diag1::
ICB_FPGA_Revision () const
{
  return this->ICB_FPGA_Revision_.get ();
}

Diag1::ICB_FPGA_Revision_type& Diag1::
ICB_FPGA_Revision ()
{
  return this->ICB_FPGA_Revision_.get ();
}

void Diag1::
ICB_FPGA_Revision (const ICB_FPGA_Revision_type& x)
{
  this->ICB_FPGA_Revision_.set (x);
}

void Diag1::
ICB_FPGA_Revision (::std::auto_ptr< ICB_FPGA_Revision_type > x)
{
  this->ICB_FPGA_Revision_.set (x);
}

const Diag1::GDI_Objects_type& Diag1::
GDI_Objects () const
{
  return this->GDI_Objects_.get ();
}

Diag1::GDI_Objects_type& Diag1::
GDI_Objects ()
{
  return this->GDI_Objects_.get ();
}

void Diag1::
GDI_Objects (const GDI_Objects_type& x)
{
  this->GDI_Objects_.set (x);
}

void Diag1::
GDI_Objects (::std::auto_ptr< GDI_Objects_type > x)
{
  this->GDI_Objects_.set (x);
}

const Diag1::Mem_WorkingSet_type& Diag1::
Mem_WorkingSet () const
{
  return this->Mem_WorkingSet_.get ();
}

Diag1::Mem_WorkingSet_type& Diag1::
Mem_WorkingSet ()
{
  return this->Mem_WorkingSet_.get ();
}

void Diag1::
Mem_WorkingSet (const Mem_WorkingSet_type& x)
{
  this->Mem_WorkingSet_.set (x);
}

void Diag1::
Mem_WorkingSet (::std::auto_ptr< Mem_WorkingSet_type > x)
{
  this->Mem_WorkingSet_.set (x);
}

const Diag1::Switch_PCB_ID_type& Diag1::
Switch_PCB_ID () const
{
  return this->Switch_PCB_ID_.get ();
}

Diag1::Switch_PCB_ID_type& Diag1::
Switch_PCB_ID ()
{
  return this->Switch_PCB_ID_.get ();
}

void Diag1::
Switch_PCB_ID (const Switch_PCB_ID_type& x)
{
  this->Switch_PCB_ID_.set (x);
}

void Diag1::
Switch_PCB_ID (::std::auto_ptr< Switch_PCB_ID_type > x)
{
  this->Switch_PCB_ID_.set (x);
}


// ECG1
// 

const ECG1::Respiration_Threshold_Change_type& ECG1::
Respiration_Threshold_Change () const
{
  return this->Respiration_Threshold_Change_.get ();
}

ECG1::Respiration_Threshold_Change_type& ECG1::
Respiration_Threshold_Change ()
{
  return this->Respiration_Threshold_Change_.get ();
}

void ECG1::
Respiration_Threshold_Change (const Respiration_Threshold_Change_type& x)
{
  this->Respiration_Threshold_Change_.set (x);
}

void ECG1::
Respiration_Threshold_Change (::std::auto_ptr< Respiration_Threshold_Change_type > x)
{
  this->Respiration_Threshold_Change_.set (x);
}

const ECG1::Respiration_Threshold_type& ECG1::
Respiration_Threshold () const
{
  return this->Respiration_Threshold_.get ();
}

ECG1::Respiration_Threshold_type& ECG1::
Respiration_Threshold ()
{
  return this->Respiration_Threshold_.get ();
}

void ECG1::
Respiration_Threshold (const Respiration_Threshold_type& x)
{
  this->Respiration_Threshold_.set (x);
}

void ECG1::
Respiration_Threshold (::std::auto_ptr< Respiration_Threshold_type > x)
{
  this->Respiration_Threshold_.set (x);
}

const ECG1::Pressure_Range_type& ECG1::
Pressure_Range () const
{
  return this->Pressure_Range_.get ();
}

ECG1::Pressure_Range_type& ECG1::
Pressure_Range ()
{
  return this->Pressure_Range_.get ();
}

void ECG1::
Pressure_Range (const Pressure_Range_type& x)
{
  this->Pressure_Range_.set (x);
}

void ECG1::
Pressure_Range (::std::auto_ptr< Pressure_Range_type > x)
{
  this->Pressure_Range_.set (x);
}

const ECG1::Respiration_Gate_Delay_type& ECG1::
Respiration_Gate_Delay () const
{
  return this->Respiration_Gate_Delay_.get ();
}

ECG1::Respiration_Gate_Delay_type& ECG1::
Respiration_Gate_Delay ()
{
  return this->Respiration_Gate_Delay_.get ();
}

void ECG1::
Respiration_Gate_Delay (const Respiration_Gate_Delay_type& x)
{
  this->Respiration_Gate_Delay_.set (x);
}

void ECG1::
Respiration_Gate_Delay (::std::auto_ptr< Respiration_Gate_Delay_type > x)
{
  this->Respiration_Gate_Delay_.set (x);
}

const ECG1::Respiration_Timeout_type& ECG1::
Respiration_Timeout () const
{
  return this->Respiration_Timeout_.get ();
}

ECG1::Respiration_Timeout_type& ECG1::
Respiration_Timeout ()
{
  return this->Respiration_Timeout_.get ();
}

void ECG1::
Respiration_Timeout (const Respiration_Timeout_type& x)
{
  this->Respiration_Timeout_.set (x);
}

void ECG1::
Respiration_Timeout (::std::auto_ptr< Respiration_Timeout_type > x)
{
  this->Respiration_Timeout_.set (x);
}

const ECG1::RWave_Max_Change_Factor_Percent_type& ECG1::
RWave_Max_Change_Factor_Percent () const
{
  return this->RWave_Max_Change_Factor_Percent_.get ();
}

ECG1::RWave_Max_Change_Factor_Percent_type& ECG1::
RWave_Max_Change_Factor_Percent ()
{
  return this->RWave_Max_Change_Factor_Percent_.get ();
}

void ECG1::
RWave_Max_Change_Factor_Percent (const RWave_Max_Change_Factor_Percent_type& x)
{
  this->RWave_Max_Change_Factor_Percent_.set (x);
}

void ECG1::
RWave_Max_Change_Factor_Percent (::std::auto_ptr< RWave_Max_Change_Factor_Percent_type > x)
{
  this->RWave_Max_Change_Factor_Percent_.set (x);
}

const ECG1::Respiration_Period_type& ECG1::
Respiration_Period () const
{
  return this->Respiration_Period_.get ();
}

ECG1::Respiration_Period_type& ECG1::
Respiration_Period ()
{
  return this->Respiration_Period_.get ();
}

void ECG1::
Respiration_Period (const Respiration_Period_type& x)
{
  this->Respiration_Period_.set (x);
}

void ECG1::
Respiration_Period (::std::auto_ptr< Respiration_Period_type > x)
{
  this->Respiration_Period_.set (x);
}

const ECG1::Respiration_Subsample_Rate_type& ECG1::
Respiration_Subsample_Rate () const
{
  return this->Respiration_Subsample_Rate_.get ();
}

ECG1::Respiration_Subsample_Rate_type& ECG1::
Respiration_Subsample_Rate ()
{
  return this->Respiration_Subsample_Rate_.get ();
}

void ECG1::
Respiration_Subsample_Rate (const Respiration_Subsample_Rate_type& x)
{
  this->Respiration_Subsample_Rate_.set (x);
}

void ECG1::
Respiration_Subsample_Rate (::std::auto_ptr< Respiration_Subsample_Rate_type > x)
{
  this->Respiration_Subsample_Rate_.set (x);
}

const ECG1::Show_RWaves_type& ECG1::
Show_RWaves () const
{
  return this->Show_RWaves_.get ();
}

ECG1::Show_RWaves_type& ECG1::
Show_RWaves ()
{
  return this->Show_RWaves_.get ();
}

void ECG1::
Show_RWaves (const Show_RWaves_type& x)
{
  this->Show_RWaves_.set (x);
}

void ECG1::
Show_RWaves (::std::auto_ptr< Show_RWaves_type > x)
{
  this->Show_RWaves_.set (x);
}

const ECG1::Respiration_Minimal_Peak_2_Peak_type& ECG1::
Respiration_Minimal_Peak_2_Peak () const
{
  return this->Respiration_Minimal_Peak_2_Peak_.get ();
}

ECG1::Respiration_Minimal_Peak_2_Peak_type& ECG1::
Respiration_Minimal_Peak_2_Peak ()
{
  return this->Respiration_Minimal_Peak_2_Peak_.get ();
}

void ECG1::
Respiration_Minimal_Peak_2_Peak (const Respiration_Minimal_Peak_2_Peak_type& x)
{
  this->Respiration_Minimal_Peak_2_Peak_.set (x);
}

void ECG1::
Respiration_Minimal_Peak_2_Peak (::std::auto_ptr< Respiration_Minimal_Peak_2_Peak_type > x)
{
  this->Respiration_Minimal_Peak_2_Peak_.set (x);
}

const ECG1::Respiration_Window_type& ECG1::
Respiration_Window () const
{
  return this->Respiration_Window_.get ();
}

ECG1::Respiration_Window_type& ECG1::
Respiration_Window ()
{
  return this->Respiration_Window_.get ();
}

void ECG1::
Respiration_Window (const Respiration_Window_type& x)
{
  this->Respiration_Window_.set (x);
}

void ECG1::
Respiration_Window (::std::auto_ptr< Respiration_Window_type > x)
{
  this->Respiration_Window_.set (x);
}

const ECG1::Pressure_Zeroed_type& ECG1::
Pressure_Zeroed () const
{
  return this->Pressure_Zeroed_.get ();
}

ECG1::Pressure_Zeroed_type& ECG1::
Pressure_Zeroed ()
{
  return this->Pressure_Zeroed_.get ();
}

void ECG1::
Pressure_Zeroed (const Pressure_Zeroed_type& x)
{
  this->Pressure_Zeroed_.set (x);
}

void ECG1::
Pressure_Zeroed (::std::auto_ptr< Pressure_Zeroed_type > x)
{
  this->Pressure_Zeroed_.set (x);
}

const ECG1::Pressure_Systolic_type& ECG1::
Pressure_Systolic () const
{
  return this->Pressure_Systolic_.get ();
}

ECG1::Pressure_Systolic_type& ECG1::
Pressure_Systolic ()
{
  return this->Pressure_Systolic_.get ();
}

void ECG1::
Pressure_Systolic (const Pressure_Systolic_type& x)
{
  this->Pressure_Systolic_.set (x);
}

void ECG1::
Pressure_Systolic (::std::auto_ptr< Pressure_Systolic_type > x)
{
  this->Pressure_Systolic_.set (x);
}

const ECG1::Respiration_Show_Window_type& ECG1::
Respiration_Show_Window () const
{
  return this->Respiration_Show_Window_.get ();
}

ECG1::Respiration_Show_Window_type& ECG1::
Respiration_Show_Window ()
{
  return this->Respiration_Show_Window_.get ();
}

void ECG1::
Respiration_Show_Window (const Respiration_Show_Window_type& x)
{
  this->Respiration_Show_Window_.set (x);
}

void ECG1::
Respiration_Show_Window (::std::auto_ptr< Respiration_Show_Window_type > x)
{
  this->Respiration_Show_Window_.set (x);
}

const ECG1::Frequency_type& ECG1::
Frequency () const
{
  return this->Frequency_.get ();
}

ECG1::Frequency_type& ECG1::
Frequency ()
{
  return this->Frequency_.get ();
}

void ECG1::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void ECG1::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const ECG1::Respiration_Blank_Period_type& ECG1::
Respiration_Blank_Period () const
{
  return this->Respiration_Blank_Period_.get ();
}

ECG1::Respiration_Blank_Period_type& ECG1::
Respiration_Blank_Period ()
{
  return this->Respiration_Blank_Period_.get ();
}

void ECG1::
Respiration_Blank_Period (const Respiration_Blank_Period_type& x)
{
  this->Respiration_Blank_Period_.set (x);
}

void ECG1::
Respiration_Blank_Period (::std::auto_ptr< Respiration_Blank_Period_type > x)
{
  this->Respiration_Blank_Period_.set (x);
}

const ECG1::Respiration_Range_type& ECG1::
Respiration_Range () const
{
  return this->Respiration_Range_.get ();
}

ECG1::Respiration_Range_type& ECG1::
Respiration_Range ()
{
  return this->Respiration_Range_.get ();
}

void ECG1::
Respiration_Range (const Respiration_Range_type& x)
{
  this->Respiration_Range_.set (x);
}

void ECG1::
Respiration_Range (::std::auto_ptr< Respiration_Range_type > x)
{
  this->Respiration_Range_.set (x);
}

const ECG1::Pressure_Zero_type& ECG1::
Pressure_Zero () const
{
  return this->Pressure_Zero_.get ();
}

ECG1::Pressure_Zero_type& ECG1::
Pressure_Zero ()
{
  return this->Pressure_Zero_.get ();
}

void ECG1::
Pressure_Zero (const Pressure_Zero_type& x)
{
  this->Pressure_Zero_.set (x);
}

void ECG1::
Pressure_Zero (::std::auto_ptr< Pressure_Zero_type > x)
{
  this->Pressure_Zero_.set (x);
}

const ECG1::Temperature_Amplification_type& ECG1::
Temperature_Amplification () const
{
  return this->Temperature_Amplification_.get ();
}

ECG1::Temperature_Amplification_type& ECG1::
Temperature_Amplification ()
{
  return this->Temperature_Amplification_.get ();
}

void ECG1::
Temperature_Amplification (const Temperature_Amplification_type& x)
{
  this->Temperature_Amplification_.set (x);
}

void ECG1::
Temperature_Amplification (::std::auto_ptr< Temperature_Amplification_type > x)
{
  this->Temperature_Amplification_.set (x);
}

const ECG1::P_Wave_Start_type& ECG1::
P_Wave_Start () const
{
  return this->P_Wave_Start_.get ();
}

ECG1::P_Wave_Start_type& ECG1::
P_Wave_Start ()
{
  return this->P_Wave_Start_.get ();
}

void ECG1::
P_Wave_Start (const P_Wave_Start_type& x)
{
  this->P_Wave_Start_.set (x);
}

void ECG1::
P_Wave_Start (::std::auto_ptr< P_Wave_Start_type > x)
{
  this->P_Wave_Start_.set (x);
}

const ECG1::ECG_Filter_Taps_type& ECG1::
ECG_Filter_Taps () const
{
  return this->ECG_Filter_Taps_.get ();
}

ECG1::ECG_Filter_Taps_type& ECG1::
ECG_Filter_Taps ()
{
  return this->ECG_Filter_Taps_.get ();
}

void ECG1::
ECG_Filter_Taps (const ECG_Filter_Taps_type& x)
{
  this->ECG_Filter_Taps_.set (x);
}

void ECG1::
ECG_Filter_Taps (::std::auto_ptr< ECG_Filter_Taps_type > x)
{
  this->ECG_Filter_Taps_.set (x);
}

const ECG1::Respiration_Percent_Peak_type& ECG1::
Respiration_Percent_Peak () const
{
  return this->Respiration_Percent_Peak_.get ();
}

ECG1::Respiration_Percent_Peak_type& ECG1::
Respiration_Percent_Peak ()
{
  return this->Respiration_Percent_Peak_.get ();
}

void ECG1::
Respiration_Percent_Peak (const Respiration_Percent_Peak_type& x)
{
  this->Respiration_Percent_Peak_.set (x);
}

void ECG1::
Respiration_Percent_Peak (::std::auto_ptr< Respiration_Percent_Peak_type > x)
{
  this->Respiration_Percent_Peak_.set (x);
}

const ECG1::T_Wave_Start_type& ECG1::
T_Wave_Start () const
{
  return this->T_Wave_Start_.get ();
}

ECG1::T_Wave_Start_type& ECG1::
T_Wave_Start ()
{
  return this->T_Wave_Start_.get ();
}

void ECG1::
T_Wave_Start (const T_Wave_Start_type& x)
{
  this->T_Wave_Start_.set (x);
}

void ECG1::
T_Wave_Start (::std::auto_ptr< T_Wave_Start_type > x)
{
  this->T_Wave_Start_.set (x);
}

const ECG1::Strain_Rate_RR_Diff_Ratio_type& ECG1::
Strain_Rate_RR_Diff_Ratio () const
{
  return this->Strain_Rate_RR_Diff_Ratio_.get ();
}

ECG1::Strain_Rate_RR_Diff_Ratio_type& ECG1::
Strain_Rate_RR_Diff_Ratio ()
{
  return this->Strain_Rate_RR_Diff_Ratio_.get ();
}

void ECG1::
Strain_Rate_RR_Diff_Ratio (const Strain_Rate_RR_Diff_Ratio_type& x)
{
  this->Strain_Rate_RR_Diff_Ratio_.set (x);
}

void ECG1::
Strain_Rate_RR_Diff_Ratio (::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type > x)
{
  this->Strain_Rate_RR_Diff_Ratio_.set (x);
}

const ECG1::Pressure_Calibration_Min_Level_type& ECG1::
Pressure_Calibration_Min_Level () const
{
  return this->Pressure_Calibration_Min_Level_.get ();
}

ECG1::Pressure_Calibration_Min_Level_type& ECG1::
Pressure_Calibration_Min_Level ()
{
  return this->Pressure_Calibration_Min_Level_.get ();
}

void ECG1::
Pressure_Calibration_Min_Level (const Pressure_Calibration_Min_Level_type& x)
{
  this->Pressure_Calibration_Min_Level_.set (x);
}

void ECG1::
Pressure_Calibration_Min_Level (::std::auto_ptr< Pressure_Calibration_Min_Level_type > x)
{
  this->Pressure_Calibration_Min_Level_.set (x);
}

const ECG1::DPDT_Range_type& ECG1::
DPDT_Range () const
{
  return this->DPDT_Range_.get ();
}

ECG1::DPDT_Range_type& ECG1::
DPDT_Range ()
{
  return this->DPDT_Range_.get ();
}

void ECG1::
DPDT_Range (const DPDT_Range_type& x)
{
  this->DPDT_Range_.set (x);
}

void ECG1::
DPDT_Range (::std::auto_ptr< DPDT_Range_type > x)
{
  this->DPDT_Range_.set (x);
}

const ECG1::Respiration_Show_Event_type& ECG1::
Respiration_Show_Event () const
{
  return this->Respiration_Show_Event_.get ();
}

ECG1::Respiration_Show_Event_type& ECG1::
Respiration_Show_Event ()
{
  return this->Respiration_Show_Event_.get ();
}

void ECG1::
Respiration_Show_Event (const Respiration_Show_Event_type& x)
{
  this->Respiration_Show_Event_.set (x);
}

void ECG1::
Respiration_Show_Event (::std::auto_ptr< Respiration_Show_Event_type > x)
{
  this->Respiration_Show_Event_.set (x);
}

const ECG1::Pressure_Diastolic_type& ECG1::
Pressure_Diastolic () const
{
  return this->Pressure_Diastolic_.get ();
}

ECG1::Pressure_Diastolic_type& ECG1::
Pressure_Diastolic ()
{
  return this->Pressure_Diastolic_.get ();
}

void ECG1::
Pressure_Diastolic (const Pressure_Diastolic_type& x)
{
  this->Pressure_Diastolic_.set (x);
}

void ECG1::
Pressure_Diastolic (::std::auto_ptr< Pressure_Diastolic_type > x)
{
  this->Pressure_Diastolic_.set (x);
}

const ECG1::Temperature_Calibration_type& ECG1::
Temperature_Calibration () const
{
  return this->Temperature_Calibration_.get ();
}

ECG1::Temperature_Calibration_type& ECG1::
Temperature_Calibration ()
{
  return this->Temperature_Calibration_.get ();
}

void ECG1::
Temperature_Calibration (const Temperature_Calibration_type& x)
{
  this->Temperature_Calibration_.set (x);
}

void ECG1::
Temperature_Calibration (::std::auto_ptr< Temperature_Calibration_type > x)
{
  this->Temperature_Calibration_.set (x);
}

const ECG1::Temperature_type& ECG1::
Temperature () const
{
  return this->Temperature_.get ();
}

ECG1::Temperature_type& ECG1::
Temperature ()
{
  return this->Temperature_.get ();
}

void ECG1::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void ECG1::
Temperature (::std::auto_ptr< Temperature_type > x)
{
  this->Temperature_.set (x);
}

const ECG1::Respiration_Beats_To_Average_type& ECG1::
Respiration_Beats_To_Average () const
{
  return this->Respiration_Beats_To_Average_.get ();
}

ECG1::Respiration_Beats_To_Average_type& ECG1::
Respiration_Beats_To_Average ()
{
  return this->Respiration_Beats_To_Average_.get ();
}

void ECG1::
Respiration_Beats_To_Average (const Respiration_Beats_To_Average_type& x)
{
  this->Respiration_Beats_To_Average_.set (x);
}

void ECG1::
Respiration_Beats_To_Average (::std::auto_ptr< Respiration_Beats_To_Average_type > x)
{
  this->Respiration_Beats_To_Average_.set (x);
}

const ECG1::RWave_Thresh_Trigger_Percent_type& ECG1::
RWave_Thresh_Trigger_Percent () const
{
  return this->RWave_Thresh_Trigger_Percent_.get ();
}

ECG1::RWave_Thresh_Trigger_Percent_type& ECG1::
RWave_Thresh_Trigger_Percent ()
{
  return this->RWave_Thresh_Trigger_Percent_.get ();
}

void ECG1::
RWave_Thresh_Trigger_Percent (const RWave_Thresh_Trigger_Percent_type& x)
{
  this->RWave_Thresh_Trigger_Percent_.set (x);
}

void ECG1::
RWave_Thresh_Trigger_Percent (::std::auto_ptr< RWave_Thresh_Trigger_Percent_type > x)
{
  this->RWave_Thresh_Trigger_Percent_.set (x);
}

const ECG1::Respiration_Time_To_Average_type& ECG1::
Respiration_Time_To_Average () const
{
  return this->Respiration_Time_To_Average_.get ();
}

ECG1::Respiration_Time_To_Average_type& ECG1::
Respiration_Time_To_Average ()
{
  return this->Respiration_Time_To_Average_.get ();
}

void ECG1::
Respiration_Time_To_Average (const Respiration_Time_To_Average_type& x)
{
  this->Respiration_Time_To_Average_.set (x);
}

void ECG1::
Respiration_Time_To_Average (::std::auto_ptr< Respiration_Time_To_Average_type > x)
{
  this->Respiration_Time_To_Average_.set (x);
}

const ECG1::Pressure_Amplification_type& ECG1::
Pressure_Amplification () const
{
  return this->Pressure_Amplification_.get ();
}

ECG1::Pressure_Amplification_type& ECG1::
Pressure_Amplification ()
{
  return this->Pressure_Amplification_.get ();
}

void ECG1::
Pressure_Amplification (const Pressure_Amplification_type& x)
{
  this->Pressure_Amplification_.set (x);
}

void ECG1::
Pressure_Amplification (::std::auto_ptr< Pressure_Amplification_type > x)
{
  this->Pressure_Amplification_.set (x);
}

const ECG1::Heart_Period_type& ECG1::
Heart_Period () const
{
  return this->Heart_Period_.get ();
}

ECG1::Heart_Period_type& ECG1::
Heart_Period ()
{
  return this->Heart_Period_.get ();
}

void ECG1::
Heart_Period (const Heart_Period_type& x)
{
  this->Heart_Period_.set (x);
}

void ECG1::
Heart_Period (::std::auto_ptr< Heart_Period_type > x)
{
  this->Heart_Period_.set (x);
}

const ECG1::Pressure_Show_Event_type& ECG1::
Pressure_Show_Event () const
{
  return this->Pressure_Show_Event_.get ();
}

ECG1::Pressure_Show_Event_type& ECG1::
Pressure_Show_Event ()
{
  return this->Pressure_Show_Event_.get ();
}

void ECG1::
Pressure_Show_Event (const Pressure_Show_Event_type& x)
{
  this->Pressure_Show_Event_.set (x);
}

void ECG1::
Pressure_Show_Event (::std::auto_ptr< Pressure_Show_Event_type > x)
{
  this->Pressure_Show_Event_.set (x);
}

const ECG1::RWave_Default_Threshold_type& ECG1::
RWave_Default_Threshold () const
{
  return this->RWave_Default_Threshold_.get ();
}

ECG1::RWave_Default_Threshold_type& ECG1::
RWave_Default_Threshold ()
{
  return this->RWave_Default_Threshold_.get ();
}

void ECG1::
RWave_Default_Threshold (const RWave_Default_Threshold_type& x)
{
  this->RWave_Default_Threshold_.set (x);
}

void ECG1::
RWave_Default_Threshold (::std::auto_ptr< RWave_Default_Threshold_type > x)
{
  this->RWave_Default_Threshold_.set (x);
}

const ECG1::Show_Filtered_Data_type& ECG1::
Show_Filtered_Data () const
{
  return this->Show_Filtered_Data_.get ();
}

ECG1::Show_Filtered_Data_type& ECG1::
Show_Filtered_Data ()
{
  return this->Show_Filtered_Data_.get ();
}

void ECG1::
Show_Filtered_Data (const Show_Filtered_Data_type& x)
{
  this->Show_Filtered_Data_.set (x);
}

void ECG1::
Show_Filtered_Data (::std::auto_ptr< Show_Filtered_Data_type > x)
{
  this->Show_Filtered_Data_.set (x);
}

const ECG1::ECG_Range_type& ECG1::
ECG_Range () const
{
  return this->ECG_Range_.get ();
}

ECG1::ECG_Range_type& ECG1::
ECG_Range ()
{
  return this->ECG_Range_.get ();
}

void ECG1::
ECG_Range (const ECG_Range_type& x)
{
  this->ECG_Range_.set (x);
}

void ECG1::
ECG_Range (::std::auto_ptr< ECG_Range_type > x)
{
  this->ECG_Range_.set (x);
}

const ECG1::RWave_Maxima_Block_Time_type& ECG1::
RWave_Maxima_Block_Time () const
{
  return this->RWave_Maxima_Block_Time_.get ();
}

ECG1::RWave_Maxima_Block_Time_type& ECG1::
RWave_Maxima_Block_Time ()
{
  return this->RWave_Maxima_Block_Time_.get ();
}

void ECG1::
RWave_Maxima_Block_Time (const RWave_Maxima_Block_Time_type& x)
{
  this->RWave_Maxima_Block_Time_.set (x);
}

void ECG1::
RWave_Maxima_Block_Time (::std::auto_ptr< RWave_Maxima_Block_Time_type > x)
{
  this->RWave_Maxima_Block_Time_.set (x);
}

const ECG1::RWave_Noise_Threshold_type& ECG1::
RWave_Noise_Threshold () const
{
  return this->RWave_Noise_Threshold_.get ();
}

ECG1::RWave_Noise_Threshold_type& ECG1::
RWave_Noise_Threshold ()
{
  return this->RWave_Noise_Threshold_.get ();
}

void ECG1::
RWave_Noise_Threshold (const RWave_Noise_Threshold_type& x)
{
  this->RWave_Noise_Threshold_.set (x);
}

void ECG1::
RWave_Noise_Threshold (::std::auto_ptr< RWave_Noise_Threshold_type > x)
{
  this->RWave_Noise_Threshold_.set (x);
}

const ECG1::Pressure_Calibration_Level_type& ECG1::
Pressure_Calibration_Level () const
{
  return this->Pressure_Calibration_Level_.get ();
}

ECG1::Pressure_Calibration_Level_type& ECG1::
Pressure_Calibration_Level ()
{
  return this->Pressure_Calibration_Level_.get ();
}

void ECG1::
Pressure_Calibration_Level (const Pressure_Calibration_Level_type& x)
{
  this->Pressure_Calibration_Level_.set (x);
}

void ECG1::
Pressure_Calibration_Level (::std::auto_ptr< Pressure_Calibration_Level_type > x)
{
  this->Pressure_Calibration_Level_.set (x);
}

const ECG1::ECG_HP_Filter_type& ECG1::
ECG_HP_Filter () const
{
  return this->ECG_HP_Filter_.get ();
}

ECG1::ECG_HP_Filter_type& ECG1::
ECG_HP_Filter ()
{
  return this->ECG_HP_Filter_.get ();
}

void ECG1::
ECG_HP_Filter (const ECG_HP_Filter_type& x)
{
  this->ECG_HP_Filter_.set (x);
}

void ECG1::
ECG_HP_Filter (::std::auto_ptr< ECG_HP_Filter_type > x)
{
  this->ECG_HP_Filter_.set (x);
}

const ECG1::ECG_LP_Filter_type& ECG1::
ECG_LP_Filter () const
{
  return this->ECG_LP_Filter_.get ();
}

ECG1::ECG_LP_Filter_type& ECG1::
ECG_LP_Filter ()
{
  return this->ECG_LP_Filter_.get ();
}

void ECG1::
ECG_LP_Filter (const ECG_LP_Filter_type& x)
{
  this->ECG_LP_Filter_.set (x);
}

void ECG1::
ECG_LP_Filter (::std::auto_ptr< ECG_LP_Filter_type > x)
{
  this->ECG_LP_Filter_.set (x);
}

const ECG1::RWave_Max_Change_Period_type& ECG1::
RWave_Max_Change_Period () const
{
  return this->RWave_Max_Change_Period_.get ();
}

ECG1::RWave_Max_Change_Period_type& ECG1::
RWave_Max_Change_Period ()
{
  return this->RWave_Max_Change_Period_.get ();
}

void ECG1::
RWave_Max_Change_Period (const RWave_Max_Change_Period_type& x)
{
  this->RWave_Max_Change_Period_.set (x);
}

void ECG1::
RWave_Max_Change_Period (::std::auto_ptr< RWave_Max_Change_Period_type > x)
{
  this->RWave_Max_Change_Period_.set (x);
}

const ECG1::Pressure_Time_Out_type& ECG1::
Pressure_Time_Out () const
{
  return this->Pressure_Time_Out_.get ();
}

ECG1::Pressure_Time_Out_type& ECG1::
Pressure_Time_Out ()
{
  return this->Pressure_Time_Out_.get ();
}

void ECG1::
Pressure_Time_Out (const Pressure_Time_Out_type& x)
{
  this->Pressure_Time_Out_.set (x);
}

void ECG1::
Pressure_Time_Out (::std::auto_ptr< Pressure_Time_Out_type > x)
{
  this->Pressure_Time_Out_.set (x);
}

const ECG1::Pressure_Calibration_type& ECG1::
Pressure_Calibration () const
{
  return this->Pressure_Calibration_.get ();
}

ECG1::Pressure_Calibration_type& ECG1::
Pressure_Calibration ()
{
  return this->Pressure_Calibration_.get ();
}

void ECG1::
Pressure_Calibration (const Pressure_Calibration_type& x)
{
  this->Pressure_Calibration_.set (x);
}

void ECG1::
Pressure_Calibration (::std::auto_ptr< Pressure_Calibration_type > x)
{
  this->Pressure_Calibration_.set (x);
}

const ECG1::RWave_Blank_Time_type& ECG1::
RWave_Blank_Time () const
{
  return this->RWave_Blank_Time_.get ();
}

ECG1::RWave_Blank_Time_type& ECG1::
RWave_Blank_Time ()
{
  return this->RWave_Blank_Time_.get ();
}

void ECG1::
RWave_Blank_Time (const RWave_Blank_Time_type& x)
{
  this->RWave_Blank_Time_.set (x);
}

void ECG1::
RWave_Blank_Time (::std::auto_ptr< RWave_Blank_Time_type > x)
{
  this->RWave_Blank_Time_.set (x);
}

const ECG1::RWave_Future_Search_Time_type& ECG1::
RWave_Future_Search_Time () const
{
  return this->RWave_Future_Search_Time_.get ();
}

ECG1::RWave_Future_Search_Time_type& ECG1::
RWave_Future_Search_Time ()
{
  return this->RWave_Future_Search_Time_.get ();
}

void ECG1::
RWave_Future_Search_Time (const RWave_Future_Search_Time_type& x)
{
  this->RWave_Future_Search_Time_.set (x);
}

void ECG1::
RWave_Future_Search_Time (::std::auto_ptr< RWave_Future_Search_Time_type > x)
{
  this->RWave_Future_Search_Time_.set (x);
}

const ECG1::Pressure_Calibrated_type& ECG1::
Pressure_Calibrated () const
{
  return this->Pressure_Calibrated_.get ();
}

ECG1::Pressure_Calibrated_type& ECG1::
Pressure_Calibrated ()
{
  return this->Pressure_Calibrated_.get ();
}

void ECG1::
Pressure_Calibrated (const Pressure_Calibrated_type& x)
{
  this->Pressure_Calibrated_.set (x);
}

void ECG1::
Pressure_Calibrated (::std::auto_ptr< Pressure_Calibrated_type > x)
{
  this->Pressure_Calibrated_.set (x);
}


// TX1
// 

const TX1::V_Position_Table_type& TX1::
V_Position_Table () const
{
  return this->V_Position_Table_.get ();
}

TX1::V_Position_Table_type& TX1::
V_Position_Table ()
{
  return this->V_Position_Table_.get ();
}

void TX1::
V_Position_Table (const V_Position_Table_type& x)
{
  this->V_Position_Table_.set (x);
}

void TX1::
V_Position_Table (::std::auto_ptr< V_Position_Table_type > x)
{
  this->V_Position_Table_.set (x);
}

const TX1::V_Transmit_Length_type& TX1::
V_Transmit_Length () const
{
  return this->V_Transmit_Length_.get ();
}

TX1::V_Transmit_Length_type& TX1::
V_Transmit_Length ()
{
  return this->V_Transmit_Length_.get ();
}

void TX1::
V_Transmit_Length (const V_Transmit_Length_type& x)
{
  this->V_Transmit_Length_.set (x);
}

void TX1::
V_Transmit_Length (::std::auto_ptr< V_Transmit_Length_type > x)
{
  this->V_Transmit_Length_.set (x);
}

const TX1::Trigger_Counter_Clear_type& TX1::
Trigger_Counter_Clear () const
{
  return this->Trigger_Counter_Clear_.get ();
}

TX1::Trigger_Counter_Clear_type& TX1::
Trigger_Counter_Clear ()
{
  return this->Trigger_Counter_Clear_.get ();
}

void TX1::
Trigger_Counter_Clear (const Trigger_Counter_Clear_type& x)
{
  this->Trigger_Counter_Clear_.set (x);
}

void TX1::
Trigger_Counter_Clear (::std::auto_ptr< Trigger_Counter_Clear_type > x)
{
  this->Trigger_Counter_Clear_.set (x);
}

const TX1::Trigger_Counter_type& TX1::
Trigger_Counter () const
{
  return this->Trigger_Counter_.get ();
}

TX1::Trigger_Counter_type& TX1::
Trigger_Counter ()
{
  return this->Trigger_Counter_.get ();
}

void TX1::
Trigger_Counter (const Trigger_Counter_type& x)
{
  this->Trigger_Counter_.set (x);
}

void TX1::
Trigger_Counter (::std::auto_ptr< Trigger_Counter_type > x)
{
  this->Trigger_Counter_.set (x);
}

const TX1::RF_Amp_type& TX1::
RF_Amp () const
{
  return this->RF_Amp_.get ();
}

TX1::RF_Amp_type& TX1::
RF_Amp ()
{
  return this->RF_Amp_.get ();
}

void TX1::
RF_Amp (const RF_Amp_type& x)
{
  this->RF_Amp_.set (x);
}

void TX1::
RF_Amp (::std::auto_ptr< RF_Amp_type > x)
{
  this->RF_Amp_.set (x);
}

const TX1::Trigger_Control_type& TX1::
Trigger_Control () const
{
  return this->Trigger_Control_.get ();
}

TX1::Trigger_Control_type& TX1::
Trigger_Control ()
{
  return this->Trigger_Control_.get ();
}

void TX1::
Trigger_Control (const Trigger_Control_type& x)
{
  this->Trigger_Control_.set (x);
}

void TX1::
Trigger_Control (::std::auto_ptr< Trigger_Control_type > x)
{
  this->Trigger_Control_.set (x);
}

const TX1::V_Pulse_Rep_Freq_type& TX1::
V_Pulse_Rep_Freq () const
{
  return this->V_Pulse_Rep_Freq_.get ();
}

TX1::V_Pulse_Rep_Freq_type& TX1::
V_Pulse_Rep_Freq ()
{
  return this->V_Pulse_Rep_Freq_.get ();
}

void TX1::
V_Pulse_Rep_Freq (const V_Pulse_Rep_Freq_type& x)
{
  this->V_Pulse_Rep_Freq_.set (x);
}

void TX1::
V_Pulse_Rep_Freq (::std::auto_ptr< V_Pulse_Rep_Freq_type > x)
{
  this->V_Pulse_Rep_Freq_.set (x);
}

const TX1::Phase_type& TX1::
Phase () const
{
  return this->Phase_.get ();
}

TX1::Phase_type& TX1::
Phase ()
{
  return this->Phase_.get ();
}

void TX1::
Phase (const Phase_type& x)
{
  this->Phase_.set (x);
}

void TX1::
Phase (::std::auto_ptr< Phase_type > x)
{
  this->Phase_.set (x);
}

const TX1::Frequency_type& TX1::
Frequency () const
{
  return this->Frequency_.get ();
}

TX1::Frequency_type& TX1::
Frequency ()
{
  return this->Frequency_.get ();
}

void TX1::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void TX1::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const TX1::V_Unblank_Time_type& TX1::
V_Unblank_Time () const
{
  return this->V_Unblank_Time_.get ();
}

TX1::V_Unblank_Time_type& TX1::
V_Unblank_Time ()
{
  return this->V_Unblank_Time_.get ();
}

void TX1::
V_Unblank_Time (const V_Unblank_Time_type& x)
{
  this->V_Unblank_Time_.set (x);
}

void TX1::
V_Unblank_Time (::std::auto_ptr< V_Unblank_Time_type > x)
{
  this->V_Unblank_Time_.set (x);
}

const TX1::V_Frequency_type& TX1::
V_Frequency () const
{
  return this->V_Frequency_.get ();
}

TX1::V_Frequency_type& TX1::
V_Frequency ()
{
  return this->V_Frequency_.get ();
}

void TX1::
V_Frequency (const V_Frequency_type& x)
{
  this->V_Frequency_.set (x);
}

void TX1::
V_Frequency (::std::auto_ptr< V_Frequency_type > x)
{
  this->V_Frequency_.set (x);
}

const TX1::Pulse_Rep_Frequency_type& TX1::
Pulse_Rep_Frequency () const
{
  return this->Pulse_Rep_Frequency_.get ();
}

TX1::Pulse_Rep_Frequency_type& TX1::
Pulse_Rep_Frequency ()
{
  return this->Pulse_Rep_Frequency_.get ();
}

void TX1::
Pulse_Rep_Frequency (const Pulse_Rep_Frequency_type& x)
{
  this->Pulse_Rep_Frequency_.set (x);
}

void TX1::
Pulse_Rep_Frequency (::std::auto_ptr< Pulse_Rep_Frequency_type > x)
{
  this->Pulse_Rep_Frequency_.set (x);
}

const TX1::Multi_Trigger_type& TX1::
Multi_Trigger () const
{
  return this->Multi_Trigger_.get ();
}

TX1::Multi_Trigger_type& TX1::
Multi_Trigger ()
{
  return this->Multi_Trigger_.get ();
}

void TX1::
Multi_Trigger (const Multi_Trigger_type& x)
{
  this->Multi_Trigger_.set (x);
}

void TX1::
Multi_Trigger (::std::auto_ptr< Multi_Trigger_type > x)
{
  this->Multi_Trigger_.set (x);
}

const TX1::Trig_Tbl_Trigs_type& TX1::
Trig_Tbl_Trigs () const
{
  return this->Trig_Tbl_Trigs_.get ();
}

TX1::Trig_Tbl_Trigs_type& TX1::
Trig_Tbl_Trigs ()
{
  return this->Trig_Tbl_Trigs_.get ();
}

void TX1::
Trig_Tbl_Trigs (const Trig_Tbl_Trigs_type& x)
{
  this->Trig_Tbl_Trigs_.set (x);
}

void TX1::
Trig_Tbl_Trigs (::std::auto_ptr< Trig_Tbl_Trigs_type > x)
{
  this->Trig_Tbl_Trigs_.set (x);
}

const TX1::Width_type& TX1::
Width () const
{
  return this->Width_.get ();
}

TX1::Width_type& TX1::
Width ()
{
  return this->Width_.get ();
}

void TX1::
Width (const Width_type& x)
{
  this->Width_.set (x);
}

void TX1::
Width (::std::auto_ptr< Width_type > x)
{
  this->Width_.set (x);
}

const TX1::Unblank_Cycles_type& TX1::
Unblank_Cycles () const
{
  return this->Unblank_Cycles_.get ();
}

TX1::Unblank_Cycles_type& TX1::
Unblank_Cycles ()
{
  return this->Unblank_Cycles_.get ();
}

void TX1::
Unblank_Cycles (const Unblank_Cycles_type& x)
{
  this->Unblank_Cycles_.set (x);
}

void TX1::
Unblank_Cycles (::std::auto_ptr< Unblank_Cycles_type > x)
{
  this->Unblank_Cycles_.set (x);
}

const TX1::V_Width_type& TX1::
V_Width () const
{
  return this->V_Width_.get ();
}

TX1::V_Width_type& TX1::
V_Width ()
{
  return this->V_Width_.get ();
}

void TX1::
V_Width (const V_Width_type& x)
{
  this->V_Width_.set (x);
}

void TX1::
V_Width (::std::auto_ptr< V_Width_type > x)
{
  this->V_Width_.set (x);
}

const TX1::Unblank_Time_type& TX1::
Unblank_Time () const
{
  return this->Unblank_Time_.get ();
}

TX1::Unblank_Time_type& TX1::
Unblank_Time ()
{
  return this->Unblank_Time_.get ();
}

void TX1::
Unblank_Time (const Unblank_Time_type& x)
{
  this->Unblank_Time_.set (x);
}

void TX1::
Unblank_Time (::std::auto_ptr< Unblank_Time_type > x)
{
  this->Unblank_Time_.set (x);
}

const TX1::Attenuation_type& TX1::
Attenuation () const
{
  return this->Attenuation_.get ();
}

TX1::Attenuation_type& TX1::
Attenuation ()
{
  return this->Attenuation_.get ();
}

void TX1::
Attenuation (const Attenuation_type& x)
{
  this->Attenuation_.set (x);
}

void TX1::
Attenuation (::std::auto_ptr< Attenuation_type > x)
{
  this->Attenuation_.set (x);
}

const TX1::V_Power_type& TX1::
V_Power () const
{
  return this->V_Power_.get ();
}

TX1::V_Power_type& TX1::
V_Power ()
{
  return this->V_Power_.get ();
}

void TX1::
V_Power (const V_Power_type& x)
{
  this->V_Power_.set (x);
}

void TX1::
V_Power (::std::auto_ptr< V_Power_type > x)
{
  this->V_Power_.set (x);
}

const TX1::Computer_Trigger_type& TX1::
Computer_Trigger () const
{
  return this->Computer_Trigger_.get ();
}

TX1::Computer_Trigger_type& TX1::
Computer_Trigger ()
{
  return this->Computer_Trigger_.get ();
}

void TX1::
Computer_Trigger (const Computer_Trigger_type& x)
{
  this->Computer_Trigger_.set (x);
}

void TX1::
Computer_Trigger (::std::auto_ptr< Computer_Trigger_type > x)
{
  this->Computer_Trigger_.set (x);
}

const TX1::Multi_Trigger_Freq_type& TX1::
Multi_Trigger_Freq () const
{
  return this->Multi_Trigger_Freq_.get ();
}

TX1::Multi_Trigger_Freq_type& TX1::
Multi_Trigger_Freq ()
{
  return this->Multi_Trigger_Freq_.get ();
}

void TX1::
Multi_Trigger_Freq (const Multi_Trigger_Freq_type& x)
{
  this->Multi_Trigger_Freq_.set (x);
}

void TX1::
Multi_Trigger_Freq (::std::auto_ptr< Multi_Trigger_Freq_type > x)
{
  this->Multi_Trigger_Freq_.set (x);
}


// ContrastDestroy
// 

const ContrastDestroy::Tx_Width_type& ContrastDestroy::
Tx_Width () const
{
  return this->Tx_Width_.get ();
}

ContrastDestroy::Tx_Width_type& ContrastDestroy::
Tx_Width ()
{
  return this->Tx_Width_.get ();
}

void ContrastDestroy::
Tx_Width (const Tx_Width_type& x)
{
  this->Tx_Width_.set (x);
}

void ContrastDestroy::
Tx_Width (::std::auto_ptr< Tx_Width_type > x)
{
  this->Tx_Width_.set (x);
}

const ContrastDestroy::Destroy_External_type& ContrastDestroy::
Destroy_External () const
{
  return this->Destroy_External_.get ();
}

ContrastDestroy::Destroy_External_type& ContrastDestroy::
Destroy_External ()
{
  return this->Destroy_External_.get ();
}

void ContrastDestroy::
Destroy_External (const Destroy_External_type& x)
{
  this->Destroy_External_.set (x);
}

void ContrastDestroy::
Destroy_External (::std::auto_ptr< Destroy_External_type > x)
{
  this->Destroy_External_.set (x);
}

const ContrastDestroy::Frames_type& ContrastDestroy::
Frames () const
{
  return this->Frames_.get ();
}

ContrastDestroy::Frames_type& ContrastDestroy::
Frames ()
{
  return this->Frames_.get ();
}

void ContrastDestroy::
Frames (const Frames_type& x)
{
  this->Frames_.set (x);
}

void ContrastDestroy::
Frames (::std::auto_ptr< Frames_type > x)
{
  this->Frames_.set (x);
}

const ContrastDestroy::Frame_Rate_type& ContrastDestroy::
Frame_Rate () const
{
  return this->Frame_Rate_.get ();
}

ContrastDestroy::Frame_Rate_type& ContrastDestroy::
Frame_Rate ()
{
  return this->Frame_Rate_.get ();
}

void ContrastDestroy::
Frame_Rate (const Frame_Rate_type& x)
{
  this->Frame_Rate_.set (x);
}

void ContrastDestroy::
Frame_Rate (::std::auto_ptr< Frame_Rate_type > x)
{
  this->Frame_Rate_.set (x);
}

const ContrastDestroy::Tx_PRF_type& ContrastDestroy::
Tx_PRF () const
{
  return this->Tx_PRF_.get ();
}

ContrastDestroy::Tx_PRF_type& ContrastDestroy::
Tx_PRF ()
{
  return this->Tx_PRF_.get ();
}

void ContrastDestroy::
Tx_PRF (const Tx_PRF_type& x)
{
  this->Tx_PRF_.set (x);
}

void ContrastDestroy::
Tx_PRF (::std::auto_ptr< Tx_PRF_type > x)
{
  this->Tx_PRF_.set (x);
}

const ContrastDestroy::Tx_Power_type& ContrastDestroy::
Tx_Power () const
{
  return this->Tx_Power_.get ();
}

ContrastDestroy::Tx_Power_type& ContrastDestroy::
Tx_Power ()
{
  return this->Tx_Power_.get ();
}

void ContrastDestroy::
Tx_Power (const Tx_Power_type& x)
{
  this->Tx_Power_.set (x);
}

void ContrastDestroy::
Tx_Power (::std::auto_ptr< Tx_Power_type > x)
{
  this->Tx_Power_.set (x);
}

const ContrastDestroy::Duration_type& ContrastDestroy::
Duration () const
{
  return this->Duration_.get ();
}

ContrastDestroy::Duration_type& ContrastDestroy::
Duration ()
{
  return this->Duration_.get ();
}

void ContrastDestroy::
Duration (const Duration_type& x)
{
  this->Duration_.set (x);
}

void ContrastDestroy::
Duration (::std::auto_ptr< Duration_type > x)
{
  this->Duration_.set (x);
}

const ContrastDestroy::Control_type& ContrastDestroy::
Control () const
{
  return this->Control_.get ();
}

ContrastDestroy::Control_type& ContrastDestroy::
Control ()
{
  return this->Control_.get ();
}

void ContrastDestroy::
Control (const Control_type& x)
{
  this->Control_.set (x);
}

void ContrastDestroy::
Control (::std::auto_ptr< Control_type > x)
{
  this->Control_.set (x);
}

const ContrastDestroy::Tx_Frequency_type& ContrastDestroy::
Tx_Frequency () const
{
  return this->Tx_Frequency_.get ();
}

ContrastDestroy::Tx_Frequency_type& ContrastDestroy::
Tx_Frequency ()
{
  return this->Tx_Frequency_.get ();
}

void ContrastDestroy::
Tx_Frequency (const Tx_Frequency_type& x)
{
  this->Tx_Frequency_.set (x);
}

void ContrastDestroy::
Tx_Frequency (::std::auto_ptr< Tx_Frequency_type > x)
{
  this->Tx_Frequency_.set (x);
}

const ContrastDestroy::Destroy_Sequence_Active_type& ContrastDestroy::
Destroy_Sequence_Active () const
{
  return this->Destroy_Sequence_Active_.get ();
}

ContrastDestroy::Destroy_Sequence_Active_type& ContrastDestroy::
Destroy_Sequence_Active ()
{
  return this->Destroy_Sequence_Active_.get ();
}

void ContrastDestroy::
Destroy_Sequence_Active (const Destroy_Sequence_Active_type& x)
{
  this->Destroy_Sequence_Active_.set (x);
}

void ContrastDestroy::
Destroy_Sequence_Active (::std::auto_ptr< Destroy_Sequence_Active_type > x)
{
  this->Destroy_Sequence_Active_.set (x);
}

const ContrastDestroy::Destroy_Sequence_Position_type& ContrastDestroy::
Destroy_Sequence_Position () const
{
  return this->Destroy_Sequence_Position_.get ();
}

ContrastDestroy::Destroy_Sequence_Position_type& ContrastDestroy::
Destroy_Sequence_Position ()
{
  return this->Destroy_Sequence_Position_.get ();
}

void ContrastDestroy::
Destroy_Sequence_Position (const Destroy_Sequence_Position_type& x)
{
  this->Destroy_Sequence_Position_.set (x);
}

void ContrastDestroy::
Destroy_Sequence_Position (::std::auto_ptr< Destroy_Sequence_Position_type > x)
{
  this->Destroy_Sequence_Position_.set (x);
}


// X_3D1
// 

const X_3D1::Speed_type& X_3D1::
Speed () const
{
  return this->Speed_.get ();
}

X_3D1::Speed_type& X_3D1::
Speed ()
{
  return this->Speed_.get ();
}

void X_3D1::
Speed (const Speed_type& x)
{
  this->Speed_.set (x);
}

void X_3D1::
Speed (::std::auto_ptr< Speed_type > x)
{
  this->Speed_.set (x);
}

const X_3D1::Status_type& X_3D1::
Status () const
{
  return this->Status_.get ();
}

X_3D1::Status_type& X_3D1::
Status ()
{
  return this->Status_.get ();
}

void X_3D1::
Status (const Status_type& x)
{
  this->Status_.set (x);
}

void X_3D1::
Status (::std::auto_ptr< Status_type > x)
{
  this->Status_.set (x);
}

const X_3D1::Motor_Enable_type& X_3D1::
Motor_Enable () const
{
  return this->Motor_Enable_.get ();
}

X_3D1::Motor_Enable_type& X_3D1::
Motor_Enable ()
{
  return this->Motor_Enable_.get ();
}

void X_3D1::
Motor_Enable (const Motor_Enable_type& x)
{
  this->Motor_Enable_.set (x);
}

void X_3D1::
Motor_Enable (::std::auto_ptr< Motor_Enable_type > x)
{
  this->Motor_Enable_.set (x);
}

const X_3D1::Scan_Distance_type& X_3D1::
Scan_Distance () const
{
  return this->Scan_Distance_.get ();
}

X_3D1::Scan_Distance_type& X_3D1::
Scan_Distance ()
{
  return this->Scan_Distance_.get ();
}

void X_3D1::
Scan_Distance (const Scan_Distance_type& x)
{
  this->Scan_Distance_.set (x);
}

void X_3D1::
Scan_Distance (::std::auto_ptr< Scan_Distance_type > x)
{
  this->Scan_Distance_.set (x);
}

const X_3D1::Error_type& X_3D1::
Error () const
{
  return this->Error_.get ();
}

X_3D1::Error_type& X_3D1::
Error ()
{
  return this->Error_.get ();
}

void X_3D1::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void X_3D1::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const X_3D1::Steps_type& X_3D1::
Steps () const
{
  return this->Steps_.get ();
}

X_3D1::Steps_type& X_3D1::
Steps ()
{
  return this->Steps_.get ();
}

void X_3D1::
Steps (const Steps_type& x)
{
  this->Steps_.set (x);
}

void X_3D1::
Steps (::std::auto_ptr< Steps_type > x)
{
  this->Steps_.set (x);
}

const X_3D1::Action_type& X_3D1::
Action () const
{
  return this->Action_.get ();
}

X_3D1::Action_type& X_3D1::
Action ()
{
  return this->Action_.get ();
}

void X_3D1::
Action (const Action_type& x)
{
  this->Action_.set (x);
}

void X_3D1::
Action (::std::auto_ptr< Action_type > x)
{
  this->Action_.set (x);
}

const X_3D1::Clear_Error_type& X_3D1::
Clear_Error () const
{
  return this->Clear_Error_.get ();
}

X_3D1::Clear_Error_type& X_3D1::
Clear_Error ()
{
  return this->Clear_Error_.get ();
}

void X_3D1::
Clear_Error (const Clear_Error_type& x)
{
  this->Clear_Error_.set (x);
}

void X_3D1::
Clear_Error (::std::auto_ptr< Clear_Error_type > x)
{
  this->Clear_Error_.set (x);
}

const X_3D1::Direction_type& X_3D1::
Direction () const
{
  return this->Direction_.get ();
}

X_3D1::Direction_type& X_3D1::
Direction ()
{
  return this->Direction_.get ();
}

void X_3D1::
Direction (const Direction_type& x)
{
  this->Direction_.set (x);
}

void X_3D1::
Direction (::std::auto_ptr< Direction_type > x)
{
  this->Direction_.set (x);
}

const X_3D1::Step_Size_type& X_3D1::
Step_Size () const
{
  return this->Step_Size_.get ();
}

X_3D1::Step_Size_type& X_3D1::
Step_Size ()
{
  return this->Step_Size_.get ();
}

void X_3D1::
Step_Size (const Step_Size_type& x)
{
  this->Step_Size_.set (x);
}

void X_3D1::
Step_Size (::std::auto_ptr< Step_Size_type > x)
{
  this->Step_Size_.set (x);
}

const X_3D1::Max_Scan_Steps_type& X_3D1::
Max_Scan_Steps () const
{
  return this->Max_Scan_Steps_.get ();
}

X_3D1::Max_Scan_Steps_type& X_3D1::
Max_Scan_Steps ()
{
  return this->Max_Scan_Steps_.get ();
}

void X_3D1::
Max_Scan_Steps (const Max_Scan_Steps_type& x)
{
  this->Max_Scan_Steps_.set (x);
}

void X_3D1::
Max_Scan_Steps (::std::auto_ptr< Max_Scan_Steps_type > x)
{
  this->Max_Scan_Steps_.set (x);
}

const X_3D1::Position_type& X_3D1::
Position () const
{
  return this->Position_.get ();
}

X_3D1::Position_type& X_3D1::
Position ()
{
  return this->Position_.get ();
}

void X_3D1::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void X_3D1::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}


// X_3DSoft
// 

const X_3DSoft::Acquire_Persist_3DMIP_type& X_3DSoft::
Acquire_Persist_3DMIP () const
{
  return this->Acquire_Persist_3DMIP_.get ();
}

X_3DSoft::Acquire_Persist_3DMIP_type& X_3DSoft::
Acquire_Persist_3DMIP ()
{
  return this->Acquire_Persist_3DMIP_.get ();
}

void X_3DSoft::
Acquire_Persist_3DMIP (const Acquire_Persist_3DMIP_type& x)
{
  this->Acquire_Persist_3DMIP_.set (x);
}

void X_3DSoft::
Acquire_Persist_3DMIP (::std::auto_ptr< Acquire_Persist_3DMIP_type > x)
{
  this->Acquire_Persist_3DMIP_.set (x);
}

const X_3DSoft::Acquire_Persist_3D_Frames_type& X_3DSoft::
Acquire_Persist_3D_Frames () const
{
  return this->Acquire_Persist_3D_Frames_.get ();
}

X_3DSoft::Acquire_Persist_3D_Frames_type& X_3DSoft::
Acquire_Persist_3D_Frames ()
{
  return this->Acquire_Persist_3D_Frames_.get ();
}

void X_3DSoft::
Acquire_Persist_3D_Frames (const Acquire_Persist_3D_Frames_type& x)
{
  this->Acquire_Persist_3D_Frames_.set (x);
}

void X_3DSoft::
Acquire_Persist_3D_Frames (::std::auto_ptr< Acquire_Persist_3D_Frames_type > x)
{
  this->Acquire_Persist_3D_Frames_.set (x);
}

const X_3DSoft::Acquire_Persist_3DAVR_type& X_3DSoft::
Acquire_Persist_3DAVR () const
{
  return this->Acquire_Persist_3DAVR_.get ();
}

X_3DSoft::Acquire_Persist_3DAVR_type& X_3DSoft::
Acquire_Persist_3DAVR ()
{
  return this->Acquire_Persist_3DAVR_.get ();
}

void X_3DSoft::
Acquire_Persist_3DAVR (const Acquire_Persist_3DAVR_type& x)
{
  this->Acquire_Persist_3DAVR_.set (x);
}

void X_3DSoft::
Acquire_Persist_3DAVR (::std::auto_ptr< Acquire_Persist_3DAVR_type > x)
{
  this->Acquire_Persist_3DAVR_.set (x);
}

const X_3DSoft::Rotational_Direction_type& X_3DSoft::
Rotational_Direction () const
{
  return this->Rotational_Direction_.get ();
}

X_3DSoft::Rotational_Direction_type& X_3DSoft::
Rotational_Direction ()
{
  return this->Rotational_Direction_.get ();
}

void X_3DSoft::
Rotational_Direction (const Rotational_Direction_type& x)
{
  this->Rotational_Direction_.set (x);
}

void X_3DSoft::
Rotational_Direction (::std::auto_ptr< Rotational_Direction_type > x)
{
  this->Rotational_Direction_.set (x);
}

const X_3DSoft::Sigma_type& X_3DSoft::
Sigma () const
{
  return this->Sigma_.get ();
}

X_3DSoft::Sigma_type& X_3DSoft::
Sigma ()
{
  return this->Sigma_.get ();
}

void X_3DSoft::
Sigma (const Sigma_type& x)
{
  this->Sigma_.set (x);
}

void X_3DSoft::
Sigma (::std::auto_ptr< Sigma_type > x)
{
  this->Sigma_.set (x);
}

const X_3DSoft::Dilation_Iteration_type& X_3DSoft::
Dilation_Iteration () const
{
  return this->Dilation_Iteration_.get ();
}

X_3DSoft::Dilation_Iteration_type& X_3DSoft::
Dilation_Iteration ()
{
  return this->Dilation_Iteration_.get ();
}

void X_3DSoft::
Dilation_Iteration (const Dilation_Iteration_type& x)
{
  this->Dilation_Iteration_.set (x);
}

void X_3DSoft::
Dilation_Iteration (::std::auto_ptr< Dilation_Iteration_type > x)
{
  this->Dilation_Iteration_.set (x);
}

const X_3DSoft::Parallel_Direction_type& X_3DSoft::
Parallel_Direction () const
{
  return this->Parallel_Direction_.get ();
}

X_3DSoft::Parallel_Direction_type& X_3DSoft::
Parallel_Direction ()
{
  return this->Parallel_Direction_.get ();
}

void X_3DSoft::
Parallel_Direction (const Parallel_Direction_type& x)
{
  this->Parallel_Direction_.set (x);
}

void X_3DSoft::
Parallel_Direction (::std::auto_ptr< Parallel_Direction_type > x)
{
  this->Parallel_Direction_.set (x);
}

const X_3DSoft::Class_type& X_3DSoft::
Class () const
{
  return this->Class_.get ();
}

X_3DSoft::Class_type& X_3DSoft::
Class ()
{
  return this->Class_.get ();
}

void X_3DSoft::
Class (const Class_type& x)
{
  this->Class_.set (x);
}

void X_3DSoft::
Class (::std::auto_ptr< Class_type > x)
{
  this->Class_.set (x);
}

const X_3DSoft::Orientation_Length_type& X_3DSoft::
Orientation_Length () const
{
  return this->Orientation_Length_.get ();
}

X_3DSoft::Orientation_Length_type& X_3DSoft::
Orientation_Length ()
{
  return this->Orientation_Length_.get ();
}

void X_3DSoft::
Orientation_Length (const Orientation_Length_type& x)
{
  this->Orientation_Length_.set (x);
}

void X_3DSoft::
Orientation_Length (::std::auto_ptr< Orientation_Length_type > x)
{
  this->Orientation_Length_.set (x);
}

const X_3DSoft::External_Force_type& X_3DSoft::
External_Force () const
{
  return this->External_Force_.get ();
}

X_3DSoft::External_Force_type& X_3DSoft::
External_Force ()
{
  return this->External_Force_.get ();
}

void X_3DSoft::
External_Force (const External_Force_type& x)
{
  this->External_Force_.set (x);
}

void X_3DSoft::
External_Force (::std::auto_ptr< External_Force_type > x)
{
  this->External_Force_.set (x);
}

const X_3DSoft::Interpolation_Resolution_type& X_3DSoft::
Interpolation_Resolution () const
{
  return this->Interpolation_Resolution_.get ();
}

X_3DSoft::Interpolation_Resolution_type& X_3DSoft::
Interpolation_Resolution ()
{
  return this->Interpolation_Resolution_.get ();
}

void X_3DSoft::
Interpolation_Resolution (const Interpolation_Resolution_type& x)
{
  this->Interpolation_Resolution_.set (x);
}

void X_3DSoft::
Interpolation_Resolution (::std::auto_ptr< Interpolation_Resolution_type > x)
{
  this->Interpolation_Resolution_.set (x);
}

const X_3DSoft::Steps_type& X_3DSoft::
Steps () const
{
  return this->Steps_.get ();
}

X_3DSoft::Steps_type& X_3DSoft::
Steps ()
{
  return this->Steps_.get ();
}

void X_3DSoft::
Steps (const Steps_type& x)
{
  this->Steps_.set (x);
}

void X_3DSoft::
Steps (::std::auto_ptr< Steps_type > x)
{
  this->Steps_.set (x);
}

const X_3DSoft::Parallel_Recon_Resolution_type& X_3DSoft::
Parallel_Recon_Resolution () const
{
  return this->Parallel_Recon_Resolution_.get ();
}

X_3DSoft::Parallel_Recon_Resolution_type& X_3DSoft::
Parallel_Recon_Resolution ()
{
  return this->Parallel_Recon_Resolution_.get ();
}

void X_3DSoft::
Parallel_Recon_Resolution (const Parallel_Recon_Resolution_type& x)
{
  this->Parallel_Recon_Resolution_.set (x);
}

void X_3DSoft::
Parallel_Recon_Resolution (::std::auto_ptr< Parallel_Recon_Resolution_type > x)
{
  this->Parallel_Recon_Resolution_.set (x);
}

const X_3DSoft::Iteration_type& X_3DSoft::
Iteration () const
{
  return this->Iteration_.get ();
}

X_3DSoft::Iteration_type& X_3DSoft::
Iteration ()
{
  return this->Iteration_.get ();
}

void X_3DSoft::
Iteration (const Iteration_type& x)
{
  this->Iteration_.set (x);
}

void X_3DSoft::
Iteration (::std::auto_ptr< Iteration_type > x)
{
  this->Iteration_.set (x);
}

const X_3DSoft::Type_type& X_3DSoft::
Type () const
{
  return this->Type_.get ();
}

X_3DSoft::Type_type& X_3DSoft::
Type ()
{
  return this->Type_.get ();
}

void X_3DSoft::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void X_3DSoft::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const X_3DSoft::Rotational_Step_Size_type& X_3DSoft::
Rotational_Step_Size () const
{
  return this->Rotational_Step_Size_.get ();
}

X_3DSoft::Rotational_Step_Size_type& X_3DSoft::
Rotational_Step_Size ()
{
  return this->Rotational_Step_Size_.get ();
}

void X_3DSoft::
Rotational_Step_Size (const Rotational_Step_Size_type& x)
{
  this->Rotational_Step_Size_.set (x);
}

void X_3DSoft::
Rotational_Step_Size (::std::auto_ptr< Rotational_Step_Size_type > x)
{
  this->Rotational_Step_Size_.set (x);
}

const X_3DSoft::Internal_Force_type& X_3DSoft::
Internal_Force () const
{
  return this->Internal_Force_.get ();
}

X_3DSoft::Internal_Force_type& X_3DSoft::
Internal_Force ()
{
  return this->Internal_Force_.get ();
}

void X_3DSoft::
Internal_Force (const Internal_Force_type& x)
{
  this->Internal_Force_.set (x);
}

void X_3DSoft::
Internal_Force (::std::auto_ptr< Internal_Force_type > x)
{
  this->Internal_Force_.set (x);
}

const X_3DSoft::Parallel_Step_Size_type& X_3DSoft::
Parallel_Step_Size () const
{
  return this->Parallel_Step_Size_.get ();
}

X_3DSoft::Parallel_Step_Size_type& X_3DSoft::
Parallel_Step_Size ()
{
  return this->Parallel_Step_Size_.get ();
}

void X_3DSoft::
Parallel_Step_Size (const Parallel_Step_Size_type& x)
{
  this->Parallel_Step_Size_.set (x);
}

void X_3DSoft::
Parallel_Step_Size (::std::auto_ptr< Parallel_Step_Size_type > x)
{
  this->Parallel_Step_Size_.set (x);
}


// RX1
// 

const RX1::AD_IF_type& RX1::
AD_IF () const
{
  return this->AD_IF_.get ();
}

RX1::AD_IF_type& RX1::
AD_IF ()
{
  return this->AD_IF_.get ();
}

void RX1::
AD_IF (const AD_IF_type& x)
{
  this->AD_IF_.set (x);
}

void RX1::
AD_IF (::std::auto_ptr< AD_IF_type > x)
{
  this->AD_IF_.set (x);
}

const RX1::Sector_Width_Target_type& RX1::
Sector_Width_Target () const
{
  return this->Sector_Width_Target_.get ();
}

RX1::Sector_Width_Target_type& RX1::
Sector_Width_Target ()
{
  return this->Sector_Width_Target_.get ();
}

void RX1::
Sector_Width_Target (const Sector_Width_Target_type& x)
{
  this->Sector_Width_Target_.set (x);
}

void RX1::
Sector_Width_Target (::std::auto_ptr< Sector_Width_Target_type > x)
{
  this->Sector_Width_Target_.set (x);
}

const RX1::RF_Gain_type& RX1::
RF_Gain () const
{
  return this->RF_Gain_.get ();
}

RX1::RF_Gain_type& RX1::
RF_Gain ()
{
  return this->RF_Gain_.get ();
}

void RX1::
RF_Gain (const RF_Gain_type& x)
{
  this->RF_Gain_.set (x);
}

void RX1::
RF_Gain (::std::auto_ptr< RF_Gain_type > x)
{
  this->RF_Gain_.set (x);
}

const RX1::TGC_Enable_type& RX1::
TGC_Enable () const
{
  return this->TGC_Enable_.get ();
}

RX1::TGC_Enable_type& RX1::
TGC_Enable ()
{
  return this->TGC_Enable_.get ();
}

void RX1::
TGC_Enable (const TGC_Enable_type& x)
{
  this->TGC_Enable_.set (x);
}

void RX1::
TGC_Enable (::std::auto_ptr< TGC_Enable_type > x)
{
  this->TGC_Enable_.set (x);
}

const RX1::V_Digi_Depth_Imaging_type& RX1::
V_Digi_Depth_Imaging () const
{
  return this->V_Digi_Depth_Imaging_.get ();
}

RX1::V_Digi_Depth_Imaging_type& RX1::
V_Digi_Depth_Imaging ()
{
  return this->V_Digi_Depth_Imaging_.get ();
}

void RX1::
V_Digi_Depth_Imaging (const V_Digi_Depth_Imaging_type& x)
{
  this->V_Digi_Depth_Imaging_.set (x);
}

void RX1::
V_Digi_Depth_Imaging (::std::auto_ptr< V_Digi_Depth_Imaging_type > x)
{
  this->V_Digi_Depth_Imaging_.set (x);
}

const RX1::RF_Bandwidth_type& RX1::
RF_Bandwidth () const
{
  return this->RF_Bandwidth_.get ();
}

RX1::RF_Bandwidth_type& RX1::
RF_Bandwidth ()
{
  return this->RF_Bandwidth_.get ();
}

void RX1::
RF_Bandwidth (const RF_Bandwidth_type& x)
{
  this->RF_Bandwidth_.set (x);
}

void RX1::
RF_Bandwidth (::std::auto_ptr< RF_Bandwidth_type > x)
{
  this->RF_Bandwidth_.set (x);
}

const RX1::Test_Freq_type& RX1::
Test_Freq () const
{
  return this->Test_Freq_.get ();
}

RX1::Test_Freq_type& RX1::
Test_Freq ()
{
  return this->Test_Freq_.get ();
}

void RX1::
Test_Freq (const Test_Freq_type& x)
{
  this->Test_Freq_.set (x);
}

void RX1::
Test_Freq (::std::auto_ptr< Test_Freq_type > x)
{
  this->Test_Freq_.set (x);
}

const RX1::V_TGC_type& RX1::
V_TGC () const
{
  return this->V_TGC_.get ();
}

RX1::V_TGC_type& RX1::
V_TGC ()
{
  return this->V_TGC_.get ();
}

void RX1::
V_TGC (const V_TGC_type& x)
{
  this->V_TGC_.set (x);
}

void RX1::
V_TGC (::std::auto_ptr< V_TGC_type > x)
{
  this->V_TGC_.set (x);
}

const RX1::Current_Channel_type& RX1::
Current_Channel () const
{
  return this->Current_Channel_.get ();
}

RX1::Current_Channel_type& RX1::
Current_Channel ()
{
  return this->Current_Channel_.get ();
}

void RX1::
Current_Channel (const Current_Channel_type& x)
{
  this->Current_Channel_.set (x);
}

void RX1::
Current_Channel (::std::auto_ptr< Current_Channel_type > x)
{
  this->Current_Channel_.set (x);
}

const RX1::AD_In_type& RX1::
AD_In () const
{
  return this->AD_In_.get ();
}

RX1::AD_In_type& RX1::
AD_In ()
{
  return this->AD_In_.get ();
}

void RX1::
AD_In (const AD_In_type& x)
{
  this->AD_In_.set (x);
}

void RX1::
AD_In (::std::auto_ptr< AD_In_type > x)
{
  this->AD_In_.set (x);
}

const RX1::Image_FIFO_Status_type& RX1::
Image_FIFO_Status () const
{
  return this->Image_FIFO_Status_.get ();
}

RX1::Image_FIFO_Status_type& RX1::
Image_FIFO_Status ()
{
  return this->Image_FIFO_Status_.get ();
}

void RX1::
Image_FIFO_Status (const Image_FIFO_Status_type& x)
{
  this->Image_FIFO_Status_.set (x);
}

void RX1::
Image_FIFO_Status (::std::auto_ptr< Image_FIFO_Status_type > x)
{
  this->Image_FIFO_Status_.set (x);
}

const RX1::RF_Filter_type& RX1::
RF_Filter () const
{
  return this->RF_Filter_.get ();
}

RX1::RF_Filter_type& RX1::
RF_Filter ()
{
  return this->RF_Filter_.get ();
}

void RX1::
RF_Filter (const RF_Filter_type& x)
{
  this->RF_Filter_.set (x);
}

void RX1::
RF_Filter (::std::auto_ptr< RF_Filter_type > x)
{
  this->RF_Filter_.set (x);
}

const RX1::DDRS_type& RX1::
DDRS () const
{
  return this->DDRS_.get ();
}

RX1::DDRS_type& RX1::
DDRS ()
{
  return this->DDRS_.get ();
}

void RX1::
DDRS (const DDRS_type& x)
{
  this->DDRS_.set (x);
}

void RX1::
DDRS (::std::auto_ptr< DDRS_type > x)
{
  this->DDRS_.set (x);
}

const RX1::ADCA_Out_type& RX1::
ADCA_Out () const
{
  return this->ADCA_Out_.get ();
}

RX1::ADCA_Out_type& RX1::
ADCA_Out ()
{
  return this->ADCA_Out_.get ();
}

void RX1::
ADCA_Out (const ADCA_Out_type& x)
{
  this->ADCA_Out_.set (x);
}

void RX1::
ADCA_Out (::std::auto_ptr< ADCA_Out_type > x)
{
  this->ADCA_Out_.set (x);
}

const RX1::AD_Clock_Div_type& RX1::
AD_Clock_Div () const
{
  return this->AD_Clock_Div_.get ();
}

RX1::AD_Clock_Div_type& RX1::
AD_Clock_Div ()
{
  return this->AD_Clock_Div_.get ();
}

void RX1::
AD_Clock_Div (const AD_Clock_Div_type& x)
{
  this->AD_Clock_Div_.set (x);
}

void RX1::
AD_Clock_Div (::std::auto_ptr< AD_Clock_Div_type > x)
{
  this->AD_Clock_Div_.set (x);
}

const RX1::Imaging_Mode_type& RX1::
Imaging_Mode () const
{
  return this->Imaging_Mode_.get ();
}

RX1::Imaging_Mode_type& RX1::
Imaging_Mode ()
{
  return this->Imaging_Mode_.get ();
}

void RX1::
Imaging_Mode (const Imaging_Mode_type& x)
{
  this->Imaging_Mode_.set (x);
}

void RX1::
Imaging_Mode (::std::auto_ptr< Imaging_Mode_type > x)
{
  this->Imaging_Mode_.set (x);
}

const RX1::V_RF_Filter_type& RX1::
V_RF_Filter () const
{
  return this->V_RF_Filter_.get ();
}

RX1::V_RF_Filter_type& RX1::
V_RF_Filter ()
{
  return this->V_RF_Filter_.get ();
}

void RX1::
V_RF_Filter (const V_RF_Filter_type& x)
{
  this->V_RF_Filter_.set (x);
}

void RX1::
V_RF_Filter (::std::auto_ptr< V_RF_Filter_type > x)
{
  this->V_RF_Filter_.set (x);
}

const RX1::ADCB_Out_type& RX1::
ADCB_Out () const
{
  return this->ADCB_Out_.get ();
}

RX1::ADCB_Out_type& RX1::
ADCB_Out ()
{
  return this->ADCB_Out_.get ();
}

void RX1::
ADCB_Out (const ADCB_Out_type& x)
{
  this->ADCB_Out_.set (x);
}

void RX1::
ADCB_Out (::std::auto_ptr< ADCB_Out_type > x)
{
  this->ADCB_Out_.set (x);
}

const RX1::Delay_type& RX1::
Delay () const
{
  return this->Delay_.get ();
}

RX1::Delay_type& RX1::
Delay ()
{
  return this->Delay_.get ();
}

void RX1::
Delay (const Delay_type& x)
{
  this->Delay_.set (x);
}

void RX1::
Delay (::std::auto_ptr< Delay_type > x)
{
  this->Delay_.set (x);
}

const RX1::AD_Gate_Width_type& RX1::
AD_Gate_Width () const
{
  return this->AD_Gate_Width_.get ();
}

RX1::AD_Gate_Width_type& RX1::
AD_Gate_Width ()
{
  return this->AD_Gate_Width_.get ();
}

void RX1::
AD_Gate_Width (const AD_Gate_Width_type& x)
{
  this->AD_Gate_Width_.set (x);
}

void RX1::
AD_Gate_Width (::std::auto_ptr< AD_Gate_Width_type > x)
{
  this->AD_Gate_Width_.set (x);
}

const RX1::Frequency_type& RX1::
Frequency () const
{
  return this->Frequency_.get ();
}

RX1::Frequency_type& RX1::
Frequency ()
{
  return this->Frequency_.get ();
}

void RX1::
Frequency (const Frequency_type& x)
{
  this->Frequency_.set (x);
}

void RX1::
Frequency (::std::auto_ptr< Frequency_type > x)
{
  this->Frequency_.set (x);
}

const RX1::V_Frequency_type& RX1::
V_Frequency () const
{
  return this->V_Frequency_.get ();
}

RX1::V_Frequency_type& RX1::
V_Frequency ()
{
  return this->V_Frequency_.get ();
}

void RX1::
V_Frequency (const V_Frequency_type& x)
{
  this->V_Frequency_.set (x);
}

void RX1::
V_Frequency (::std::auto_ptr< V_Frequency_type > x)
{
  this->V_Frequency_.set (x);
}

const RX1::V_Field_Of_View_type& RX1::
V_Field_Of_View () const
{
  return this->V_Field_Of_View_.get ();
}

RX1::V_Field_Of_View_type& RX1::
V_Field_Of_View ()
{
  return this->V_Field_Of_View_.get ();
}

void RX1::
V_Field_Of_View (const V_Field_Of_View_type& x)
{
  this->V_Field_Of_View_.set (x);
}

void RX1::
V_Field_Of_View (::std::auto_ptr< V_Field_Of_View_type > x)
{
  this->V_Field_Of_View_.set (x);
}

const RX1::Packet_Format_type& RX1::
Packet_Format () const
{
  return this->Packet_Format_.get ();
}

RX1::Packet_Format_type& RX1::
Packet_Format ()
{
  return this->Packet_Format_.get ();
}

void RX1::
Packet_Format (const Packet_Format_type& x)
{
  this->Packet_Format_.set (x);
}

void RX1::
Packet_Format (::std::auto_ptr< Packet_Format_type > x)
{
  this->Packet_Format_.set (x);
}

const RX1::Sector_Height_Target_type& RX1::
Sector_Height_Target () const
{
  return this->Sector_Height_Target_.get ();
}

RX1::Sector_Height_Target_type& RX1::
Sector_Height_Target ()
{
  return this->Sector_Height_Target_.get ();
}

void RX1::
Sector_Height_Target (const Sector_Height_Target_type& x)
{
  this->Sector_Height_Target_.set (x);
}

void RX1::
Sector_Height_Target (::std::auto_ptr< Sector_Height_Target_type > x)
{
  this->Sector_Height_Target_.set (x);
}

const RX1::Low_Speed_FIFO_Status_type& RX1::
Low_Speed_FIFO_Status () const
{
  return this->Low_Speed_FIFO_Status_.get ();
}

RX1::Low_Speed_FIFO_Status_type& RX1::
Low_Speed_FIFO_Status ()
{
  return this->Low_Speed_FIFO_Status_.get ();
}

void RX1::
Low_Speed_FIFO_Status (const Low_Speed_FIFO_Status_type& x)
{
  this->Low_Speed_FIFO_Status_.set (x);
}

void RX1::
Low_Speed_FIFO_Status (::std::auto_ptr< Low_Speed_FIFO_Status_type > x)
{
  this->Low_Speed_FIFO_Status_.set (x);
}

const RX1::AD_TestIn_type& RX1::
AD_TestIn () const
{
  return this->AD_TestIn_.get ();
}

RX1::AD_TestIn_type& RX1::
AD_TestIn ()
{
  return this->AD_TestIn_.get ();
}

void RX1::
AD_TestIn (const AD_TestIn_type& x)
{
  this->AD_TestIn_.set (x);
}

void RX1::
AD_TestIn (::std::auto_ptr< AD_TestIn_type > x)
{
  this->AD_TestIn_.set (x);
}

const RX1::Error_type& RX1::
Error () const
{
  return this->Error_.get ();
}

RX1::Error_type& RX1::
Error ()
{
  return this->Error_.get ();
}

void RX1::
Error (const Error_type& x)
{
  this->Error_.set (x);
}

void RX1::
Error (::std::auto_ptr< Error_type > x)
{
  this->Error_.set (x);
}

const RX1::Test_On_type& RX1::
Test_On () const
{
  return this->Test_On_.get ();
}

RX1::Test_On_type& RX1::
Test_On ()
{
  return this->Test_On_.get ();
}

void RX1::
Test_On (const Test_On_type& x)
{
  this->Test_On_.set (x);
}

void RX1::
Test_On (::std::auto_ptr< Test_On_type > x)
{
  this->Test_On_.set (x);
}

const RX1::AD_DCS_type& RX1::
AD_DCS () const
{
  return this->AD_DCS_.get ();
}

RX1::AD_DCS_type& RX1::
AD_DCS ()
{
  return this->AD_DCS_.get ();
}

void RX1::
AD_DCS (const AD_DCS_type& x)
{
  this->AD_DCS_.set (x);
}

void RX1::
AD_DCS (::std::auto_ptr< AD_DCS_type > x)
{
  this->AD_DCS_.set (x);
}

const RX1::DTB_Tfr_Enable_type& RX1::
DTB_Tfr_Enable () const
{
  return this->DTB_Tfr_Enable_.get ();
}

RX1::DTB_Tfr_Enable_type& RX1::
DTB_Tfr_Enable ()
{
  return this->DTB_Tfr_Enable_.get ();
}

void RX1::
DTB_Tfr_Enable (const DTB_Tfr_Enable_type& x)
{
  this->DTB_Tfr_Enable_.set (x);
}

void RX1::
DTB_Tfr_Enable (::std::auto_ptr< DTB_Tfr_Enable_type > x)
{
  this->DTB_Tfr_Enable_.set (x);
}

const RX1::DTB_Test_Enable_type& RX1::
DTB_Test_Enable () const
{
  return this->DTB_Test_Enable_.get ();
}

RX1::DTB_Test_Enable_type& RX1::
DTB_Test_Enable ()
{
  return this->DTB_Test_Enable_.get ();
}

void RX1::
DTB_Test_Enable (const DTB_Test_Enable_type& x)
{
  this->DTB_Test_Enable_.set (x);
}

void RX1::
DTB_Test_Enable (::std::auto_ptr< DTB_Test_Enable_type > x)
{
  this->DTB_Test_Enable_.set (x);
}

const RX1::V_Delay_Length_type& RX1::
V_Delay_Length () const
{
  return this->V_Delay_Length_.get ();
}

RX1::V_Delay_Length_type& RX1::
V_Delay_Length ()
{
  return this->V_Delay_Length_.get ();
}

void RX1::
V_Delay_Length (const V_Delay_Length_type& x)
{
  this->V_Delay_Length_.set (x);
}

void RX1::
V_Delay_Length (::std::auto_ptr< V_Delay_Length_type > x)
{
  this->V_Delay_Length_.set (x);
}

const RX1::Current_Mode_type& RX1::
Current_Mode () const
{
  return this->Current_Mode_.get ();
}

RX1::Current_Mode_type& RX1::
Current_Mode ()
{
  return this->Current_Mode_.get ();
}

void RX1::
Current_Mode (const Current_Mode_type& x)
{
  this->Current_Mode_.set (x);
}

void RX1::
Current_Mode (::std::auto_ptr< Current_Mode_type > x)
{
  this->Current_Mode_.set (x);
}

const RX1::Line_Number_type& RX1::
Line_Number () const
{
  return this->Line_Number_.get ();
}

RX1::Line_Number_type& RX1::
Line_Number ()
{
  return this->Line_Number_.get ();
}

void RX1::
Line_Number (const Line_Number_type& x)
{
  this->Line_Number_.set (x);
}

void RX1::
Line_Number (::std::auto_ptr< Line_Number_type > x)
{
  this->Line_Number_.set (x);
}

const RX1::IF_Filter_type& RX1::
IF_Filter () const
{
  return this->IF_Filter_.get ();
}

RX1::IF_Filter_type& RX1::
IF_Filter ()
{
  return this->IF_Filter_.get ();
}

void RX1::
IF_Filter (const IF_Filter_type& x)
{
  this->IF_Filter_.set (x);
}

void RX1::
IF_Filter (::std::auto_ptr< IF_Filter_type > x)
{
  this->IF_Filter_.set (x);
}

const RX1::Track_Width_type& RX1::
Track_Width () const
{
  return this->Track_Width_.get ();
}

RX1::Track_Width_type& RX1::
Track_Width ()
{
  return this->Track_Width_.get ();
}

void RX1::
Track_Width (const Track_Width_type& x)
{
  this->Track_Width_.set (x);
}

void RX1::
Track_Width (::std::auto_ptr< Track_Width_type > x)
{
  this->Track_Width_.set (x);
}

const RX1::DTB_Error_Clr_type& RX1::
DTB_Error_Clr () const
{
  return this->DTB_Error_Clr_.get ();
}

RX1::DTB_Error_Clr_type& RX1::
DTB_Error_Clr ()
{
  return this->DTB_Error_Clr_.get ();
}

void RX1::
DTB_Error_Clr (const DTB_Error_Clr_type& x)
{
  this->DTB_Error_Clr_.set (x);
}

void RX1::
DTB_Error_Clr (::std::auto_ptr< DTB_Error_Clr_type > x)
{
  this->DTB_Error_Clr_.set (x);
}

const RX1::V_IF_Filter_type& RX1::
V_IF_Filter () const
{
  return this->V_IF_Filter_.get ();
}

RX1::V_IF_Filter_type& RX1::
V_IF_Filter ()
{
  return this->V_IF_Filter_.get ();
}

void RX1::
V_IF_Filter (const V_IF_Filter_type& x)
{
  this->V_IF_Filter_.set (x);
}

void RX1::
V_IF_Filter (::std::auto_ptr< V_IF_Filter_type > x)
{
  this->V_IF_Filter_.set (x);
}

const RX1::IQ_Select_type& RX1::
IQ_Select () const
{
  return this->IQ_Select_.get ();
}

RX1::IQ_Select_type& RX1::
IQ_Select ()
{
  return this->IQ_Select_.get ();
}

void RX1::
IQ_Select (const IQ_Select_type& x)
{
  this->IQ_Select_.set (x);
}

void RX1::
IQ_Select (::std::auto_ptr< IQ_Select_type > x)
{
  this->IQ_Select_.set (x);
}

const RX1::HP_Clutter_type& RX1::
HP_Clutter () const
{
  return this->HP_Clutter_.get ();
}

RX1::HP_Clutter_type& RX1::
HP_Clutter ()
{
  return this->HP_Clutter_.get ();
}

void RX1::
HP_Clutter (const HP_Clutter_type& x)
{
  this->HP_Clutter_.set (x);
}

void RX1::
HP_Clutter (::std::auto_ptr< HP_Clutter_type > x)
{
  this->HP_Clutter_.set (x);
}

const RX1::V_TGC_Copy_type& RX1::
V_TGC_Copy () const
{
  return this->V_TGC_Copy_.get ();
}

RX1::V_TGC_Copy_type& RX1::
V_TGC_Copy ()
{
  return this->V_TGC_Copy_.get ();
}

void RX1::
V_TGC_Copy (const V_TGC_Copy_type& x)
{
  this->V_TGC_Copy_.set (x);
}

void RX1::
V_TGC_Copy (::std::auto_ptr< V_TGC_Copy_type > x)
{
  this->V_TGC_Copy_.set (x);
}


// Display1
// 

const Display1::Direction_type& Display1::
Direction () const
{
  return this->Direction_.get ();
}

Display1::Direction_type& Display1::
Direction ()
{
  return this->Direction_.get ();
}

void Display1::
Direction (const Direction_type& x)
{
  this->Direction_.set (x);
}

void Display1::
Direction (::std::auto_ptr< Direction_type > x)
{
  this->Direction_.set (x);
}

const Display1::V_SV_TissueMode_type& Display1::
V_SV_TissueMode () const
{
  return this->V_SV_TissueMode_.get ();
}

Display1::V_SV_TissueMode_type& Display1::
V_SV_TissueMode ()
{
  return this->V_SV_TissueMode_.get ();
}

void Display1::
V_SV_TissueMode (const V_SV_TissueMode_type& x)
{
  this->V_SV_TissueMode_.set (x);
}

void Display1::
V_SV_TissueMode (::std::auto_ptr< V_SV_TissueMode_type > x)
{
  this->V_SV_TissueMode_.set (x);
}

const Display1::V_SV_MMode_type& Display1::
V_SV_MMode () const
{
  return this->V_SV_MMode_.get ();
}

Display1::V_SV_MMode_type& Display1::
V_SV_MMode ()
{
  return this->V_SV_MMode_.get ();
}

void Display1::
V_SV_MMode (const V_SV_MMode_type& x)
{
  this->V_SV_MMode_.set (x);
}

void Display1::
V_SV_MMode (::std::auto_ptr< V_SV_MMode_type > x)
{
  this->V_SV_MMode_.set (x);
}

const Display1::X_3D_Gain_type& Display1::
X_3D_Gain () const
{
  return this->X_3D_Gain_.get ();
}

Display1::X_3D_Gain_type& Display1::
X_3D_Gain ()
{
  return this->X_3D_Gain_.get ();
}

void Display1::
X_3D_Gain (const X_3D_Gain_type& x)
{
  this->X_3D_Gain_.set (x);
}

void Display1::
X_3D_Gain (::std::auto_ptr< X_3D_Gain_type > x)
{
  this->X_3D_Gain_.set (x);
}

const Display1::X_3D_Dynamic_Range_type& Display1::
X_3D_Dynamic_Range () const
{
  return this->X_3D_Dynamic_Range_.get ();
}

Display1::X_3D_Dynamic_Range_type& Display1::
X_3D_Dynamic_Range ()
{
  return this->X_3D_Dynamic_Range_.get ();
}

void Display1::
X_3D_Dynamic_Range (const X_3D_Dynamic_Range_type& x)
{
  this->X_3D_Dynamic_Range_.set (x);
}

void Display1::
X_3D_Dynamic_Range (::std::auto_ptr< X_3D_Dynamic_Range_type > x)
{
  this->X_3D_Dynamic_Range_.set (x);
}

const Display1::Gain_type& Display1::
Gain () const
{
  return this->Gain_.get ();
}

Display1::Gain_type& Display1::
Gain ()
{
  return this->Gain_.get ();
}

void Display1::
Gain (const Gain_type& x)
{
  this->Gain_.set (x);
}

void Display1::
Gain (::std::auto_ptr< Gain_type > x)
{
  this->Gain_.set (x);
}

const Display1::V_SV_RfMode_type& Display1::
V_SV_RfMode () const
{
  return this->V_SV_RfMode_.get ();
}

Display1::V_SV_RfMode_type& Display1::
V_SV_RfMode ()
{
  return this->V_SV_RfMode_.get ();
}

void Display1::
V_SV_RfMode (const V_SV_RfMode_type& x)
{
  this->V_SV_RfMode_.set (x);
}

void Display1::
V_SV_RfMode (::std::auto_ptr< V_SV_RfMode_type > x)
{
  this->V_SV_RfMode_.set (x);
}

const Display1::V_SV_EkvMode_type& Display1::
V_SV_EkvMode () const
{
  return this->V_SV_EkvMode_.get ();
}

Display1::V_SV_EkvMode_type& Display1::
V_SV_EkvMode ()
{
  return this->V_SV_EkvMode_.get ();
}

void Display1::
V_SV_EkvMode (const V_SV_EkvMode_type& x)
{
  this->V_SV_EkvMode_.set (x);
}

void Display1::
V_SV_EkvMode (::std::auto_ptr< V_SV_EkvMode_type > x)
{
  this->V_SV_EkvMode_.set (x);
}

const Display1::Dynamic_Range_type& Display1::
Dynamic_Range () const
{
  return this->Dynamic_Range_.get ();
}

Display1::Dynamic_Range_type& Display1::
Dynamic_Range ()
{
  return this->Dynamic_Range_.get ();
}

void Display1::
Dynamic_Range (const Dynamic_Range_type& x)
{
  this->Dynamic_Range_.set (x);
}

void Display1::
Dynamic_Range (::std::auto_ptr< Dynamic_Range_type > x)
{
  this->Dynamic_Range_.set (x);
}

const Display1::Window_Time_type& Display1::
Window_Time () const
{
  return this->Window_Time_.get ();
}

Display1::Window_Time_type& Display1::
Window_Time ()
{
  return this->Window_Time_.get ();
}

void Display1::
Window_Time (const Window_Time_type& x)
{
  this->Window_Time_.set (x);
}

void Display1::
Window_Time (::std::auto_ptr< Window_Time_type > x)
{
  this->Window_Time_.set (x);
}

const Display1::V_SV_DopplerMode_type& Display1::
V_SV_DopplerMode () const
{
  return this->V_SV_DopplerMode_.get ();
}

Display1::V_SV_DopplerMode_type& Display1::
V_SV_DopplerMode ()
{
  return this->V_SV_DopplerMode_.get ();
}

void Display1::
V_SV_DopplerMode (const V_SV_DopplerMode_type& x)
{
  this->V_SV_DopplerMode_.set (x);
}

void Display1::
V_SV_DopplerMode (::std::auto_ptr< V_SV_DopplerMode_type > x)
{
  this->V_SV_DopplerMode_.set (x);
}

const Display1::V_SV_NeedleGuide_type& Display1::
V_SV_NeedleGuide () const
{
  return this->V_SV_NeedleGuide_.get ();
}

Display1::V_SV_NeedleGuide_type& Display1::
V_SV_NeedleGuide ()
{
  return this->V_SV_NeedleGuide_.get ();
}

void Display1::
V_SV_NeedleGuide (const V_SV_NeedleGuide_type& x)
{
  this->V_SV_NeedleGuide_.set (x);
}

void Display1::
V_SV_NeedleGuide (::std::auto_ptr< V_SV_NeedleGuide_type > x)
{
  this->V_SV_NeedleGuide_.set (x);
}

const Display1::V_SV_ColorMode_type& Display1::
V_SV_ColorMode () const
{
  return this->V_SV_ColorMode_.get ();
}

Display1::V_SV_ColorMode_type& Display1::
V_SV_ColorMode ()
{
  return this->V_SV_ColorMode_.get ();
}

void Display1::
V_SV_ColorMode (const V_SV_ColorMode_type& x)
{
  this->V_SV_ColorMode_.set (x);
}

void Display1::
V_SV_ColorMode (::std::auto_ptr< V_SV_ColorMode_type > x)
{
  this->V_SV_ColorMode_.set (x);
}


// EKVModeSoft
// 

const EKVModeSoft::RWave_Time_Tollerance_type& EKVModeSoft::
RWave_Time_Tollerance () const
{
  return this->RWave_Time_Tollerance_.get ();
}

EKVModeSoft::RWave_Time_Tollerance_type& EKVModeSoft::
RWave_Time_Tollerance ()
{
  return this->RWave_Time_Tollerance_.get ();
}

void EKVModeSoft::
RWave_Time_Tollerance (const RWave_Time_Tollerance_type& x)
{
  this->RWave_Time_Tollerance_.set (x);
}

void EKVModeSoft::
RWave_Time_Tollerance (::std::auto_ptr< RWave_Time_Tollerance_type > x)
{
  this->RWave_Time_Tollerance_.set (x);
}

const EKVModeSoft::EKV_Start_type& EKVModeSoft::
EKV_Start () const
{
  return this->EKV_Start_.get ();
}

EKVModeSoft::EKV_Start_type& EKVModeSoft::
EKV_Start ()
{
  return this->EKV_Start_.get ();
}

void EKVModeSoft::
EKV_Start (const EKV_Start_type& x)
{
  this->EKV_Start_.set (x);
}

void EKVModeSoft::
EKV_Start (::std::auto_ptr< EKV_Start_type > x)
{
  this->EKV_Start_.set (x);
}

const EKVModeSoft::EKV_Stop_type& EKVModeSoft::
EKV_Stop () const
{
  return this->EKV_Stop_.get ();
}

EKVModeSoft::EKV_Stop_type& EKVModeSoft::
EKV_Stop ()
{
  return this->EKV_Stop_.get ();
}

void EKVModeSoft::
EKV_Stop (const EKV_Stop_type& x)
{
  this->EKV_Stop_.set (x);
}

void EKVModeSoft::
EKV_Stop (::std::auto_ptr< EKV_Stop_type > x)
{
  this->EKV_Stop_.set (x);
}

const EKVModeSoft::EKV_Quality_Times_type& EKVModeSoft::
EKV_Quality_Times () const
{
  return this->EKV_Quality_Times_.get ();
}

EKVModeSoft::EKV_Quality_Times_type& EKVModeSoft::
EKV_Quality_Times ()
{
  return this->EKV_Quality_Times_.get ();
}

void EKVModeSoft::
EKV_Quality_Times (const EKV_Quality_Times_type& x)
{
  this->EKV_Quality_Times_.set (x);
}

void EKVModeSoft::
EKV_Quality_Times (::std::auto_ptr< EKV_Quality_Times_type > x)
{
  this->EKV_Quality_Times_.set (x);
}

const EKVModeSoft::EKV_Quality_type& EKVModeSoft::
EKV_Quality () const
{
  return this->EKV_Quality_.get ();
}

EKVModeSoft::EKV_Quality_type& EKVModeSoft::
EKV_Quality ()
{
  return this->EKV_Quality_.get ();
}

void EKVModeSoft::
EKV_Quality (const EKV_Quality_type& x)
{
  this->EKV_Quality_.set (x);
}

void EKVModeSoft::
EKV_Quality (::std::auto_ptr< EKV_Quality_type > x)
{
  this->EKV_Quality_.set (x);
}

const EKVModeSoft::EKV_Quality_Resolution_type& EKVModeSoft::
EKV_Quality_Resolution () const
{
  return this->EKV_Quality_Resolution_.get ();
}

EKVModeSoft::EKV_Quality_Resolution_type& EKVModeSoft::
EKV_Quality_Resolution ()
{
  return this->EKV_Quality_Resolution_.get ();
}

void EKVModeSoft::
EKV_Quality_Resolution (const EKV_Quality_Resolution_type& x)
{
  this->EKV_Quality_Resolution_.set (x);
}

void EKVModeSoft::
EKV_Quality_Resolution (::std::auto_ptr< EKV_Quality_Resolution_type > x)
{
  this->EKV_Quality_Resolution_.set (x);
}

const EKVModeSoft::Difference_Percent_Periods_Keep_type& EKVModeSoft::
Difference_Percent_Periods_Keep () const
{
  return this->Difference_Percent_Periods_Keep_.get ();
}

EKVModeSoft::Difference_Percent_Periods_Keep_type& EKVModeSoft::
Difference_Percent_Periods_Keep ()
{
  return this->Difference_Percent_Periods_Keep_.get ();
}

void EKVModeSoft::
Difference_Percent_Periods_Keep (const Difference_Percent_Periods_Keep_type& x)
{
  this->Difference_Percent_Periods_Keep_.set (x);
}

void EKVModeSoft::
Difference_Percent_Periods_Keep (::std::auto_ptr< Difference_Percent_Periods_Keep_type > x)
{
  this->Difference_Percent_Periods_Keep_.set (x);
}

const EKVModeSoft::EKV_Advanced_type& EKVModeSoft::
EKV_Advanced () const
{
  return this->EKV_Advanced_.get ();
}

EKVModeSoft::EKV_Advanced_type& EKVModeSoft::
EKV_Advanced ()
{
  return this->EKV_Advanced_.get ();
}

void EKVModeSoft::
EKV_Advanced (const EKV_Advanced_type& x)
{
  this->EKV_Advanced_.set (x);
}

void EKVModeSoft::
EKV_Advanced (::std::auto_ptr< EKV_Advanced_type > x)
{
  this->EKV_Advanced_.set (x);
}

const EKVModeSoft::EKV_Variance_type& EKVModeSoft::
EKV_Variance () const
{
  return this->EKV_Variance_.get ();
}

EKVModeSoft::EKV_Variance_type& EKVModeSoft::
EKV_Variance ()
{
  return this->EKV_Variance_.get ();
}

void EKVModeSoft::
EKV_Variance (const EKV_Variance_type& x)
{
  this->EKV_Variance_.set (x);
}

void EKVModeSoft::
EKV_Variance (::std::auto_ptr< EKV_Variance_type > x)
{
  this->EKV_Variance_.set (x);
}

const EKVModeSoft::EKV_Triggers_type& EKVModeSoft::
EKV_Triggers () const
{
  return this->EKV_Triggers_.get ();
}

EKVModeSoft::EKV_Triggers_type& EKVModeSoft::
EKV_Triggers ()
{
  return this->EKV_Triggers_.get ();
}

void EKVModeSoft::
EKV_Triggers (const EKV_Triggers_type& x)
{
  this->EKV_Triggers_.set (x);
}

void EKVModeSoft::
EKV_Triggers (::std::auto_ptr< EKV_Triggers_type > x)
{
  this->EKV_Triggers_.set (x);
}


// BModeLVAnalysis
// 

const BModeLVAnalysis::Cycles_Cardiac_Region_type& BModeLVAnalysis::
Cycles_Cardiac_Region () const
{
  return this->Cycles_Cardiac_Region_.get ();
}

BModeLVAnalysis::Cycles_Cardiac_Region_type& BModeLVAnalysis::
Cycles_Cardiac_Region ()
{
  return this->Cycles_Cardiac_Region_.get ();
}

void BModeLVAnalysis::
Cycles_Cardiac_Region (const Cycles_Cardiac_Region_type& x)
{
  this->Cycles_Cardiac_Region_.set (x);
}

void BModeLVAnalysis::
Cycles_Cardiac_Region (::std::auto_ptr< Cycles_Cardiac_Region_type > x)
{
  this->Cycles_Cardiac_Region_.set (x);
}

const BModeLVAnalysis::Cycles_type& BModeLVAnalysis::
Cycles () const
{
  return this->Cycles_.get ();
}

BModeLVAnalysis::Cycles_type& BModeLVAnalysis::
Cycles ()
{
  return this->Cycles_.get ();
}

void BModeLVAnalysis::
Cycles (const Cycles_type& x)
{
  this->Cycles_.set (x);
}

void BModeLVAnalysis::
Cycles (::std::auto_ptr< Cycles_type > x)
{
  this->Cycles_.set (x);
}

const BModeLVAnalysis::Spline_Process_Points_type& BModeLVAnalysis::
Spline_Process_Points () const
{
  return this->Spline_Process_Points_.get ();
}

BModeLVAnalysis::Spline_Process_Points_type& BModeLVAnalysis::
Spline_Process_Points ()
{
  return this->Spline_Process_Points_.get ();
}

void BModeLVAnalysis::
Spline_Process_Points (const Spline_Process_Points_type& x)
{
  this->Spline_Process_Points_.set (x);
}

void BModeLVAnalysis::
Spline_Process_Points (::std::auto_ptr< Spline_Process_Points_type > x)
{
  this->Spline_Process_Points_.set (x);
}

const BModeLVAnalysis::Speckle_Search_Size_type& BModeLVAnalysis::
Speckle_Search_Size () const
{
  return this->Speckle_Search_Size_.get ();
}

BModeLVAnalysis::Speckle_Search_Size_type& BModeLVAnalysis::
Speckle_Search_Size ()
{
  return this->Speckle_Search_Size_.get ();
}

void BModeLVAnalysis::
Speckle_Search_Size (const Speckle_Search_Size_type& x)
{
  this->Speckle_Search_Size_.set (x);
}

void BModeLVAnalysis::
Speckle_Search_Size (::std::auto_ptr< Speckle_Search_Size_type > x)
{
  this->Speckle_Search_Size_.set (x);
}

const BModeLVAnalysis::Speckle_Compare_Size_type& BModeLVAnalysis::
Speckle_Compare_Size () const
{
  return this->Speckle_Compare_Size_.get ();
}

BModeLVAnalysis::Speckle_Compare_Size_type& BModeLVAnalysis::
Speckle_Compare_Size ()
{
  return this->Speckle_Compare_Size_.get ();
}

void BModeLVAnalysis::
Speckle_Compare_Size (const Speckle_Compare_Size_type& x)
{
  this->Speckle_Compare_Size_.set (x);
}

void BModeLVAnalysis::
Speckle_Compare_Size (::std::auto_ptr< Speckle_Compare_Size_type > x)
{
  this->Speckle_Compare_Size_.set (x);
}

const BModeLVAnalysis::EKV_Frames_type& BModeLVAnalysis::
EKV_Frames () const
{
  return this->EKV_Frames_.get ();
}

BModeLVAnalysis::EKV_Frames_type& BModeLVAnalysis::
EKV_Frames ()
{
  return this->EKV_Frames_.get ();
}

void BModeLVAnalysis::
EKV_Frames (const EKV_Frames_type& x)
{
  this->EKV_Frames_.set (x);
}

void BModeLVAnalysis::
EKV_Frames (::std::auto_ptr< EKV_Frames_type > x)
{
  this->EKV_Frames_.set (x);
}

const BModeLVAnalysis::Axis_type& BModeLVAnalysis::
Axis () const
{
  return this->Axis_.get ();
}

BModeLVAnalysis::Axis_type& BModeLVAnalysis::
Axis ()
{
  return this->Axis_.get ();
}

void BModeLVAnalysis::
Axis (const Axis_type& x)
{
  this->Axis_.set (x);
}

void BModeLVAnalysis::
Axis (::std::auto_ptr< Axis_type > x)
{
  this->Axis_.set (x);
}

const BModeLVAnalysis::Cardinal_Tension_type& BModeLVAnalysis::
Cardinal_Tension () const
{
  return this->Cardinal_Tension_.get ();
}

BModeLVAnalysis::Cardinal_Tension_type& BModeLVAnalysis::
Cardinal_Tension ()
{
  return this->Cardinal_Tension_.get ();
}

void BModeLVAnalysis::
Cardinal_Tension (const Cardinal_Tension_type& x)
{
  this->Cardinal_Tension_.set (x);
}

void BModeLVAnalysis::
Cardinal_Tension (::std::auto_ptr< Cardinal_Tension_type > x)
{
  this->Cardinal_Tension_.set (x);
}


// Sample_Time
// 

const Sample_Time::units_type& Sample_Time::
units () const
{
  return this->units_.get ();
}

Sample_Time::units_type& Sample_Time::
units ()
{
  return this->units_.get ();
}

void Sample_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sample_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Focal_Length
// 

const Focal_Length::units_type& Focal_Length::
units () const
{
  return this->units_.get ();
}

Focal_Length::units_type& Focal_Length::
units ()
{
  return this->units_.get ();
}

void Focal_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void Focal_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Scan_Speed
// 

const Default_Scan_Speed::units_type& Default_Scan_Speed::
units () const
{
  return this->units_.get ();
}

Default_Scan_Speed::units_type& Default_Scan_Speed::
units ()
{
  return this->units_.get ();
}

void Default_Scan_Speed::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Scan_Speed::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Cutoff_Scan_Speed
// 

const Cutoff_Scan_Speed::units_type& Cutoff_Scan_Speed::
units () const
{
  return this->units_.get ();
}

Cutoff_Scan_Speed::units_type& Cutoff_Scan_Speed::
units ()
{
  return this->units_.get ();
}

void Cutoff_Scan_Speed::
units (const units_type& x)
{
  this->units_.set (x);
}

void Cutoff_Scan_Speed::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Low
// 

const Frequency_Low::units_type& Frequency_Low::
units () const
{
  return this->units_.get ();
}

Frequency_Low::units_type& Frequency_Low::
units ()
{
  return this->units_.get ();
}

void Frequency_Low::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Low::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_FOV
// 

const Default_FOV::units_type& Default_FOV::
units () const
{
  return this->units_.get ();
}

Default_FOV::units_type& Default_FOV::
units ()
{
  return this->units_.get ();
}

void Default_FOV::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_FOV::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler_Default
// 

const Frequency_Doppler_Default::units_type& Frequency_Doppler_Default::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler_Default::units_type& Frequency_Doppler_Default::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler_Default::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler_Default::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler
// 

const Frequency_Doppler::units_type& Frequency_Doppler::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler::units_type& Frequency_Doppler::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Axial_Res
// 

const Axial_Res::units_type& Axial_Res::
units () const
{
  return this->units_.get ();
}

Axial_Res::units_type& Axial_Res::
units ()
{
  return this->units_.get ();
}

void Axial_Res::
units (const units_type& x)
{
  this->units_.set (x);
}

void Axial_Res::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_High
// 

const Filter_High::units_type& Filter_High::
units () const
{
  return this->units_.get ();
}

Filter_High::units_type& Filter_High::
units ()
{
  return this->units_.get ();
}

void Filter_High::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_High::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pivot_Encoder_Dist
// 

const Pivot_Encoder_Dist::units_type& Pivot_Encoder_Dist::
units () const
{
  return this->units_.get ();
}

Pivot_Encoder_Dist::units_type& Pivot_Encoder_Dist::
units ()
{
  return this->units_.get ();
}

void Pivot_Encoder_Dist::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pivot_Encoder_Dist::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Range_Max
// 

const Encoder_Range_Max::units_type& Encoder_Range_Max::
units () const
{
  return this->units_.get ();
}

Encoder_Range_Max::units_type& Encoder_Range_Max::
units ()
{
  return this->units_.get ();
}

void Encoder_Range_Max::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Range_Max::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Range_Min
// 

const Encoder_Range_Min::units_type& Encoder_Range_Min::
units () const
{
  return this->units_.get ();
}

Encoder_Range_Min::units_type& Encoder_Range_Min::
units ()
{
  return this->units_.get ();
}

void Encoder_Range_Min::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Range_Min::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Lateral_Res
// 

const Lateral_Res::units_type& Lateral_Res::
units () const
{
  return this->units_.get ();
}

Lateral_Res::units_type& Lateral_Res::
units ()
{
  return this->units_.get ();
}

void Lateral_Res::
units (const units_type& x)
{
  this->units_.set (x);
}

void Lateral_Res::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Motor_Overhead
// 

const Motor_Overhead::units_type& Motor_Overhead::
units () const
{
  return this->units_.get ();
}

Motor_Overhead::units_type& Motor_Overhead::
units ()
{
  return this->units_.get ();
}

void Motor_Overhead::
units (const units_type& x)
{
  this->units_.set (x);
}

void Motor_Overhead::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Max_Scan_Distance
// 

const Max_Scan_Distance::units_type& Max_Scan_Distance::
units () const
{
  return this->units_.get ();
}

Max_Scan_Distance::units_type& Max_Scan_Distance::
units ()
{
  return this->units_.get ();
}

void Max_Scan_Distance::
units (const units_type& x)
{
  this->units_.set (x);
}

void Max_Scan_Distance::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Rx_Gain
// 

const Default_Rx_Gain::units_type& Default_Rx_Gain::
units () const
{
  return this->units_.get ();
}

Default_Rx_Gain::units_type& Default_Rx_Gain::
units ()
{
  return this->units_.get ();
}

void Default_Rx_Gain::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Rx_Gain::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Low
// 

const Filter_Low::units_type& Filter_Low::
units () const
{
  return this->units_.get ();
}

Filter_Low::units_type& Filter_Low::
units ()
{
  return this->units_.get ();
}

void Filter_Low::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Low::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_High
// 

const Frequency_High::units_type& Frequency_High::
units () const
{
  return this->units_.get ();
}

Frequency_High::units_type& Frequency_High::
units ()
{
  return this->units_.get ();
}

void Frequency_High::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_High::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Speeds
// 

const Scan_Speeds::units_type& Scan_Speeds::
units () const
{
  return this->units_.get ();
}

Scan_Speeds::units_type& Scan_Speeds::
units ()
{
  return this->units_.get ();
}

void Scan_Speeds::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Speeds::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler_Cutoff
// 

const Filter_Doppler_Cutoff::units_type& Filter_Doppler_Cutoff::
units () const
{
  return this->units_.get ();
}

Filter_Doppler_Cutoff::units_type& Filter_Doppler_Cutoff::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler_Cutoff::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler_Cutoff::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler_Low
// 

const Frequency_Doppler_Low::units_type& Frequency_Doppler_Low::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler_Low::units_type& Frequency_Doppler_Low::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler_Low::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler_Low::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pivot_Transducer_Face_Dist
// 

const Pivot_Transducer_Face_Dist::units_type& Pivot_Transducer_Face_Dist::
units () const
{
  return this->units_.get ();
}

Pivot_Transducer_Face_Dist::units_type& Pivot_Transducer_Face_Dist::
units ()
{
  return this->units_.get ();
}

void Pivot_Transducer_Face_Dist::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pivot_Transducer_Face_Dist::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler
// 

const Filter_Doppler::units_type& Filter_Doppler::
units () const
{
  return this->units_.get ();
}

Filter_Doppler::units_type& Filter_Doppler::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency
// 

const Frequency::units_type& Frequency::
units () const
{
  return this->units_.get ();
}

Frequency::units_type& Frequency::
units ()
{
  return this->units_.get ();
}

void Frequency::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Separation
// 

const Encoder_Separation::units_type& Encoder_Separation::
units () const
{
  return this->units_.get ();
}

Encoder_Separation::units_type& Encoder_Separation::
units ()
{
  return this->units_.get ();
}

void Encoder_Separation::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Separation::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Overshoot
// 

const Overshoot::units_type& Overshoot::
units () const
{
  return this->units_.get ();
}

Overshoot::units_type& Overshoot::
units ()
{
  return this->units_.get ();
}

void Overshoot::
units (const units_type& x)
{
  this->units_.set (x);
}

void Overshoot::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter
// 

const Filter::units_type& Filter::
units () const
{
  return this->units_.get ();
}

Filter::units_type& Filter::
units ()
{
  return this->units_.get ();
}

void Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Rx_Gain_Doppler
// 

const Default_Rx_Gain_Doppler::units_type& Default_Rx_Gain_Doppler::
units () const
{
  return this->units_.get ();
}

Default_Rx_Gain_Doppler::units_type& Default_Rx_Gain_Doppler::
units ()
{
  return this->units_.get ();
}

void Default_Rx_Gain_Doppler::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Rx_Gain_Doppler::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler_Low
// 

const Filter_Doppler_Low::units_type& Filter_Doppler_Low::
units () const
{
  return this->units_.get ();
}

Filter_Doppler_Low::units_type& Filter_Doppler_Low::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler_Low::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler_Low::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Buffer_Size
// 

const Buffer_Size::units_type& Buffer_Size::
units () const
{
  return this->units_.get ();
}

Buffer_Size::units_type& Buffer_Size::
units ()
{
  return this->units_.get ();
}

void Buffer_Size::
units (const units_type& x)
{
  this->units_.set (x);
}

void Buffer_Size::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// BMode_Size_Default
// 

const BMode_Size_Default::units_type& BMode_Size_Default::
units () const
{
  return this->units_.get ();
}

BMode_Size_Default::units_type& BMode_Size_Default::
units ()
{
  return this->units_.get ();
}

void BMode_Size_Default::
units (const units_type& x)
{
  this->units_.set (x);
}

void BMode_Size_Default::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Refresh_Rate
// 

const Refresh_Rate::units_type& Refresh_Rate::
units () const
{
  return this->units_.get ();
}

Refresh_Rate::units_type& Refresh_Rate::
units ()
{
  return this->units_.get ();
}

void Refresh_Rate::
units (const units_type& x)
{
  this->units_.set (x);
}

void Refresh_Rate::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Power_Size_Default
// 

const Power_Size_Default::units_type& Power_Size_Default::
units () const
{
  return this->units_.get ();
}

Power_Size_Default::units_type& Power_Size_Default::
units ()
{
  return this->units_.get ();
}

void Power_Size_Default::
units (const units_type& x)
{
  this->units_.set (x);
}

void Power_Size_Default::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Target_Field_Of_View
// 

const Target_Field_Of_View::units_type& Target_Field_Of_View::
units () const
{
  return this->units_.get ();
}

Target_Field_Of_View::units_type& Target_Field_Of_View::
units ()
{
  return this->units_.get ();
}

void Target_Field_Of_View::
units (const units_type& x)
{
  this->units_.set (x);
}

void Target_Field_Of_View::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sound_Speed
// 

const Sound_Speed::units_type& Sound_Speed::
units () const
{
  return this->units_.get ();
}

Sound_Speed::units_type& Sound_Speed::
units ()
{
  return this->units_.get ();
}

void Sound_Speed::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sound_Speed::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pipeline_Delay
// 

const Pipeline_Delay::units_type& Pipeline_Delay::
units () const
{
  return this->units_.get ();
}

Pipeline_Delay::units_type& Pipeline_Delay::
units ()
{
  return this->units_.get ();
}

void Pipeline_Delay::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pipeline_Delay::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Center
// 

const Center::units_type& Center::
units () const
{
  return this->units_.get ();
}

Center::units_type& Center::
units ()
{
  return this->units_.get ();
}

void Center::
units (const units_type& x)
{
  this->units_.set (x);
}

void Center::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Scan_Speed
// 

const V_Scan_Speed::units_type& V_Scan_Speed::
units () const
{
  return this->units_.get ();
}

V_Scan_Speed::units_type& V_Scan_Speed::
units ()
{
  return this->units_.get ();
}

void V_Scan_Speed::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Scan_Speed::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Scan_Rate
// 

const V_Scan_Rate::units_type& V_Scan_Rate::
units () const
{
  return this->units_.get ();
}

V_Scan_Rate::units_type& V_Scan_Rate::
units ()
{
  return this->units_.get ();
}

void V_Scan_Rate::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Scan_Rate::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Width
// 

const Scan_Width::units_type& Scan_Width::
units () const
{
  return this->units_.get ();
}

Scan_Width::units_type& Scan_Width::
units ()
{
  return this->units_.get ();
}

void Scan_Width::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Width::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position
// 

const Position::units_type& Position::
units () const
{
  return this->units_.get ();
}

Position::units_type& Position::
units ()
{
  return this->units_.get ();
}

void Position::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move_No_Wait
// 

const R_Scan_Move_No_Wait::units_type& R_Scan_Move_No_Wait::
units () const
{
  return this->units_.get ();
}

R_Scan_Move_No_Wait::units_type& R_Scan_Move_No_Wait::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move_No_Wait::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move_No_Wait::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Acceleration
// 

const Acceleration::units_type& Acceleration::
units () const
{
  return this->units_.get ();
}

Acceleration::units_type& Acceleration::
units ()
{
  return this->units_.get ();
}

void Acceleration::
units (const units_type& x)
{
  this->units_.set (x);
}

void Acceleration::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Velocity_Stationary
// 

const Velocity_Stationary::units_type& Velocity_Stationary::
units () const
{
  return this->units_.get ();
}

Velocity_Stationary::units_type& Velocity_Stationary::
units ()
{
  return this->units_.get ();
}

void Velocity_Stationary::
units (const units_type& x)
{
  this->units_.set (x);
}

void Velocity_Stationary::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move2
// 

const R_Scan_Move2::units_type& R_Scan_Move2::
units () const
{
  return this->units_.get ();
}

R_Scan_Move2::units_type& R_Scan_Move2::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move2::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move2::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Acceleration_Stationary
// 

const Acceleration_Stationary::units_type& Acceleration_Stationary::
units () const
{
  return this->units_.get ();
}

Acceleration_Stationary::units_type& Acceleration_Stationary::
units ()
{
  return this->units_.get ();
}

void Acceleration_Stationary::
units (const units_type& x)
{
  this->units_.set (x);
}

void Acceleration_Stationary::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position_Reverse
// 

const Position_Reverse::units_type& Position_Reverse::
units () const
{
  return this->units_.get ();
}

Position_Reverse::units_type& Position_Reverse::
units ()
{
  return this->units_.get ();
}

void Position_Reverse::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position_Reverse::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position2
// 

const Position2::units_type& Position2::
units () const
{
  return this->units_.get ();
}

Position2::units_type& Position2::
units ()
{
  return this->units_.get ();
}

void Position2::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position2::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Velocity
// 

const Velocity::units_type& Velocity::
units () const
{
  return this->units_.get ();
}

Velocity::units_type& Velocity::
units ()
{
  return this->units_.get ();
}

void Velocity::
units (const units_type& x)
{
  this->units_.set (x);
}

void Velocity::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move
// 

const R_Scan_Move::units_type& R_Scan_Move::
units () const
{
  return this->units_.get ();
}

R_Scan_Move::units_type& R_Scan_Move::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position_Forward
// 

const Position_Forward::units_type& Position_Forward::
units () const
{
  return this->units_.get ();
}

Position_Forward::units_type& Position_Forward::
units ()
{
  return this->units_.get ();
}

void Position_Forward::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position_Forward::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_3point3V
// 

const Monitor_3point3V::units_type& Monitor_3point3V::
units () const
{
  return this->units_.get ();
}

Monitor_3point3V::units_type& Monitor_3point3V::
units ()
{
  return this->units_.get ();
}

void Monitor_3point3V::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_3point3V::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_15V
// 

const Monitor_15V::units_type& Monitor_15V::
units () const
{
  return this->units_.get ();
}

Monitor_15V::units_type& Monitor_15V::
units ()
{
  return this->units_.get ();
}

void Monitor_15V::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_15V::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_5V
// 

const Monitor_5V::units_type& Monitor_5V::
units () const
{
  return this->units_.get ();
}

Monitor_5V::units_type& Monitor_5V::
units ()
{
  return this->units_.get ();
}

void Monitor_5V::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_5V::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_Neg15V
// 

const Monitor_Neg15V::units_type& Monitor_Neg15V::
units () const
{
  return this->units_.get ();
}

Monitor_Neg15V::units_type& Monitor_Neg15V::
units ()
{
  return this->units_.get ();
}

void Monitor_Neg15V::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_Neg15V::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_Neg5V
// 

const Monitor_Neg5V::units_type& Monitor_Neg5V::
units () const
{
  return this->units_.get ();
}

Monitor_Neg5V::units_type& Monitor_Neg5V::
units ()
{
  return this->units_.get ();
}

void Monitor_Neg5V::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_Neg5V::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Threshold_Change
// 

const Respiration_Threshold_Change::units_type& Respiration_Threshold_Change::
units () const
{
  return this->units_.get ();
}

Respiration_Threshold_Change::units_type& Respiration_Threshold_Change::
units ()
{
  return this->units_.get ();
}

void Respiration_Threshold_Change::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Threshold_Change::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Range
// 

const Pressure_Range::units_type& Pressure_Range::
units () const
{
  return this->units_.get ();
}

Pressure_Range::units_type& Pressure_Range::
units ()
{
  return this->units_.get ();
}

void Pressure_Range::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Range::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Gate_Delay
// 

const Respiration_Gate_Delay::units_type& Respiration_Gate_Delay::
units () const
{
  return this->units_.get ();
}

Respiration_Gate_Delay::units_type& Respiration_Gate_Delay::
units ()
{
  return this->units_.get ();
}

void Respiration_Gate_Delay::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Gate_Delay::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Timeout
// 

const Respiration_Timeout::units_type& Respiration_Timeout::
units () const
{
  return this->units_.get ();
}

Respiration_Timeout::units_type& Respiration_Timeout::
units ()
{
  return this->units_.get ();
}

void Respiration_Timeout::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Timeout::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Max_Change_Factor_Percent
// 

const RWave_Max_Change_Factor_Percent::units_type& RWave_Max_Change_Factor_Percent::
units () const
{
  return this->units_.get ();
}

RWave_Max_Change_Factor_Percent::units_type& RWave_Max_Change_Factor_Percent::
units ()
{
  return this->units_.get ();
}

void RWave_Max_Change_Factor_Percent::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Max_Change_Factor_Percent::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Period
// 

const Respiration_Period::units_type& Respiration_Period::
units () const
{
  return this->units_.get ();
}

Respiration_Period::units_type& Respiration_Period::
units ()
{
  return this->units_.get ();
}

void Respiration_Period::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Period::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Subsample_Rate
// 

const Respiration_Subsample_Rate::units_type& Respiration_Subsample_Rate::
units () const
{
  return this->units_.get ();
}

Respiration_Subsample_Rate::units_type& Respiration_Subsample_Rate::
units ()
{
  return this->units_.get ();
}

void Respiration_Subsample_Rate::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Subsample_Rate::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Window
// 

const Respiration_Window::units_type& Respiration_Window::
units () const
{
  return this->units_.get ();
}

Respiration_Window::units_type& Respiration_Window::
units ()
{
  return this->units_.get ();
}

void Respiration_Window::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Window::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Systolic
// 

const Pressure_Systolic::units_type& Pressure_Systolic::
units () const
{
  return this->units_.get ();
}

Pressure_Systolic::units_type& Pressure_Systolic::
units ()
{
  return this->units_.get ();
}

void Pressure_Systolic::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Systolic::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency1
// 

const Frequency1::units_type& Frequency1::
units () const
{
  return this->units_.get ();
}

Frequency1::units_type& Frequency1::
units ()
{
  return this->units_.get ();
}

void Frequency1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Blank_Period
// 

const Respiration_Blank_Period::units_type& Respiration_Blank_Period::
units () const
{
  return this->units_.get ();
}

Respiration_Blank_Period::units_type& Respiration_Blank_Period::
units ()
{
  return this->units_.get ();
}

void Respiration_Blank_Period::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Blank_Period::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Range
// 

const Respiration_Range::units_type& Respiration_Range::
units () const
{
  return this->units_.get ();
}

Respiration_Range::units_type& Respiration_Range::
units ()
{
  return this->units_.get ();
}

void Respiration_Range::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Range::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Zero
// 

const Pressure_Zero::units_type& Pressure_Zero::
units () const
{
  return this->units_.get ();
}

Pressure_Zero::units_type& Pressure_Zero::
units ()
{
  return this->units_.get ();
}

void Pressure_Zero::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Zero::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// P_Wave_Start
// 

const P_Wave_Start::units_type& P_Wave_Start::
units () const
{
  return this->units_.get ();
}

P_Wave_Start::units_type& P_Wave_Start::
units ()
{
  return this->units_.get ();
}

void P_Wave_Start::
units (const units_type& x)
{
  this->units_.set (x);
}

void P_Wave_Start::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Future_Search_Time
// 

const RWave_Future_Search_Time::units_type& RWave_Future_Search_Time::
units () const
{
  return this->units_.get ();
}

RWave_Future_Search_Time::units_type& RWave_Future_Search_Time::
units ()
{
  return this->units_.get ();
}

void RWave_Future_Search_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Future_Search_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Percent_Peak
// 

const Respiration_Percent_Peak::units_type& Respiration_Percent_Peak::
units () const
{
  return this->units_.get ();
}

Respiration_Percent_Peak::units_type& Respiration_Percent_Peak::
units ()
{
  return this->units_.get ();
}

void Respiration_Percent_Peak::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Percent_Peak::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// T_Wave_Start
// 

const T_Wave_Start::units_type& T_Wave_Start::
units () const
{
  return this->units_.get ();
}

T_Wave_Start::units_type& T_Wave_Start::
units ()
{
  return this->units_.get ();
}

void T_Wave_Start::
units (const units_type& x)
{
  this->units_.set (x);
}

void T_Wave_Start::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Strain_Rate_RR_Diff_Ratio
// 

const Strain_Rate_RR_Diff_Ratio::units_type& Strain_Rate_RR_Diff_Ratio::
units () const
{
  return this->units_.get ();
}

Strain_Rate_RR_Diff_Ratio::units_type& Strain_Rate_RR_Diff_Ratio::
units ()
{
  return this->units_.get ();
}

void Strain_Rate_RR_Diff_Ratio::
units (const units_type& x)
{
  this->units_.set (x);
}

void Strain_Rate_RR_Diff_Ratio::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Diastolic
// 

const Pressure_Diastolic::units_type& Pressure_Diastolic::
units () const
{
  return this->units_.get ();
}

Pressure_Diastolic::units_type& Pressure_Diastolic::
units ()
{
  return this->units_.get ();
}

void Pressure_Diastolic::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Diastolic::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Temperature_Calibration
// 

const Temperature_Calibration::units_type& Temperature_Calibration::
units () const
{
  return this->units_.get ();
}

Temperature_Calibration::units_type& Temperature_Calibration::
units ()
{
  return this->units_.get ();
}

void Temperature_Calibration::
units (const units_type& x)
{
  this->units_.set (x);
}

void Temperature_Calibration::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Temperature
// 

const Temperature::units_type& Temperature::
units () const
{
  return this->units_.get ();
}

Temperature::units_type& Temperature::
units ()
{
  return this->units_.get ();
}

void Temperature::
units (const units_type& x)
{
  this->units_.set (x);
}

void Temperature::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Beats_To_Average
// 

const Respiration_Beats_To_Average::units_type& Respiration_Beats_To_Average::
units () const
{
  return this->units_.get ();
}

Respiration_Beats_To_Average::units_type& Respiration_Beats_To_Average::
units ()
{
  return this->units_.get ();
}

void Respiration_Beats_To_Average::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Beats_To_Average::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Thresh_Trigger_Percent
// 

const RWave_Thresh_Trigger_Percent::units_type& RWave_Thresh_Trigger_Percent::
units () const
{
  return this->units_.get ();
}

RWave_Thresh_Trigger_Percent::units_type& RWave_Thresh_Trigger_Percent::
units ()
{
  return this->units_.get ();
}

void RWave_Thresh_Trigger_Percent::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Thresh_Trigger_Percent::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Time_To_Average
// 

const Respiration_Time_To_Average::units_type& Respiration_Time_To_Average::
units () const
{
  return this->units_.get ();
}

Respiration_Time_To_Average::units_type& Respiration_Time_To_Average::
units ()
{
  return this->units_.get ();
}

void Respiration_Time_To_Average::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Time_To_Average::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Heart_Period
// 

const Heart_Period::units_type& Heart_Period::
units () const
{
  return this->units_.get ();
}

Heart_Period::units_type& Heart_Period::
units ()
{
  return this->units_.get ();
}

void Heart_Period::
units (const units_type& x)
{
  this->units_.set (x);
}

void Heart_Period::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_Range
// 

const ECG_Range::units_type& ECG_Range::
units () const
{
  return this->units_.get ();
}

ECG_Range::units_type& ECG_Range::
units ()
{
  return this->units_.get ();
}

void ECG_Range::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_Range::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Maxima_Block_Time
// 

const RWave_Maxima_Block_Time::units_type& RWave_Maxima_Block_Time::
units () const
{
  return this->units_.get ();
}

RWave_Maxima_Block_Time::units_type& RWave_Maxima_Block_Time::
units ()
{
  return this->units_.get ();
}

void RWave_Maxima_Block_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Maxima_Block_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Calibration_Level
// 

const Pressure_Calibration_Level::units_type& Pressure_Calibration_Level::
units () const
{
  return this->units_.get ();
}

Pressure_Calibration_Level::units_type& Pressure_Calibration_Level::
units ()
{
  return this->units_.get ();
}

void Pressure_Calibration_Level::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Calibration_Level::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_HP_Filter
// 

const ECG_HP_Filter::units_type& ECG_HP_Filter::
units () const
{
  return this->units_.get ();
}

ECG_HP_Filter::units_type& ECG_HP_Filter::
units ()
{
  return this->units_.get ();
}

void ECG_HP_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_HP_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_LP_Filter
// 

const ECG_LP_Filter::units_type& ECG_LP_Filter::
units () const
{
  return this->units_.get ();
}

ECG_LP_Filter::units_type& ECG_LP_Filter::
units ()
{
  return this->units_.get ();
}

void ECG_LP_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_LP_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Max_Change_Period
// 

const RWave_Max_Change_Period::units_type& RWave_Max_Change_Period::
units () const
{
  return this->units_.get ();
}

RWave_Max_Change_Period::units_type& RWave_Max_Change_Period::
units ()
{
  return this->units_.get ();
}

void RWave_Max_Change_Period::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Max_Change_Period::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Calibration
// 

const Pressure_Calibration::units_type& Pressure_Calibration::
units () const
{
  return this->units_.get ();
}

Pressure_Calibration::units_type& Pressure_Calibration::
units ()
{
  return this->units_.get ();
}

void Pressure_Calibration::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Calibration::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Blank_Time
// 

const RWave_Blank_Time::units_type& RWave_Blank_Time::
units () const
{
  return this->units_.get ();
}

RWave_Blank_Time::units_type& RWave_Blank_Time::
units ()
{
  return this->units_.get ();
}

void RWave_Blank_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Blank_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Magnitude_Origin
// 

const Magnitude_Origin::units_type& Magnitude_Origin::
units () const
{
  return this->units_.get ();
}

Magnitude_Origin::units_type& Magnitude_Origin::
units ()
{
  return this->units_.get ();
}

void Magnitude_Origin::
units (const units_type& x)
{
  this->units_.set (x);
}

void Magnitude_Origin::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Origin
// 

const Frequency_Origin::units_type& Frequency_Origin::
units () const
{
  return this->units_.get ();
}

Frequency_Origin::units_type& Frequency_Origin::
units ()
{
  return this->units_.get ();
}

void Frequency_Origin::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Origin::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Length_Origin
// 

const Length_Origin::units_type& Length_Origin::
units () const
{
  return this->units_.get ();
}

Length_Origin::units_type& Length_Origin::
units ()
{
  return this->units_.get ();
}

void Length_Origin::
units (const units_type& x)
{
  this->units_.set (x);
}

void Length_Origin::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Vertical_Scale
// 

const Vertical_Scale::units_type& Vertical_Scale::
units () const
{
  return this->units_.get ();
}

Vertical_Scale::units_type& Vertical_Scale::
units ()
{
  return this->units_.get ();
}

void Vertical_Scale::
units (const units_type& x)
{
  this->units_.set (x);
}

void Vertical_Scale::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// SamplesPerSec
// 

const SamplesPerSec::units_type& SamplesPerSec::
units () const
{
  return this->units_.get ();
}

SamplesPerSec::units_type& SamplesPerSec::
units ()
{
  return this->units_.get ();
}

void SamplesPerSec::
units (const units_type& x)
{
  this->units_.set (x);
}

void SamplesPerSec::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Magnitude_Height
// 

const Magnitude_Height::units_type& Magnitude_Height::
units () const
{
  return this->units_.get ();
}

Magnitude_Height::units_type& Magnitude_Height::
units ()
{
  return this->units_.get ();
}

void Magnitude_Height::
units (const units_type& x)
{
  this->units_.set (x);
}

void Magnitude_Height::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Length_Length
// 

const Length_Length::units_type& Length_Length::
units () const
{
  return this->units_.get ();
}

Length_Length::units_type& Length_Length::
units ()
{
  return this->units_.get ();
}

void Length_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void Length_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Length
// 

const Frequency_Length::units_type& Frequency_Length::
units () const
{
  return this->units_.get ();
}

Frequency_Length::units_type& Frequency_Length::
units ()
{
  return this->units_.get ();
}

void Frequency_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// SV_Center
// 

const SV_Center::units_type& SV_Center::
units () const
{
  return this->units_.get ();
}

SV_Center::units_type& SV_Center::
units ()
{
  return this->units_.get ();
}

void SV_Center::
units (const units_type& x)
{
  this->units_.set (x);
}

void SV_Center::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Path_15Mhz_Time_Correction
// 

const RF_Path_15Mhz_Time_Correction::units_type& RF_Path_15Mhz_Time_Correction::
units () const
{
  return this->units_.get ();
}

RF_Path_15Mhz_Time_Correction::units_type& RF_Path_15Mhz_Time_Correction::
units ()
{
  return this->units_.get ();
}

void RF_Path_15Mhz_Time_Correction::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Path_15Mhz_Time_Correction::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Path_23Mhz_Time_Correction
// 

const RF_Path_23Mhz_Time_Correction::units_type& RF_Path_23Mhz_Time_Correction::
units () const
{
  return this->units_.get ();
}

RF_Path_23Mhz_Time_Correction::units_type& RF_Path_23Mhz_Time_Correction::
units ()
{
  return this->units_.get ();
}

void RF_Path_23Mhz_Time_Correction::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Path_23Mhz_Time_Correction::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// SV_Length_Limits
// 

const SV_Length_Limits::units_type& SV_Length_Limits::
units () const
{
  return this->units_.get ();
}

SV_Length_Limits::units_type& SV_Length_Limits::
units ()
{
  return this->units_.get ();
}

void SV_Length_Limits::
units (const units_type& x)
{
  this->units_.set (x);
}

void SV_Length_Limits::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Transmit_Length
// 

const V_Transmit_Length::units_type& V_Transmit_Length::
units () const
{
  return this->units_.get ();
}

V_Transmit_Length::units_type& V_Transmit_Length::
units ()
{
  return this->units_.get ();
}

void V_Transmit_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Transmit_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Pulse_Rep_Freq
// 

const V_Pulse_Rep_Freq::units_type& V_Pulse_Rep_Freq::
units () const
{
  return this->units_.get ();
}

V_Pulse_Rep_Freq::units_type& V_Pulse_Rep_Freq::
units ()
{
  return this->units_.get ();
}

void V_Pulse_Rep_Freq::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Pulse_Rep_Freq::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency2
// 

const Frequency2::units_type& Frequency2::
units () const
{
  return this->units_.get ();
}

Frequency2::units_type& Frequency2::
units ()
{
  return this->units_.get ();
}

void Frequency2::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency2::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Unblank_Time
// 

const V_Unblank_Time::units_type& V_Unblank_Time::
units () const
{
  return this->units_.get ();
}

V_Unblank_Time::units_type& V_Unblank_Time::
units ()
{
  return this->units_.get ();
}

void V_Unblank_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Unblank_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Frequency
// 

const V_Frequency::units_type& V_Frequency::
units () const
{
  return this->units_.get ();
}

V_Frequency::units_type& V_Frequency::
units ()
{
  return this->units_.get ();
}

void V_Frequency::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Frequency::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pulse_Rep_Frequency
// 

const Pulse_Rep_Frequency::units_type& Pulse_Rep_Frequency::
units () const
{
  return this->units_.get ();
}

Pulse_Rep_Frequency::units_type& Pulse_Rep_Frequency::
units ()
{
  return this->units_.get ();
}

void Pulse_Rep_Frequency::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pulse_Rep_Frequency::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Trig_Tbl_Trigs
// 

const Trig_Tbl_Trigs::units_type& Trig_Tbl_Trigs::
units () const
{
  return this->units_.get ();
}

Trig_Tbl_Trigs::units_type& Trig_Tbl_Trigs::
units ()
{
  return this->units_.get ();
}

void Trig_Tbl_Trigs::
units (const units_type& x)
{
  this->units_.set (x);
}

void Trig_Tbl_Trigs::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Unblank_Cycles
// 

const Unblank_Cycles::units_type& Unblank_Cycles::
units () const
{
  return this->units_.get ();
}

Unblank_Cycles::units_type& Unblank_Cycles::
units ()
{
  return this->units_.get ();
}

void Unblank_Cycles::
units (const units_type& x)
{
  this->units_.set (x);
}

void Unblank_Cycles::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Unblank_Time
// 

const Unblank_Time::units_type& Unblank_Time::
units () const
{
  return this->units_.get ();
}

Unblank_Time::units_type& Unblank_Time::
units ()
{
  return this->units_.get ();
}

void Unblank_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void Unblank_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Attenuation
// 

const Attenuation::units_type& Attenuation::
units () const
{
  return this->units_.get ();
}

Attenuation::units_type& Attenuation::
units ()
{
  return this->units_.get ();
}

void Attenuation::
units (const units_type& x)
{
  this->units_.set (x);
}

void Attenuation::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Power
// 

const V_Power::units_type& V_Power::
units () const
{
  return this->units_.get ();
}

V_Power::units_type& V_Power::
units ()
{
  return this->units_.get ();
}

void V_Power::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Power::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Distance
// 

const Scan_Distance::units_type& Scan_Distance::
units () const
{
  return this->units_.get ();
}

Scan_Distance::units_type& Scan_Distance::
units ()
{
  return this->units_.get ();
}

void Scan_Distance::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Distance::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Step_Size
// 

const Step_Size::units_type& Step_Size::
units () const
{
  return this->units_.get ();
}

Step_Size::units_type& Step_Size::
units ()
{
  return this->units_.get ();
}

void Step_Size::
units (const units_type& x)
{
  this->units_.set (x);
}

void Step_Size::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Ref_Probe_Focal_Length
// 

const Ref_Probe_Focal_Length::units_type& Ref_Probe_Focal_Length::
units () const
{
  return this->units_.get ();
}

Ref_Probe_Focal_Length::units_type& Ref_Probe_Focal_Length::
units ()
{
  return this->units_.get ();
}

void Ref_Probe_Focal_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void Ref_Probe_Focal_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Ref_Tx_Frequency
// 

const Ref_Tx_Frequency::units_type& Ref_Tx_Frequency::
units () const
{
  return this->units_.get ();
}

Ref_Tx_Frequency::units_type& Ref_Tx_Frequency::
units ()
{
  return this->units_.get ();
}

void Ref_Tx_Frequency::
units (const units_type& x)
{
  this->units_.set (x);
}

void Ref_Tx_Frequency::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Normalized_Height
// 

const Normalized_Height::units_type& Normalized_Height::
units () const
{
  return this->units_.get ();
}

Normalized_Height::units_type& Normalized_Height::
units ()
{
  return this->units_.get ();
}

void Normalized_Height::
units (const units_type& x)
{
  this->units_.set (x);
}

void Normalized_Height::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Normalized_Origin
// 

const Normalized_Origin::units_type& Normalized_Origin::
units () const
{
  return this->units_.get ();
}

Normalized_Origin::units_type& Normalized_Origin::
units ()
{
  return this->units_.get ();
}

void Normalized_Origin::
units (const units_type& x)
{
  this->units_.set (x);
}

void Normalized_Origin::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Ref_Tx_Power
// 

const Ref_Tx_Power::units_type& Ref_Tx_Power::
units () const
{
  return this->units_.get ();
}

Ref_Tx_Power::units_type& Ref_Tx_Power::
units ()
{
  return this->units_.get ();
}

void Ref_Tx_Power::
units (const units_type& x)
{
  this->units_.set (x);
}

void Ref_Tx_Power::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Freq_Range_Max
// 

const Freq_Range_Max::units_type& Freq_Range_Max::
units () const
{
  return this->units_.get ();
}

Freq_Range_Max::units_type& Freq_Range_Max::
units ()
{
  return this->units_.get ();
}

void Freq_Range_Max::
units (const units_type& x)
{
  this->units_.set (x);
}

void Freq_Range_Max::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Freq_Range_Min
// 

const Freq_Range_Min::units_type& Freq_Range_Min::
units () const
{
  return this->units_.get ();
}

Freq_Range_Min::units_type& Freq_Range_Min::
units ()
{
  return this->units_.get ();
}

void Freq_Range_Min::
units (const units_type& x)
{
  this->units_.set (x);
}

void Freq_Range_Min::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Width_Target
// 

const Sector_Width_Target::units_type& Sector_Width_Target::
units () const
{
  return this->units_.get ();
}

Sector_Width_Target::units_type& Sector_Width_Target::
units ()
{
  return this->units_.get ();
}

void Sector_Width_Target::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Width_Target::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Gain
// 

const RF_Gain::units_type& RF_Gain::
units () const
{
  return this->units_.get ();
}

RF_Gain::units_type& RF_Gain::
units ()
{
  return this->units_.get ();
}

void RF_Gain::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Gain::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Digi_Depth_Imaging
// 

const V_Digi_Depth_Imaging::units_type& V_Digi_Depth_Imaging::
units () const
{
  return this->units_.get ();
}

V_Digi_Depth_Imaging::units_type& V_Digi_Depth_Imaging::
units ()
{
  return this->units_.get ();
}

void V_Digi_Depth_Imaging::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Digi_Depth_Imaging::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Test_Freq
// 

const Test_Freq::units_type& Test_Freq::
units () const
{
  return this->units_.get ();
}

Test_Freq::units_type& Test_Freq::
units ()
{
  return this->units_.get ();
}

void Test_Freq::
units (const units_type& x)
{
  this->units_.set (x);
}

void Test_Freq::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// IF_Filter
// 

const IF_Filter::units_type& IF_Filter::
units () const
{
  return this->units_.get ();
}

IF_Filter::units_type& IF_Filter::
units ()
{
  return this->units_.get ();
}

void IF_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void IF_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Track_Width
// 

const Track_Width::units_type& Track_Width::
units () const
{
  return this->units_.get ();
}

Track_Width::units_type& Track_Width::
units ()
{
  return this->units_.get ();
}

void Track_Width::
units (const units_type& x)
{
  this->units_.set (x);
}

void Track_Width::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_IF_Filter
// 

const V_IF_Filter::units_type& V_IF_Filter::
units () const
{
  return this->units_.get ();
}

V_IF_Filter::units_type& V_IF_Filter::
units ()
{
  return this->units_.get ();
}

void V_IF_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_IF_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// HP_Clutter
// 

const HP_Clutter::units_type& HP_Clutter::
units () const
{
  return this->units_.get ();
}

HP_Clutter::units_type& HP_Clutter::
units ()
{
  return this->units_.get ();
}

void HP_Clutter::
units (const units_type& x)
{
  this->units_.set (x);
}

void HP_Clutter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Filter
// 

const RF_Filter::units_type& RF_Filter::
units () const
{
  return this->units_.get ();
}

RF_Filter::units_type& RF_Filter::
units ()
{
  return this->units_.get ();
}

void RF_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_RF_Filter
// 

const V_RF_Filter::units_type& V_RF_Filter::
units () const
{
  return this->units_.get ();
}

V_RF_Filter::units_type& V_RF_Filter::
units ()
{
  return this->units_.get ();
}

void V_RF_Filter::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_RF_Filter::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Delay
// 

const Delay::units_type& Delay::
units () const
{
  return this->units_.get ();
}

Delay::units_type& Delay::
units ()
{
  return this->units_.get ();
}

void Delay::
units (const units_type& x)
{
  this->units_.set (x);
}

void Delay::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// AD_Gate_Width
// 

const AD_Gate_Width::units_type& AD_Gate_Width::
units () const
{
  return this->units_.get ();
}

AD_Gate_Width::units_type& AD_Gate_Width::
units ()
{
  return this->units_.get ();
}

void AD_Gate_Width::
units (const units_type& x)
{
  this->units_.set (x);
}

void AD_Gate_Width::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency3
// 

const Frequency3::units_type& Frequency3::
units () const
{
  return this->units_.get ();
}

Frequency3::units_type& Frequency3::
units ()
{
  return this->units_.get ();
}

void Frequency3::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency3::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Frequency1
// 

const V_Frequency1::units_type& V_Frequency1::
units () const
{
  return this->units_.get ();
}

V_Frequency1::units_type& V_Frequency1::
units ()
{
  return this->units_.get ();
}

void V_Frequency1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Frequency1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Field_Of_View
// 

const V_Field_Of_View::units_type& V_Field_Of_View::
units () const
{
  return this->units_.get ();
}

V_Field_Of_View::units_type& V_Field_Of_View::
units ()
{
  return this->units_.get ();
}

void V_Field_Of_View::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Field_Of_View::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Height_Target
// 

const Sector_Height_Target::units_type& Sector_Height_Target::
units () const
{
  return this->units_.get ();
}

Sector_Height_Target::units_type& Sector_Height_Target::
units ()
{
  return this->units_.get ();
}

void Sector_Height_Target::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Height_Target::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// AD_TestIn
// 

const AD_TestIn::units_type& AD_TestIn::
units () const
{
  return this->units_.get ();
}

AD_TestIn::units_type& AD_TestIn::
units ()
{
  return this->units_.get ();
}

void AD_TestIn::
units (const units_type& x)
{
  this->units_.set (x);
}

void AD_TestIn::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Delay_Length
// 

const V_Delay_Length::units_type& V_Delay_Length::
units () const
{
  return this->units_.get ();
}

V_Delay_Length::units_type& V_Delay_Length::
units ()
{
  return this->units_.get ();
}

void V_Delay_Length::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Delay_Length::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Window_Time
// 

const Window_Time::units_type& Window_Time::
units () const
{
  return this->units_.get ();
}

Window_Time::units_type& Window_Time::
units ()
{
  return this->units_.get ();
}

void Window_Time::
units (const units_type& x)
{
  this->units_.set (x);
}

void Window_Time::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sample_Time1
// 

const Sample_Time1::units_type& Sample_Time1::
units () const
{
  return this->units_.get ();
}

Sample_Time1::units_type& Sample_Time1::
units ()
{
  return this->units_.get ();
}

void Sample_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sample_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Focal_Length1
// 

const Focal_Length1::units_type& Focal_Length1::
units () const
{
  return this->units_.get ();
}

Focal_Length1::units_type& Focal_Length1::
units ()
{
  return this->units_.get ();
}

void Focal_Length1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Focal_Length1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Scan_Speed1
// 

const Default_Scan_Speed1::units_type& Default_Scan_Speed1::
units () const
{
  return this->units_.get ();
}

Default_Scan_Speed1::units_type& Default_Scan_Speed1::
units ()
{
  return this->units_.get ();
}

void Default_Scan_Speed1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Scan_Speed1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Cutoff_Scan_Speed1
// 

const Cutoff_Scan_Speed1::units_type& Cutoff_Scan_Speed1::
units () const
{
  return this->units_.get ();
}

Cutoff_Scan_Speed1::units_type& Cutoff_Scan_Speed1::
units ()
{
  return this->units_.get ();
}

void Cutoff_Scan_Speed1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Cutoff_Scan_Speed1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Low1
// 

const Frequency_Low1::units_type& Frequency_Low1::
units () const
{
  return this->units_.get ();
}

Frequency_Low1::units_type& Frequency_Low1::
units ()
{
  return this->units_.get ();
}

void Frequency_Low1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Low1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_FOV1
// 

const Default_FOV1::units_type& Default_FOV1::
units () const
{
  return this->units_.get ();
}

Default_FOV1::units_type& Default_FOV1::
units ()
{
  return this->units_.get ();
}

void Default_FOV1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_FOV1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler_Default1
// 

const Frequency_Doppler_Default1::units_type& Frequency_Doppler_Default1::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler_Default1::units_type& Frequency_Doppler_Default1::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler_Default1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler_Default1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Axial_Res1
// 

const Axial_Res1::units_type& Axial_Res1::
units () const
{
  return this->units_.get ();
}

Axial_Res1::units_type& Axial_Res1::
units ()
{
  return this->units_.get ();
}

void Axial_Res1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Axial_Res1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pivot_Encoder_Dist1
// 

const Pivot_Encoder_Dist1::units_type& Pivot_Encoder_Dist1::
units () const
{
  return this->units_.get ();
}

Pivot_Encoder_Dist1::units_type& Pivot_Encoder_Dist1::
units ()
{
  return this->units_.get ();
}

void Pivot_Encoder_Dist1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pivot_Encoder_Dist1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Range_Max1
// 

const Encoder_Range_Max1::units_type& Encoder_Range_Max1::
units () const
{
  return this->units_.get ();
}

Encoder_Range_Max1::units_type& Encoder_Range_Max1::
units ()
{
  return this->units_.get ();
}

void Encoder_Range_Max1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Range_Max1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Range_Min1
// 

const Encoder_Range_Min1::units_type& Encoder_Range_Min1::
units () const
{
  return this->units_.get ();
}

Encoder_Range_Min1::units_type& Encoder_Range_Min1::
units ()
{
  return this->units_.get ();
}

void Encoder_Range_Min1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Range_Min1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Lateral_Res1
// 

const Lateral_Res1::units_type& Lateral_Res1::
units () const
{
  return this->units_.get ();
}

Lateral_Res1::units_type& Lateral_Res1::
units ()
{
  return this->units_.get ();
}

void Lateral_Res1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Lateral_Res1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Max_Scan_Distance1
// 

const Max_Scan_Distance1::units_type& Max_Scan_Distance1::
units () const
{
  return this->units_.get ();
}

Max_Scan_Distance1::units_type& Max_Scan_Distance1::
units ()
{
  return this->units_.get ();
}

void Max_Scan_Distance1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Max_Scan_Distance1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Rx_Gain1
// 

const Default_Rx_Gain1::units_type& Default_Rx_Gain1::
units () const
{
  return this->units_.get ();
}

Default_Rx_Gain1::units_type& Default_Rx_Gain1::
units ()
{
  return this->units_.get ();
}

void Default_Rx_Gain1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Rx_Gain1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_High1
// 

const Frequency_High1::units_type& Frequency_High1::
units () const
{
  return this->units_.get ();
}

Frequency_High1::units_type& Frequency_High1::
units ()
{
  return this->units_.get ();
}

void Frequency_High1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_High1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Speeds1
// 

const Scan_Speeds1::units_type& Scan_Speeds1::
units () const
{
  return this->units_.get ();
}

Scan_Speeds1::units_type& Scan_Speeds1::
units ()
{
  return this->units_.get ();
}

void Scan_Speeds1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Speeds1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler_Cutoff1
// 

const Filter_Doppler_Cutoff1::units_type& Filter_Doppler_Cutoff1::
units () const
{
  return this->units_.get ();
}

Filter_Doppler_Cutoff1::units_type& Filter_Doppler_Cutoff1::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler_Cutoff1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler_Cutoff1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler_Low1
// 

const Frequency_Doppler_Low1::units_type& Frequency_Doppler_Low1::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler_Low1::units_type& Frequency_Doppler_Low1::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler_Low1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler_Low1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pivot_Transducer_Face_Dist1
// 

const Pivot_Transducer_Face_Dist1::units_type& Pivot_Transducer_Face_Dist1::
units () const
{
  return this->units_.get ();
}

Pivot_Transducer_Face_Dist1::units_type& Pivot_Transducer_Face_Dist1::
units ()
{
  return this->units_.get ();
}

void Pivot_Transducer_Face_Dist1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pivot_Transducer_Face_Dist1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler1
// 

const Filter_Doppler1::units_type& Filter_Doppler1::
units () const
{
  return this->units_.get ();
}

Filter_Doppler1::units_type& Filter_Doppler1::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency4
// 

const Frequency4::units_type& Frequency4::
units () const
{
  return this->units_.get ();
}

Frequency4::units_type& Frequency4::
units ()
{
  return this->units_.get ();
}

void Frequency4::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency4::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Encoder_Separation1
// 

const Encoder_Separation1::units_type& Encoder_Separation1::
units () const
{
  return this->units_.get ();
}

Encoder_Separation1::units_type& Encoder_Separation1::
units ()
{
  return this->units_.get ();
}

void Encoder_Separation1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Encoder_Separation1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Overshoot1
// 

const Overshoot1::units_type& Overshoot1::
units () const
{
  return this->units_.get ();
}

Overshoot1::units_type& Overshoot1::
units ()
{
  return this->units_.get ();
}

void Overshoot1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Overshoot1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter1
// 

const Filter1::units_type& Filter1::
units () const
{
  return this->units_.get ();
}

Filter1::units_type& Filter1::
units ()
{
  return this->units_.get ();
}

void Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Default_Rx_Gain_Doppler1
// 

const Default_Rx_Gain_Doppler1::units_type& Default_Rx_Gain_Doppler1::
units () const
{
  return this->units_.get ();
}

Default_Rx_Gain_Doppler1::units_type& Default_Rx_Gain_Doppler1::
units ()
{
  return this->units_.get ();
}

void Default_Rx_Gain_Doppler1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Default_Rx_Gain_Doppler1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Doppler_Low1
// 

const Filter_Doppler_Low1::units_type& Filter_Doppler_Low1::
units () const
{
  return this->units_.get ();
}

Filter_Doppler_Low1::units_type& Filter_Doppler_Low1::
units ()
{
  return this->units_.get ();
}

void Filter_Doppler_Low1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Doppler_Low1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency_Doppler1
// 

const Frequency_Doppler1::units_type& Frequency_Doppler1::
units () const
{
  return this->units_.get ();
}

Frequency_Doppler1::units_type& Frequency_Doppler1::
units ()
{
  return this->units_.get ();
}

void Frequency_Doppler1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency_Doppler1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_High1
// 

const Filter_High1::units_type& Filter_High1::
units () const
{
  return this->units_.get ();
}

Filter_High1::units_type& Filter_High1::
units ()
{
  return this->units_.get ();
}

void Filter_High1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_High1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Motor_Overhead1
// 

const Motor_Overhead1::units_type& Motor_Overhead1::
units () const
{
  return this->units_.get ();
}

Motor_Overhead1::units_type& Motor_Overhead1::
units ()
{
  return this->units_.get ();
}

void Motor_Overhead1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Motor_Overhead1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Filter_Low1
// 

const Filter_Low1::units_type& Filter_Low1::
units () const
{
  return this->units_.get ();
}

Filter_Low1::units_type& Filter_Low1::
units ()
{
  return this->units_.get ();
}

void Filter_Low1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Filter_Low1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Buffer_Size1
// 

const Buffer_Size1::units_type& Buffer_Size1::
units () const
{
  return this->units_.get ();
}

Buffer_Size1::units_type& Buffer_Size1::
units ()
{
  return this->units_.get ();
}

void Buffer_Size1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Buffer_Size1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// BMode_Size_Default1
// 

const BMode_Size_Default1::units_type& BMode_Size_Default1::
units () const
{
  return this->units_.get ();
}

BMode_Size_Default1::units_type& BMode_Size_Default1::
units ()
{
  return this->units_.get ();
}

void BMode_Size_Default1::
units (const units_type& x)
{
  this->units_.set (x);
}

void BMode_Size_Default1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Overlay_Mode
// 

const Overlay_Mode::units_type& Overlay_Mode::
units () const
{
  return this->units_.get ();
}

Overlay_Mode::units_type& Overlay_Mode::
units ()
{
  return this->units_.get ();
}

void Overlay_Mode::
units (const units_type& x)
{
  this->units_.set (x);
}

void Overlay_Mode::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Refresh_Rate1
// 

const Refresh_Rate1::units_type& Refresh_Rate1::
units () const
{
  return this->units_.get ();
}

Refresh_Rate1::units_type& Refresh_Rate1::
units ()
{
  return this->units_.get ();
}

void Refresh_Rate1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Refresh_Rate1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Acquisition_Mode
// 

const Acquisition_Mode::units_type& Acquisition_Mode::
units () const
{
  return this->units_.get ();
}

Acquisition_Mode::units_type& Acquisition_Mode::
units ()
{
  return this->units_.get ();
}

void Acquisition_Mode::
units (const units_type& x)
{
  this->units_.set (x);
}

void Acquisition_Mode::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Actual_Scan_Rate
// 

const Actual_Scan_Rate::units_type& Actual_Scan_Rate::
units () const
{
  return this->units_.get ();
}

Actual_Scan_Rate::units_type& Actual_Scan_Rate::
units ()
{
  return this->units_.get ();
}

void Actual_Scan_Rate::
units (const units_type& x)
{
  this->units_.set (x);
}

void Actual_Scan_Rate::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_X_Res
// 

const Sector_X_Res::units_type& Sector_X_Res::
units () const
{
  return this->units_.get ();
}

Sector_X_Res::units_type& Sector_X_Res::
units ()
{
  return this->units_.get ();
}

void Sector_X_Res::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_X_Res::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Y_Res
// 

const Sector_Y_Res::units_type& Sector_Y_Res::
units () const
{
  return this->units_.get ();
}

Sector_Y_Res::units_type& Sector_Y_Res::
units ()
{
  return this->units_.get ();
}

void Sector_Y_Res::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Y_Res::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Power_Size_Default1
// 

const Power_Size_Default1::units_type& Power_Size_Default1::
units () const
{
  return this->units_.get ();
}

Power_Size_Default1::units_type& Power_Size_Default1::
units ()
{
  return this->units_.get ();
}

void Power_Size_Default1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Power_Size_Default1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_X_Start
// 

const Sector_X_Start::units_type& Sector_X_Start::
units () const
{
  return this->units_.get ();
}

Sector_X_Start::units_type& Sector_X_Start::
units ()
{
  return this->units_.get ();
}

void Sector_X_Start::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_X_Start::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Y_Start
// 

const Sector_Y_Start::units_type& Sector_Y_Start::
units () const
{
  return this->units_.get ();
}

Sector_Y_Start::units_type& Sector_Y_Start::
units ()
{
  return this->units_.get ();
}

void Sector_Y_Start::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Y_Start::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Target_Field_Of_View1
// 

const Target_Field_Of_View1::units_type& Target_Field_Of_View1::
units () const
{
  return this->units_.get ();
}

Target_Field_Of_View1::units_type& Target_Field_Of_View1::
units ()
{
  return this->units_.get ();
}

void Target_Field_Of_View1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Target_Field_Of_View1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sound_Speed1
// 

const Sound_Speed1::units_type& Sound_Speed1::
units () const
{
  return this->units_.get ();
}

Sound_Speed1::units_type& Sound_Speed1::
units ()
{
  return this->units_.get ();
}

void Sound_Speed1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sound_Speed1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pipeline_Delay1
// 

const Pipeline_Delay1::units_type& Pipeline_Delay1::
units () const
{
  return this->units_.get ();
}

Pipeline_Delay1::units_type& Pipeline_Delay1::
units ()
{
  return this->units_.get ();
}

void Pipeline_Delay1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pipeline_Delay1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Reference_3D_Step_Size
// 

const Reference_3D_Step_Size::units_type& Reference_3D_Step_Size::
units () const
{
  return this->units_.get ();
}

Reference_3D_Step_Size::units_type& Reference_3D_Step_Size::
units ()
{
  return this->units_.get ();
}

void Reference_3D_Step_Size::
units (const units_type& x)
{
  this->units_.set (x);
}

void Reference_3D_Step_Size::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Contrast_Size_Default
// 

const Contrast_Size_Default::units_type& Contrast_Size_Default::
units () const
{
  return this->units_.get ();
}

Contrast_Size_Default::units_type& Contrast_Size_Default::
units ()
{
  return this->units_.get ();
}

void Contrast_Size_Default::
units (const units_type& x)
{
  this->units_.set (x);
}

void Contrast_Size_Default::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Reference_3D_Scan_Distance
// 

const Reference_3D_Scan_Distance::units_type& Reference_3D_Scan_Distance::
units () const
{
  return this->units_.get ();
}

Reference_3D_Scan_Distance::units_type& Reference_3D_Scan_Distance::
units ()
{
  return this->units_.get ();
}

void Reference_3D_Scan_Distance::
units (const units_type& x)
{
  this->units_.set (x);
}

void Reference_3D_Scan_Distance::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Center1
// 

const Center1::units_type& Center1::
units () const
{
  return this->units_.get ();
}

Center1::units_type& Center1::
units ()
{
  return this->units_.get ();
}

void Center1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Center1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Scan_Speed1
// 

const V_Scan_Speed1::units_type& V_Scan_Speed1::
units () const
{
  return this->units_.get ();
}

V_Scan_Speed1::units_type& V_Scan_Speed1::
units ()
{
  return this->units_.get ();
}

void V_Scan_Speed1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Scan_Speed1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Scan_Rate1
// 

const V_Scan_Rate1::units_type& V_Scan_Rate1::
units () const
{
  return this->units_.get ();
}

V_Scan_Rate1::units_type& V_Scan_Rate1::
units ()
{
  return this->units_.get ();
}

void V_Scan_Rate1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Scan_Rate1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Width1
// 

const Scan_Width1::units_type& Scan_Width1::
units () const
{
  return this->units_.get ();
}

Scan_Width1::units_type& Scan_Width1::
units ()
{
  return this->units_.get ();
}

void Scan_Width1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Width1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position1
// 

const Position1::units_type& Position1::
units () const
{
  return this->units_.get ();
}

Position1::units_type& Position1::
units ()
{
  return this->units_.get ();
}

void Position1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move_No_Wait1
// 

const R_Scan_Move_No_Wait1::units_type& R_Scan_Move_No_Wait1::
units () const
{
  return this->units_.get ();
}

R_Scan_Move_No_Wait1::units_type& R_Scan_Move_No_Wait1::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move_No_Wait1::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move_No_Wait1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Acceleration1
// 

const Acceleration1::units_type& Acceleration1::
units () const
{
  return this->units_.get ();
}

Acceleration1::units_type& Acceleration1::
units ()
{
  return this->units_.get ();
}

void Acceleration1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Acceleration1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Velocity_Stationary1
// 

const Velocity_Stationary1::units_type& Velocity_Stationary1::
units () const
{
  return this->units_.get ();
}

Velocity_Stationary1::units_type& Velocity_Stationary1::
units ()
{
  return this->units_.get ();
}

void Velocity_Stationary1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Velocity_Stationary1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move21
// 

const R_Scan_Move21::units_type& R_Scan_Move21::
units () const
{
  return this->units_.get ();
}

R_Scan_Move21::units_type& R_Scan_Move21::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move21::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move21::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position_Reverse1
// 

const Position_Reverse1::units_type& Position_Reverse1::
units () const
{
  return this->units_.get ();
}

Position_Reverse1::units_type& Position_Reverse1::
units ()
{
  return this->units_.get ();
}

void Position_Reverse1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position_Reverse1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position21
// 

const Position21::units_type& Position21::
units () const
{
  return this->units_.get ();
}

Position21::units_type& Position21::
units ()
{
  return this->units_.get ();
}

void Position21::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position21::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Velocity1
// 

const Velocity1::units_type& Velocity1::
units () const
{
  return this->units_.get ();
}

Velocity1::units_type& Velocity1::
units ()
{
  return this->units_.get ();
}

void Velocity1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Velocity1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// R_Scan_Move1
// 

const R_Scan_Move1::units_type& R_Scan_Move1::
units () const
{
  return this->units_.get ();
}

R_Scan_Move1::units_type& R_Scan_Move1::
units ()
{
  return this->units_.get ();
}

void R_Scan_Move1::
units (const units_type& x)
{
  this->units_.set (x);
}

void R_Scan_Move1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Position_Forward1
// 

const Position_Forward1::units_type& Position_Forward1::
units () const
{
  return this->units_.get ();
}

Position_Forward1::units_type& Position_Forward1::
units ()
{
  return this->units_.get ();
}

void Position_Forward1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Position_Forward1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Acceleration_Stationary1
// 

const Acceleration_Stationary1::units_type& Acceleration_Stationary1::
units () const
{
  return this->units_.get ();
}

Acceleration_Stationary1::units_type& Acceleration_Stationary1::
units ()
{
  return this->units_.get ();
}

void Acceleration_Stationary1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Acceleration_Stationary1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_3point3V1
// 

const Monitor_3point3V1::units_type& Monitor_3point3V1::
units () const
{
  return this->units_.get ();
}

Monitor_3point3V1::units_type& Monitor_3point3V1::
units ()
{
  return this->units_.get ();
}

void Monitor_3point3V1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_3point3V1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_5V1
// 

const Monitor_5V1::units_type& Monitor_5V1::
units () const
{
  return this->units_.get ();
}

Monitor_5V1::units_type& Monitor_5V1::
units ()
{
  return this->units_.get ();
}

void Monitor_5V1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_5V1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_Neg15V1
// 

const Monitor_Neg15V1::units_type& Monitor_Neg15V1::
units () const
{
  return this->units_.get ();
}

Monitor_Neg15V1::units_type& Monitor_Neg15V1::
units ()
{
  return this->units_.get ();
}

void Monitor_Neg15V1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_Neg15V1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_Neg5V1
// 

const Monitor_Neg5V1::units_type& Monitor_Neg5V1::
units () const
{
  return this->units_.get ();
}

Monitor_Neg5V1::units_type& Monitor_Neg5V1::
units ()
{
  return this->units_.get ();
}

void Monitor_Neg5V1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_Neg5V1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Monitor_15V1
// 

const Monitor_15V1::units_type& Monitor_15V1::
units () const
{
  return this->units_.get ();
}

Monitor_15V1::units_type& Monitor_15V1::
units ()
{
  return this->units_.get ();
}

void Monitor_15V1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Monitor_15V1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Threshold_Change1
// 

const Respiration_Threshold_Change1::units_type& Respiration_Threshold_Change1::
units () const
{
  return this->units_.get ();
}

Respiration_Threshold_Change1::units_type& Respiration_Threshold_Change1::
units ()
{
  return this->units_.get ();
}

void Respiration_Threshold_Change1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Threshold_Change1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Range1
// 

const Pressure_Range1::units_type& Pressure_Range1::
units () const
{
  return this->units_.get ();
}

Pressure_Range1::units_type& Pressure_Range1::
units ()
{
  return this->units_.get ();
}

void Pressure_Range1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Range1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Gate_Delay1
// 

const Respiration_Gate_Delay1::units_type& Respiration_Gate_Delay1::
units () const
{
  return this->units_.get ();
}

Respiration_Gate_Delay1::units_type& Respiration_Gate_Delay1::
units ()
{
  return this->units_.get ();
}

void Respiration_Gate_Delay1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Gate_Delay1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Timeout1
// 

const Respiration_Timeout1::units_type& Respiration_Timeout1::
units () const
{
  return this->units_.get ();
}

Respiration_Timeout1::units_type& Respiration_Timeout1::
units ()
{
  return this->units_.get ();
}

void Respiration_Timeout1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Timeout1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Max_Change_Factor_Percent1
// 

const RWave_Max_Change_Factor_Percent1::units_type& RWave_Max_Change_Factor_Percent1::
units () const
{
  return this->units_.get ();
}

RWave_Max_Change_Factor_Percent1::units_type& RWave_Max_Change_Factor_Percent1::
units ()
{
  return this->units_.get ();
}

void RWave_Max_Change_Factor_Percent1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Max_Change_Factor_Percent1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Period1
// 

const Respiration_Period1::units_type& Respiration_Period1::
units () const
{
  return this->units_.get ();
}

Respiration_Period1::units_type& Respiration_Period1::
units ()
{
  return this->units_.get ();
}

void Respiration_Period1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Period1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Subsample_Rate1
// 

const Respiration_Subsample_Rate1::units_type& Respiration_Subsample_Rate1::
units () const
{
  return this->units_.get ();
}

Respiration_Subsample_Rate1::units_type& Respiration_Subsample_Rate1::
units ()
{
  return this->units_.get ();
}

void Respiration_Subsample_Rate1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Subsample_Rate1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Window1
// 

const Respiration_Window1::units_type& Respiration_Window1::
units () const
{
  return this->units_.get ();
}

Respiration_Window1::units_type& Respiration_Window1::
units ()
{
  return this->units_.get ();
}

void Respiration_Window1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Window1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Systolic1
// 

const Pressure_Systolic1::units_type& Pressure_Systolic1::
units () const
{
  return this->units_.get ();
}

Pressure_Systolic1::units_type& Pressure_Systolic1::
units ()
{
  return this->units_.get ();
}

void Pressure_Systolic1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Systolic1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency5
// 

const Frequency5::units_type& Frequency5::
units () const
{
  return this->units_.get ();
}

Frequency5::units_type& Frequency5::
units ()
{
  return this->units_.get ();
}

void Frequency5::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency5::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Blank_Period1
// 

const Respiration_Blank_Period1::units_type& Respiration_Blank_Period1::
units () const
{
  return this->units_.get ();
}

Respiration_Blank_Period1::units_type& Respiration_Blank_Period1::
units ()
{
  return this->units_.get ();
}

void Respiration_Blank_Period1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Blank_Period1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Range1
// 

const Respiration_Range1::units_type& Respiration_Range1::
units () const
{
  return this->units_.get ();
}

Respiration_Range1::units_type& Respiration_Range1::
units ()
{
  return this->units_.get ();
}

void Respiration_Range1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Range1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Zero1
// 

const Pressure_Zero1::units_type& Pressure_Zero1::
units () const
{
  return this->units_.get ();
}

Pressure_Zero1::units_type& Pressure_Zero1::
units ()
{
  return this->units_.get ();
}

void Pressure_Zero1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Zero1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// P_Wave_Start1
// 

const P_Wave_Start1::units_type& P_Wave_Start1::
units () const
{
  return this->units_.get ();
}

P_Wave_Start1::units_type& P_Wave_Start1::
units ()
{
  return this->units_.get ();
}

void P_Wave_Start1::
units (const units_type& x)
{
  this->units_.set (x);
}

void P_Wave_Start1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Percent_Peak1
// 

const Respiration_Percent_Peak1::units_type& Respiration_Percent_Peak1::
units () const
{
  return this->units_.get ();
}

Respiration_Percent_Peak1::units_type& Respiration_Percent_Peak1::
units ()
{
  return this->units_.get ();
}

void Respiration_Percent_Peak1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Percent_Peak1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// T_Wave_Start1
// 

const T_Wave_Start1::units_type& T_Wave_Start1::
units () const
{
  return this->units_.get ();
}

T_Wave_Start1::units_type& T_Wave_Start1::
units ()
{
  return this->units_.get ();
}

void T_Wave_Start1::
units (const units_type& x)
{
  this->units_.set (x);
}

void T_Wave_Start1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Strain_Rate_RR_Diff_Ratio1
// 

const Strain_Rate_RR_Diff_Ratio1::units_type& Strain_Rate_RR_Diff_Ratio1::
units () const
{
  return this->units_.get ();
}

Strain_Rate_RR_Diff_Ratio1::units_type& Strain_Rate_RR_Diff_Ratio1::
units ()
{
  return this->units_.get ();
}

void Strain_Rate_RR_Diff_Ratio1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Strain_Rate_RR_Diff_Ratio1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Diastolic1
// 

const Pressure_Diastolic1::units_type& Pressure_Diastolic1::
units () const
{
  return this->units_.get ();
}

Pressure_Diastolic1::units_type& Pressure_Diastolic1::
units ()
{
  return this->units_.get ();
}

void Pressure_Diastolic1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Diastolic1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Temperature_Calibration1
// 

const Temperature_Calibration1::units_type& Temperature_Calibration1::
units () const
{
  return this->units_.get ();
}

Temperature_Calibration1::units_type& Temperature_Calibration1::
units ()
{
  return this->units_.get ();
}

void Temperature_Calibration1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Temperature_Calibration1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Temperature1
// 

const Temperature1::units_type& Temperature1::
units () const
{
  return this->units_.get ();
}

Temperature1::units_type& Temperature1::
units ()
{
  return this->units_.get ();
}

void Temperature1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Temperature1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Beats_To_Average1
// 

const Respiration_Beats_To_Average1::units_type& Respiration_Beats_To_Average1::
units () const
{
  return this->units_.get ();
}

Respiration_Beats_To_Average1::units_type& Respiration_Beats_To_Average1::
units ()
{
  return this->units_.get ();
}

void Respiration_Beats_To_Average1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Beats_To_Average1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Thresh_Trigger_Percent1
// 

const RWave_Thresh_Trigger_Percent1::units_type& RWave_Thresh_Trigger_Percent1::
units () const
{
  return this->units_.get ();
}

RWave_Thresh_Trigger_Percent1::units_type& RWave_Thresh_Trigger_Percent1::
units ()
{
  return this->units_.get ();
}

void RWave_Thresh_Trigger_Percent1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Thresh_Trigger_Percent1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Respiration_Time_To_Average1
// 

const Respiration_Time_To_Average1::units_type& Respiration_Time_To_Average1::
units () const
{
  return this->units_.get ();
}

Respiration_Time_To_Average1::units_type& Respiration_Time_To_Average1::
units ()
{
  return this->units_.get ();
}

void Respiration_Time_To_Average1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Respiration_Time_To_Average1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Heart_Period1
// 

const Heart_Period1::units_type& Heart_Period1::
units () const
{
  return this->units_.get ();
}

Heart_Period1::units_type& Heart_Period1::
units ()
{
  return this->units_.get ();
}

void Heart_Period1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Heart_Period1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_Range1
// 

const ECG_Range1::units_type& ECG_Range1::
units () const
{
  return this->units_.get ();
}

ECG_Range1::units_type& ECG_Range1::
units ()
{
  return this->units_.get ();
}

void ECG_Range1::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_Range1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Maxima_Block_Time1
// 

const RWave_Maxima_Block_Time1::units_type& RWave_Maxima_Block_Time1::
units () const
{
  return this->units_.get ();
}

RWave_Maxima_Block_Time1::units_type& RWave_Maxima_Block_Time1::
units ()
{
  return this->units_.get ();
}

void RWave_Maxima_Block_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Maxima_Block_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Calibration_Level1
// 

const Pressure_Calibration_Level1::units_type& Pressure_Calibration_Level1::
units () const
{
  return this->units_.get ();
}

Pressure_Calibration_Level1::units_type& Pressure_Calibration_Level1::
units ()
{
  return this->units_.get ();
}

void Pressure_Calibration_Level1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Calibration_Level1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_HP_Filter1
// 

const ECG_HP_Filter1::units_type& ECG_HP_Filter1::
units () const
{
  return this->units_.get ();
}

ECG_HP_Filter1::units_type& ECG_HP_Filter1::
units ()
{
  return this->units_.get ();
}

void ECG_HP_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_HP_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// ECG_LP_Filter1
// 

const ECG_LP_Filter1::units_type& ECG_LP_Filter1::
units () const
{
  return this->units_.get ();
}

ECG_LP_Filter1::units_type& ECG_LP_Filter1::
units ()
{
  return this->units_.get ();
}

void ECG_LP_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void ECG_LP_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Max_Change_Period1
// 

const RWave_Max_Change_Period1::units_type& RWave_Max_Change_Period1::
units () const
{
  return this->units_.get ();
}

RWave_Max_Change_Period1::units_type& RWave_Max_Change_Period1::
units ()
{
  return this->units_.get ();
}

void RWave_Max_Change_Period1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Max_Change_Period1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pressure_Calibration1
// 

const Pressure_Calibration1::units_type& Pressure_Calibration1::
units () const
{
  return this->units_.get ();
}

Pressure_Calibration1::units_type& Pressure_Calibration1::
units ()
{
  return this->units_.get ();
}

void Pressure_Calibration1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pressure_Calibration1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Blank_Time1
// 

const RWave_Blank_Time1::units_type& RWave_Blank_Time1::
units () const
{
  return this->units_.get ();
}

RWave_Blank_Time1::units_type& RWave_Blank_Time1::
units ()
{
  return this->units_.get ();
}

void RWave_Blank_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Blank_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RWave_Future_Search_Time1
// 

const RWave_Future_Search_Time1::units_type& RWave_Future_Search_Time1::
units () const
{
  return this->units_.get ();
}

RWave_Future_Search_Time1::units_type& RWave_Future_Search_Time1::
units ()
{
  return this->units_.get ();
}

void RWave_Future_Search_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RWave_Future_Search_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Transmit_Length1
// 

const V_Transmit_Length1::units_type& V_Transmit_Length1::
units () const
{
  return this->units_.get ();
}

V_Transmit_Length1::units_type& V_Transmit_Length1::
units ()
{
  return this->units_.get ();
}

void V_Transmit_Length1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Transmit_Length1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Pulse_Rep_Freq1
// 

const V_Pulse_Rep_Freq1::units_type& V_Pulse_Rep_Freq1::
units () const
{
  return this->units_.get ();
}

V_Pulse_Rep_Freq1::units_type& V_Pulse_Rep_Freq1::
units ()
{
  return this->units_.get ();
}

void V_Pulse_Rep_Freq1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Pulse_Rep_Freq1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency6
// 

const Frequency6::units_type& Frequency6::
units () const
{
  return this->units_.get ();
}

Frequency6::units_type& Frequency6::
units ()
{
  return this->units_.get ();
}

void Frequency6::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency6::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Unblank_Time1
// 

const V_Unblank_Time1::units_type& V_Unblank_Time1::
units () const
{
  return this->units_.get ();
}

V_Unblank_Time1::units_type& V_Unblank_Time1::
units ()
{
  return this->units_.get ();
}

void V_Unblank_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Unblank_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Frequency2
// 

const V_Frequency2::units_type& V_Frequency2::
units () const
{
  return this->units_.get ();
}

V_Frequency2::units_type& V_Frequency2::
units ()
{
  return this->units_.get ();
}

void V_Frequency2::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Frequency2::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Pulse_Rep_Frequency1
// 

const Pulse_Rep_Frequency1::units_type& Pulse_Rep_Frequency1::
units () const
{
  return this->units_.get ();
}

Pulse_Rep_Frequency1::units_type& Pulse_Rep_Frequency1::
units ()
{
  return this->units_.get ();
}

void Pulse_Rep_Frequency1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Pulse_Rep_Frequency1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Trig_Tbl_Trigs1
// 

const Trig_Tbl_Trigs1::units_type& Trig_Tbl_Trigs1::
units () const
{
  return this->units_.get ();
}

Trig_Tbl_Trigs1::units_type& Trig_Tbl_Trigs1::
units ()
{
  return this->units_.get ();
}

void Trig_Tbl_Trigs1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Trig_Tbl_Trigs1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Unblank_Cycles1
// 

const Unblank_Cycles1::units_type& Unblank_Cycles1::
units () const
{
  return this->units_.get ();
}

Unblank_Cycles1::units_type& Unblank_Cycles1::
units ()
{
  return this->units_.get ();
}

void Unblank_Cycles1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Unblank_Cycles1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Unblank_Time1
// 

const Unblank_Time1::units_type& Unblank_Time1::
units () const
{
  return this->units_.get ();
}

Unblank_Time1::units_type& Unblank_Time1::
units ()
{
  return this->units_.get ();
}

void Unblank_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Unblank_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Attenuation1
// 

const Attenuation1::units_type& Attenuation1::
units () const
{
  return this->units_.get ();
}

Attenuation1::units_type& Attenuation1::
units ()
{
  return this->units_.get ();
}

void Attenuation1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Attenuation1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Power1
// 

const V_Power1::units_type& V_Power1::
units () const
{
  return this->units_.get ();
}

V_Power1::units_type& V_Power1::
units ()
{
  return this->units_.get ();
}

void V_Power1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Power1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frames
// 

const Frames::units_type& Frames::
units () const
{
  return this->units_.get ();
}

Frames::units_type& Frames::
units ()
{
  return this->units_.get ();
}

void Frames::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frames::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frame_Rate
// 

const Frame_Rate::units_type& Frame_Rate::
units () const
{
  return this->units_.get ();
}

Frame_Rate::units_type& Frame_Rate::
units ()
{
  return this->units_.get ();
}

void Frame_Rate::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frame_Rate::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Tx_PRF
// 

const Tx_PRF::units_type& Tx_PRF::
units () const
{
  return this->units_.get ();
}

Tx_PRF::units_type& Tx_PRF::
units ()
{
  return this->units_.get ();
}

void Tx_PRF::
units (const units_type& x)
{
  this->units_.set (x);
}

void Tx_PRF::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Tx_Power
// 

const Tx_Power::units_type& Tx_Power::
units () const
{
  return this->units_.get ();
}

Tx_Power::units_type& Tx_Power::
units ()
{
  return this->units_.get ();
}

void Tx_Power::
units (const units_type& x)
{
  this->units_.set (x);
}

void Tx_Power::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Duration
// 

const Duration::units_type& Duration::
units () const
{
  return this->units_.get ();
}

Duration::units_type& Duration::
units ()
{
  return this->units_.get ();
}

void Duration::
units (const units_type& x)
{
  this->units_.set (x);
}

void Duration::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Tx_Frequency
// 

const Tx_Frequency::units_type& Tx_Frequency::
units () const
{
  return this->units_.get ();
}

Tx_Frequency::units_type& Tx_Frequency::
units ()
{
  return this->units_.get ();
}

void Tx_Frequency::
units (const units_type& x)
{
  this->units_.set (x);
}

void Tx_Frequency::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Destroy_Sequence_Position
// 

const Destroy_Sequence_Position::units_type& Destroy_Sequence_Position::
units () const
{
  return this->units_.get ();
}

Destroy_Sequence_Position::units_type& Destroy_Sequence_Position::
units ()
{
  return this->units_.get ();
}

void Destroy_Sequence_Position::
units (const units_type& x)
{
  this->units_.set (x);
}

void Destroy_Sequence_Position::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Scan_Distance1
// 

const Scan_Distance1::units_type& Scan_Distance1::
units () const
{
  return this->units_.get ();
}

Scan_Distance1::units_type& Scan_Distance1::
units ()
{
  return this->units_.get ();
}

void Scan_Distance1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Scan_Distance1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Step_Size1
// 

const Step_Size1::units_type& Step_Size1::
units () const
{
  return this->units_.get ();
}

Step_Size1::units_type& Step_Size1::
units ()
{
  return this->units_.get ();
}

void Step_Size1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Step_Size1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Parallel_Step_Size
// 

const Parallel_Step_Size::units_type& Parallel_Step_Size::
units () const
{
  return this->units_.get ();
}

Parallel_Step_Size::units_type& Parallel_Step_Size::
units ()
{
  return this->units_.get ();
}

void Parallel_Step_Size::
units (const units_type& x)
{
  this->units_.set (x);
}

void Parallel_Step_Size::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Width_Target1
// 

const Sector_Width_Target1::units_type& Sector_Width_Target1::
units () const
{
  return this->units_.get ();
}

Sector_Width_Target1::units_type& Sector_Width_Target1::
units ()
{
  return this->units_.get ();
}

void Sector_Width_Target1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Width_Target1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Gain1
// 

const RF_Gain1::units_type& RF_Gain1::
units () const
{
  return this->units_.get ();
}

RF_Gain1::units_type& RF_Gain1::
units ()
{
  return this->units_.get ();
}

void RF_Gain1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Gain1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Digi_Depth_Imaging1
// 

const V_Digi_Depth_Imaging1::units_type& V_Digi_Depth_Imaging1::
units () const
{
  return this->units_.get ();
}

V_Digi_Depth_Imaging1::units_type& V_Digi_Depth_Imaging1::
units ()
{
  return this->units_.get ();
}

void V_Digi_Depth_Imaging1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Digi_Depth_Imaging1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Test_Freq1
// 

const Test_Freq1::units_type& Test_Freq1::
units () const
{
  return this->units_.get ();
}

Test_Freq1::units_type& Test_Freq1::
units ()
{
  return this->units_.get ();
}

void Test_Freq1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Test_Freq1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// RF_Filter1
// 

const RF_Filter1::units_type& RF_Filter1::
units () const
{
  return this->units_.get ();
}

RF_Filter1::units_type& RF_Filter1::
units ()
{
  return this->units_.get ();
}

void RF_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void RF_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_RF_Filter1
// 

const V_RF_Filter1::units_type& V_RF_Filter1::
units () const
{
  return this->units_.get ();
}

V_RF_Filter1::units_type& V_RF_Filter1::
units ()
{
  return this->units_.get ();
}

void V_RF_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_RF_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Delay1
// 

const Delay1::units_type& Delay1::
units () const
{
  return this->units_.get ();
}

Delay1::units_type& Delay1::
units ()
{
  return this->units_.get ();
}

void Delay1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Delay1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// AD_Gate_Width1
// 

const AD_Gate_Width1::units_type& AD_Gate_Width1::
units () const
{
  return this->units_.get ();
}

AD_Gate_Width1::units_type& AD_Gate_Width1::
units ()
{
  return this->units_.get ();
}

void AD_Gate_Width1::
units (const units_type& x)
{
  this->units_.set (x);
}

void AD_Gate_Width1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Frequency7
// 

const Frequency7::units_type& Frequency7::
units () const
{
  return this->units_.get ();
}

Frequency7::units_type& Frequency7::
units ()
{
  return this->units_.get ();
}

void Frequency7::
units (const units_type& x)
{
  this->units_.set (x);
}

void Frequency7::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Frequency3
// 

const V_Frequency3::units_type& V_Frequency3::
units () const
{
  return this->units_.get ();
}

V_Frequency3::units_type& V_Frequency3::
units ()
{
  return this->units_.get ();
}

void V_Frequency3::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Frequency3::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Field_Of_View1
// 

const V_Field_Of_View1::units_type& V_Field_Of_View1::
units () const
{
  return this->units_.get ();
}

V_Field_Of_View1::units_type& V_Field_Of_View1::
units ()
{
  return this->units_.get ();
}

void V_Field_Of_View1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Field_Of_View1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Sector_Height_Target1
// 

const Sector_Height_Target1::units_type& Sector_Height_Target1::
units () const
{
  return this->units_.get ();
}

Sector_Height_Target1::units_type& Sector_Height_Target1::
units ()
{
  return this->units_.get ();
}

void Sector_Height_Target1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Sector_Height_Target1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// AD_TestIn1
// 

const AD_TestIn1::units_type& AD_TestIn1::
units () const
{
  return this->units_.get ();
}

AD_TestIn1::units_type& AD_TestIn1::
units ()
{
  return this->units_.get ();
}

void AD_TestIn1::
units (const units_type& x)
{
  this->units_.set (x);
}

void AD_TestIn1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_Delay_Length1
// 

const V_Delay_Length1::units_type& V_Delay_Length1::
units () const
{
  return this->units_.get ();
}

V_Delay_Length1::units_type& V_Delay_Length1::
units ()
{
  return this->units_.get ();
}

void V_Delay_Length1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_Delay_Length1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// IF_Filter1
// 

const IF_Filter1::units_type& IF_Filter1::
units () const
{
  return this->units_.get ();
}

IF_Filter1::units_type& IF_Filter1::
units ()
{
  return this->units_.get ();
}

void IF_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void IF_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Track_Width1
// 

const Track_Width1::units_type& Track_Width1::
units () const
{
  return this->units_.get ();
}

Track_Width1::units_type& Track_Width1::
units ()
{
  return this->units_.get ();
}

void Track_Width1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Track_Width1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// V_IF_Filter1
// 

const V_IF_Filter1::units_type& V_IF_Filter1::
units () const
{
  return this->units_.get ();
}

V_IF_Filter1::units_type& V_IF_Filter1::
units ()
{
  return this->units_.get ();
}

void V_IF_Filter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void V_IF_Filter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// HP_Clutter1
// 

const HP_Clutter1::units_type& HP_Clutter1::
units () const
{
  return this->units_.get ();
}

HP_Clutter1::units_type& HP_Clutter1::
units ()
{
  return this->units_.get ();
}

void HP_Clutter1::
units (const units_type& x)
{
  this->units_.set (x);
}

void HP_Clutter1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// Window_Time1
// 

const Window_Time1::units_type& Window_Time1::
units () const
{
  return this->units_.get ();
}

Window_Time1::units_type& Window_Time1::
units ()
{
  return this->units_.get ();
}

void Window_Time1::
units (const units_type& x)
{
  this->units_.set (x);
}

void Window_Time1::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Start
// 

const EKV_Start::units_type& EKV_Start::
units () const
{
  return this->units_.get ();
}

EKV_Start::units_type& EKV_Start::
units ()
{
  return this->units_.get ();
}

void EKV_Start::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Start::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Stop
// 

const EKV_Stop::units_type& EKV_Stop::
units () const
{
  return this->units_.get ();
}

EKV_Stop::units_type& EKV_Stop::
units ()
{
  return this->units_.get ();
}

void EKV_Stop::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Stop::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Quality_Times
// 

const EKV_Quality_Times::units_type& EKV_Quality_Times::
units () const
{
  return this->units_.get ();
}

EKV_Quality_Times::units_type& EKV_Quality_Times::
units ()
{
  return this->units_.get ();
}

void EKV_Quality_Times::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Quality_Times::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Quality
// 

const EKV_Quality::units_type& EKV_Quality::
units () const
{
  return this->units_.get ();
}

EKV_Quality::units_type& EKV_Quality::
units ()
{
  return this->units_.get ();
}

void EKV_Quality::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Quality::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Quality_Resolution
// 

const EKV_Quality_Resolution::units_type& EKV_Quality_Resolution::
units () const
{
  return this->units_.get ();
}

EKV_Quality_Resolution::units_type& EKV_Quality_Resolution::
units ()
{
  return this->units_.get ();
}

void EKV_Quality_Resolution::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Quality_Resolution::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Variance
// 

const EKV_Variance::units_type& EKV_Variance::
units () const
{
  return this->units_.get ();
}

EKV_Variance::units_type& EKV_Variance::
units ()
{
  return this->units_.get ();
}

void EKV_Variance::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Variance::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


// EKV_Triggers
// 

const EKV_Triggers::units_type& EKV_Triggers::
units () const
{
  return this->units_.get ();
}

EKV_Triggers::units_type& EKV_Triggers::
units ()
{
  return this->units_.get ();
}

void EKV_Triggers::
units (const units_type& x)
{
  this->units_.set (x);
}

void EKV_Triggers::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// image_info_t
//

image_info_t::
image_info_t (const Study_Name_type& Study_Name,
              const Image_Label_type& Image_Label,
              const Image_Frames_type& Image_Frames,
              const Image_Lines_type& Image_Lines,
              const Image_Acquisition_Per_Line_type& Image_Acquisition_Per_Line,
              const Image_Acquisition_Size_type& Image_Acquisition_Size,
              const Animal_ID_type& Animal_ID,
              const Acquisition_Mode_type& Acquisition_Mode,
              const Acquisition_Date_type& Acquisition_Date,
              const Acquisition_Time_type& Acquisition_Time,
              const Acquisition_Operator_type& Acquisition_Operator)
: ::xml_schema::type (),
  Study_Name_ (Study_Name, ::xml_schema::flags (), this),
  Image_Id_ (::xml_schema::flags (), this),
  Image_Label_ (Image_Label, ::xml_schema::flags (), this),
  Image_Frames_ (Image_Frames, ::xml_schema::flags (), this),
  Image_Lines_ (Image_Lines, ::xml_schema::flags (), this),
  Image_Acquisition_Per_Line_ (Image_Acquisition_Per_Line, ::xml_schema::flags (), this),
  Image_Acquisition_Size_ (Image_Acquisition_Size, ::xml_schema::flags (), this),
  Animal_ID_ (Animal_ID, ::xml_schema::flags (), this),
  Acquisition_Mode_ (Acquisition_Mode, ::xml_schema::flags (), this),
  Acquisition_Date_ (Acquisition_Date, ::xml_schema::flags (), this),
  Acquisition_Time_ (Acquisition_Time, ::xml_schema::flags (), this),
  Acquisition_Operator_ (Acquisition_Operator, ::xml_schema::flags (), this)
{
}

image_info_t::
image_info_t (const image_info_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Study_Name_ (x.Study_Name_, f, this),
  Image_Id_ (x.Image_Id_, f, this),
  Image_Label_ (x.Image_Label_, f, this),
  Image_Frames_ (x.Image_Frames_, f, this),
  Image_Lines_ (x.Image_Lines_, f, this),
  Image_Acquisition_Per_Line_ (x.Image_Acquisition_Per_Line_, f, this),
  Image_Acquisition_Size_ (x.Image_Acquisition_Size_, f, this),
  Animal_ID_ (x.Animal_ID_, f, this),
  Acquisition_Mode_ (x.Acquisition_Mode_, f, this),
  Acquisition_Date_ (x.Acquisition_Date_, f, this),
  Acquisition_Time_ (x.Acquisition_Time_, f, this),
  Acquisition_Operator_ (x.Acquisition_Operator_, f, this)
{
}

image_info_t::
image_info_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Study_Name_ (f, this),
  Image_Id_ (f, this),
  Image_Label_ (f, this),
  Image_Frames_ (f, this),
  Image_Lines_ (f, this),
  Image_Acquisition_Per_Line_ (f, this),
  Image_Acquisition_Size_ (f, this),
  Animal_ID_ (f, this),
  Acquisition_Mode_ (f, this),
  Acquisition_Date_ (f, this),
  Acquisition_Time_ (f, this),
  Acquisition_Operator_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void image_info_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Study_Name
    //
    if (n.name () == "Study_Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Study_Name_type > r (
        Study_Name_traits::create (i, f, this));

      if (!Study_Name_.present ())
      {
        this->Study_Name_.set (r);
        continue;
      }
    }

    // Image_Id
    //
    if (n.name () == "Image_Id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_Id_type > r (
        Image_Id_traits::create (i, f, this));

      if (!this->Image_Id_)
      {
        this->Image_Id_.set (r);
        continue;
      }
    }

    // Image_Label
    //
    if (n.name () == "Image_Label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_Label_type > r (
        Image_Label_traits::create (i, f, this));

      if (!Image_Label_.present ())
      {
        this->Image_Label_.set (r);
        continue;
      }
    }

    // Image_Frames
    //
    if (n.name () == "Image_Frames" && n.namespace_ ().empty ())
    {
      if (!Image_Frames_.present ())
      {
        this->Image_Frames_.set (Image_Frames_traits::create (i, f, this));
        continue;
      }
    }

    // Image_Lines
    //
    if (n.name () == "Image_Lines" && n.namespace_ ().empty ())
    {
      if (!Image_Lines_.present ())
      {
        this->Image_Lines_.set (Image_Lines_traits::create (i, f, this));
        continue;
      }
    }

    // Image_Acquisition_Per_Line
    //
    if (n.name () == "Image_Acquisition_Per_Line" && n.namespace_ ().empty ())
    {
      if (!Image_Acquisition_Per_Line_.present ())
      {
        this->Image_Acquisition_Per_Line_.set (Image_Acquisition_Per_Line_traits::create (i, f, this));
        continue;
      }
    }

    // Image_Acquisition_Size
    //
    if (n.name () == "Image_Acquisition_Size" && n.namespace_ ().empty ())
    {
      if (!Image_Acquisition_Size_.present ())
      {
        this->Image_Acquisition_Size_.set (Image_Acquisition_Size_traits::create (i, f, this));
        continue;
      }
    }

    // Animal_ID
    //
    if (n.name () == "Animal_ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Animal_ID_type > r (
        Animal_ID_traits::create (i, f, this));

      if (!Animal_ID_.present ())
      {
        this->Animal_ID_.set (r);
        continue;
      }
    }

    // Acquisition_Mode
    //
    if (n.name () == "Acquisition_Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_Mode_type > r (
        Acquisition_Mode_traits::create (i, f, this));

      if (!Acquisition_Mode_.present ())
      {
        this->Acquisition_Mode_.set (r);
        continue;
      }
    }

    // Acquisition_Date
    //
    if (n.name () == "Acquisition_Date" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_Date_type > r (
        Acquisition_Date_traits::create (i, f, this));

      if (!Acquisition_Date_.present ())
      {
        this->Acquisition_Date_.set (r);
        continue;
      }
    }

    // Acquisition_Time
    //
    if (n.name () == "Acquisition_Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_Time_type > r (
        Acquisition_Time_traits::create (i, f, this));

      if (!Acquisition_Time_.present ())
      {
        this->Acquisition_Time_.set (r);
        continue;
      }
    }

    // Acquisition_Operator
    //
    if (n.name () == "Acquisition_Operator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_Operator_type > r (
        Acquisition_Operator_traits::create (i, f, this));

      if (!Acquisition_Operator_.present ())
      {
        this->Acquisition_Operator_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Study_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Study_Name",
      "");
  }

  if (!Image_Label_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image_Label",
      "");
  }

  if (!Image_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image_Frames",
      "");
  }

  if (!Image_Lines_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image_Lines",
      "");
  }

  if (!Image_Acquisition_Per_Line_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image_Acquisition_Per_Line",
      "");
  }

  if (!Image_Acquisition_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image_Acquisition_Size",
      "");
  }

  if (!Animal_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Animal_ID",
      "");
  }

  if (!Acquisition_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition_Mode",
      "");
  }

  if (!Acquisition_Date_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition_Date",
      "");
  }

  if (!Acquisition_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition_Time",
      "");
  }

  if (!Acquisition_Operator_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition_Operator",
      "");
  }
}

image_info_t* image_info_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class image_info_t (*this, f, c);
}

image_info_t::
~image_info_t ()
{
}

// image_data_t
//

image_data_t::
image_data_t ()
: ::xml_schema::type ()
{
}

image_data_t::
image_data_t (const image_data_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

image_data_t::
image_data_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

image_data_t::
image_data_t (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

image_data_t::
image_data_t (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

image_data_t* image_data_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class image_data_t (*this, f, c);
}

image_data_t::
~image_data_t ()
{
}

// image_parameters_t
//

image_parameters_t::
image_parameters_t (const RF_Mode_type& RF_Mode,
                    const B_Mode_type& B_Mode)
: ::xml_schema::type (),
  RF_Mode_ (RF_Mode, ::xml_schema::flags (), this),
  B_Mode_ (B_Mode, ::xml_schema::flags (), this)
{
}

image_parameters_t::
image_parameters_t (::std::auto_ptr< RF_Mode_type >& RF_Mode,
                    ::std::auto_ptr< B_Mode_type >& B_Mode)
: ::xml_schema::type (),
  RF_Mode_ (RF_Mode, ::xml_schema::flags (), this),
  B_Mode_ (B_Mode, ::xml_schema::flags (), this)
{
}

image_parameters_t::
image_parameters_t (const image_parameters_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  RF_Mode_ (x.RF_Mode_, f, this),
  B_Mode_ (x.B_Mode_, f, this)
{
}

image_parameters_t::
image_parameters_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  RF_Mode_ (f, this),
  B_Mode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void image_parameters_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RF-Mode
    //
    if (n.name () == "RF-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Mode_type > r (
        RF_Mode_traits::create (i, f, this));

      if (!RF_Mode_.present ())
      {
        this->RF_Mode_.set (r);
        continue;
      }
    }

    // B-Mode
    //
    if (n.name () == "B-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< B_Mode_type > r (
        B_Mode_traits::create (i, f, this));

      if (!B_Mode_.present ())
      {
        this->B_Mode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!RF_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Mode",
      "");
  }

  if (!B_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "B-Mode",
      "");
  }
}

image_parameters_t* image_parameters_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class image_parameters_t (*this, f, c);
}

image_parameters_t::
~image_parameters_t ()
{
}

// rdi_t
//

rdi_t::
rdi_t (const image_info_type& image_info,
       const image_data_type& image_data,
       const image_parameters_type& image_parameters)
: ::xml_schema::type (),
  image_info_ (image_info, ::xml_schema::flags (), this),
  image_data_ (image_data, ::xml_schema::flags (), this),
  image_parameters_ (image_parameters, ::xml_schema::flags (), this)
{
}

rdi_t::
rdi_t (::std::auto_ptr< image_info_type >& image_info,
       const image_data_type& image_data,
       ::std::auto_ptr< image_parameters_type >& image_parameters)
: ::xml_schema::type (),
  image_info_ (image_info, ::xml_schema::flags (), this),
  image_data_ (image_data, ::xml_schema::flags (), this),
  image_parameters_ (image_parameters, ::xml_schema::flags (), this)
{
}

rdi_t::
rdi_t (const rdi_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  image_info_ (x.image_info_, f, this),
  image_data_ (x.image_data_, f, this),
  image_parameters_ (x.image_parameters_, f, this)
{
}

rdi_t::
rdi_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  image_info_ (f, this),
  image_data_ (f, this),
  image_parameters_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void rdi_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // image_info
    //
    if (n.name () == "image_info" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_info_type > r (
        image_info_traits::create (i, f, this));

      if (!image_info_.present ())
      {
        this->image_info_.set (r);
        continue;
      }
    }

    // image_data
    //
    if (n.name () == "image_data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_data_type > r (
        image_data_traits::create (i, f, this));

      if (!image_data_.present ())
      {
        this->image_data_.set (r);
        continue;
      }
    }

    // image_parameters
    //
    if (n.name () == "image_parameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_parameters_type > r (
        image_parameters_traits::create (i, f, this));

      if (!image_parameters_.present ())
      {
        this->image_parameters_.set (r);
        continue;
      }
    }

    break;
  }

  if (!image_info_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "image_info",
      "");
  }

  if (!image_data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "image_data",
      "");
  }

  if (!image_parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "image_parameters",
      "");
  }
}

rdi_t* rdi_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rdi_t (*this, f, c);
}

rdi_t::
~rdi_t ()
{
}

// RF_Mode
//

RF_Mode::
RF_Mode (const ActiveProbe_type& ActiveProbe,
         const BModeSoft_type& BModeSoft,
         const Sys_type& Sys,
         const MIS_type& MIS,
         const Scan_type& Scan,
         const Motor_type& Motor,
         const Diag_type& Diag,
         const ECG_type& ECG,
         const RfModeSoft_type& RfModeSoft,
         const TX_type& TX,
         const X_3D_type& X_3D,
         const RfAnalysis_type& RfAnalysis,
         const RX_type& RX,
         const Display_type& Display,
         const Acqiris_type& Acqiris)
: ::xml_schema::type (),
  ActiveProbe_ (ActiveProbe, ::xml_schema::flags (), this),
  BModeSoft_ (BModeSoft, ::xml_schema::flags (), this),
  Sys_ (Sys, ::xml_schema::flags (), this),
  MIS_ (MIS, ::xml_schema::flags (), this),
  Scan_ (Scan, ::xml_schema::flags (), this),
  Motor_ (Motor, ::xml_schema::flags (), this),
  Diag_ (Diag, ::xml_schema::flags (), this),
  ECG_ (ECG, ::xml_schema::flags (), this),
  RfModeSoft_ (RfModeSoft, ::xml_schema::flags (), this),
  TX_ (TX, ::xml_schema::flags (), this),
  X_3D_ (X_3D, ::xml_schema::flags (), this),
  RfAnalysis_ (RfAnalysis, ::xml_schema::flags (), this),
  RX_ (RX, ::xml_schema::flags (), this),
  Display_ (Display, ::xml_schema::flags (), this),
  Acqiris_ (Acqiris, ::xml_schema::flags (), this)
{
}

RF_Mode::
RF_Mode (::std::auto_ptr< ActiveProbe_type >& ActiveProbe,
         ::std::auto_ptr< BModeSoft_type >& BModeSoft,
         ::std::auto_ptr< Sys_type >& Sys,
         ::std::auto_ptr< MIS_type >& MIS,
         ::std::auto_ptr< Scan_type >& Scan,
         ::std::auto_ptr< Motor_type >& Motor,
         ::std::auto_ptr< Diag_type >& Diag,
         ::std::auto_ptr< ECG_type >& ECG,
         ::std::auto_ptr< RfModeSoft_type >& RfModeSoft,
         ::std::auto_ptr< TX_type >& TX,
         ::std::auto_ptr< X_3D_type >& X_3D,
         ::std::auto_ptr< RfAnalysis_type >& RfAnalysis,
         ::std::auto_ptr< RX_type >& RX,
         ::std::auto_ptr< Display_type >& Display,
         ::std::auto_ptr< Acqiris_type >& Acqiris)
: ::xml_schema::type (),
  ActiveProbe_ (ActiveProbe, ::xml_schema::flags (), this),
  BModeSoft_ (BModeSoft, ::xml_schema::flags (), this),
  Sys_ (Sys, ::xml_schema::flags (), this),
  MIS_ (MIS, ::xml_schema::flags (), this),
  Scan_ (Scan, ::xml_schema::flags (), this),
  Motor_ (Motor, ::xml_schema::flags (), this),
  Diag_ (Diag, ::xml_schema::flags (), this),
  ECG_ (ECG, ::xml_schema::flags (), this),
  RfModeSoft_ (RfModeSoft, ::xml_schema::flags (), this),
  TX_ (TX, ::xml_schema::flags (), this),
  X_3D_ (X_3D, ::xml_schema::flags (), this),
  RfAnalysis_ (RfAnalysis, ::xml_schema::flags (), this),
  RX_ (RX, ::xml_schema::flags (), this),
  Display_ (Display, ::xml_schema::flags (), this),
  Acqiris_ (Acqiris, ::xml_schema::flags (), this)
{
}

RF_Mode::
RF_Mode (const RF_Mode& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ActiveProbe_ (x.ActiveProbe_, f, this),
  BModeSoft_ (x.BModeSoft_, f, this),
  Sys_ (x.Sys_, f, this),
  MIS_ (x.MIS_, f, this),
  Scan_ (x.Scan_, f, this),
  Motor_ (x.Motor_, f, this),
  Diag_ (x.Diag_, f, this),
  ECG_ (x.ECG_, f, this),
  RfModeSoft_ (x.RfModeSoft_, f, this),
  TX_ (x.TX_, f, this),
  X_3D_ (x.X_3D_, f, this),
  RfAnalysis_ (x.RfAnalysis_, f, this),
  RX_ (x.RX_, f, this),
  Display_ (x.Display_, f, this),
  Acqiris_ (x.Acqiris_, f, this)
{
}

RF_Mode::
RF_Mode (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ActiveProbe_ (f, this),
  BModeSoft_ (f, this),
  Sys_ (f, this),
  MIS_ (f, this),
  Scan_ (f, this),
  Motor_ (f, this),
  Diag_ (f, this),
  ECG_ (f, this),
  RfModeSoft_ (f, this),
  TX_ (f, this),
  X_3D_ (f, this),
  RfAnalysis_ (f, this),
  RX_ (f, this),
  Display_ (f, this),
  Acqiris_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RF_Mode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ActiveProbe
    //
    if (n.name () == "ActiveProbe" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ActiveProbe_type > r (
        ActiveProbe_traits::create (i, f, this));

      if (!ActiveProbe_.present ())
      {
        this->ActiveProbe_.set (r);
        continue;
      }
    }

    // BModeSoft
    //
    if (n.name () == "BModeSoft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BModeSoft_type > r (
        BModeSoft_traits::create (i, f, this));

      if (!BModeSoft_.present ())
      {
        this->BModeSoft_.set (r);
        continue;
      }
    }

    // Sys
    //
    if (n.name () == "Sys" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sys_type > r (
        Sys_traits::create (i, f, this));

      if (!Sys_.present ())
      {
        this->Sys_.set (r);
        continue;
      }
    }

    // MIS
    //
    if (n.name () == "MIS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MIS_type > r (
        MIS_traits::create (i, f, this));

      if (!MIS_.present ())
      {
        this->MIS_.set (r);
        continue;
      }
    }

    // Scan
    //
    if (n.name () == "Scan" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_type > r (
        Scan_traits::create (i, f, this));

      if (!Scan_.present ())
      {
        this->Scan_.set (r);
        continue;
      }
    }

    // Motor
    //
    if (n.name () == "Motor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_type > r (
        Motor_traits::create (i, f, this));

      if (!Motor_.present ())
      {
        this->Motor_.set (r);
        continue;
      }
    }

    // Diag
    //
    if (n.name () == "Diag" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Diag_type > r (
        Diag_traits::create (i, f, this));

      if (!Diag_.present ())
      {
        this->Diag_.set (r);
        continue;
      }
    }

    // ECG
    //
    if (n.name () == "ECG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_type > r (
        ECG_traits::create (i, f, this));

      if (!ECG_.present ())
      {
        this->ECG_.set (r);
        continue;
      }
    }

    // RfModeSoft
    //
    if (n.name () == "RfModeSoft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RfModeSoft_type > r (
        RfModeSoft_traits::create (i, f, this));

      if (!RfModeSoft_.present ())
      {
        this->RfModeSoft_.set (r);
        continue;
      }
    }

    // TX
    //
    if (n.name () == "TX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TX_type > r (
        TX_traits::create (i, f, this));

      if (!TX_.present ())
      {
        this->TX_.set (r);
        continue;
      }
    }

    // X_3D
    //
    if (n.name () == "X_3D" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_type > r (
        X_3D_traits::create (i, f, this));

      if (!X_3D_.present ())
      {
        this->X_3D_.set (r);
        continue;
      }
    }

    // RfAnalysis
    //
    if (n.name () == "RfAnalysis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RfAnalysis_type > r (
        RfAnalysis_traits::create (i, f, this));

      if (!RfAnalysis_.present ())
      {
        this->RfAnalysis_.set (r);
        continue;
      }
    }

    // RX
    //
    if (n.name () == "RX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RX_type > r (
        RX_traits::create (i, f, this));

      if (!RX_.present ())
      {
        this->RX_.set (r);
        continue;
      }
    }

    // Display
    //
    if (n.name () == "Display" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Display_type > r (
        Display_traits::create (i, f, this));

      if (!Display_.present ())
      {
        this->Display_.set (r);
        continue;
      }
    }

    // Acqiris
    //
    if (n.name () == "Acqiris" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acqiris_type > r (
        Acqiris_traits::create (i, f, this));

      if (!Acqiris_.present ())
      {
        this->Acqiris_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ActiveProbe_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ActiveProbe",
      "");
  }

  if (!BModeSoft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BModeSoft",
      "");
  }

  if (!Sys_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sys",
      "");
  }

  if (!MIS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MIS",
      "");
  }

  if (!Scan_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan",
      "");
  }

  if (!Motor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor",
      "");
  }

  if (!Diag_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Diag",
      "");
  }

  if (!ECG_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG",
      "");
  }

  if (!RfModeSoft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RfModeSoft",
      "");
  }

  if (!TX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TX",
      "");
  }

  if (!X_3D_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D",
      "");
  }

  if (!RfAnalysis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RfAnalysis",
      "");
  }

  if (!RX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RX",
      "");
  }

  if (!Display_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Display",
      "");
  }

  if (!Acqiris_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acqiris",
      "");
  }
}

RF_Mode* RF_Mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Mode (*this, f, c);
}

RF_Mode::
~RF_Mode ()
{
}

// B_Mode
//

B_Mode::
B_Mode (const ActiveProbe_type& ActiveProbe,
        const BModeSoft_type& BModeSoft,
        const Sys_type& Sys,
        const Contrast_type& Contrast,
        const MIS_type& MIS,
        const Scan_type& Scan,
        const Motor_type& Motor,
        const ContrastDlg_type& ContrastDlg,
        const Diag_type& Diag,
        const ECG_type& ECG,
        const TX_type& TX,
        const ContrastDestroy_type& ContrastDestroy,
        const X_3D_type& X_3D,
        const X_3DSoft_type& X_3DSoft,
        const RX_type& RX,
        const Display_type& Display,
        const EKVModeSoft_type& EKVModeSoft,
        const BModeLVAnalysis_type& BModeLVAnalysis)
: ::xml_schema::type (),
  ActiveProbe_ (ActiveProbe, ::xml_schema::flags (), this),
  BModeSoft_ (BModeSoft, ::xml_schema::flags (), this),
  Sys_ (Sys, ::xml_schema::flags (), this),
  Contrast_ (Contrast, ::xml_schema::flags (), this),
  MIS_ (MIS, ::xml_schema::flags (), this),
  Scan_ (Scan, ::xml_schema::flags (), this),
  Motor_ (Motor, ::xml_schema::flags (), this),
  ContrastDlg_ (ContrastDlg, ::xml_schema::flags (), this),
  Diag_ (Diag, ::xml_schema::flags (), this),
  ECG_ (ECG, ::xml_schema::flags (), this),
  TX_ (TX, ::xml_schema::flags (), this),
  ContrastDestroy_ (ContrastDestroy, ::xml_schema::flags (), this),
  X_3D_ (X_3D, ::xml_schema::flags (), this),
  X_3DSoft_ (X_3DSoft, ::xml_schema::flags (), this),
  RX_ (RX, ::xml_schema::flags (), this),
  Display_ (Display, ::xml_schema::flags (), this),
  EKVModeSoft_ (EKVModeSoft, ::xml_schema::flags (), this),
  BModeLVAnalysis_ (BModeLVAnalysis, ::xml_schema::flags (), this)
{
}

B_Mode::
B_Mode (::std::auto_ptr< ActiveProbe_type >& ActiveProbe,
        ::std::auto_ptr< BModeSoft_type >& BModeSoft,
        ::std::auto_ptr< Sys_type >& Sys,
        ::std::auto_ptr< Contrast_type >& Contrast,
        ::std::auto_ptr< MIS_type >& MIS,
        ::std::auto_ptr< Scan_type >& Scan,
        ::std::auto_ptr< Motor_type >& Motor,
        ::std::auto_ptr< ContrastDlg_type >& ContrastDlg,
        ::std::auto_ptr< Diag_type >& Diag,
        ::std::auto_ptr< ECG_type >& ECG,
        ::std::auto_ptr< TX_type >& TX,
        ::std::auto_ptr< ContrastDestroy_type >& ContrastDestroy,
        ::std::auto_ptr< X_3D_type >& X_3D,
        ::std::auto_ptr< X_3DSoft_type >& X_3DSoft,
        ::std::auto_ptr< RX_type >& RX,
        ::std::auto_ptr< Display_type >& Display,
        ::std::auto_ptr< EKVModeSoft_type >& EKVModeSoft,
        ::std::auto_ptr< BModeLVAnalysis_type >& BModeLVAnalysis)
: ::xml_schema::type (),
  ActiveProbe_ (ActiveProbe, ::xml_schema::flags (), this),
  BModeSoft_ (BModeSoft, ::xml_schema::flags (), this),
  Sys_ (Sys, ::xml_schema::flags (), this),
  Contrast_ (Contrast, ::xml_schema::flags (), this),
  MIS_ (MIS, ::xml_schema::flags (), this),
  Scan_ (Scan, ::xml_schema::flags (), this),
  Motor_ (Motor, ::xml_schema::flags (), this),
  ContrastDlg_ (ContrastDlg, ::xml_schema::flags (), this),
  Diag_ (Diag, ::xml_schema::flags (), this),
  ECG_ (ECG, ::xml_schema::flags (), this),
  TX_ (TX, ::xml_schema::flags (), this),
  ContrastDestroy_ (ContrastDestroy, ::xml_schema::flags (), this),
  X_3D_ (X_3D, ::xml_schema::flags (), this),
  X_3DSoft_ (X_3DSoft, ::xml_schema::flags (), this),
  RX_ (RX, ::xml_schema::flags (), this),
  Display_ (Display, ::xml_schema::flags (), this),
  EKVModeSoft_ (EKVModeSoft, ::xml_schema::flags (), this),
  BModeLVAnalysis_ (BModeLVAnalysis, ::xml_schema::flags (), this)
{
}

B_Mode::
B_Mode (const B_Mode& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ActiveProbe_ (x.ActiveProbe_, f, this),
  BModeSoft_ (x.BModeSoft_, f, this),
  Sys_ (x.Sys_, f, this),
  Contrast_ (x.Contrast_, f, this),
  MIS_ (x.MIS_, f, this),
  Scan_ (x.Scan_, f, this),
  Motor_ (x.Motor_, f, this),
  ContrastDlg_ (x.ContrastDlg_, f, this),
  Diag_ (x.Diag_, f, this),
  ECG_ (x.ECG_, f, this),
  TX_ (x.TX_, f, this),
  ContrastDestroy_ (x.ContrastDestroy_, f, this),
  X_3D_ (x.X_3D_, f, this),
  X_3DSoft_ (x.X_3DSoft_, f, this),
  RX_ (x.RX_, f, this),
  Display_ (x.Display_, f, this),
  EKVModeSoft_ (x.EKVModeSoft_, f, this),
  BModeLVAnalysis_ (x.BModeLVAnalysis_, f, this)
{
}

B_Mode::
B_Mode (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ActiveProbe_ (f, this),
  BModeSoft_ (f, this),
  Sys_ (f, this),
  Contrast_ (f, this),
  MIS_ (f, this),
  Scan_ (f, this),
  Motor_ (f, this),
  ContrastDlg_ (f, this),
  Diag_ (f, this),
  ECG_ (f, this),
  TX_ (f, this),
  ContrastDestroy_ (f, this),
  X_3D_ (f, this),
  X_3DSoft_ (f, this),
  RX_ (f, this),
  Display_ (f, this),
  EKVModeSoft_ (f, this),
  BModeLVAnalysis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void B_Mode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ActiveProbe
    //
    if (n.name () == "ActiveProbe" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ActiveProbe_type > r (
        ActiveProbe_traits::create (i, f, this));

      if (!ActiveProbe_.present ())
      {
        this->ActiveProbe_.set (r);
        continue;
      }
    }

    // BModeSoft
    //
    if (n.name () == "BModeSoft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BModeSoft_type > r (
        BModeSoft_traits::create (i, f, this));

      if (!BModeSoft_.present ())
      {
        this->BModeSoft_.set (r);
        continue;
      }
    }

    // Sys
    //
    if (n.name () == "Sys" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sys_type > r (
        Sys_traits::create (i, f, this));

      if (!Sys_.present ())
      {
        this->Sys_.set (r);
        continue;
      }
    }

    // Contrast
    //
    if (n.name () == "Contrast" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_type > r (
        Contrast_traits::create (i, f, this));

      if (!Contrast_.present ())
      {
        this->Contrast_.set (r);
        continue;
      }
    }

    // MIS
    //
    if (n.name () == "MIS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MIS_type > r (
        MIS_traits::create (i, f, this));

      if (!MIS_.present ())
      {
        this->MIS_.set (r);
        continue;
      }
    }

    // Scan
    //
    if (n.name () == "Scan" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_type > r (
        Scan_traits::create (i, f, this));

      if (!Scan_.present ())
      {
        this->Scan_.set (r);
        continue;
      }
    }

    // Motor
    //
    if (n.name () == "Motor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_type > r (
        Motor_traits::create (i, f, this));

      if (!Motor_.present ())
      {
        this->Motor_.set (r);
        continue;
      }
    }

    // ContrastDlg
    //
    if (n.name () == "ContrastDlg" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ContrastDlg_type > r (
        ContrastDlg_traits::create (i, f, this));

      if (!ContrastDlg_.present ())
      {
        this->ContrastDlg_.set (r);
        continue;
      }
    }

    // Diag
    //
    if (n.name () == "Diag" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Diag_type > r (
        Diag_traits::create (i, f, this));

      if (!Diag_.present ())
      {
        this->Diag_.set (r);
        continue;
      }
    }

    // ECG
    //
    if (n.name () == "ECG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_type > r (
        ECG_traits::create (i, f, this));

      if (!ECG_.present ())
      {
        this->ECG_.set (r);
        continue;
      }
    }

    // TX
    //
    if (n.name () == "TX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TX_type > r (
        TX_traits::create (i, f, this));

      if (!TX_.present ())
      {
        this->TX_.set (r);
        continue;
      }
    }

    // ContrastDestroy
    //
    if (n.name () == "ContrastDestroy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ContrastDestroy_type > r (
        ContrastDestroy_traits::create (i, f, this));

      if (!ContrastDestroy_.present ())
      {
        this->ContrastDestroy_.set (r);
        continue;
      }
    }

    // X_3D
    //
    if (n.name () == "X_3D" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_type > r (
        X_3D_traits::create (i, f, this));

      if (!X_3D_.present ())
      {
        this->X_3D_.set (r);
        continue;
      }
    }

    // X_3DSoft
    //
    if (n.name () == "X_3DSoft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3DSoft_type > r (
        X_3DSoft_traits::create (i, f, this));

      if (!X_3DSoft_.present ())
      {
        this->X_3DSoft_.set (r);
        continue;
      }
    }

    // RX
    //
    if (n.name () == "RX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RX_type > r (
        RX_traits::create (i, f, this));

      if (!RX_.present ())
      {
        this->RX_.set (r);
        continue;
      }
    }

    // Display
    //
    if (n.name () == "Display" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Display_type > r (
        Display_traits::create (i, f, this));

      if (!Display_.present ())
      {
        this->Display_.set (r);
        continue;
      }
    }

    // EKVModeSoft
    //
    if (n.name () == "EKVModeSoft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKVModeSoft_type > r (
        EKVModeSoft_traits::create (i, f, this));

      if (!EKVModeSoft_.present ())
      {
        this->EKVModeSoft_.set (r);
        continue;
      }
    }

    // BModeLVAnalysis
    //
    if (n.name () == "BModeLVAnalysis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BModeLVAnalysis_type > r (
        BModeLVAnalysis_traits::create (i, f, this));

      if (!BModeLVAnalysis_.present ())
      {
        this->BModeLVAnalysis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ActiveProbe_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ActiveProbe",
      "");
  }

  if (!BModeSoft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BModeSoft",
      "");
  }

  if (!Sys_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sys",
      "");
  }

  if (!Contrast_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast",
      "");
  }

  if (!MIS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MIS",
      "");
  }

  if (!Scan_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan",
      "");
  }

  if (!Motor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor",
      "");
  }

  if (!ContrastDlg_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ContrastDlg",
      "");
  }

  if (!Diag_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Diag",
      "");
  }

  if (!ECG_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG",
      "");
  }

  if (!TX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TX",
      "");
  }

  if (!ContrastDestroy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ContrastDestroy",
      "");
  }

  if (!X_3D_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D",
      "");
  }

  if (!X_3DSoft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3DSoft",
      "");
  }

  if (!RX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RX",
      "");
  }

  if (!Display_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Display",
      "");
  }

  if (!EKVModeSoft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKVModeSoft",
      "");
  }

  if (!BModeLVAnalysis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BModeLVAnalysis",
      "");
  }
}

B_Mode* B_Mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class B_Mode (*this, f, c);
}

B_Mode::
~B_Mode ()
{
}

// ActiveProbe
//

ActiveProbe::
ActiveProbe (const Notes_type& Notes,
             const Sample_Time_type& Sample_Time,
             const Focal_Length_type& Focal_Length,
             const Acceleration_Limit_Slope_type& Acceleration_Limit_Slope,
             const Type_type& Type,
             const Detect_Id_type& Detect_Id,
             const Default_Scan_Speed_type& Default_Scan_Speed,
             const K1_Power_type& K1_Power,
             const Cutoff_Scan_Speed_type& Cutoff_Scan_Speed,
             const Frequency_Low_type& Frequency_Low,
             const Default_FOV_type& Default_FOV,
             const Frequency_Doppler_Default_type& Frequency_Doppler_Default,
             const Default_SvSize_MMode_type& Default_SvSize_MMode,
             const Axial_Res_Factor_Target_type& Axial_Res_Factor_Target,
             const F_Number_type& F_Number,
             const Acc_Time_Factor_type& Acc_Time_Factor,
             const Frequency_Doppler_type& Frequency_Doppler,
             const Axial_Res_type& Axial_Res,
             const Detect_Ratio_Min_type& Detect_Ratio_Min,
             const Lateral_Res_Factor_Target_type& Lateral_Res_Factor_Target,
             const Derivative_Time_type& Derivative_Time,
             const Filter_High_type& Filter_High,
             const Pivot_Encoder_Dist_type& Pivot_Encoder_Dist,
             const Encoder_Range_Max_type& Encoder_Range_Max,
             const Encoder_Range_Min_type& Encoder_Range_Min,
             const Lateral_Res_type& Lateral_Res,
             const Motor_Overhead_type& Motor_Overhead,
             const Max_Scan_Distance_type& Max_Scan_Distance,
             const Version_type& Version,
             const Default_Rx_Gain_type& Default_Rx_Gain,
             const Filter_Low_type& Filter_Low,
             const PID_KD_High_type& PID_KD_High,
             const PID_KI_High_type& PID_KI_High,
             const PID_KP_High_type& PID_KP_High,
             const Frequency_High_type& Frequency_High,
             const Lateral_Res_Factor_Max_type& Lateral_Res_Factor_Max,
             const Scan_Speeds_type& Scan_Speeds,
             const Filter_Doppler_Cutoff_type& Filter_Doppler_Cutoff,
             const Name_type& Name,
             const PID_KD_Low_type& PID_KD_Low,
             const PID_KI_Low_type& PID_KI_Low,
             const PID_KP_Low_type& PID_KP_Low,
             const Peak_Bandwidth_Correction_type& Peak_Bandwidth_Correction,
             const Frequency_Doppler_Low_type& Frequency_Doppler_Low,
             const Pivot_Transducer_Face_Dist_type& Pivot_Transducer_Face_Dist,
             const Filter_Doppler_type& Filter_Doppler,
             const Frequency_type& Frequency,
             const Integration_Limit_type& Integration_Limit,
             const Encoder_Separation_type& Encoder_Separation,
             const Overshoot_type& Overshoot,
             const Attenuation_Shift_type& Attenuation_Shift,
             const Filter_type& Filter,
             const Default_Rx_Gain_Doppler_type& Default_Rx_Gain_Doppler,
             const Peak_Vel_Correction_type& Peak_Vel_Correction,
             const Detect_Ratio_Max_type& Detect_Ratio_Max,
             const Acceleration_Limit_Constant_type& Acceleration_Limit_Constant,
             const Filter_Doppler_Low_type& Filter_Doppler_Low)
: ::xml_schema::type (),
  Notes_ (Notes, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Focal_Length_ (Focal_Length, ::xml_schema::flags (), this),
  Acceleration_Limit_Slope_ (Acceleration_Limit_Slope, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Detect_Id_ (Detect_Id, ::xml_schema::flags (), this),
  Default_Scan_Speed_ (Default_Scan_Speed, ::xml_schema::flags (), this),
  K1_Power_ (K1_Power, ::xml_schema::flags (), this),
  Cutoff_Scan_Speed_ (Cutoff_Scan_Speed, ::xml_schema::flags (), this),
  Frequency_Low_ (Frequency_Low, ::xml_schema::flags (), this),
  Default_FOV_ (Default_FOV, ::xml_schema::flags (), this),
  Frequency_Doppler_Default_ (Frequency_Doppler_Default, ::xml_schema::flags (), this),
  Default_SvSize_MMode_ (Default_SvSize_MMode, ::xml_schema::flags (), this),
  Axial_Res_Factor_Target_ (Axial_Res_Factor_Target, ::xml_schema::flags (), this),
  F_Number_ (F_Number, ::xml_schema::flags (), this),
  Acc_Time_Factor_ (Acc_Time_Factor, ::xml_schema::flags (), this),
  Frequency_Doppler_ (Frequency_Doppler, ::xml_schema::flags (), this),
  Axial_Res_ (Axial_Res, ::xml_schema::flags (), this),
  Detect_Ratio_Min_ (Detect_Ratio_Min, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Target_ (Lateral_Res_Factor_Target, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Filter_High_ (Filter_High, ::xml_schema::flags (), this),
  Pivot_Encoder_Dist_ (Pivot_Encoder_Dist, ::xml_schema::flags (), this),
  Encoder_Range_Max_ (Encoder_Range_Max, ::xml_schema::flags (), this),
  Encoder_Range_Min_ (Encoder_Range_Min, ::xml_schema::flags (), this),
  Lateral_Res_ (Lateral_Res, ::xml_schema::flags (), this),
  Motor_Overhead_ (Motor_Overhead, ::xml_schema::flags (), this),
  Max_Scan_Distance_ (Max_Scan_Distance, ::xml_schema::flags (), this),
  Version_ (Version, ::xml_schema::flags (), this),
  Default_Rx_Gain_ (Default_Rx_Gain, ::xml_schema::flags (), this),
  Filter_Low_ (Filter_Low, ::xml_schema::flags (), this),
  PID_KD_High_ (PID_KD_High, ::xml_schema::flags (), this),
  PID_KI_High_ (PID_KI_High, ::xml_schema::flags (), this),
  PID_KP_High_ (PID_KP_High, ::xml_schema::flags (), this),
  Frequency_High_ (Frequency_High, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Max_ (Lateral_Res_Factor_Max, ::xml_schema::flags (), this),
  Scan_Speeds_ (Scan_Speeds, ::xml_schema::flags (), this),
  Filter_Doppler_Cutoff_ (Filter_Doppler_Cutoff, ::xml_schema::flags (), this),
  Name_ (Name, ::xml_schema::flags (), this),
  PID_KD_Low_ (PID_KD_Low, ::xml_schema::flags (), this),
  PID_KI_Low_ (PID_KI_Low, ::xml_schema::flags (), this),
  PID_KP_Low_ (PID_KP_Low, ::xml_schema::flags (), this),
  Peak_Bandwidth_Correction_ (Peak_Bandwidth_Correction, ::xml_schema::flags (), this),
  Frequency_Doppler_Low_ (Frequency_Doppler_Low, ::xml_schema::flags (), this),
  Pivot_Transducer_Face_Dist_ (Pivot_Transducer_Face_Dist, ::xml_schema::flags (), this),
  Filter_Doppler_ (Filter_Doppler, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  Encoder_Separation_ (Encoder_Separation, ::xml_schema::flags (), this),
  Overshoot_ (Overshoot, ::xml_schema::flags (), this),
  Attenuation_Shift_ (Attenuation_Shift, ::xml_schema::flags (), this),
  Filter_ (Filter, ::xml_schema::flags (), this),
  Default_Rx_Gain_Doppler_ (Default_Rx_Gain_Doppler, ::xml_schema::flags (), this),
  Peak_Vel_Correction_ (Peak_Vel_Correction, ::xml_schema::flags (), this),
  Detect_Ratio_Max_ (Detect_Ratio_Max, ::xml_schema::flags (), this),
  Acceleration_Limit_Constant_ (Acceleration_Limit_Constant, ::xml_schema::flags (), this),
  Filter_Doppler_Low_ (Filter_Doppler_Low, ::xml_schema::flags (), this)
{
}

ActiveProbe::
ActiveProbe (const Notes_type& Notes,
             ::std::auto_ptr< Sample_Time_type >& Sample_Time,
             ::std::auto_ptr< Focal_Length_type >& Focal_Length,
             const Acceleration_Limit_Slope_type& Acceleration_Limit_Slope,
             const Type_type& Type,
             const Detect_Id_type& Detect_Id,
             ::std::auto_ptr< Default_Scan_Speed_type >& Default_Scan_Speed,
             const K1_Power_type& K1_Power,
             ::std::auto_ptr< Cutoff_Scan_Speed_type >& Cutoff_Scan_Speed,
             ::std::auto_ptr< Frequency_Low_type >& Frequency_Low,
             ::std::auto_ptr< Default_FOV_type >& Default_FOV,
             ::std::auto_ptr< Frequency_Doppler_Default_type >& Frequency_Doppler_Default,
             const Default_SvSize_MMode_type& Default_SvSize_MMode,
             const Axial_Res_Factor_Target_type& Axial_Res_Factor_Target,
             const F_Number_type& F_Number,
             const Acc_Time_Factor_type& Acc_Time_Factor,
             ::std::auto_ptr< Frequency_Doppler_type >& Frequency_Doppler,
             ::std::auto_ptr< Axial_Res_type >& Axial_Res,
             const Detect_Ratio_Min_type& Detect_Ratio_Min,
             const Lateral_Res_Factor_Target_type& Lateral_Res_Factor_Target,
             const Derivative_Time_type& Derivative_Time,
             ::std::auto_ptr< Filter_High_type >& Filter_High,
             ::std::auto_ptr< Pivot_Encoder_Dist_type >& Pivot_Encoder_Dist,
             ::std::auto_ptr< Encoder_Range_Max_type >& Encoder_Range_Max,
             ::std::auto_ptr< Encoder_Range_Min_type >& Encoder_Range_Min,
             ::std::auto_ptr< Lateral_Res_type >& Lateral_Res,
             ::std::auto_ptr< Motor_Overhead_type >& Motor_Overhead,
             ::std::auto_ptr< Max_Scan_Distance_type >& Max_Scan_Distance,
             const Version_type& Version,
             ::std::auto_ptr< Default_Rx_Gain_type >& Default_Rx_Gain,
             ::std::auto_ptr< Filter_Low_type >& Filter_Low,
             const PID_KD_High_type& PID_KD_High,
             const PID_KI_High_type& PID_KI_High,
             const PID_KP_High_type& PID_KP_High,
             ::std::auto_ptr< Frequency_High_type >& Frequency_High,
             const Lateral_Res_Factor_Max_type& Lateral_Res_Factor_Max,
             ::std::auto_ptr< Scan_Speeds_type >& Scan_Speeds,
             ::std::auto_ptr< Filter_Doppler_Cutoff_type >& Filter_Doppler_Cutoff,
             const Name_type& Name,
             const PID_KD_Low_type& PID_KD_Low,
             const PID_KI_Low_type& PID_KI_Low,
             const PID_KP_Low_type& PID_KP_Low,
             const Peak_Bandwidth_Correction_type& Peak_Bandwidth_Correction,
             ::std::auto_ptr< Frequency_Doppler_Low_type >& Frequency_Doppler_Low,
             ::std::auto_ptr< Pivot_Transducer_Face_Dist_type >& Pivot_Transducer_Face_Dist,
             ::std::auto_ptr< Filter_Doppler_type >& Filter_Doppler,
             ::std::auto_ptr< Frequency_type >& Frequency,
             const Integration_Limit_type& Integration_Limit,
             ::std::auto_ptr< Encoder_Separation_type >& Encoder_Separation,
             ::std::auto_ptr< Overshoot_type >& Overshoot,
             const Attenuation_Shift_type& Attenuation_Shift,
             ::std::auto_ptr< Filter_type >& Filter,
             ::std::auto_ptr< Default_Rx_Gain_Doppler_type >& Default_Rx_Gain_Doppler,
             const Peak_Vel_Correction_type& Peak_Vel_Correction,
             const Detect_Ratio_Max_type& Detect_Ratio_Max,
             const Acceleration_Limit_Constant_type& Acceleration_Limit_Constant,
             ::std::auto_ptr< Filter_Doppler_Low_type >& Filter_Doppler_Low)
: ::xml_schema::type (),
  Notes_ (Notes, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Focal_Length_ (Focal_Length, ::xml_schema::flags (), this),
  Acceleration_Limit_Slope_ (Acceleration_Limit_Slope, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Detect_Id_ (Detect_Id, ::xml_schema::flags (), this),
  Default_Scan_Speed_ (Default_Scan_Speed, ::xml_schema::flags (), this),
  K1_Power_ (K1_Power, ::xml_schema::flags (), this),
  Cutoff_Scan_Speed_ (Cutoff_Scan_Speed, ::xml_schema::flags (), this),
  Frequency_Low_ (Frequency_Low, ::xml_schema::flags (), this),
  Default_FOV_ (Default_FOV, ::xml_schema::flags (), this),
  Frequency_Doppler_Default_ (Frequency_Doppler_Default, ::xml_schema::flags (), this),
  Default_SvSize_MMode_ (Default_SvSize_MMode, ::xml_schema::flags (), this),
  Axial_Res_Factor_Target_ (Axial_Res_Factor_Target, ::xml_schema::flags (), this),
  F_Number_ (F_Number, ::xml_schema::flags (), this),
  Acc_Time_Factor_ (Acc_Time_Factor, ::xml_schema::flags (), this),
  Frequency_Doppler_ (Frequency_Doppler, ::xml_schema::flags (), this),
  Axial_Res_ (Axial_Res, ::xml_schema::flags (), this),
  Detect_Ratio_Min_ (Detect_Ratio_Min, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Target_ (Lateral_Res_Factor_Target, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Filter_High_ (Filter_High, ::xml_schema::flags (), this),
  Pivot_Encoder_Dist_ (Pivot_Encoder_Dist, ::xml_schema::flags (), this),
  Encoder_Range_Max_ (Encoder_Range_Max, ::xml_schema::flags (), this),
  Encoder_Range_Min_ (Encoder_Range_Min, ::xml_schema::flags (), this),
  Lateral_Res_ (Lateral_Res, ::xml_schema::flags (), this),
  Motor_Overhead_ (Motor_Overhead, ::xml_schema::flags (), this),
  Max_Scan_Distance_ (Max_Scan_Distance, ::xml_schema::flags (), this),
  Version_ (Version, ::xml_schema::flags (), this),
  Default_Rx_Gain_ (Default_Rx_Gain, ::xml_schema::flags (), this),
  Filter_Low_ (Filter_Low, ::xml_schema::flags (), this),
  PID_KD_High_ (PID_KD_High, ::xml_schema::flags (), this),
  PID_KI_High_ (PID_KI_High, ::xml_schema::flags (), this),
  PID_KP_High_ (PID_KP_High, ::xml_schema::flags (), this),
  Frequency_High_ (Frequency_High, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Max_ (Lateral_Res_Factor_Max, ::xml_schema::flags (), this),
  Scan_Speeds_ (Scan_Speeds, ::xml_schema::flags (), this),
  Filter_Doppler_Cutoff_ (Filter_Doppler_Cutoff, ::xml_schema::flags (), this),
  Name_ (Name, ::xml_schema::flags (), this),
  PID_KD_Low_ (PID_KD_Low, ::xml_schema::flags (), this),
  PID_KI_Low_ (PID_KI_Low, ::xml_schema::flags (), this),
  PID_KP_Low_ (PID_KP_Low, ::xml_schema::flags (), this),
  Peak_Bandwidth_Correction_ (Peak_Bandwidth_Correction, ::xml_schema::flags (), this),
  Frequency_Doppler_Low_ (Frequency_Doppler_Low, ::xml_schema::flags (), this),
  Pivot_Transducer_Face_Dist_ (Pivot_Transducer_Face_Dist, ::xml_schema::flags (), this),
  Filter_Doppler_ (Filter_Doppler, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  Encoder_Separation_ (Encoder_Separation, ::xml_schema::flags (), this),
  Overshoot_ (Overshoot, ::xml_schema::flags (), this),
  Attenuation_Shift_ (Attenuation_Shift, ::xml_schema::flags (), this),
  Filter_ (Filter, ::xml_schema::flags (), this),
  Default_Rx_Gain_Doppler_ (Default_Rx_Gain_Doppler, ::xml_schema::flags (), this),
  Peak_Vel_Correction_ (Peak_Vel_Correction, ::xml_schema::flags (), this),
  Detect_Ratio_Max_ (Detect_Ratio_Max, ::xml_schema::flags (), this),
  Acceleration_Limit_Constant_ (Acceleration_Limit_Constant, ::xml_schema::flags (), this),
  Filter_Doppler_Low_ (Filter_Doppler_Low, ::xml_schema::flags (), this)
{
}

ActiveProbe::
ActiveProbe (const ActiveProbe& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Notes_ (x.Notes_, f, this),
  Sample_Time_ (x.Sample_Time_, f, this),
  Focal_Length_ (x.Focal_Length_, f, this),
  Acceleration_Limit_Slope_ (x.Acceleration_Limit_Slope_, f, this),
  Type_ (x.Type_, f, this),
  Detect_Id_ (x.Detect_Id_, f, this),
  Default_Scan_Speed_ (x.Default_Scan_Speed_, f, this),
  K1_Power_ (x.K1_Power_, f, this),
  Cutoff_Scan_Speed_ (x.Cutoff_Scan_Speed_, f, this),
  Frequency_Low_ (x.Frequency_Low_, f, this),
  Default_FOV_ (x.Default_FOV_, f, this),
  Frequency_Doppler_Default_ (x.Frequency_Doppler_Default_, f, this),
  Default_SvSize_MMode_ (x.Default_SvSize_MMode_, f, this),
  Axial_Res_Factor_Target_ (x.Axial_Res_Factor_Target_, f, this),
  F_Number_ (x.F_Number_, f, this),
  Acc_Time_Factor_ (x.Acc_Time_Factor_, f, this),
  Frequency_Doppler_ (x.Frequency_Doppler_, f, this),
  Axial_Res_ (x.Axial_Res_, f, this),
  Detect_Ratio_Min_ (x.Detect_Ratio_Min_, f, this),
  Lateral_Res_Factor_Target_ (x.Lateral_Res_Factor_Target_, f, this),
  Derivative_Time_ (x.Derivative_Time_, f, this),
  Filter_High_ (x.Filter_High_, f, this),
  Pivot_Encoder_Dist_ (x.Pivot_Encoder_Dist_, f, this),
  Encoder_Range_Max_ (x.Encoder_Range_Max_, f, this),
  Encoder_Range_Min_ (x.Encoder_Range_Min_, f, this),
  Lateral_Res_ (x.Lateral_Res_, f, this),
  Motor_Overhead_ (x.Motor_Overhead_, f, this),
  Max_Scan_Distance_ (x.Max_Scan_Distance_, f, this),
  Version_ (x.Version_, f, this),
  Default_Rx_Gain_ (x.Default_Rx_Gain_, f, this),
  Filter_Low_ (x.Filter_Low_, f, this),
  PID_KD_High_ (x.PID_KD_High_, f, this),
  PID_KI_High_ (x.PID_KI_High_, f, this),
  PID_KP_High_ (x.PID_KP_High_, f, this),
  Frequency_High_ (x.Frequency_High_, f, this),
  Lateral_Res_Factor_Max_ (x.Lateral_Res_Factor_Max_, f, this),
  Scan_Speeds_ (x.Scan_Speeds_, f, this),
  Filter_Doppler_Cutoff_ (x.Filter_Doppler_Cutoff_, f, this),
  Name_ (x.Name_, f, this),
  PID_KD_Low_ (x.PID_KD_Low_, f, this),
  PID_KI_Low_ (x.PID_KI_Low_, f, this),
  PID_KP_Low_ (x.PID_KP_Low_, f, this),
  Peak_Bandwidth_Correction_ (x.Peak_Bandwidth_Correction_, f, this),
  Frequency_Doppler_Low_ (x.Frequency_Doppler_Low_, f, this),
  Pivot_Transducer_Face_Dist_ (x.Pivot_Transducer_Face_Dist_, f, this),
  Filter_Doppler_ (x.Filter_Doppler_, f, this),
  Frequency_ (x.Frequency_, f, this),
  Integration_Limit_ (x.Integration_Limit_, f, this),
  Encoder_Separation_ (x.Encoder_Separation_, f, this),
  Overshoot_ (x.Overshoot_, f, this),
  Attenuation_Shift_ (x.Attenuation_Shift_, f, this),
  Filter_ (x.Filter_, f, this),
  Default_Rx_Gain_Doppler_ (x.Default_Rx_Gain_Doppler_, f, this),
  Peak_Vel_Correction_ (x.Peak_Vel_Correction_, f, this),
  Detect_Ratio_Max_ (x.Detect_Ratio_Max_, f, this),
  Acceleration_Limit_Constant_ (x.Acceleration_Limit_Constant_, f, this),
  Filter_Doppler_Low_ (x.Filter_Doppler_Low_, f, this)
{
}

ActiveProbe::
ActiveProbe (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Notes_ (f, this),
  Sample_Time_ (f, this),
  Focal_Length_ (f, this),
  Acceleration_Limit_Slope_ (f, this),
  Type_ (f, this),
  Detect_Id_ (f, this),
  Default_Scan_Speed_ (f, this),
  K1_Power_ (f, this),
  Cutoff_Scan_Speed_ (f, this),
  Frequency_Low_ (f, this),
  Default_FOV_ (f, this),
  Frequency_Doppler_Default_ (f, this),
  Default_SvSize_MMode_ (f, this),
  Axial_Res_Factor_Target_ (f, this),
  F_Number_ (f, this),
  Acc_Time_Factor_ (f, this),
  Frequency_Doppler_ (f, this),
  Axial_Res_ (f, this),
  Detect_Ratio_Min_ (f, this),
  Lateral_Res_Factor_Target_ (f, this),
  Derivative_Time_ (f, this),
  Filter_High_ (f, this),
  Pivot_Encoder_Dist_ (f, this),
  Encoder_Range_Max_ (f, this),
  Encoder_Range_Min_ (f, this),
  Lateral_Res_ (f, this),
  Motor_Overhead_ (f, this),
  Max_Scan_Distance_ (f, this),
  Version_ (f, this),
  Default_Rx_Gain_ (f, this),
  Filter_Low_ (f, this),
  PID_KD_High_ (f, this),
  PID_KI_High_ (f, this),
  PID_KP_High_ (f, this),
  Frequency_High_ (f, this),
  Lateral_Res_Factor_Max_ (f, this),
  Scan_Speeds_ (f, this),
  Filter_Doppler_Cutoff_ (f, this),
  Name_ (f, this),
  PID_KD_Low_ (f, this),
  PID_KI_Low_ (f, this),
  PID_KP_Low_ (f, this),
  Peak_Bandwidth_Correction_ (f, this),
  Frequency_Doppler_Low_ (f, this),
  Pivot_Transducer_Face_Dist_ (f, this),
  Filter_Doppler_ (f, this),
  Frequency_ (f, this),
  Integration_Limit_ (f, this),
  Encoder_Separation_ (f, this),
  Overshoot_ (f, this),
  Attenuation_Shift_ (f, this),
  Filter_ (f, this),
  Default_Rx_Gain_Doppler_ (f, this),
  Peak_Vel_Correction_ (f, this),
  Detect_Ratio_Max_ (f, this),
  Acceleration_Limit_Constant_ (f, this),
  Filter_Doppler_Low_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ActiveProbe::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!Notes_.present ())
      {
        this->Notes_.set (r);
        continue;
      }
    }

    // Sample-Time
    //
    if (n.name () == "Sample-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sample_Time_type > r (
        Sample_Time_traits::create (i, f, this));

      if (!Sample_Time_.present ())
      {
        this->Sample_Time_.set (r);
        continue;
      }
    }

    // Focal-Length
    //
    if (n.name () == "Focal-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Focal_Length_type > r (
        Focal_Length_traits::create (i, f, this));

      if (!Focal_Length_.present ())
      {
        this->Focal_Length_.set (r);
        continue;
      }
    }

    // Acceleration-Limit-Slope
    //
    if (n.name () == "Acceleration-Limit-Slope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Limit_Slope_type > r (
        Acceleration_Limit_Slope_traits::create (i, f, this));

      if (!Acceleration_Limit_Slope_.present ())
      {
        this->Acceleration_Limit_Slope_.set (r);
        continue;
      }
    }

    // Type
    //
    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Type_type > r (
        Type_traits::create (i, f, this));

      if (!Type_.present ())
      {
        this->Type_.set (r);
        continue;
      }
    }

    // Detect-Id
    //
    if (n.name () == "Detect-Id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Id_type > r (
        Detect_Id_traits::create (i, f, this));

      if (!Detect_Id_.present ())
      {
        this->Detect_Id_.set (r);
        continue;
      }
    }

    // Default-Scan-Speed
    //
    if (n.name () == "Default-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Scan_Speed_type > r (
        Default_Scan_Speed_traits::create (i, f, this));

      if (!Default_Scan_Speed_.present ())
      {
        this->Default_Scan_Speed_.set (r);
        continue;
      }
    }

    // K1-Power
    //
    if (n.name () == "K1-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< K1_Power_type > r (
        K1_Power_traits::create (i, f, this));

      if (!K1_Power_.present ())
      {
        this->K1_Power_.set (r);
        continue;
      }
    }

    // Cutoff-Scan-Speed
    //
    if (n.name () == "Cutoff-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cutoff_Scan_Speed_type > r (
        Cutoff_Scan_Speed_traits::create (i, f, this));

      if (!Cutoff_Scan_Speed_.present ())
      {
        this->Cutoff_Scan_Speed_.set (r);
        continue;
      }
    }

    // Frequency-Low
    //
    if (n.name () == "Frequency-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Low_type > r (
        Frequency_Low_traits::create (i, f, this));

      if (!Frequency_Low_.present ())
      {
        this->Frequency_Low_.set (r);
        continue;
      }
    }

    // Default-FOV
    //
    if (n.name () == "Default-FOV" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_FOV_type > r (
        Default_FOV_traits::create (i, f, this));

      if (!Default_FOV_.present ())
      {
        this->Default_FOV_.set (r);
        continue;
      }
    }

    // Frequency-Doppler-Default
    //
    if (n.name () == "Frequency-Doppler-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_Default_type > r (
        Frequency_Doppler_Default_traits::create (i, f, this));

      if (!Frequency_Doppler_Default_.present ())
      {
        this->Frequency_Doppler_Default_.set (r);
        continue;
      }
    }

    // Default-SvSize-MMode
    //
    if (n.name () == "Default-SvSize-MMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_SvSize_MMode_type > r (
        Default_SvSize_MMode_traits::create (i, f, this));

      if (!Default_SvSize_MMode_.present ())
      {
        this->Default_SvSize_MMode_.set (r);
        continue;
      }
    }

    // Axial-Res-Factor-Target
    //
    if (n.name () == "Axial-Res-Factor-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axial_Res_Factor_Target_type > r (
        Axial_Res_Factor_Target_traits::create (i, f, this));

      if (!Axial_Res_Factor_Target_.present ())
      {
        this->Axial_Res_Factor_Target_.set (r);
        continue;
      }
    }

    // F-Number
    //
    if (n.name () == "F-Number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< F_Number_type > r (
        F_Number_traits::create (i, f, this));

      if (!F_Number_.present ())
      {
        this->F_Number_.set (r);
        continue;
      }
    }

    // Acc-Time-Factor
    //
    if (n.name () == "Acc-Time-Factor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acc_Time_Factor_type > r (
        Acc_Time_Factor_traits::create (i, f, this));

      if (!Acc_Time_Factor_.present ())
      {
        this->Acc_Time_Factor_.set (r);
        continue;
      }
    }

    // Frequency-Doppler
    //
    if (n.name () == "Frequency-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_type > r (
        Frequency_Doppler_traits::create (i, f, this));

      if (!Frequency_Doppler_.present ())
      {
        this->Frequency_Doppler_.set (r);
        continue;
      }
    }

    // Axial-Res
    //
    if (n.name () == "Axial-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axial_Res_type > r (
        Axial_Res_traits::create (i, f, this));

      if (!Axial_Res_.present ())
      {
        this->Axial_Res_.set (r);
        continue;
      }
    }

    // Detect-Ratio-Min
    //
    if (n.name () == "Detect-Ratio-Min" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Ratio_Min_type > r (
        Detect_Ratio_Min_traits::create (i, f, this));

      if (!Detect_Ratio_Min_.present ())
      {
        this->Detect_Ratio_Min_.set (r);
        continue;
      }
    }

    // Lateral-Res-Factor-Target
    //
    if (n.name () == "Lateral-Res-Factor-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_Factor_Target_type > r (
        Lateral_Res_Factor_Target_traits::create (i, f, this));

      if (!Lateral_Res_Factor_Target_.present ())
      {
        this->Lateral_Res_Factor_Target_.set (r);
        continue;
      }
    }

    // Derivative-Time
    //
    if (n.name () == "Derivative-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Derivative_Time_type > r (
        Derivative_Time_traits::create (i, f, this));

      if (!Derivative_Time_.present ())
      {
        this->Derivative_Time_.set (r);
        continue;
      }
    }

    // Filter-High
    //
    if (n.name () == "Filter-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_High_type > r (
        Filter_High_traits::create (i, f, this));

      if (!Filter_High_.present ())
      {
        this->Filter_High_.set (r);
        continue;
      }
    }

    // Pivot-Encoder-Dist
    //
    if (n.name () == "Pivot-Encoder-Dist" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pivot_Encoder_Dist_type > r (
        Pivot_Encoder_Dist_traits::create (i, f, this));

      if (!Pivot_Encoder_Dist_.present ())
      {
        this->Pivot_Encoder_Dist_.set (r);
        continue;
      }
    }

    // Encoder-Range-Max
    //
    if (n.name () == "Encoder-Range-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Range_Max_type > r (
        Encoder_Range_Max_traits::create (i, f, this));

      if (!Encoder_Range_Max_.present ())
      {
        this->Encoder_Range_Max_.set (r);
        continue;
      }
    }

    // Encoder-Range-Min
    //
    if (n.name () == "Encoder-Range-Min" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Range_Min_type > r (
        Encoder_Range_Min_traits::create (i, f, this));

      if (!Encoder_Range_Min_.present ())
      {
        this->Encoder_Range_Min_.set (r);
        continue;
      }
    }

    // Lateral-Res
    //
    if (n.name () == "Lateral-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_type > r (
        Lateral_Res_traits::create (i, f, this));

      if (!Lateral_Res_.present ())
      {
        this->Lateral_Res_.set (r);
        continue;
      }
    }

    // Motor-Overhead
    //
    if (n.name () == "Motor-Overhead" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Overhead_type > r (
        Motor_Overhead_traits::create (i, f, this));

      if (!Motor_Overhead_.present ())
      {
        this->Motor_Overhead_.set (r);
        continue;
      }
    }

    // Max-Scan-Distance
    //
    if (n.name () == "Max-Scan-Distance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Scan_Distance_type > r (
        Max_Scan_Distance_traits::create (i, f, this));

      if (!Max_Scan_Distance_.present ())
      {
        this->Max_Scan_Distance_.set (r);
        continue;
      }
    }

    // Version
    //
    if (n.name () == "Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Version_type > r (
        Version_traits::create (i, f, this));

      if (!Version_.present ())
      {
        this->Version_.set (r);
        continue;
      }
    }

    // Default-Rx-Gain
    //
    if (n.name () == "Default-Rx-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Rx_Gain_type > r (
        Default_Rx_Gain_traits::create (i, f, this));

      if (!Default_Rx_Gain_.present ())
      {
        this->Default_Rx_Gain_.set (r);
        continue;
      }
    }

    // Filter-Low
    //
    if (n.name () == "Filter-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Low_type > r (
        Filter_Low_traits::create (i, f, this));

      if (!Filter_Low_.present ())
      {
        this->Filter_Low_.set (r);
        continue;
      }
    }

    // PID-KD-High
    //
    if (n.name () == "PID-KD-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KD_High_type > r (
        PID_KD_High_traits::create (i, f, this));

      if (!PID_KD_High_.present ())
      {
        this->PID_KD_High_.set (r);
        continue;
      }
    }

    // PID-KI-High
    //
    if (n.name () == "PID-KI-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KI_High_type > r (
        PID_KI_High_traits::create (i, f, this));

      if (!PID_KI_High_.present ())
      {
        this->PID_KI_High_.set (r);
        continue;
      }
    }

    // PID-KP-High
    //
    if (n.name () == "PID-KP-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KP_High_type > r (
        PID_KP_High_traits::create (i, f, this));

      if (!PID_KP_High_.present ())
      {
        this->PID_KP_High_.set (r);
        continue;
      }
    }

    // Frequency-High
    //
    if (n.name () == "Frequency-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_High_type > r (
        Frequency_High_traits::create (i, f, this));

      if (!Frequency_High_.present ())
      {
        this->Frequency_High_.set (r);
        continue;
      }
    }

    // Lateral-Res-Factor-Max
    //
    if (n.name () == "Lateral-Res-Factor-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_Factor_Max_type > r (
        Lateral_Res_Factor_Max_traits::create (i, f, this));

      if (!Lateral_Res_Factor_Max_.present ())
      {
        this->Lateral_Res_Factor_Max_.set (r);
        continue;
      }
    }

    // Scan-Speeds
    //
    if (n.name () == "Scan-Speeds" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Speeds_type > r (
        Scan_Speeds_traits::create (i, f, this));

      if (!Scan_Speeds_.present ())
      {
        this->Scan_Speeds_.set (r);
        continue;
      }
    }

    // Filter-Doppler-Cutoff
    //
    if (n.name () == "Filter-Doppler-Cutoff" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_Cutoff_type > r (
        Filter_Doppler_Cutoff_traits::create (i, f, this));

      if (!Filter_Doppler_Cutoff_.present ())
      {
        this->Filter_Doppler_Cutoff_.set (r);
        continue;
      }
    }

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (r);
        continue;
      }
    }

    // PID-KD-Low
    //
    if (n.name () == "PID-KD-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KD_Low_type > r (
        PID_KD_Low_traits::create (i, f, this));

      if (!PID_KD_Low_.present ())
      {
        this->PID_KD_Low_.set (r);
        continue;
      }
    }

    // PID-KI-Low
    //
    if (n.name () == "PID-KI-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KI_Low_type > r (
        PID_KI_Low_traits::create (i, f, this));

      if (!PID_KI_Low_.present ())
      {
        this->PID_KI_Low_.set (r);
        continue;
      }
    }

    // PID-KP-Low
    //
    if (n.name () == "PID-KP-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KP_Low_type > r (
        PID_KP_Low_traits::create (i, f, this));

      if (!PID_KP_Low_.present ())
      {
        this->PID_KP_Low_.set (r);
        continue;
      }
    }

    // Peak-Bandwidth-Correction
    //
    if (n.name () == "Peak-Bandwidth-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Peak_Bandwidth_Correction_type > r (
        Peak_Bandwidth_Correction_traits::create (i, f, this));

      if (!Peak_Bandwidth_Correction_.present ())
      {
        this->Peak_Bandwidth_Correction_.set (r);
        continue;
      }
    }

    // Frequency-Doppler-Low
    //
    if (n.name () == "Frequency-Doppler-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_Low_type > r (
        Frequency_Doppler_Low_traits::create (i, f, this));

      if (!Frequency_Doppler_Low_.present ())
      {
        this->Frequency_Doppler_Low_.set (r);
        continue;
      }
    }

    // Pivot-Transducer-Face-Dist
    //
    if (n.name () == "Pivot-Transducer-Face-Dist" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pivot_Transducer_Face_Dist_type > r (
        Pivot_Transducer_Face_Dist_traits::create (i, f, this));

      if (!Pivot_Transducer_Face_Dist_.present ())
      {
        this->Pivot_Transducer_Face_Dist_.set (r);
        continue;
      }
    }

    // Filter-Doppler
    //
    if (n.name () == "Filter-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_type > r (
        Filter_Doppler_traits::create (i, f, this));

      if (!Filter_Doppler_.present ())
      {
        this->Filter_Doppler_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // Integration-Limit
    //
    if (n.name () == "Integration-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Integration_Limit_type > r (
        Integration_Limit_traits::create (i, f, this));

      if (!Integration_Limit_.present ())
      {
        this->Integration_Limit_.set (r);
        continue;
      }
    }

    // Encoder-Separation
    //
    if (n.name () == "Encoder-Separation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Separation_type > r (
        Encoder_Separation_traits::create (i, f, this));

      if (!Encoder_Separation_.present ())
      {
        this->Encoder_Separation_.set (r);
        continue;
      }
    }

    // Overshoot
    //
    if (n.name () == "Overshoot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Overshoot_type > r (
        Overshoot_traits::create (i, f, this));

      if (!Overshoot_.present ())
      {
        this->Overshoot_.set (r);
        continue;
      }
    }

    // Attenuation-Shift
    //
    if (n.name () == "Attenuation-Shift" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attenuation_Shift_type > r (
        Attenuation_Shift_traits::create (i, f, this));

      if (!Attenuation_Shift_.present ())
      {
        this->Attenuation_Shift_.set (r);
        continue;
      }
    }

    // Filter
    //
    if (n.name () == "Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_type > r (
        Filter_traits::create (i, f, this));

      if (!Filter_.present ())
      {
        this->Filter_.set (r);
        continue;
      }
    }

    // Default-Rx-Gain-Doppler
    //
    if (n.name () == "Default-Rx-Gain-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Rx_Gain_Doppler_type > r (
        Default_Rx_Gain_Doppler_traits::create (i, f, this));

      if (!Default_Rx_Gain_Doppler_.present ())
      {
        this->Default_Rx_Gain_Doppler_.set (r);
        continue;
      }
    }

    // Peak-Vel-Correction
    //
    if (n.name () == "Peak-Vel-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Peak_Vel_Correction_type > r (
        Peak_Vel_Correction_traits::create (i, f, this));

      if (!Peak_Vel_Correction_.present ())
      {
        this->Peak_Vel_Correction_.set (r);
        continue;
      }
    }

    // Detect-Ratio-Max
    //
    if (n.name () == "Detect-Ratio-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Ratio_Max_type > r (
        Detect_Ratio_Max_traits::create (i, f, this));

      if (!Detect_Ratio_Max_.present ())
      {
        this->Detect_Ratio_Max_.set (r);
        continue;
      }
    }

    // Acceleration-Limit-Constant
    //
    if (n.name () == "Acceleration-Limit-Constant" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Limit_Constant_type > r (
        Acceleration_Limit_Constant_traits::create (i, f, this));

      if (!Acceleration_Limit_Constant_.present ())
      {
        this->Acceleration_Limit_Constant_.set (r);
        continue;
      }
    }

    // Filter-Doppler-Low
    //
    if (n.name () == "Filter-Doppler-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_Low_type > r (
        Filter_Doppler_Low_traits::create (i, f, this));

      if (!Filter_Doppler_Low_.present ())
      {
        this->Filter_Doppler_Low_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Notes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Notes",
      "");
  }

  if (!Sample_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sample-Time",
      "");
  }

  if (!Focal_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Focal-Length",
      "");
  }

  if (!Acceleration_Limit_Slope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Limit-Slope",
      "");
  }

  if (!Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Type",
      "");
  }

  if (!Detect_Id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Id",
      "");
  }

  if (!Default_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Scan-Speed",
      "");
  }

  if (!K1_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "K1-Power",
      "");
  }

  if (!Cutoff_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cutoff-Scan-Speed",
      "");
  }

  if (!Frequency_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Low",
      "");
  }

  if (!Default_FOV_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-FOV",
      "");
  }

  if (!Frequency_Doppler_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler-Default",
      "");
  }

  if (!Default_SvSize_MMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-SvSize-MMode",
      "");
  }

  if (!Axial_Res_Factor_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axial-Res-Factor-Target",
      "");
  }

  if (!F_Number_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "F-Number",
      "");
  }

  if (!Acc_Time_Factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acc-Time-Factor",
      "");
  }

  if (!Frequency_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler",
      "");
  }

  if (!Axial_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axial-Res",
      "");
  }

  if (!Detect_Ratio_Min_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Ratio-Min",
      "");
  }

  if (!Lateral_Res_Factor_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res-Factor-Target",
      "");
  }

  if (!Derivative_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Derivative-Time",
      "");
  }

  if (!Filter_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-High",
      "");
  }

  if (!Pivot_Encoder_Dist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pivot-Encoder-Dist",
      "");
  }

  if (!Encoder_Range_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Range-Max",
      "");
  }

  if (!Encoder_Range_Min_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Range-Min",
      "");
  }

  if (!Lateral_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res",
      "");
  }

  if (!Motor_Overhead_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Overhead",
      "");
  }

  if (!Max_Scan_Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Scan-Distance",
      "");
  }

  if (!Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Version",
      "");
  }

  if (!Default_Rx_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Rx-Gain",
      "");
  }

  if (!Filter_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Low",
      "");
  }

  if (!PID_KD_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KD-High",
      "");
  }

  if (!PID_KI_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KI-High",
      "");
  }

  if (!PID_KP_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KP-High",
      "");
  }

  if (!Frequency_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-High",
      "");
  }

  if (!Lateral_Res_Factor_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res-Factor-Max",
      "");
  }

  if (!Scan_Speeds_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Speeds",
      "");
  }

  if (!Filter_Doppler_Cutoff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler-Cutoff",
      "");
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!PID_KD_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KD-Low",
      "");
  }

  if (!PID_KI_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KI-Low",
      "");
  }

  if (!PID_KP_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KP-Low",
      "");
  }

  if (!Peak_Bandwidth_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Peak-Bandwidth-Correction",
      "");
  }

  if (!Frequency_Doppler_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler-Low",
      "");
  }

  if (!Pivot_Transducer_Face_Dist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pivot-Transducer-Face-Dist",
      "");
  }

  if (!Filter_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!Integration_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Integration-Limit",
      "");
  }

  if (!Encoder_Separation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Separation",
      "");
  }

  if (!Overshoot_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Overshoot",
      "");
  }

  if (!Attenuation_Shift_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Attenuation-Shift",
      "");
  }

  if (!Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter",
      "");
  }

  if (!Default_Rx_Gain_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Rx-Gain-Doppler",
      "");
  }

  if (!Peak_Vel_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Peak-Vel-Correction",
      "");
  }

  if (!Detect_Ratio_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Ratio-Max",
      "");
  }

  if (!Acceleration_Limit_Constant_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Limit-Constant",
      "");
  }

  if (!Filter_Doppler_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler-Low",
      "");
  }
}

ActiveProbe* ActiveProbe::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActiveProbe (*this, f, c);
}

ActiveProbe::
~ActiveProbe ()
{
}

// BModeSoft
//

BModeSoft::
BModeSoft (const V_Relative_Frame_Rate_type& V_Relative_Frame_Rate,
           const Max_Power_Size_Default_type& Max_Power_Size_Default,
           const Buffer_Size_type& Buffer_Size,
           const AVR_Factor_type& AVR_Factor,
           const AVR_Startup_Frames_type& AVR_Startup_Frames,
           const BMode_Size_Default_type& BMode_Size_Default,
           const Relative_Frame_Rate_type& Relative_Frame_Rate,
           const Refresh_Rate_type& Refresh_Rate,
           const Acquire_Both_Directions_type& Acquire_Both_Directions,
           const Acquire_Persist_AVR_type& Acquire_Persist_AVR,
           const Power_Size_Default_type& Power_Size_Default,
           const Max_BMode_Size_Default_type& Max_BMode_Size_Default,
           const Target_Field_Of_View_type& Target_Field_Of_View,
           const Processing_Command_type& Processing_Command)
: ::xml_schema::type (),
  V_Relative_Frame_Rate_ (V_Relative_Frame_Rate, ::xml_schema::flags (), this),
  Max_Power_Size_Default_ (Max_Power_Size_Default, ::xml_schema::flags (), this),
  Buffer_Size_ (Buffer_Size, ::xml_schema::flags (), this),
  AVR_Factor_ (AVR_Factor, ::xml_schema::flags (), this),
  AVR_Startup_Frames_ (AVR_Startup_Frames, ::xml_schema::flags (), this),
  BMode_Size_Default_ (BMode_Size_Default, ::xml_schema::flags (), this),
  Relative_Frame_Rate_ (Relative_Frame_Rate, ::xml_schema::flags (), this),
  Refresh_Rate_ (Refresh_Rate, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Acquire_Persist_AVR_ (Acquire_Persist_AVR, ::xml_schema::flags (), this),
  Power_Size_Default_ (Power_Size_Default, ::xml_schema::flags (), this),
  Max_BMode_Size_Default_ (Max_BMode_Size_Default, ::xml_schema::flags (), this),
  Target_Field_Of_View_ (Target_Field_Of_View, ::xml_schema::flags (), this),
  Processing_Command_ (Processing_Command, ::xml_schema::flags (), this)
{
}

BModeSoft::
BModeSoft (const V_Relative_Frame_Rate_type& V_Relative_Frame_Rate,
           const Max_Power_Size_Default_type& Max_Power_Size_Default,
           ::std::auto_ptr< Buffer_Size_type >& Buffer_Size,
           const AVR_Factor_type& AVR_Factor,
           const AVR_Startup_Frames_type& AVR_Startup_Frames,
           ::std::auto_ptr< BMode_Size_Default_type >& BMode_Size_Default,
           const Relative_Frame_Rate_type& Relative_Frame_Rate,
           ::std::auto_ptr< Refresh_Rate_type >& Refresh_Rate,
           const Acquire_Both_Directions_type& Acquire_Both_Directions,
           const Acquire_Persist_AVR_type& Acquire_Persist_AVR,
           ::std::auto_ptr< Power_Size_Default_type >& Power_Size_Default,
           const Max_BMode_Size_Default_type& Max_BMode_Size_Default,
           ::std::auto_ptr< Target_Field_Of_View_type >& Target_Field_Of_View,
           const Processing_Command_type& Processing_Command)
: ::xml_schema::type (),
  V_Relative_Frame_Rate_ (V_Relative_Frame_Rate, ::xml_schema::flags (), this),
  Max_Power_Size_Default_ (Max_Power_Size_Default, ::xml_schema::flags (), this),
  Buffer_Size_ (Buffer_Size, ::xml_schema::flags (), this),
  AVR_Factor_ (AVR_Factor, ::xml_schema::flags (), this),
  AVR_Startup_Frames_ (AVR_Startup_Frames, ::xml_schema::flags (), this),
  BMode_Size_Default_ (BMode_Size_Default, ::xml_schema::flags (), this),
  Relative_Frame_Rate_ (Relative_Frame_Rate, ::xml_schema::flags (), this),
  Refresh_Rate_ (Refresh_Rate, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Acquire_Persist_AVR_ (Acquire_Persist_AVR, ::xml_schema::flags (), this),
  Power_Size_Default_ (Power_Size_Default, ::xml_schema::flags (), this),
  Max_BMode_Size_Default_ (Max_BMode_Size_Default, ::xml_schema::flags (), this),
  Target_Field_Of_View_ (Target_Field_Of_View, ::xml_schema::flags (), this),
  Processing_Command_ (Processing_Command, ::xml_schema::flags (), this)
{
}

BModeSoft::
BModeSoft (const BModeSoft& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  V_Relative_Frame_Rate_ (x.V_Relative_Frame_Rate_, f, this),
  Max_Power_Size_Default_ (x.Max_Power_Size_Default_, f, this),
  Buffer_Size_ (x.Buffer_Size_, f, this),
  AVR_Factor_ (x.AVR_Factor_, f, this),
  AVR_Startup_Frames_ (x.AVR_Startup_Frames_, f, this),
  BMode_Size_Default_ (x.BMode_Size_Default_, f, this),
  Relative_Frame_Rate_ (x.Relative_Frame_Rate_, f, this),
  Refresh_Rate_ (x.Refresh_Rate_, f, this),
  Acquire_Both_Directions_ (x.Acquire_Both_Directions_, f, this),
  Acquire_Persist_AVR_ (x.Acquire_Persist_AVR_, f, this),
  Power_Size_Default_ (x.Power_Size_Default_, f, this),
  Max_BMode_Size_Default_ (x.Max_BMode_Size_Default_, f, this),
  Target_Field_Of_View_ (x.Target_Field_Of_View_, f, this),
  Processing_Command_ (x.Processing_Command_, f, this)
{
}

BModeSoft::
BModeSoft (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  V_Relative_Frame_Rate_ (f, this),
  Max_Power_Size_Default_ (f, this),
  Buffer_Size_ (f, this),
  AVR_Factor_ (f, this),
  AVR_Startup_Frames_ (f, this),
  BMode_Size_Default_ (f, this),
  Relative_Frame_Rate_ (f, this),
  Refresh_Rate_ (f, this),
  Acquire_Both_Directions_ (f, this),
  Acquire_Persist_AVR_ (f, this),
  Power_Size_Default_ (f, this),
  Max_BMode_Size_Default_ (f, this),
  Target_Field_Of_View_ (f, this),
  Processing_Command_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void BModeSoft::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // V-Relative-Frame-Rate
    //
    if (n.name () == "V-Relative-Frame-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Relative_Frame_Rate_type > r (
        V_Relative_Frame_Rate_traits::create (i, f, this));

      if (!V_Relative_Frame_Rate_.present ())
      {
        this->V_Relative_Frame_Rate_.set (r);
        continue;
      }
    }

    // Max-Power-Size-Default
    //
    if (n.name () == "Max-Power-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Power_Size_Default_type > r (
        Max_Power_Size_Default_traits::create (i, f, this));

      if (!Max_Power_Size_Default_.present ())
      {
        this->Max_Power_Size_Default_.set (r);
        continue;
      }
    }

    // Buffer-Size
    //
    if (n.name () == "Buffer-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Size_type > r (
        Buffer_Size_traits::create (i, f, this));

      if (!Buffer_Size_.present ())
      {
        this->Buffer_Size_.set (r);
        continue;
      }
    }

    // AVR-Factor
    //
    if (n.name () == "AVR-Factor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AVR_Factor_type > r (
        AVR_Factor_traits::create (i, f, this));

      if (!AVR_Factor_.present ())
      {
        this->AVR_Factor_.set (r);
        continue;
      }
    }

    // AVR-Startup-Frames
    //
    if (n.name () == "AVR-Startup-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AVR_Startup_Frames_type > r (
        AVR_Startup_Frames_traits::create (i, f, this));

      if (!AVR_Startup_Frames_.present ())
      {
        this->AVR_Startup_Frames_.set (r);
        continue;
      }
    }

    // BMode-Size-Default
    //
    if (n.name () == "BMode-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BMode_Size_Default_type > r (
        BMode_Size_Default_traits::create (i, f, this));

      if (!BMode_Size_Default_.present ())
      {
        this->BMode_Size_Default_.set (r);
        continue;
      }
    }

    // Relative-Frame-Rate
    //
    if (n.name () == "Relative-Frame-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Relative_Frame_Rate_type > r (
        Relative_Frame_Rate_traits::create (i, f, this));

      if (!Relative_Frame_Rate_.present ())
      {
        this->Relative_Frame_Rate_.set (r);
        continue;
      }
    }

    // Refresh-Rate
    //
    if (n.name () == "Refresh-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Refresh_Rate_type > r (
        Refresh_Rate_traits::create (i, f, this));

      if (!Refresh_Rate_.present ())
      {
        this->Refresh_Rate_.set (r);
        continue;
      }
    }

    // Acquire-Both-Directions
    //
    if (n.name () == "Acquire-Both-Directions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Both_Directions_type > r (
        Acquire_Both_Directions_traits::create (i, f, this));

      if (!Acquire_Both_Directions_.present ())
      {
        this->Acquire_Both_Directions_.set (r);
        continue;
      }
    }

    // Acquire-Persist-AVR
    //
    if (n.name () == "Acquire-Persist-AVR" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_AVR_type > r (
        Acquire_Persist_AVR_traits::create (i, f, this));

      if (!Acquire_Persist_AVR_.present ())
      {
        this->Acquire_Persist_AVR_.set (r);
        continue;
      }
    }

    // Power-Size-Default
    //
    if (n.name () == "Power-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Power_Size_Default_type > r (
        Power_Size_Default_traits::create (i, f, this));

      if (!Power_Size_Default_.present ())
      {
        this->Power_Size_Default_.set (r);
        continue;
      }
    }

    // Max-BMode-Size-Default
    //
    if (n.name () == "Max-BMode-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_BMode_Size_Default_type > r (
        Max_BMode_Size_Default_traits::create (i, f, this));

      if (!Max_BMode_Size_Default_.present ())
      {
        this->Max_BMode_Size_Default_.set (r);
        continue;
      }
    }

    // Target-Field-Of-View
    //
    if (n.name () == "Target-Field-Of-View" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Target_Field_Of_View_type > r (
        Target_Field_Of_View_traits::create (i, f, this));

      if (!Target_Field_Of_View_.present ())
      {
        this->Target_Field_Of_View_.set (r);
        continue;
      }
    }

    // Processing-Command
    //
    if (n.name () == "Processing-Command" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Processing_Command_type > r (
        Processing_Command_traits::create (i, f, this));

      if (!Processing_Command_.present ())
      {
        this->Processing_Command_.set (r);
        continue;
      }
    }

    break;
  }

  if (!V_Relative_Frame_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Relative-Frame-Rate",
      "");
  }

  if (!Max_Power_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Power-Size-Default",
      "");
  }

  if (!Buffer_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Size",
      "");
  }

  if (!AVR_Factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AVR-Factor",
      "");
  }

  if (!AVR_Startup_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AVR-Startup-Frames",
      "");
  }

  if (!BMode_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BMode-Size-Default",
      "");
  }

  if (!Relative_Frame_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Relative-Frame-Rate",
      "");
  }

  if (!Refresh_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Refresh-Rate",
      "");
  }

  if (!Acquire_Both_Directions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Both-Directions",
      "");
  }

  if (!Acquire_Persist_AVR_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-AVR",
      "");
  }

  if (!Power_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Power-Size-Default",
      "");
  }

  if (!Max_BMode_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-BMode-Size-Default",
      "");
  }

  if (!Target_Field_Of_View_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Target-Field-Of-View",
      "");
  }

  if (!Processing_Command_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Processing-Command",
      "");
  }
}

BModeSoft* BModeSoft::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BModeSoft (*this, f, c);
}

BModeSoft::
~BModeSoft ()
{
}

// Sys
//

Sys::
Sys (const Query_Discard_Loop_On_Save_Frame_type& Query_Discard_Loop_On_Save_Frame,
     const Sound_Speed_type& Sound_Speed,
     const SubMode_type& SubMode,
     const Interrupt_Mask_type& Interrupt_Mask,
     const Calculation_Instances_type& Calculation_Instances,
     const Start_Licence_Date_type& Start_Licence_Date,
     const End_Licence_Date_type& End_Licence_Date,
     const Auto_Save_PreTrig_Loop_type& Auto_Save_PreTrig_Loop,
     const Feature_type& Feature,
     const Review_Setup_Dialog_type& Review_Setup_Dialog,
     const Acq_Setup_Dialog_type& Acq_Setup_Dialog,
     const Interrupt_Clear_type& Interrupt_Clear,
     const Interrupt_Status_type& Interrupt_Status,
     const Auto_Save_Load_3D_type& Auto_Save_Load_3D,
     const DICOM_Root_ID_type& DICOM_Root_ID,
     const Company_Name_type& Company_Name,
     const Image_To_Auto_Save_On_Label_type& Image_To_Auto_Save_On_Label,
     const DICOM_Encode_Regions_type& DICOM_Encode_Regions,
     const Pipeline_Delay_type& Pipeline_Delay,
     const DDS_Control_type& DDS_Control,
     const Mode_type& Mode)
: ::xml_schema::type (),
  Query_Discard_Loop_On_Save_Frame_ (Query_Discard_Loop_On_Save_Frame, ::xml_schema::flags (), this),
  Sound_Speed_ (Sound_Speed, ::xml_schema::flags (), this),
  SubMode_ (SubMode, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Calculation_Instances_ (Calculation_Instances, ::xml_schema::flags (), this),
  Start_Licence_Date_ (Start_Licence_Date, ::xml_schema::flags (), this),
  End_Licence_Date_ (End_Licence_Date, ::xml_schema::flags (), this),
  Auto_Save_PreTrig_Loop_ (Auto_Save_PreTrig_Loop, ::xml_schema::flags (), this),
  Feature_ (Feature, ::xml_schema::flags (), this),
  Review_Setup_Dialog_ (Review_Setup_Dialog, ::xml_schema::flags (), this),
  Acq_Setup_Dialog_ (Acq_Setup_Dialog, ::xml_schema::flags (), this),
  Interrupt_Clear_ (Interrupt_Clear, ::xml_schema::flags (), this),
  Interrupt_Status_ (Interrupt_Status, ::xml_schema::flags (), this),
  Auto_Save_Load_3D_ (Auto_Save_Load_3D, ::xml_schema::flags (), this),
  DICOM_Root_ID_ (DICOM_Root_ID, ::xml_schema::flags (), this),
  Company_Name_ (Company_Name, ::xml_schema::flags (), this),
  Image_To_Auto_Save_On_Label_ (Image_To_Auto_Save_On_Label, ::xml_schema::flags (), this),
  DICOM_Encode_Regions_ (DICOM_Encode_Regions, ::xml_schema::flags (), this),
  Pipeline_Delay_ (Pipeline_Delay, ::xml_schema::flags (), this),
  DDS_Control_ (DDS_Control, ::xml_schema::flags (), this),
  Mode_ (Mode, ::xml_schema::flags (), this)
{
}

Sys::
Sys (const Query_Discard_Loop_On_Save_Frame_type& Query_Discard_Loop_On_Save_Frame,
     ::std::auto_ptr< Sound_Speed_type >& Sound_Speed,
     const SubMode_type& SubMode,
     const Interrupt_Mask_type& Interrupt_Mask,
     const Calculation_Instances_type& Calculation_Instances,
     const Start_Licence_Date_type& Start_Licence_Date,
     const End_Licence_Date_type& End_Licence_Date,
     const Auto_Save_PreTrig_Loop_type& Auto_Save_PreTrig_Loop,
     const Feature_type& Feature,
     const Review_Setup_Dialog_type& Review_Setup_Dialog,
     const Acq_Setup_Dialog_type& Acq_Setup_Dialog,
     const Interrupt_Clear_type& Interrupt_Clear,
     const Interrupt_Status_type& Interrupt_Status,
     const Auto_Save_Load_3D_type& Auto_Save_Load_3D,
     const DICOM_Root_ID_type& DICOM_Root_ID,
     const Company_Name_type& Company_Name,
     const Image_To_Auto_Save_On_Label_type& Image_To_Auto_Save_On_Label,
     const DICOM_Encode_Regions_type& DICOM_Encode_Regions,
     ::std::auto_ptr< Pipeline_Delay_type >& Pipeline_Delay,
     const DDS_Control_type& DDS_Control,
     const Mode_type& Mode)
: ::xml_schema::type (),
  Query_Discard_Loop_On_Save_Frame_ (Query_Discard_Loop_On_Save_Frame, ::xml_schema::flags (), this),
  Sound_Speed_ (Sound_Speed, ::xml_schema::flags (), this),
  SubMode_ (SubMode, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Calculation_Instances_ (Calculation_Instances, ::xml_schema::flags (), this),
  Start_Licence_Date_ (Start_Licence_Date, ::xml_schema::flags (), this),
  End_Licence_Date_ (End_Licence_Date, ::xml_schema::flags (), this),
  Auto_Save_PreTrig_Loop_ (Auto_Save_PreTrig_Loop, ::xml_schema::flags (), this),
  Feature_ (Feature, ::xml_schema::flags (), this),
  Review_Setup_Dialog_ (Review_Setup_Dialog, ::xml_schema::flags (), this),
  Acq_Setup_Dialog_ (Acq_Setup_Dialog, ::xml_schema::flags (), this),
  Interrupt_Clear_ (Interrupt_Clear, ::xml_schema::flags (), this),
  Interrupt_Status_ (Interrupt_Status, ::xml_schema::flags (), this),
  Auto_Save_Load_3D_ (Auto_Save_Load_3D, ::xml_schema::flags (), this),
  DICOM_Root_ID_ (DICOM_Root_ID, ::xml_schema::flags (), this),
  Company_Name_ (Company_Name, ::xml_schema::flags (), this),
  Image_To_Auto_Save_On_Label_ (Image_To_Auto_Save_On_Label, ::xml_schema::flags (), this),
  DICOM_Encode_Regions_ (DICOM_Encode_Regions, ::xml_schema::flags (), this),
  Pipeline_Delay_ (Pipeline_Delay, ::xml_schema::flags (), this),
  DDS_Control_ (DDS_Control, ::xml_schema::flags (), this),
  Mode_ (Mode, ::xml_schema::flags (), this)
{
}

Sys::
Sys (const Sys& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Query_Discard_Loop_On_Save_Frame_ (x.Query_Discard_Loop_On_Save_Frame_, f, this),
  Sound_Speed_ (x.Sound_Speed_, f, this),
  SubMode_ (x.SubMode_, f, this),
  Interrupt_Mask_ (x.Interrupt_Mask_, f, this),
  Calculation_Instances_ (x.Calculation_Instances_, f, this),
  Start_Licence_Date_ (x.Start_Licence_Date_, f, this),
  End_Licence_Date_ (x.End_Licence_Date_, f, this),
  Auto_Save_PreTrig_Loop_ (x.Auto_Save_PreTrig_Loop_, f, this),
  Feature_ (x.Feature_, f, this),
  Review_Setup_Dialog_ (x.Review_Setup_Dialog_, f, this),
  Acq_Setup_Dialog_ (x.Acq_Setup_Dialog_, f, this),
  Interrupt_Clear_ (x.Interrupt_Clear_, f, this),
  Interrupt_Status_ (x.Interrupt_Status_, f, this),
  Auto_Save_Load_3D_ (x.Auto_Save_Load_3D_, f, this),
  DICOM_Root_ID_ (x.DICOM_Root_ID_, f, this),
  Company_Name_ (x.Company_Name_, f, this),
  Image_To_Auto_Save_On_Label_ (x.Image_To_Auto_Save_On_Label_, f, this),
  DICOM_Encode_Regions_ (x.DICOM_Encode_Regions_, f, this),
  Pipeline_Delay_ (x.Pipeline_Delay_, f, this),
  DDS_Control_ (x.DDS_Control_, f, this),
  Mode_ (x.Mode_, f, this)
{
}

Sys::
Sys (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Query_Discard_Loop_On_Save_Frame_ (f, this),
  Sound_Speed_ (f, this),
  SubMode_ (f, this),
  Interrupt_Mask_ (f, this),
  Calculation_Instances_ (f, this),
  Start_Licence_Date_ (f, this),
  End_Licence_Date_ (f, this),
  Auto_Save_PreTrig_Loop_ (f, this),
  Feature_ (f, this),
  Review_Setup_Dialog_ (f, this),
  Acq_Setup_Dialog_ (f, this),
  Interrupt_Clear_ (f, this),
  Interrupt_Status_ (f, this),
  Auto_Save_Load_3D_ (f, this),
  DICOM_Root_ID_ (f, this),
  Company_Name_ (f, this),
  Image_To_Auto_Save_On_Label_ (f, this),
  DICOM_Encode_Regions_ (f, this),
  Pipeline_Delay_ (f, this),
  DDS_Control_ (f, this),
  Mode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sys::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Query-Discard-Loop-On-Save-Frame
    //
    if (n.name () == "Query-Discard-Loop-On-Save-Frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Query_Discard_Loop_On_Save_Frame_type > r (
        Query_Discard_Loop_On_Save_Frame_traits::create (i, f, this));

      if (!Query_Discard_Loop_On_Save_Frame_.present ())
      {
        this->Query_Discard_Loop_On_Save_Frame_.set (r);
        continue;
      }
    }

    // Sound-Speed
    //
    if (n.name () == "Sound-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sound_Speed_type > r (
        Sound_Speed_traits::create (i, f, this));

      if (!Sound_Speed_.present ())
      {
        this->Sound_Speed_.set (r);
        continue;
      }
    }

    // SubMode
    //
    if (n.name () == "SubMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SubMode_type > r (
        SubMode_traits::create (i, f, this));

      if (!SubMode_.present ())
      {
        this->SubMode_.set (r);
        continue;
      }
    }

    // Interrupt-Mask
    //
    if (n.name () == "Interrupt-Mask" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Mask_type > r (
        Interrupt_Mask_traits::create (i, f, this));

      if (!Interrupt_Mask_.present ())
      {
        this->Interrupt_Mask_.set (r);
        continue;
      }
    }

    // Calculation-Instances
    //
    if (n.name () == "Calculation-Instances" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Calculation_Instances_type > r (
        Calculation_Instances_traits::create (i, f, this));

      if (!Calculation_Instances_.present ())
      {
        this->Calculation_Instances_.set (r);
        continue;
      }
    }

    // Start-Licence-Date
    //
    if (n.name () == "Start-Licence-Date" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Start_Licence_Date_type > r (
        Start_Licence_Date_traits::create (i, f, this));

      if (!Start_Licence_Date_.present ())
      {
        this->Start_Licence_Date_.set (r);
        continue;
      }
    }

    // End-Licence-Date
    //
    if (n.name () == "End-Licence-Date" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< End_Licence_Date_type > r (
        End_Licence_Date_traits::create (i, f, this));

      if (!End_Licence_Date_.present ())
      {
        this->End_Licence_Date_.set (r);
        continue;
      }
    }

    // Auto-Save-PreTrig-Loop
    //
    if (n.name () == "Auto-Save-PreTrig-Loop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Auto_Save_PreTrig_Loop_type > r (
        Auto_Save_PreTrig_Loop_traits::create (i, f, this));

      if (!Auto_Save_PreTrig_Loop_.present ())
      {
        this->Auto_Save_PreTrig_Loop_.set (r);
        continue;
      }
    }

    // Feature
    //
    if (n.name () == "Feature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Feature_type > r (
        Feature_traits::create (i, f, this));

      if (!Feature_.present ())
      {
        this->Feature_.set (r);
        continue;
      }
    }

    // Review-Setup-Dialog
    //
    if (n.name () == "Review-Setup-Dialog" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Review_Setup_Dialog_type > r (
        Review_Setup_Dialog_traits::create (i, f, this));

      if (!Review_Setup_Dialog_.present ())
      {
        this->Review_Setup_Dialog_.set (r);
        continue;
      }
    }

    // Acq-Setup-Dialog
    //
    if (n.name () == "Acq-Setup-Dialog" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acq_Setup_Dialog_type > r (
        Acq_Setup_Dialog_traits::create (i, f, this));

      if (!Acq_Setup_Dialog_.present ())
      {
        this->Acq_Setup_Dialog_.set (r);
        continue;
      }
    }

    // Interrupt-Clear
    //
    if (n.name () == "Interrupt-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Clear_type > r (
        Interrupt_Clear_traits::create (i, f, this));

      if (!Interrupt_Clear_.present ())
      {
        this->Interrupt_Clear_.set (r);
        continue;
      }
    }

    // Interrupt-Status
    //
    if (n.name () == "Interrupt-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Status_type > r (
        Interrupt_Status_traits::create (i, f, this));

      if (!Interrupt_Status_.present ())
      {
        this->Interrupt_Status_.set (r);
        continue;
      }
    }

    // Auto-Save-Load-3D
    //
    if (n.name () == "Auto-Save-Load-3D" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Auto_Save_Load_3D_type > r (
        Auto_Save_Load_3D_traits::create (i, f, this));

      if (!Auto_Save_Load_3D_.present ())
      {
        this->Auto_Save_Load_3D_.set (r);
        continue;
      }
    }

    // DICOM-Root-ID
    //
    if (n.name () == "DICOM-Root-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DICOM_Root_ID_type > r (
        DICOM_Root_ID_traits::create (i, f, this));

      if (!DICOM_Root_ID_.present ())
      {
        this->DICOM_Root_ID_.set (r);
        continue;
      }
    }

    // Company-Name
    //
    if (n.name () == "Company-Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Company_Name_type > r (
        Company_Name_traits::create (i, f, this));

      if (!Company_Name_.present ())
      {
        this->Company_Name_.set (r);
        continue;
      }
    }

    // Image-To-Auto-Save-On-Label
    //
    if (n.name () == "Image-To-Auto-Save-On-Label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_To_Auto_Save_On_Label_type > r (
        Image_To_Auto_Save_On_Label_traits::create (i, f, this));

      if (!Image_To_Auto_Save_On_Label_.present ())
      {
        this->Image_To_Auto_Save_On_Label_.set (r);
        continue;
      }
    }

    // DICOM-Encode-Regions
    //
    if (n.name () == "DICOM-Encode-Regions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DICOM_Encode_Regions_type > r (
        DICOM_Encode_Regions_traits::create (i, f, this));

      if (!DICOM_Encode_Regions_.present ())
      {
        this->DICOM_Encode_Regions_.set (r);
        continue;
      }
    }

    // Pipeline-Delay
    //
    if (n.name () == "Pipeline-Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pipeline_Delay_type > r (
        Pipeline_Delay_traits::create (i, f, this));

      if (!Pipeline_Delay_.present ())
      {
        this->Pipeline_Delay_.set (r);
        continue;
      }
    }

    // DDS-Control
    //
    if (n.name () == "DDS-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DDS_Control_type > r (
        DDS_Control_traits::create (i, f, this));

      if (!DDS_Control_.present ())
      {
        this->DDS_Control_.set (r);
        continue;
      }
    }

    // Mode
    //
    if (n.name () == "Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mode_type > r (
        Mode_traits::create (i, f, this));

      if (!Mode_.present ())
      {
        this->Mode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Query_Discard_Loop_On_Save_Frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Query-Discard-Loop-On-Save-Frame",
      "");
  }

  if (!Sound_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sound-Speed",
      "");
  }

  if (!SubMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SubMode",
      "");
  }

  if (!Interrupt_Mask_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Mask",
      "");
  }

  if (!Calculation_Instances_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Calculation-Instances",
      "");
  }

  if (!Start_Licence_Date_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Start-Licence-Date",
      "");
  }

  if (!End_Licence_Date_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "End-Licence-Date",
      "");
  }

  if (!Auto_Save_PreTrig_Loop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Auto-Save-PreTrig-Loop",
      "");
  }

  if (!Feature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Feature",
      "");
  }

  if (!Review_Setup_Dialog_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Review-Setup-Dialog",
      "");
  }

  if (!Acq_Setup_Dialog_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acq-Setup-Dialog",
      "");
  }

  if (!Interrupt_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Clear",
      "");
  }

  if (!Interrupt_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Status",
      "");
  }

  if (!Auto_Save_Load_3D_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Auto-Save-Load-3D",
      "");
  }

  if (!DICOM_Root_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DICOM-Root-ID",
      "");
  }

  if (!Company_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Company-Name",
      "");
  }

  if (!Image_To_Auto_Save_On_Label_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image-To-Auto-Save-On-Label",
      "");
  }

  if (!DICOM_Encode_Regions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DICOM-Encode-Regions",
      "");
  }

  if (!Pipeline_Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pipeline-Delay",
      "");
  }

  if (!DDS_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DDS-Control",
      "");
  }

  if (!Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mode",
      "");
  }
}

Sys* Sys::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sys (*this, f, c);
}

Sys::
~Sys ()
{
}

// MIS
//

MIS::
MIS (const ECG_Gain_type& ECG_Gain,
     const ECG_Available_type& ECG_Available,
     const Blood_Pressure_Available_type& Blood_Pressure_Available,
     const Respiration_Gating_type& Respiration_Gating,
     const Respiration_Available_type& Respiration_Available,
     const Control_type& Control,
     const BP_Gain_type& BP_Gain,
     const Temperature_Available_type& Temperature_Available)
: ::xml_schema::type (),
  ECG_Gain_ (ECG_Gain, ::xml_schema::flags (), this),
  ECG_Available_ (ECG_Available, ::xml_schema::flags (), this),
  Blood_Pressure_Available_ (Blood_Pressure_Available, ::xml_schema::flags (), this),
  Respiration_Gating_ (Respiration_Gating, ::xml_schema::flags (), this),
  Respiration_Available_ (Respiration_Available, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  BP_Gain_ (BP_Gain, ::xml_schema::flags (), this),
  Temperature_Available_ (Temperature_Available, ::xml_schema::flags (), this)
{
}

MIS::
MIS (const MIS& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ECG_Gain_ (x.ECG_Gain_, f, this),
  ECG_Available_ (x.ECG_Available_, f, this),
  Blood_Pressure_Available_ (x.Blood_Pressure_Available_, f, this),
  Respiration_Gating_ (x.Respiration_Gating_, f, this),
  Respiration_Available_ (x.Respiration_Available_, f, this),
  Control_ (x.Control_, f, this),
  BP_Gain_ (x.BP_Gain_, f, this),
  Temperature_Available_ (x.Temperature_Available_, f, this)
{
}

MIS::
MIS (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ECG_Gain_ (f, this),
  ECG_Available_ (f, this),
  Blood_Pressure_Available_ (f, this),
  Respiration_Gating_ (f, this),
  Respiration_Available_ (f, this),
  Control_ (f, this),
  BP_Gain_ (f, this),
  Temperature_Available_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MIS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ECG-Gain
    //
    if (n.name () == "ECG-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Gain_type > r (
        ECG_Gain_traits::create (i, f, this));

      if (!ECG_Gain_.present ())
      {
        this->ECG_Gain_.set (r);
        continue;
      }
    }

    // ECG-Available
    //
    if (n.name () == "ECG-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Available_type > r (
        ECG_Available_traits::create (i, f, this));

      if (!ECG_Available_.present ())
      {
        this->ECG_Available_.set (r);
        continue;
      }
    }

    // Blood-Pressure-Available
    //
    if (n.name () == "Blood-Pressure-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Blood_Pressure_Available_type > r (
        Blood_Pressure_Available_traits::create (i, f, this));

      if (!Blood_Pressure_Available_.present ())
      {
        this->Blood_Pressure_Available_.set (r);
        continue;
      }
    }

    // Respiration-Gating
    //
    if (n.name () == "Respiration-Gating" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Gating_type > r (
        Respiration_Gating_traits::create (i, f, this));

      if (!Respiration_Gating_.present ())
      {
        this->Respiration_Gating_.set (r);
        continue;
      }
    }

    // Respiration-Available
    //
    if (n.name () == "Respiration-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Available_type > r (
        Respiration_Available_traits::create (i, f, this));

      if (!Respiration_Available_.present ())
      {
        this->Respiration_Available_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    // BP-Gain
    //
    if (n.name () == "BP-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BP_Gain_type > r (
        BP_Gain_traits::create (i, f, this));

      if (!BP_Gain_.present ())
      {
        this->BP_Gain_.set (r);
        continue;
      }
    }

    // Temperature-Available
    //
    if (n.name () == "Temperature-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Available_type > r (
        Temperature_Available_traits::create (i, f, this));

      if (!Temperature_Available_.present ())
      {
        this->Temperature_Available_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ECG_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Gain",
      "");
  }

  if (!ECG_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Available",
      "");
  }

  if (!Blood_Pressure_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Blood-Pressure-Available",
      "");
  }

  if (!Respiration_Gating_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Gating",
      "");
  }

  if (!Respiration_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Available",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  if (!BP_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BP-Gain",
      "");
  }

  if (!Temperature_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Available",
      "");
  }
}

MIS* MIS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MIS (*this, f, c);
}

MIS::
~MIS ()
{
}

// Scan
//

Scan::
Scan (const Encoder_Position_type& Encoder_Position,
      const Center_type& Center,
      const Control_type& Control,
      const Probe_ID1_type& Probe_ID1,
      const Probe_ID2_type& Probe_ID2,
      const V_Scan_Speed_type& V_Scan_Speed,
      const Probe_ID1_Reread_type& Probe_ID1_Reread,
      const Probe_ID1_Valid_type& Probe_ID1_Valid,
      const Probe_ID1_Voltage_type& Probe_ID1_Voltage,
      const Probe_ID2_Reread_type& Probe_ID2_Reread,
      const Probe_ID2_Valid_type& Probe_ID2_Valid,
      const Probe_ID2_Voltage_type& Probe_ID2_Voltage,
      const V_Scan_Rate_type& V_Scan_Rate,
      const Position_Counter_Lock_type& Position_Counter_Lock,
      const Scan_Width_type& Scan_Width,
      const Position_Counter_Reset_type& Position_Counter_Reset)
: ::xml_schema::type (),
  Encoder_Position_ (Encoder_Position, ::xml_schema::flags (), this),
  Center_ (Center, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Probe_ID1_ (Probe_ID1, ::xml_schema::flags (), this),
  Probe_ID2_ (Probe_ID2, ::xml_schema::flags (), this),
  V_Scan_Speed_ (V_Scan_Speed, ::xml_schema::flags (), this),
  Probe_ID1_Reread_ (Probe_ID1_Reread, ::xml_schema::flags (), this),
  Probe_ID1_Valid_ (Probe_ID1_Valid, ::xml_schema::flags (), this),
  Probe_ID1_Voltage_ (Probe_ID1_Voltage, ::xml_schema::flags (), this),
  Probe_ID2_Reread_ (Probe_ID2_Reread, ::xml_schema::flags (), this),
  Probe_ID2_Valid_ (Probe_ID2_Valid, ::xml_schema::flags (), this),
  Probe_ID2_Voltage_ (Probe_ID2_Voltage, ::xml_schema::flags (), this),
  V_Scan_Rate_ (V_Scan_Rate, ::xml_schema::flags (), this),
  Position_Counter_Lock_ (Position_Counter_Lock, ::xml_schema::flags (), this),
  Scan_Width_ (Scan_Width, ::xml_schema::flags (), this),
  Position_Counter_Reset_ (Position_Counter_Reset, ::xml_schema::flags (), this)
{
}

Scan::
Scan (const Encoder_Position_type& Encoder_Position,
      ::std::auto_ptr< Center_type >& Center,
      const Control_type& Control,
      const Probe_ID1_type& Probe_ID1,
      const Probe_ID2_type& Probe_ID2,
      ::std::auto_ptr< V_Scan_Speed_type >& V_Scan_Speed,
      const Probe_ID1_Reread_type& Probe_ID1_Reread,
      const Probe_ID1_Valid_type& Probe_ID1_Valid,
      const Probe_ID1_Voltage_type& Probe_ID1_Voltage,
      const Probe_ID2_Reread_type& Probe_ID2_Reread,
      const Probe_ID2_Valid_type& Probe_ID2_Valid,
      const Probe_ID2_Voltage_type& Probe_ID2_Voltage,
      ::std::auto_ptr< V_Scan_Rate_type >& V_Scan_Rate,
      const Position_Counter_Lock_type& Position_Counter_Lock,
      ::std::auto_ptr< Scan_Width_type >& Scan_Width,
      const Position_Counter_Reset_type& Position_Counter_Reset)
: ::xml_schema::type (),
  Encoder_Position_ (Encoder_Position, ::xml_schema::flags (), this),
  Center_ (Center, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Probe_ID1_ (Probe_ID1, ::xml_schema::flags (), this),
  Probe_ID2_ (Probe_ID2, ::xml_schema::flags (), this),
  V_Scan_Speed_ (V_Scan_Speed, ::xml_schema::flags (), this),
  Probe_ID1_Reread_ (Probe_ID1_Reread, ::xml_schema::flags (), this),
  Probe_ID1_Valid_ (Probe_ID1_Valid, ::xml_schema::flags (), this),
  Probe_ID1_Voltage_ (Probe_ID1_Voltage, ::xml_schema::flags (), this),
  Probe_ID2_Reread_ (Probe_ID2_Reread, ::xml_schema::flags (), this),
  Probe_ID2_Valid_ (Probe_ID2_Valid, ::xml_schema::flags (), this),
  Probe_ID2_Voltage_ (Probe_ID2_Voltage, ::xml_schema::flags (), this),
  V_Scan_Rate_ (V_Scan_Rate, ::xml_schema::flags (), this),
  Position_Counter_Lock_ (Position_Counter_Lock, ::xml_schema::flags (), this),
  Scan_Width_ (Scan_Width, ::xml_schema::flags (), this),
  Position_Counter_Reset_ (Position_Counter_Reset, ::xml_schema::flags (), this)
{
}

Scan::
Scan (const Scan& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Encoder_Position_ (x.Encoder_Position_, f, this),
  Center_ (x.Center_, f, this),
  Control_ (x.Control_, f, this),
  Probe_ID1_ (x.Probe_ID1_, f, this),
  Probe_ID2_ (x.Probe_ID2_, f, this),
  V_Scan_Speed_ (x.V_Scan_Speed_, f, this),
  Probe_ID1_Reread_ (x.Probe_ID1_Reread_, f, this),
  Probe_ID1_Valid_ (x.Probe_ID1_Valid_, f, this),
  Probe_ID1_Voltage_ (x.Probe_ID1_Voltage_, f, this),
  Probe_ID2_Reread_ (x.Probe_ID2_Reread_, f, this),
  Probe_ID2_Valid_ (x.Probe_ID2_Valid_, f, this),
  Probe_ID2_Voltage_ (x.Probe_ID2_Voltage_, f, this),
  V_Scan_Rate_ (x.V_Scan_Rate_, f, this),
  Position_Counter_Lock_ (x.Position_Counter_Lock_, f, this),
  Scan_Width_ (x.Scan_Width_, f, this),
  Position_Counter_Reset_ (x.Position_Counter_Reset_, f, this)
{
}

Scan::
Scan (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Encoder_Position_ (f, this),
  Center_ (f, this),
  Control_ (f, this),
  Probe_ID1_ (f, this),
  Probe_ID2_ (f, this),
  V_Scan_Speed_ (f, this),
  Probe_ID1_Reread_ (f, this),
  Probe_ID1_Valid_ (f, this),
  Probe_ID1_Voltage_ (f, this),
  Probe_ID2_Reread_ (f, this),
  Probe_ID2_Valid_ (f, this),
  Probe_ID2_Voltage_ (f, this),
  V_Scan_Rate_ (f, this),
  Position_Counter_Lock_ (f, this),
  Scan_Width_ (f, this),
  Position_Counter_Reset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Scan::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Encoder-Position
    //
    if (n.name () == "Encoder-Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Position_type > r (
        Encoder_Position_traits::create (i, f, this));

      if (!Encoder_Position_.present ())
      {
        this->Encoder_Position_.set (r);
        continue;
      }
    }

    // Center
    //
    if (n.name () == "Center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Center_type > r (
        Center_traits::create (i, f, this));

      if (!Center_.present ())
      {
        this->Center_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    // Probe-ID1
    //
    if (n.name () == "Probe-ID1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_type > r (
        Probe_ID1_traits::create (i, f, this));

      if (!Probe_ID1_.present ())
      {
        this->Probe_ID1_.set (r);
        continue;
      }
    }

    // Probe-ID2
    //
    if (n.name () == "Probe-ID2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_type > r (
        Probe_ID2_traits::create (i, f, this));

      if (!Probe_ID2_.present ())
      {
        this->Probe_ID2_.set (r);
        continue;
      }
    }

    // V-Scan-Speed
    //
    if (n.name () == "V-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Scan_Speed_type > r (
        V_Scan_Speed_traits::create (i, f, this));

      if (!V_Scan_Speed_.present ())
      {
        this->V_Scan_Speed_.set (r);
        continue;
      }
    }

    // Probe-ID1-Reread
    //
    if (n.name () == "Probe-ID1-Reread" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Reread_type > r (
        Probe_ID1_Reread_traits::create (i, f, this));

      if (!Probe_ID1_Reread_.present ())
      {
        this->Probe_ID1_Reread_.set (r);
        continue;
      }
    }

    // Probe-ID1-Valid
    //
    if (n.name () == "Probe-ID1-Valid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Valid_type > r (
        Probe_ID1_Valid_traits::create (i, f, this));

      if (!Probe_ID1_Valid_.present ())
      {
        this->Probe_ID1_Valid_.set (r);
        continue;
      }
    }

    // Probe-ID1-Voltage
    //
    if (n.name () == "Probe-ID1-Voltage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Voltage_type > r (
        Probe_ID1_Voltage_traits::create (i, f, this));

      if (!Probe_ID1_Voltage_.present ())
      {
        this->Probe_ID1_Voltage_.set (r);
        continue;
      }
    }

    // Probe-ID2-Reread
    //
    if (n.name () == "Probe-ID2-Reread" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Reread_type > r (
        Probe_ID2_Reread_traits::create (i, f, this));

      if (!Probe_ID2_Reread_.present ())
      {
        this->Probe_ID2_Reread_.set (r);
        continue;
      }
    }

    // Probe-ID2-Valid
    //
    if (n.name () == "Probe-ID2-Valid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Valid_type > r (
        Probe_ID2_Valid_traits::create (i, f, this));

      if (!Probe_ID2_Valid_.present ())
      {
        this->Probe_ID2_Valid_.set (r);
        continue;
      }
    }

    // Probe-ID2-Voltage
    //
    if (n.name () == "Probe-ID2-Voltage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Voltage_type > r (
        Probe_ID2_Voltage_traits::create (i, f, this));

      if (!Probe_ID2_Voltage_.present ())
      {
        this->Probe_ID2_Voltage_.set (r);
        continue;
      }
    }

    // V-Scan-Rate
    //
    if (n.name () == "V-Scan-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Scan_Rate_type > r (
        V_Scan_Rate_traits::create (i, f, this));

      if (!V_Scan_Rate_.present ())
      {
        this->V_Scan_Rate_.set (r);
        continue;
      }
    }

    // Position-Counter-Lock
    //
    if (n.name () == "Position-Counter-Lock" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Counter_Lock_type > r (
        Position_Counter_Lock_traits::create (i, f, this));

      if (!Position_Counter_Lock_.present ())
      {
        this->Position_Counter_Lock_.set (r);
        continue;
      }
    }

    // Scan-Width
    //
    if (n.name () == "Scan-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Width_type > r (
        Scan_Width_traits::create (i, f, this));

      if (!Scan_Width_.present ())
      {
        this->Scan_Width_.set (r);
        continue;
      }
    }

    // Position-Counter-Reset
    //
    if (n.name () == "Position-Counter-Reset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Counter_Reset_type > r (
        Position_Counter_Reset_traits::create (i, f, this));

      if (!Position_Counter_Reset_.present ())
      {
        this->Position_Counter_Reset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Encoder_Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Position",
      "");
  }

  if (!Center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Center",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  if (!Probe_ID1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1",
      "");
  }

  if (!Probe_ID2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2",
      "");
  }

  if (!V_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Scan-Speed",
      "");
  }

  if (!Probe_ID1_Reread_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Reread",
      "");
  }

  if (!Probe_ID1_Valid_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Valid",
      "");
  }

  if (!Probe_ID1_Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Voltage",
      "");
  }

  if (!Probe_ID2_Reread_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Reread",
      "");
  }

  if (!Probe_ID2_Valid_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Valid",
      "");
  }

  if (!Probe_ID2_Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Voltage",
      "");
  }

  if (!V_Scan_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Scan-Rate",
      "");
  }

  if (!Position_Counter_Lock_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Counter-Lock",
      "");
  }

  if (!Scan_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Width",
      "");
  }

  if (!Position_Counter_Reset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Counter-Reset",
      "");
  }
}

Scan* Scan::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan (*this, f, c);
}

Scan::
~Scan ()
{
}

// Motor
//

Motor::
Motor (const Settle_Time_3d_type& Settle_Time_3d,
       const Position_type& Position,
       const R_Scan_Move_No_Wait_type& R_Scan_Move_No_Wait,
       const Motor_Mode_type& Motor_Mode,
       const Acceleration_type& Acceleration,
       const Serial_Port_Mode_type& Serial_Port_Mode,
       const Limit_Switch_Mode_type& Limit_Switch_Mode,
       const Breakpoint_type& Breakpoint,
       const Update_type& Update,
       const Breakpoint_Value_type& Breakpoint_Value,
       const V_Switch_Limit_type& V_Switch_Limit,
       const R_Retrieve_Trace_type& R_Retrieve_Trace,
       const Velocity_Stationary_type& Velocity_Stationary,
       const Reset_Event_Status_type& Reset_Event_Status,
       const Actual_Position_type& Actual_Position,
       const Buffer_Length_type& Buffer_Length,
       const Event_Status_type& Event_Status,
       const R_Scan_Move2_type& R_Scan_Move2,
       const Kp_type& Kp,
       const R_Wait_Finish_Scan_Move_type& R_Wait_Finish_Scan_Move,
       const Settle_Time_type& Settle_Time,
       const Acceleration_Stationary_type& Acceleration_Stationary,
       const Trace_Mode_type& Trace_Mode,
       const Trace_Period_type& Trace_Period,
       const Trace_Start_type& Trace_Start,
       const Position_Reverse_type& Position_Reverse,
       const Reset_type& Reset,
       const Trace_Count_type& Trace_Count,
       const R_Initialize_type& R_Initialize,
       const Output_Mode_type& Output_Mode,
       const Position2_type& Position2,
       const Integration_Limit_type& Integration_Limit,
       const R_Home_type& R_Home,
       const Error_type& Error,
       const R_Reset_Limit_Switch_type& R_Reset_Limit_Switch,
       const Settle_Window_3d_type& Settle_Window_3d,
       const Interrupt_Mask_type& Interrupt_Mask,
       const Scan_Move_Control_type& Scan_Move_Control,
       const Axis_Out_Source_type& Axis_Out_Source,
       const Trace_Stop_type& Trace_Stop,
       const Velocity_type& Velocity,
       const R_Setup_type& R_Setup,
       const Buffer_Start_type& Buffer_Start,
       const Signal_Sense_type& Signal_Sense,
       const R_Scan_Move_type& R_Scan_Move,
       const Position_Forward_type& Position_Forward,
       const Derivative_Time_type& Derivative_Time,
       const Settle_Window_type& Settle_Window,
       const Trace_Variable1_type& Trace_Variable1,
       const Trace_Variable2_type& Trace_Variable2,
       const Buffer_Read_Index_type& Buffer_Read_Index,
       const Signal_Status_type& Signal_Status,
       const Alarm_Clear_type& Alarm_Clear,
       const Motion_Complete_Mode_type& Motion_Complete_Mode,
       const R_Setup_Abort_type& R_Setup_Abort,
       const Read_Buffer_type& Read_Buffer,
       const Kd_type& Kd,
       const Clear_Interrupt_type& Clear_Interrupt,
       const Profile_Mode_type& Profile_Mode,
       const R_Setup_Trace_type& R_Setup_Trace,
       const No_Operation_type& No_Operation,
       const Ki_type& Ki,
       const Sample_Time_type& Sample_Time)
: ::xml_schema::type (),
  Settle_Time_3d_ (Settle_Time_3d, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  R_Scan_Move_No_Wait_ (R_Scan_Move_No_Wait, ::xml_schema::flags (), this),
  Motor_Mode_ (Motor_Mode, ::xml_schema::flags (), this),
  Acceleration_ (Acceleration, ::xml_schema::flags (), this),
  Serial_Port_Mode_ (Serial_Port_Mode, ::xml_schema::flags (), this),
  Limit_Switch_Mode_ (Limit_Switch_Mode, ::xml_schema::flags (), this),
  Breakpoint_ (Breakpoint, ::xml_schema::flags (), this),
  Update_ (Update, ::xml_schema::flags (), this),
  Breakpoint_Value_ (Breakpoint_Value, ::xml_schema::flags (), this),
  V_Switch_Limit_ (V_Switch_Limit, ::xml_schema::flags (), this),
  R_Retrieve_Trace_ (R_Retrieve_Trace, ::xml_schema::flags (), this),
  Velocity_Stationary_ (Velocity_Stationary, ::xml_schema::flags (), this),
  Reset_Event_Status_ (Reset_Event_Status, ::xml_schema::flags (), this),
  Actual_Position_ (Actual_Position, ::xml_schema::flags (), this),
  Buffer_Length_ (Buffer_Length, ::xml_schema::flags (), this),
  Event_Status_ (Event_Status, ::xml_schema::flags (), this),
  R_Scan_Move2_ (R_Scan_Move2, ::xml_schema::flags (), this),
  Kp_ (Kp, ::xml_schema::flags (), this),
  R_Wait_Finish_Scan_Move_ (R_Wait_Finish_Scan_Move, ::xml_schema::flags (), this),
  Settle_Time_ (Settle_Time, ::xml_schema::flags (), this),
  Acceleration_Stationary_ (Acceleration_Stationary, ::xml_schema::flags (), this),
  Trace_Mode_ (Trace_Mode, ::xml_schema::flags (), this),
  Trace_Period_ (Trace_Period, ::xml_schema::flags (), this),
  Trace_Start_ (Trace_Start, ::xml_schema::flags (), this),
  Position_Reverse_ (Position_Reverse, ::xml_schema::flags (), this),
  Reset_ (Reset, ::xml_schema::flags (), this),
  Trace_Count_ (Trace_Count, ::xml_schema::flags (), this),
  R_Initialize_ (R_Initialize, ::xml_schema::flags (), this),
  Output_Mode_ (Output_Mode, ::xml_schema::flags (), this),
  Position2_ (Position2, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  R_Home_ (R_Home, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  R_Reset_Limit_Switch_ (R_Reset_Limit_Switch, ::xml_schema::flags (), this),
  Settle_Window_3d_ (Settle_Window_3d, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Scan_Move_Control_ (Scan_Move_Control, ::xml_schema::flags (), this),
  Axis_Out_Source_ (Axis_Out_Source, ::xml_schema::flags (), this),
  Trace_Stop_ (Trace_Stop, ::xml_schema::flags (), this),
  Velocity_ (Velocity, ::xml_schema::flags (), this),
  R_Setup_ (R_Setup, ::xml_schema::flags (), this),
  Buffer_Start_ (Buffer_Start, ::xml_schema::flags (), this),
  Signal_Sense_ (Signal_Sense, ::xml_schema::flags (), this),
  R_Scan_Move_ (R_Scan_Move, ::xml_schema::flags (), this),
  Position_Forward_ (Position_Forward, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Settle_Window_ (Settle_Window, ::xml_schema::flags (), this),
  Trace_Variable1_ (Trace_Variable1, ::xml_schema::flags (), this),
  Trace_Variable2_ (Trace_Variable2, ::xml_schema::flags (), this),
  Buffer_Read_Index_ (Buffer_Read_Index, ::xml_schema::flags (), this),
  Signal_Status_ (Signal_Status, ::xml_schema::flags (), this),
  Alarm_Clear_ (Alarm_Clear, ::xml_schema::flags (), this),
  Motion_Complete_Mode_ (Motion_Complete_Mode, ::xml_schema::flags (), this),
  R_Setup_Abort_ (R_Setup_Abort, ::xml_schema::flags (), this),
  Read_Buffer_ (Read_Buffer, ::xml_schema::flags (), this),
  Kd_ (Kd, ::xml_schema::flags (), this),
  Clear_Interrupt_ (Clear_Interrupt, ::xml_schema::flags (), this),
  Profile_Mode_ (Profile_Mode, ::xml_schema::flags (), this),
  R_Setup_Trace_ (R_Setup_Trace, ::xml_schema::flags (), this),
  No_Operation_ (No_Operation, ::xml_schema::flags (), this),
  Ki_ (Ki, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this)
{
}

Motor::
Motor (const Settle_Time_3d_type& Settle_Time_3d,
       ::std::auto_ptr< Position_type >& Position,
       ::std::auto_ptr< R_Scan_Move_No_Wait_type >& R_Scan_Move_No_Wait,
       const Motor_Mode_type& Motor_Mode,
       ::std::auto_ptr< Acceleration_type >& Acceleration,
       const Serial_Port_Mode_type& Serial_Port_Mode,
       const Limit_Switch_Mode_type& Limit_Switch_Mode,
       const Breakpoint_type& Breakpoint,
       const Update_type& Update,
       const Breakpoint_Value_type& Breakpoint_Value,
       const V_Switch_Limit_type& V_Switch_Limit,
       const R_Retrieve_Trace_type& R_Retrieve_Trace,
       ::std::auto_ptr< Velocity_Stationary_type >& Velocity_Stationary,
       const Reset_Event_Status_type& Reset_Event_Status,
       const Actual_Position_type& Actual_Position,
       const Buffer_Length_type& Buffer_Length,
       const Event_Status_type& Event_Status,
       ::std::auto_ptr< R_Scan_Move2_type >& R_Scan_Move2,
       const Kp_type& Kp,
       const R_Wait_Finish_Scan_Move_type& R_Wait_Finish_Scan_Move,
       const Settle_Time_type& Settle_Time,
       ::std::auto_ptr< Acceleration_Stationary_type >& Acceleration_Stationary,
       const Trace_Mode_type& Trace_Mode,
       const Trace_Period_type& Trace_Period,
       const Trace_Start_type& Trace_Start,
       ::std::auto_ptr< Position_Reverse_type >& Position_Reverse,
       const Reset_type& Reset,
       const Trace_Count_type& Trace_Count,
       const R_Initialize_type& R_Initialize,
       const Output_Mode_type& Output_Mode,
       ::std::auto_ptr< Position2_type >& Position2,
       const Integration_Limit_type& Integration_Limit,
       const R_Home_type& R_Home,
       const Error_type& Error,
       const R_Reset_Limit_Switch_type& R_Reset_Limit_Switch,
       const Settle_Window_3d_type& Settle_Window_3d,
       const Interrupt_Mask_type& Interrupt_Mask,
       const Scan_Move_Control_type& Scan_Move_Control,
       const Axis_Out_Source_type& Axis_Out_Source,
       const Trace_Stop_type& Trace_Stop,
       ::std::auto_ptr< Velocity_type >& Velocity,
       const R_Setup_type& R_Setup,
       const Buffer_Start_type& Buffer_Start,
       const Signal_Sense_type& Signal_Sense,
       ::std::auto_ptr< R_Scan_Move_type >& R_Scan_Move,
       ::std::auto_ptr< Position_Forward_type >& Position_Forward,
       const Derivative_Time_type& Derivative_Time,
       const Settle_Window_type& Settle_Window,
       const Trace_Variable1_type& Trace_Variable1,
       const Trace_Variable2_type& Trace_Variable2,
       const Buffer_Read_Index_type& Buffer_Read_Index,
       const Signal_Status_type& Signal_Status,
       const Alarm_Clear_type& Alarm_Clear,
       const Motion_Complete_Mode_type& Motion_Complete_Mode,
       const R_Setup_Abort_type& R_Setup_Abort,
       const Read_Buffer_type& Read_Buffer,
       const Kd_type& Kd,
       const Clear_Interrupt_type& Clear_Interrupt,
       const Profile_Mode_type& Profile_Mode,
       const R_Setup_Trace_type& R_Setup_Trace,
       const No_Operation_type& No_Operation,
       const Ki_type& Ki,
       const Sample_Time_type& Sample_Time)
: ::xml_schema::type (),
  Settle_Time_3d_ (Settle_Time_3d, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  R_Scan_Move_No_Wait_ (R_Scan_Move_No_Wait, ::xml_schema::flags (), this),
  Motor_Mode_ (Motor_Mode, ::xml_schema::flags (), this),
  Acceleration_ (Acceleration, ::xml_schema::flags (), this),
  Serial_Port_Mode_ (Serial_Port_Mode, ::xml_schema::flags (), this),
  Limit_Switch_Mode_ (Limit_Switch_Mode, ::xml_schema::flags (), this),
  Breakpoint_ (Breakpoint, ::xml_schema::flags (), this),
  Update_ (Update, ::xml_schema::flags (), this),
  Breakpoint_Value_ (Breakpoint_Value, ::xml_schema::flags (), this),
  V_Switch_Limit_ (V_Switch_Limit, ::xml_schema::flags (), this),
  R_Retrieve_Trace_ (R_Retrieve_Trace, ::xml_schema::flags (), this),
  Velocity_Stationary_ (Velocity_Stationary, ::xml_schema::flags (), this),
  Reset_Event_Status_ (Reset_Event_Status, ::xml_schema::flags (), this),
  Actual_Position_ (Actual_Position, ::xml_schema::flags (), this),
  Buffer_Length_ (Buffer_Length, ::xml_schema::flags (), this),
  Event_Status_ (Event_Status, ::xml_schema::flags (), this),
  R_Scan_Move2_ (R_Scan_Move2, ::xml_schema::flags (), this),
  Kp_ (Kp, ::xml_schema::flags (), this),
  R_Wait_Finish_Scan_Move_ (R_Wait_Finish_Scan_Move, ::xml_schema::flags (), this),
  Settle_Time_ (Settle_Time, ::xml_schema::flags (), this),
  Acceleration_Stationary_ (Acceleration_Stationary, ::xml_schema::flags (), this),
  Trace_Mode_ (Trace_Mode, ::xml_schema::flags (), this),
  Trace_Period_ (Trace_Period, ::xml_schema::flags (), this),
  Trace_Start_ (Trace_Start, ::xml_schema::flags (), this),
  Position_Reverse_ (Position_Reverse, ::xml_schema::flags (), this),
  Reset_ (Reset, ::xml_schema::flags (), this),
  Trace_Count_ (Trace_Count, ::xml_schema::flags (), this),
  R_Initialize_ (R_Initialize, ::xml_schema::flags (), this),
  Output_Mode_ (Output_Mode, ::xml_schema::flags (), this),
  Position2_ (Position2, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  R_Home_ (R_Home, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  R_Reset_Limit_Switch_ (R_Reset_Limit_Switch, ::xml_schema::flags (), this),
  Settle_Window_3d_ (Settle_Window_3d, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Scan_Move_Control_ (Scan_Move_Control, ::xml_schema::flags (), this),
  Axis_Out_Source_ (Axis_Out_Source, ::xml_schema::flags (), this),
  Trace_Stop_ (Trace_Stop, ::xml_schema::flags (), this),
  Velocity_ (Velocity, ::xml_schema::flags (), this),
  R_Setup_ (R_Setup, ::xml_schema::flags (), this),
  Buffer_Start_ (Buffer_Start, ::xml_schema::flags (), this),
  Signal_Sense_ (Signal_Sense, ::xml_schema::flags (), this),
  R_Scan_Move_ (R_Scan_Move, ::xml_schema::flags (), this),
  Position_Forward_ (Position_Forward, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Settle_Window_ (Settle_Window, ::xml_schema::flags (), this),
  Trace_Variable1_ (Trace_Variable1, ::xml_schema::flags (), this),
  Trace_Variable2_ (Trace_Variable2, ::xml_schema::flags (), this),
  Buffer_Read_Index_ (Buffer_Read_Index, ::xml_schema::flags (), this),
  Signal_Status_ (Signal_Status, ::xml_schema::flags (), this),
  Alarm_Clear_ (Alarm_Clear, ::xml_schema::flags (), this),
  Motion_Complete_Mode_ (Motion_Complete_Mode, ::xml_schema::flags (), this),
  R_Setup_Abort_ (R_Setup_Abort, ::xml_schema::flags (), this),
  Read_Buffer_ (Read_Buffer, ::xml_schema::flags (), this),
  Kd_ (Kd, ::xml_schema::flags (), this),
  Clear_Interrupt_ (Clear_Interrupt, ::xml_schema::flags (), this),
  Profile_Mode_ (Profile_Mode, ::xml_schema::flags (), this),
  R_Setup_Trace_ (R_Setup_Trace, ::xml_schema::flags (), this),
  No_Operation_ (No_Operation, ::xml_schema::flags (), this),
  Ki_ (Ki, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this)
{
}

Motor::
Motor (const Motor& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Settle_Time_3d_ (x.Settle_Time_3d_, f, this),
  Position_ (x.Position_, f, this),
  R_Scan_Move_No_Wait_ (x.R_Scan_Move_No_Wait_, f, this),
  Motor_Mode_ (x.Motor_Mode_, f, this),
  Acceleration_ (x.Acceleration_, f, this),
  Serial_Port_Mode_ (x.Serial_Port_Mode_, f, this),
  Limit_Switch_Mode_ (x.Limit_Switch_Mode_, f, this),
  Breakpoint_ (x.Breakpoint_, f, this),
  Update_ (x.Update_, f, this),
  Breakpoint_Value_ (x.Breakpoint_Value_, f, this),
  V_Switch_Limit_ (x.V_Switch_Limit_, f, this),
  R_Retrieve_Trace_ (x.R_Retrieve_Trace_, f, this),
  Velocity_Stationary_ (x.Velocity_Stationary_, f, this),
  Reset_Event_Status_ (x.Reset_Event_Status_, f, this),
  Actual_Position_ (x.Actual_Position_, f, this),
  Buffer_Length_ (x.Buffer_Length_, f, this),
  Event_Status_ (x.Event_Status_, f, this),
  R_Scan_Move2_ (x.R_Scan_Move2_, f, this),
  Kp_ (x.Kp_, f, this),
  R_Wait_Finish_Scan_Move_ (x.R_Wait_Finish_Scan_Move_, f, this),
  Settle_Time_ (x.Settle_Time_, f, this),
  Acceleration_Stationary_ (x.Acceleration_Stationary_, f, this),
  Trace_Mode_ (x.Trace_Mode_, f, this),
  Trace_Period_ (x.Trace_Period_, f, this),
  Trace_Start_ (x.Trace_Start_, f, this),
  Position_Reverse_ (x.Position_Reverse_, f, this),
  Reset_ (x.Reset_, f, this),
  Trace_Count_ (x.Trace_Count_, f, this),
  R_Initialize_ (x.R_Initialize_, f, this),
  Output_Mode_ (x.Output_Mode_, f, this),
  Position2_ (x.Position2_, f, this),
  Integration_Limit_ (x.Integration_Limit_, f, this),
  R_Home_ (x.R_Home_, f, this),
  Error_ (x.Error_, f, this),
  R_Reset_Limit_Switch_ (x.R_Reset_Limit_Switch_, f, this),
  Settle_Window_3d_ (x.Settle_Window_3d_, f, this),
  Interrupt_Mask_ (x.Interrupt_Mask_, f, this),
  Scan_Move_Control_ (x.Scan_Move_Control_, f, this),
  Axis_Out_Source_ (x.Axis_Out_Source_, f, this),
  Trace_Stop_ (x.Trace_Stop_, f, this),
  Velocity_ (x.Velocity_, f, this),
  R_Setup_ (x.R_Setup_, f, this),
  Buffer_Start_ (x.Buffer_Start_, f, this),
  Signal_Sense_ (x.Signal_Sense_, f, this),
  R_Scan_Move_ (x.R_Scan_Move_, f, this),
  Position_Forward_ (x.Position_Forward_, f, this),
  Derivative_Time_ (x.Derivative_Time_, f, this),
  Settle_Window_ (x.Settle_Window_, f, this),
  Trace_Variable1_ (x.Trace_Variable1_, f, this),
  Trace_Variable2_ (x.Trace_Variable2_, f, this),
  Buffer_Read_Index_ (x.Buffer_Read_Index_, f, this),
  Signal_Status_ (x.Signal_Status_, f, this),
  Alarm_Clear_ (x.Alarm_Clear_, f, this),
  Motion_Complete_Mode_ (x.Motion_Complete_Mode_, f, this),
  R_Setup_Abort_ (x.R_Setup_Abort_, f, this),
  Read_Buffer_ (x.Read_Buffer_, f, this),
  Kd_ (x.Kd_, f, this),
  Clear_Interrupt_ (x.Clear_Interrupt_, f, this),
  Profile_Mode_ (x.Profile_Mode_, f, this),
  R_Setup_Trace_ (x.R_Setup_Trace_, f, this),
  No_Operation_ (x.No_Operation_, f, this),
  Ki_ (x.Ki_, f, this),
  Sample_Time_ (x.Sample_Time_, f, this)
{
}

Motor::
Motor (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Settle_Time_3d_ (f, this),
  Position_ (f, this),
  R_Scan_Move_No_Wait_ (f, this),
  Motor_Mode_ (f, this),
  Acceleration_ (f, this),
  Serial_Port_Mode_ (f, this),
  Limit_Switch_Mode_ (f, this),
  Breakpoint_ (f, this),
  Update_ (f, this),
  Breakpoint_Value_ (f, this),
  V_Switch_Limit_ (f, this),
  R_Retrieve_Trace_ (f, this),
  Velocity_Stationary_ (f, this),
  Reset_Event_Status_ (f, this),
  Actual_Position_ (f, this),
  Buffer_Length_ (f, this),
  Event_Status_ (f, this),
  R_Scan_Move2_ (f, this),
  Kp_ (f, this),
  R_Wait_Finish_Scan_Move_ (f, this),
  Settle_Time_ (f, this),
  Acceleration_Stationary_ (f, this),
  Trace_Mode_ (f, this),
  Trace_Period_ (f, this),
  Trace_Start_ (f, this),
  Position_Reverse_ (f, this),
  Reset_ (f, this),
  Trace_Count_ (f, this),
  R_Initialize_ (f, this),
  Output_Mode_ (f, this),
  Position2_ (f, this),
  Integration_Limit_ (f, this),
  R_Home_ (f, this),
  Error_ (f, this),
  R_Reset_Limit_Switch_ (f, this),
  Settle_Window_3d_ (f, this),
  Interrupt_Mask_ (f, this),
  Scan_Move_Control_ (f, this),
  Axis_Out_Source_ (f, this),
  Trace_Stop_ (f, this),
  Velocity_ (f, this),
  R_Setup_ (f, this),
  Buffer_Start_ (f, this),
  Signal_Sense_ (f, this),
  R_Scan_Move_ (f, this),
  Position_Forward_ (f, this),
  Derivative_Time_ (f, this),
  Settle_Window_ (f, this),
  Trace_Variable1_ (f, this),
  Trace_Variable2_ (f, this),
  Buffer_Read_Index_ (f, this),
  Signal_Status_ (f, this),
  Alarm_Clear_ (f, this),
  Motion_Complete_Mode_ (f, this),
  R_Setup_Abort_ (f, this),
  Read_Buffer_ (f, this),
  Kd_ (f, this),
  Clear_Interrupt_ (f, this),
  Profile_Mode_ (f, this),
  R_Setup_Trace_ (f, this),
  No_Operation_ (f, this),
  Ki_ (f, this),
  Sample_Time_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Motor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Settle-Time-3d
    //
    if (n.name () == "Settle-Time-3d" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Time_3d_type > r (
        Settle_Time_3d_traits::create (i, f, this));

      if (!Settle_Time_3d_.present ())
      {
        this->Settle_Time_3d_.set (r);
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (r);
        continue;
      }
    }

    // R-Scan-Move-No-Wait
    //
    if (n.name () == "R-Scan-Move-No-Wait" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move_No_Wait_type > r (
        R_Scan_Move_No_Wait_traits::create (i, f, this));

      if (!R_Scan_Move_No_Wait_.present ())
      {
        this->R_Scan_Move_No_Wait_.set (r);
        continue;
      }
    }

    // Motor-Mode
    //
    if (n.name () == "Motor-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Mode_type > r (
        Motor_Mode_traits::create (i, f, this));

      if (!Motor_Mode_.present ())
      {
        this->Motor_Mode_.set (r);
        continue;
      }
    }

    // Acceleration
    //
    if (n.name () == "Acceleration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_type > r (
        Acceleration_traits::create (i, f, this));

      if (!Acceleration_.present ())
      {
        this->Acceleration_.set (r);
        continue;
      }
    }

    // Serial-Port-Mode
    //
    if (n.name () == "Serial-Port-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Serial_Port_Mode_type > r (
        Serial_Port_Mode_traits::create (i, f, this));

      if (!Serial_Port_Mode_.present ())
      {
        this->Serial_Port_Mode_.set (r);
        continue;
      }
    }

    // Limit-Switch-Mode
    //
    if (n.name () == "Limit-Switch-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Limit_Switch_Mode_type > r (
        Limit_Switch_Mode_traits::create (i, f, this));

      if (!Limit_Switch_Mode_.present ())
      {
        this->Limit_Switch_Mode_.set (r);
        continue;
      }
    }

    // Breakpoint
    //
    if (n.name () == "Breakpoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Breakpoint_type > r (
        Breakpoint_traits::create (i, f, this));

      if (!Breakpoint_.present ())
      {
        this->Breakpoint_.set (r);
        continue;
      }
    }

    // Update
    //
    if (n.name () == "Update" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Update_type > r (
        Update_traits::create (i, f, this));

      if (!Update_.present ())
      {
        this->Update_.set (r);
        continue;
      }
    }

    // Breakpoint-Value
    //
    if (n.name () == "Breakpoint-Value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Breakpoint_Value_type > r (
        Breakpoint_Value_traits::create (i, f, this));

      if (!Breakpoint_Value_.present ())
      {
        this->Breakpoint_Value_.set (r);
        continue;
      }
    }

    // V-Switch-Limit
    //
    if (n.name () == "V-Switch-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Switch_Limit_type > r (
        V_Switch_Limit_traits::create (i, f, this));

      if (!V_Switch_Limit_.present ())
      {
        this->V_Switch_Limit_.set (r);
        continue;
      }
    }

    // R-Retrieve-Trace
    //
    if (n.name () == "R-Retrieve-Trace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Retrieve_Trace_type > r (
        R_Retrieve_Trace_traits::create (i, f, this));

      if (!R_Retrieve_Trace_.present ())
      {
        this->R_Retrieve_Trace_.set (r);
        continue;
      }
    }

    // Velocity-Stationary
    //
    if (n.name () == "Velocity-Stationary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Velocity_Stationary_type > r (
        Velocity_Stationary_traits::create (i, f, this));

      if (!Velocity_Stationary_.present ())
      {
        this->Velocity_Stationary_.set (r);
        continue;
      }
    }

    // Reset-Event-Status
    //
    if (n.name () == "Reset-Event-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reset_Event_Status_type > r (
        Reset_Event_Status_traits::create (i, f, this));

      if (!Reset_Event_Status_.present ())
      {
        this->Reset_Event_Status_.set (r);
        continue;
      }
    }

    // Actual-Position
    //
    if (n.name () == "Actual-Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Actual_Position_type > r (
        Actual_Position_traits::create (i, f, this));

      if (!Actual_Position_.present ())
      {
        this->Actual_Position_.set (r);
        continue;
      }
    }

    // Buffer-Length
    //
    if (n.name () == "Buffer-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Length_type > r (
        Buffer_Length_traits::create (i, f, this));

      if (!Buffer_Length_.present ())
      {
        this->Buffer_Length_.set (r);
        continue;
      }
    }

    // Event-Status
    //
    if (n.name () == "Event-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Event_Status_type > r (
        Event_Status_traits::create (i, f, this));

      if (!Event_Status_.present ())
      {
        this->Event_Status_.set (r);
        continue;
      }
    }

    // R-Scan-Move2
    //
    if (n.name () == "R-Scan-Move2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move2_type > r (
        R_Scan_Move2_traits::create (i, f, this));

      if (!R_Scan_Move2_.present ())
      {
        this->R_Scan_Move2_.set (r);
        continue;
      }
    }

    // Kp
    //
    if (n.name () == "Kp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Kp_type > r (
        Kp_traits::create (i, f, this));

      if (!Kp_.present ())
      {
        this->Kp_.set (r);
        continue;
      }
    }

    // R-Wait-Finish-Scan-Move
    //
    if (n.name () == "R-Wait-Finish-Scan-Move" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Wait_Finish_Scan_Move_type > r (
        R_Wait_Finish_Scan_Move_traits::create (i, f, this));

      if (!R_Wait_Finish_Scan_Move_.present ())
      {
        this->R_Wait_Finish_Scan_Move_.set (r);
        continue;
      }
    }

    // Settle-Time
    //
    if (n.name () == "Settle-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Time_type > r (
        Settle_Time_traits::create (i, f, this));

      if (!Settle_Time_.present ())
      {
        this->Settle_Time_.set (r);
        continue;
      }
    }

    // Acceleration-Stationary
    //
    if (n.name () == "Acceleration-Stationary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Stationary_type > r (
        Acceleration_Stationary_traits::create (i, f, this));

      if (!Acceleration_Stationary_.present ())
      {
        this->Acceleration_Stationary_.set (r);
        continue;
      }
    }

    // Trace-Mode
    //
    if (n.name () == "Trace-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Mode_type > r (
        Trace_Mode_traits::create (i, f, this));

      if (!Trace_Mode_.present ())
      {
        this->Trace_Mode_.set (r);
        continue;
      }
    }

    // Trace-Period
    //
    if (n.name () == "Trace-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Period_type > r (
        Trace_Period_traits::create (i, f, this));

      if (!Trace_Period_.present ())
      {
        this->Trace_Period_.set (r);
        continue;
      }
    }

    // Trace-Start
    //
    if (n.name () == "Trace-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Start_type > r (
        Trace_Start_traits::create (i, f, this));

      if (!Trace_Start_.present ())
      {
        this->Trace_Start_.set (r);
        continue;
      }
    }

    // Position-Reverse
    //
    if (n.name () == "Position-Reverse" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Reverse_type > r (
        Position_Reverse_traits::create (i, f, this));

      if (!Position_Reverse_.present ())
      {
        this->Position_Reverse_.set (r);
        continue;
      }
    }

    // Reset
    //
    if (n.name () == "Reset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reset_type > r (
        Reset_traits::create (i, f, this));

      if (!Reset_.present ())
      {
        this->Reset_.set (r);
        continue;
      }
    }

    // Trace-Count
    //
    if (n.name () == "Trace-Count" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Count_type > r (
        Trace_Count_traits::create (i, f, this));

      if (!Trace_Count_.present ())
      {
        this->Trace_Count_.set (r);
        continue;
      }
    }

    // R-Initialize
    //
    if (n.name () == "R-Initialize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Initialize_type > r (
        R_Initialize_traits::create (i, f, this));

      if (!R_Initialize_.present ())
      {
        this->R_Initialize_.set (r);
        continue;
      }
    }

    // Output-Mode
    //
    if (n.name () == "Output-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Output_Mode_type > r (
        Output_Mode_traits::create (i, f, this));

      if (!Output_Mode_.present ())
      {
        this->Output_Mode_.set (r);
        continue;
      }
    }

    // Position2
    //
    if (n.name () == "Position2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position2_type > r (
        Position2_traits::create (i, f, this));

      if (!Position2_.present ())
      {
        this->Position2_.set (r);
        continue;
      }
    }

    // Integration-Limit
    //
    if (n.name () == "Integration-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Integration_Limit_type > r (
        Integration_Limit_traits::create (i, f, this));

      if (!Integration_Limit_.present ())
      {
        this->Integration_Limit_.set (r);
        continue;
      }
    }

    // R-Home
    //
    if (n.name () == "R-Home" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Home_type > r (
        R_Home_traits::create (i, f, this));

      if (!R_Home_.present ())
      {
        this->R_Home_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // R-Reset-Limit-Switch
    //
    if (n.name () == "R-Reset-Limit-Switch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Reset_Limit_Switch_type > r (
        R_Reset_Limit_Switch_traits::create (i, f, this));

      if (!R_Reset_Limit_Switch_.present ())
      {
        this->R_Reset_Limit_Switch_.set (r);
        continue;
      }
    }

    // Settle-Window-3d
    //
    if (n.name () == "Settle-Window-3d" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Window_3d_type > r (
        Settle_Window_3d_traits::create (i, f, this));

      if (!Settle_Window_3d_.present ())
      {
        this->Settle_Window_3d_.set (r);
        continue;
      }
    }

    // Interrupt-Mask
    //
    if (n.name () == "Interrupt-Mask" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Mask_type > r (
        Interrupt_Mask_traits::create (i, f, this));

      if (!Interrupt_Mask_.present ())
      {
        this->Interrupt_Mask_.set (r);
        continue;
      }
    }

    // Scan-Move-Control
    //
    if (n.name () == "Scan-Move-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Move_Control_type > r (
        Scan_Move_Control_traits::create (i, f, this));

      if (!Scan_Move_Control_.present ())
      {
        this->Scan_Move_Control_.set (r);
        continue;
      }
    }

    // Axis-Out-Source
    //
    if (n.name () == "Axis-Out-Source" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axis_Out_Source_type > r (
        Axis_Out_Source_traits::create (i, f, this));

      if (!Axis_Out_Source_.present ())
      {
        this->Axis_Out_Source_.set (r);
        continue;
      }
    }

    // Trace-Stop
    //
    if (n.name () == "Trace-Stop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Stop_type > r (
        Trace_Stop_traits::create (i, f, this));

      if (!Trace_Stop_.present ())
      {
        this->Trace_Stop_.set (r);
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (r);
        continue;
      }
    }

    // R-Setup
    //
    if (n.name () == "R-Setup" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_type > r (
        R_Setup_traits::create (i, f, this));

      if (!R_Setup_.present ())
      {
        this->R_Setup_.set (r);
        continue;
      }
    }

    // Buffer-Start
    //
    if (n.name () == "Buffer-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Start_type > r (
        Buffer_Start_traits::create (i, f, this));

      if (!Buffer_Start_.present ())
      {
        this->Buffer_Start_.set (r);
        continue;
      }
    }

    // Signal-Sense
    //
    if (n.name () == "Signal-Sense" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Signal_Sense_type > r (
        Signal_Sense_traits::create (i, f, this));

      if (!Signal_Sense_.present ())
      {
        this->Signal_Sense_.set (r);
        continue;
      }
    }

    // R-Scan-Move
    //
    if (n.name () == "R-Scan-Move" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move_type > r (
        R_Scan_Move_traits::create (i, f, this));

      if (!R_Scan_Move_.present ())
      {
        this->R_Scan_Move_.set (r);
        continue;
      }
    }

    // Position-Forward
    //
    if (n.name () == "Position-Forward" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Forward_type > r (
        Position_Forward_traits::create (i, f, this));

      if (!Position_Forward_.present ())
      {
        this->Position_Forward_.set (r);
        continue;
      }
    }

    // Derivative-Time
    //
    if (n.name () == "Derivative-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Derivative_Time_type > r (
        Derivative_Time_traits::create (i, f, this));

      if (!Derivative_Time_.present ())
      {
        this->Derivative_Time_.set (r);
        continue;
      }
    }

    // Settle-Window
    //
    if (n.name () == "Settle-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Window_type > r (
        Settle_Window_traits::create (i, f, this));

      if (!Settle_Window_.present ())
      {
        this->Settle_Window_.set (r);
        continue;
      }
    }

    // Trace-Variable1
    //
    if (n.name () == "Trace-Variable1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Variable1_type > r (
        Trace_Variable1_traits::create (i, f, this));

      if (!Trace_Variable1_.present ())
      {
        this->Trace_Variable1_.set (r);
        continue;
      }
    }

    // Trace-Variable2
    //
    if (n.name () == "Trace-Variable2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Variable2_type > r (
        Trace_Variable2_traits::create (i, f, this));

      if (!Trace_Variable2_.present ())
      {
        this->Trace_Variable2_.set (r);
        continue;
      }
    }

    // Buffer-Read-Index
    //
    if (n.name () == "Buffer-Read-Index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Read_Index_type > r (
        Buffer_Read_Index_traits::create (i, f, this));

      if (!Buffer_Read_Index_.present ())
      {
        this->Buffer_Read_Index_.set (r);
        continue;
      }
    }

    // Signal-Status
    //
    if (n.name () == "Signal-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Signal_Status_type > r (
        Signal_Status_traits::create (i, f, this));

      if (!Signal_Status_.present ())
      {
        this->Signal_Status_.set (r);
        continue;
      }
    }

    // Alarm-Clear
    //
    if (n.name () == "Alarm-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Alarm_Clear_type > r (
        Alarm_Clear_traits::create (i, f, this));

      if (!Alarm_Clear_.present ())
      {
        this->Alarm_Clear_.set (r);
        continue;
      }
    }

    // Motion-Complete-Mode
    //
    if (n.name () == "Motion-Complete-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motion_Complete_Mode_type > r (
        Motion_Complete_Mode_traits::create (i, f, this));

      if (!Motion_Complete_Mode_.present ())
      {
        this->Motion_Complete_Mode_.set (r);
        continue;
      }
    }

    // R-Setup-Abort
    //
    if (n.name () == "R-Setup-Abort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_Abort_type > r (
        R_Setup_Abort_traits::create (i, f, this));

      if (!R_Setup_Abort_.present ())
      {
        this->R_Setup_Abort_.set (r);
        continue;
      }
    }

    // Read-Buffer
    //
    if (n.name () == "Read-Buffer" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Read_Buffer_type > r (
        Read_Buffer_traits::create (i, f, this));

      if (!Read_Buffer_.present ())
      {
        this->Read_Buffer_.set (r);
        continue;
      }
    }

    // Kd
    //
    if (n.name () == "Kd" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Kd_type > r (
        Kd_traits::create (i, f, this));

      if (!Kd_.present ())
      {
        this->Kd_.set (r);
        continue;
      }
    }

    // Clear-Interrupt
    //
    if (n.name () == "Clear-Interrupt" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Clear_Interrupt_type > r (
        Clear_Interrupt_traits::create (i, f, this));

      if (!Clear_Interrupt_.present ())
      {
        this->Clear_Interrupt_.set (r);
        continue;
      }
    }

    // Profile-Mode
    //
    if (n.name () == "Profile-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Profile_Mode_type > r (
        Profile_Mode_traits::create (i, f, this));

      if (!Profile_Mode_.present ())
      {
        this->Profile_Mode_.set (r);
        continue;
      }
    }

    // R-Setup-Trace
    //
    if (n.name () == "R-Setup-Trace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_Trace_type > r (
        R_Setup_Trace_traits::create (i, f, this));

      if (!R_Setup_Trace_.present ())
      {
        this->R_Setup_Trace_.set (r);
        continue;
      }
    }

    // No-Operation
    //
    if (n.name () == "No-Operation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< No_Operation_type > r (
        No_Operation_traits::create (i, f, this));

      if (!No_Operation_.present ())
      {
        this->No_Operation_.set (r);
        continue;
      }
    }

    // Ki
    //
    if (n.name () == "Ki" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ki_type > r (
        Ki_traits::create (i, f, this));

      if (!Ki_.present ())
      {
        this->Ki_.set (r);
        continue;
      }
    }

    // Sample-Time
    //
    if (n.name () == "Sample-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sample_Time_type > r (
        Sample_Time_traits::create (i, f, this));

      if (!Sample_Time_.present ())
      {
        this->Sample_Time_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Settle_Time_3d_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Time-3d",
      "");
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!R_Scan_Move_No_Wait_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move-No-Wait",
      "");
  }

  if (!Motor_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Mode",
      "");
  }

  if (!Acceleration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration",
      "");
  }

  if (!Serial_Port_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Serial-Port-Mode",
      "");
  }

  if (!Limit_Switch_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Limit-Switch-Mode",
      "");
  }

  if (!Breakpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Breakpoint",
      "");
  }

  if (!Update_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Update",
      "");
  }

  if (!Breakpoint_Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Breakpoint-Value",
      "");
  }

  if (!V_Switch_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Switch-Limit",
      "");
  }

  if (!R_Retrieve_Trace_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Retrieve-Trace",
      "");
  }

  if (!Velocity_Stationary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity-Stationary",
      "");
  }

  if (!Reset_Event_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reset-Event-Status",
      "");
  }

  if (!Actual_Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Actual-Position",
      "");
  }

  if (!Buffer_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Length",
      "");
  }

  if (!Event_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Event-Status",
      "");
  }

  if (!R_Scan_Move2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move2",
      "");
  }

  if (!Kp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Kp",
      "");
  }

  if (!R_Wait_Finish_Scan_Move_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Wait-Finish-Scan-Move",
      "");
  }

  if (!Settle_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Time",
      "");
  }

  if (!Acceleration_Stationary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Stationary",
      "");
  }

  if (!Trace_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Mode",
      "");
  }

  if (!Trace_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Period",
      "");
  }

  if (!Trace_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Start",
      "");
  }

  if (!Position_Reverse_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Reverse",
      "");
  }

  if (!Reset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reset",
      "");
  }

  if (!Trace_Count_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Count",
      "");
  }

  if (!R_Initialize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Initialize",
      "");
  }

  if (!Output_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Output-Mode",
      "");
  }

  if (!Position2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position2",
      "");
  }

  if (!Integration_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Integration-Limit",
      "");
  }

  if (!R_Home_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Home",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!R_Reset_Limit_Switch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Reset-Limit-Switch",
      "");
  }

  if (!Settle_Window_3d_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Window-3d",
      "");
  }

  if (!Interrupt_Mask_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Mask",
      "");
  }

  if (!Scan_Move_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Move-Control",
      "");
  }

  if (!Axis_Out_Source_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axis-Out-Source",
      "");
  }

  if (!Trace_Stop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Stop",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  if (!R_Setup_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup",
      "");
  }

  if (!Buffer_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Start",
      "");
  }

  if (!Signal_Sense_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Signal-Sense",
      "");
  }

  if (!R_Scan_Move_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move",
      "");
  }

  if (!Position_Forward_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Forward",
      "");
  }

  if (!Derivative_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Derivative-Time",
      "");
  }

  if (!Settle_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Window",
      "");
  }

  if (!Trace_Variable1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Variable1",
      "");
  }

  if (!Trace_Variable2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Variable2",
      "");
  }

  if (!Buffer_Read_Index_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Read-Index",
      "");
  }

  if (!Signal_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Signal-Status",
      "");
  }

  if (!Alarm_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Alarm-Clear",
      "");
  }

  if (!Motion_Complete_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motion-Complete-Mode",
      "");
  }

  if (!R_Setup_Abort_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup-Abort",
      "");
  }

  if (!Read_Buffer_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Read-Buffer",
      "");
  }

  if (!Kd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Kd",
      "");
  }

  if (!Clear_Interrupt_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Clear-Interrupt",
      "");
  }

  if (!Profile_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Profile-Mode",
      "");
  }

  if (!R_Setup_Trace_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup-Trace",
      "");
  }

  if (!No_Operation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "No-Operation",
      "");
  }

  if (!Ki_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ki",
      "");
  }

  if (!Sample_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sample-Time",
      "");
  }
}

Motor* Motor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Motor (*this, f, c);
}

Motor::
~Motor ()
{
}

// Diag
//

Diag::
Diag (const Mem_Pagefile_type& Mem_Pagefile,
      const Monitor_3point3V_type& Monitor_3point3V,
      const USER_Objects_type& USER_Objects,
      const Motor_FPGA_Revision_type& Motor_FPGA_Revision,
      const Product_Name_type& Product_Name,
      const Build_Version_type& Build_Version,
      const ICB_PCB_ID_type& ICB_PCB_ID,
      const Software_Version_type& Software_Version,
      const Receive_PCB_ID_type& Receive_PCB_ID,
      const Receive_FPGA_Revision_type& Receive_FPGA_Revision,
      const Monitor_15V_type& Monitor_15V,
      const ICB_FPGA_Revision_type& ICB_FPGA_Revision,
      const GDI_Objects_type& GDI_Objects,
      const Mem_WorkingSet_type& Mem_WorkingSet,
      const Mem_Private_type& Mem_Private,
      const Switch_PCB_ID_type& Switch_PCB_ID,
      const Monitor_5V_type& Monitor_5V,
      const Motor_PCB_Revision_type& Motor_PCB_Revision,
      const NE1619_type& NE1619,
      const Motor_PCB_ID_type& Motor_PCB_ID,
      const Transmit_PCB_Revision_type& Transmit_PCB_Revision,
      const MAX1137_type& MAX1137,
      const Monitor_Neg15V_type& Monitor_Neg15V,
      const Monitor_Neg5V_type& Monitor_Neg5V,
      const Switch_PCB_Revision_type& Switch_PCB_Revision,
      const Receive_PCB_Revision_type& Receive_PCB_Revision,
      const ICB_PCB_Revision_type& ICB_PCB_Revision,
      const Transmit_PCB_ID_type& Transmit_PCB_ID,
      const Monitor_Temperature_type& Monitor_Temperature)
: ::xml_schema::type (),
  Mem_Pagefile_ (Mem_Pagefile, ::xml_schema::flags (), this),
  Monitor_3point3V_ (Monitor_3point3V, ::xml_schema::flags (), this),
  USER_Objects_ (USER_Objects, ::xml_schema::flags (), this),
  Motor_FPGA_Revision_ (Motor_FPGA_Revision, ::xml_schema::flags (), this),
  Product_Name_ (Product_Name, ::xml_schema::flags (), this),
  Build_Version_ (Build_Version, ::xml_schema::flags (), this),
  ICB_PCB_ID_ (ICB_PCB_ID, ::xml_schema::flags (), this),
  Software_Version_ (Software_Version, ::xml_schema::flags (), this),
  Receive_PCB_ID_ (Receive_PCB_ID, ::xml_schema::flags (), this),
  Receive_FPGA_Revision_ (Receive_FPGA_Revision, ::xml_schema::flags (), this),
  Monitor_15V_ (Monitor_15V, ::xml_schema::flags (), this),
  ICB_FPGA_Revision_ (ICB_FPGA_Revision, ::xml_schema::flags (), this),
  GDI_Objects_ (GDI_Objects, ::xml_schema::flags (), this),
  Mem_WorkingSet_ (Mem_WorkingSet, ::xml_schema::flags (), this),
  Mem_Private_ (Mem_Private, ::xml_schema::flags (), this),
  Switch_PCB_ID_ (Switch_PCB_ID, ::xml_schema::flags (), this),
  Monitor_5V_ (Monitor_5V, ::xml_schema::flags (), this),
  Motor_PCB_Revision_ (Motor_PCB_Revision, ::xml_schema::flags (), this),
  NE1619_ (NE1619, ::xml_schema::flags (), this),
  Motor_PCB_ID_ (Motor_PCB_ID, ::xml_schema::flags (), this),
  Transmit_PCB_Revision_ (Transmit_PCB_Revision, ::xml_schema::flags (), this),
  MAX1137_ (MAX1137, ::xml_schema::flags (), this),
  Monitor_Neg15V_ (Monitor_Neg15V, ::xml_schema::flags (), this),
  Monitor_Neg5V_ (Monitor_Neg5V, ::xml_schema::flags (), this),
  Switch_PCB_Revision_ (Switch_PCB_Revision, ::xml_schema::flags (), this),
  Receive_PCB_Revision_ (Receive_PCB_Revision, ::xml_schema::flags (), this),
  ICB_PCB_Revision_ (ICB_PCB_Revision, ::xml_schema::flags (), this),
  Transmit_PCB_ID_ (Transmit_PCB_ID, ::xml_schema::flags (), this),
  Monitor_Temperature_ (Monitor_Temperature, ::xml_schema::flags (), this)
{
}

Diag::
Diag (const Mem_Pagefile_type& Mem_Pagefile,
      ::std::auto_ptr< Monitor_3point3V_type >& Monitor_3point3V,
      const USER_Objects_type& USER_Objects,
      const Motor_FPGA_Revision_type& Motor_FPGA_Revision,
      const Product_Name_type& Product_Name,
      const Build_Version_type& Build_Version,
      const ICB_PCB_ID_type& ICB_PCB_ID,
      const Software_Version_type& Software_Version,
      const Receive_PCB_ID_type& Receive_PCB_ID,
      const Receive_FPGA_Revision_type& Receive_FPGA_Revision,
      ::std::auto_ptr< Monitor_15V_type >& Monitor_15V,
      const ICB_FPGA_Revision_type& ICB_FPGA_Revision,
      const GDI_Objects_type& GDI_Objects,
      const Mem_WorkingSet_type& Mem_WorkingSet,
      const Mem_Private_type& Mem_Private,
      const Switch_PCB_ID_type& Switch_PCB_ID,
      ::std::auto_ptr< Monitor_5V_type >& Monitor_5V,
      const Motor_PCB_Revision_type& Motor_PCB_Revision,
      const NE1619_type& NE1619,
      const Motor_PCB_ID_type& Motor_PCB_ID,
      const Transmit_PCB_Revision_type& Transmit_PCB_Revision,
      const MAX1137_type& MAX1137,
      ::std::auto_ptr< Monitor_Neg15V_type >& Monitor_Neg15V,
      ::std::auto_ptr< Monitor_Neg5V_type >& Monitor_Neg5V,
      const Switch_PCB_Revision_type& Switch_PCB_Revision,
      const Receive_PCB_Revision_type& Receive_PCB_Revision,
      const ICB_PCB_Revision_type& ICB_PCB_Revision,
      const Transmit_PCB_ID_type& Transmit_PCB_ID,
      const Monitor_Temperature_type& Monitor_Temperature)
: ::xml_schema::type (),
  Mem_Pagefile_ (Mem_Pagefile, ::xml_schema::flags (), this),
  Monitor_3point3V_ (Monitor_3point3V, ::xml_schema::flags (), this),
  USER_Objects_ (USER_Objects, ::xml_schema::flags (), this),
  Motor_FPGA_Revision_ (Motor_FPGA_Revision, ::xml_schema::flags (), this),
  Product_Name_ (Product_Name, ::xml_schema::flags (), this),
  Build_Version_ (Build_Version, ::xml_schema::flags (), this),
  ICB_PCB_ID_ (ICB_PCB_ID, ::xml_schema::flags (), this),
  Software_Version_ (Software_Version, ::xml_schema::flags (), this),
  Receive_PCB_ID_ (Receive_PCB_ID, ::xml_schema::flags (), this),
  Receive_FPGA_Revision_ (Receive_FPGA_Revision, ::xml_schema::flags (), this),
  Monitor_15V_ (Monitor_15V, ::xml_schema::flags (), this),
  ICB_FPGA_Revision_ (ICB_FPGA_Revision, ::xml_schema::flags (), this),
  GDI_Objects_ (GDI_Objects, ::xml_schema::flags (), this),
  Mem_WorkingSet_ (Mem_WorkingSet, ::xml_schema::flags (), this),
  Mem_Private_ (Mem_Private, ::xml_schema::flags (), this),
  Switch_PCB_ID_ (Switch_PCB_ID, ::xml_schema::flags (), this),
  Monitor_5V_ (Monitor_5V, ::xml_schema::flags (), this),
  Motor_PCB_Revision_ (Motor_PCB_Revision, ::xml_schema::flags (), this),
  NE1619_ (NE1619, ::xml_schema::flags (), this),
  Motor_PCB_ID_ (Motor_PCB_ID, ::xml_schema::flags (), this),
  Transmit_PCB_Revision_ (Transmit_PCB_Revision, ::xml_schema::flags (), this),
  MAX1137_ (MAX1137, ::xml_schema::flags (), this),
  Monitor_Neg15V_ (Monitor_Neg15V, ::xml_schema::flags (), this),
  Monitor_Neg5V_ (Monitor_Neg5V, ::xml_schema::flags (), this),
  Switch_PCB_Revision_ (Switch_PCB_Revision, ::xml_schema::flags (), this),
  Receive_PCB_Revision_ (Receive_PCB_Revision, ::xml_schema::flags (), this),
  ICB_PCB_Revision_ (ICB_PCB_Revision, ::xml_schema::flags (), this),
  Transmit_PCB_ID_ (Transmit_PCB_ID, ::xml_schema::flags (), this),
  Monitor_Temperature_ (Monitor_Temperature, ::xml_schema::flags (), this)
{
}

Diag::
Diag (const Diag& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Mem_Pagefile_ (x.Mem_Pagefile_, f, this),
  Monitor_3point3V_ (x.Monitor_3point3V_, f, this),
  USER_Objects_ (x.USER_Objects_, f, this),
  Motor_FPGA_Revision_ (x.Motor_FPGA_Revision_, f, this),
  Product_Name_ (x.Product_Name_, f, this),
  Build_Version_ (x.Build_Version_, f, this),
  ICB_PCB_ID_ (x.ICB_PCB_ID_, f, this),
  Software_Version_ (x.Software_Version_, f, this),
  Receive_PCB_ID_ (x.Receive_PCB_ID_, f, this),
  Receive_FPGA_Revision_ (x.Receive_FPGA_Revision_, f, this),
  Monitor_15V_ (x.Monitor_15V_, f, this),
  ICB_FPGA_Revision_ (x.ICB_FPGA_Revision_, f, this),
  GDI_Objects_ (x.GDI_Objects_, f, this),
  Mem_WorkingSet_ (x.Mem_WorkingSet_, f, this),
  Mem_Private_ (x.Mem_Private_, f, this),
  Switch_PCB_ID_ (x.Switch_PCB_ID_, f, this),
  Monitor_5V_ (x.Monitor_5V_, f, this),
  Motor_PCB_Revision_ (x.Motor_PCB_Revision_, f, this),
  NE1619_ (x.NE1619_, f, this),
  Motor_PCB_ID_ (x.Motor_PCB_ID_, f, this),
  Transmit_PCB_Revision_ (x.Transmit_PCB_Revision_, f, this),
  MAX1137_ (x.MAX1137_, f, this),
  Monitor_Neg15V_ (x.Monitor_Neg15V_, f, this),
  Monitor_Neg5V_ (x.Monitor_Neg5V_, f, this),
  Switch_PCB_Revision_ (x.Switch_PCB_Revision_, f, this),
  Receive_PCB_Revision_ (x.Receive_PCB_Revision_, f, this),
  ICB_PCB_Revision_ (x.ICB_PCB_Revision_, f, this),
  Transmit_PCB_ID_ (x.Transmit_PCB_ID_, f, this),
  Monitor_Temperature_ (x.Monitor_Temperature_, f, this)
{
}

Diag::
Diag (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Mem_Pagefile_ (f, this),
  Monitor_3point3V_ (f, this),
  USER_Objects_ (f, this),
  Motor_FPGA_Revision_ (f, this),
  Product_Name_ (f, this),
  Build_Version_ (f, this),
  ICB_PCB_ID_ (f, this),
  Software_Version_ (f, this),
  Receive_PCB_ID_ (f, this),
  Receive_FPGA_Revision_ (f, this),
  Monitor_15V_ (f, this),
  ICB_FPGA_Revision_ (f, this),
  GDI_Objects_ (f, this),
  Mem_WorkingSet_ (f, this),
  Mem_Private_ (f, this),
  Switch_PCB_ID_ (f, this),
  Monitor_5V_ (f, this),
  Motor_PCB_Revision_ (f, this),
  NE1619_ (f, this),
  Motor_PCB_ID_ (f, this),
  Transmit_PCB_Revision_ (f, this),
  MAX1137_ (f, this),
  Monitor_Neg15V_ (f, this),
  Monitor_Neg5V_ (f, this),
  Switch_PCB_Revision_ (f, this),
  Receive_PCB_Revision_ (f, this),
  ICB_PCB_Revision_ (f, this),
  Transmit_PCB_ID_ (f, this),
  Monitor_Temperature_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Diag::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Mem-Pagefile
    //
    if (n.name () == "Mem-Pagefile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_Pagefile_type > r (
        Mem_Pagefile_traits::create (i, f, this));

      if (!Mem_Pagefile_.present ())
      {
        this->Mem_Pagefile_.set (r);
        continue;
      }
    }

    // Monitor-3point3V
    //
    if (n.name () == "Monitor-3point3V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_3point3V_type > r (
        Monitor_3point3V_traits::create (i, f, this));

      if (!Monitor_3point3V_.present ())
      {
        this->Monitor_3point3V_.set (r);
        continue;
      }
    }

    // USER-Objects
    //
    if (n.name () == "USER-Objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USER_Objects_type > r (
        USER_Objects_traits::create (i, f, this));

      if (!USER_Objects_.present ())
      {
        this->USER_Objects_.set (r);
        continue;
      }
    }

    // Motor-FPGA-Revision
    //
    if (n.name () == "Motor-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_FPGA_Revision_type > r (
        Motor_FPGA_Revision_traits::create (i, f, this));

      if (!Motor_FPGA_Revision_.present ())
      {
        this->Motor_FPGA_Revision_.set (r);
        continue;
      }
    }

    // Product-Name
    //
    if (n.name () == "Product-Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Product_Name_type > r (
        Product_Name_traits::create (i, f, this));

      if (!Product_Name_.present ())
      {
        this->Product_Name_.set (r);
        continue;
      }
    }

    // Build-Version
    //
    if (n.name () == "Build-Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Build_Version_type > r (
        Build_Version_traits::create (i, f, this));

      if (!Build_Version_.present ())
      {
        this->Build_Version_.set (r);
        continue;
      }
    }

    // ICB-PCB-ID
    //
    if (n.name () == "ICB-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_PCB_ID_type > r (
        ICB_PCB_ID_traits::create (i, f, this));

      if (!ICB_PCB_ID_.present ())
      {
        this->ICB_PCB_ID_.set (r);
        continue;
      }
    }

    // Software-Version
    //
    if (n.name () == "Software-Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Software_Version_type > r (
        Software_Version_traits::create (i, f, this));

      if (!Software_Version_.present ())
      {
        this->Software_Version_.set (r);
        continue;
      }
    }

    // Receive-PCB-ID
    //
    if (n.name () == "Receive-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_PCB_ID_type > r (
        Receive_PCB_ID_traits::create (i, f, this));

      if (!Receive_PCB_ID_.present ())
      {
        this->Receive_PCB_ID_.set (r);
        continue;
      }
    }

    // Receive-FPGA-Revision
    //
    if (n.name () == "Receive-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_FPGA_Revision_type > r (
        Receive_FPGA_Revision_traits::create (i, f, this));

      if (!Receive_FPGA_Revision_.present ())
      {
        this->Receive_FPGA_Revision_.set (r);
        continue;
      }
    }

    // Monitor-15V
    //
    if (n.name () == "Monitor-15V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_15V_type > r (
        Monitor_15V_traits::create (i, f, this));

      if (!Monitor_15V_.present ())
      {
        this->Monitor_15V_.set (r);
        continue;
      }
    }

    // ICB-FPGA-Revision
    //
    if (n.name () == "ICB-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_FPGA_Revision_type > r (
        ICB_FPGA_Revision_traits::create (i, f, this));

      if (!ICB_FPGA_Revision_.present ())
      {
        this->ICB_FPGA_Revision_.set (r);
        continue;
      }
    }

    // GDI-Objects
    //
    if (n.name () == "GDI-Objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< GDI_Objects_type > r (
        GDI_Objects_traits::create (i, f, this));

      if (!GDI_Objects_.present ())
      {
        this->GDI_Objects_.set (r);
        continue;
      }
    }

    // Mem-WorkingSet
    //
    if (n.name () == "Mem-WorkingSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_WorkingSet_type > r (
        Mem_WorkingSet_traits::create (i, f, this));

      if (!Mem_WorkingSet_.present ())
      {
        this->Mem_WorkingSet_.set (r);
        continue;
      }
    }

    // Mem-Private
    //
    if (n.name () == "Mem-Private" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_Private_type > r (
        Mem_Private_traits::create (i, f, this));

      if (!Mem_Private_.present ())
      {
        this->Mem_Private_.set (r);
        continue;
      }
    }

    // Switch-PCB-ID
    //
    if (n.name () == "Switch-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Switch_PCB_ID_type > r (
        Switch_PCB_ID_traits::create (i, f, this));

      if (!Switch_PCB_ID_.present ())
      {
        this->Switch_PCB_ID_.set (r);
        continue;
      }
    }

    // Monitor-5V
    //
    if (n.name () == "Monitor-5V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_5V_type > r (
        Monitor_5V_traits::create (i, f, this));

      if (!Monitor_5V_.present ())
      {
        this->Monitor_5V_.set (r);
        continue;
      }
    }

    // Motor-PCB-Revision
    //
    if (n.name () == "Motor-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_PCB_Revision_type > r (
        Motor_PCB_Revision_traits::create (i, f, this));

      if (!Motor_PCB_Revision_.present ())
      {
        this->Motor_PCB_Revision_.set (r);
        continue;
      }
    }

    // NE1619
    //
    if (n.name () == "NE1619" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NE1619_type > r (
        NE1619_traits::create (i, f, this));

      if (!NE1619_.present ())
      {
        this->NE1619_.set (r);
        continue;
      }
    }

    // Motor-PCB-ID
    //
    if (n.name () == "Motor-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_PCB_ID_type > r (
        Motor_PCB_ID_traits::create (i, f, this));

      if (!Motor_PCB_ID_.present ())
      {
        this->Motor_PCB_ID_.set (r);
        continue;
      }
    }

    // Transmit-PCB-Revision
    //
    if (n.name () == "Transmit-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Transmit_PCB_Revision_type > r (
        Transmit_PCB_Revision_traits::create (i, f, this));

      if (!Transmit_PCB_Revision_.present ())
      {
        this->Transmit_PCB_Revision_.set (r);
        continue;
      }
    }

    // MAX1137
    //
    if (n.name () == "MAX1137" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MAX1137_type > r (
        MAX1137_traits::create (i, f, this));

      if (!MAX1137_.present ())
      {
        this->MAX1137_.set (r);
        continue;
      }
    }

    // Monitor-Neg15V
    //
    if (n.name () == "Monitor-Neg15V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Neg15V_type > r (
        Monitor_Neg15V_traits::create (i, f, this));

      if (!Monitor_Neg15V_.present ())
      {
        this->Monitor_Neg15V_.set (r);
        continue;
      }
    }

    // Monitor-Neg5V
    //
    if (n.name () == "Monitor-Neg5V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Neg5V_type > r (
        Monitor_Neg5V_traits::create (i, f, this));

      if (!Monitor_Neg5V_.present ())
      {
        this->Monitor_Neg5V_.set (r);
        continue;
      }
    }

    // Switch-PCB-Revision
    //
    if (n.name () == "Switch-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Switch_PCB_Revision_type > r (
        Switch_PCB_Revision_traits::create (i, f, this));

      if (!Switch_PCB_Revision_.present ())
      {
        this->Switch_PCB_Revision_.set (r);
        continue;
      }
    }

    // Receive-PCB-Revision
    //
    if (n.name () == "Receive-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_PCB_Revision_type > r (
        Receive_PCB_Revision_traits::create (i, f, this));

      if (!Receive_PCB_Revision_.present ())
      {
        this->Receive_PCB_Revision_.set (r);
        continue;
      }
    }

    // ICB-PCB-Revision
    //
    if (n.name () == "ICB-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_PCB_Revision_type > r (
        ICB_PCB_Revision_traits::create (i, f, this));

      if (!ICB_PCB_Revision_.present ())
      {
        this->ICB_PCB_Revision_.set (r);
        continue;
      }
    }

    // Transmit-PCB-ID
    //
    if (n.name () == "Transmit-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Transmit_PCB_ID_type > r (
        Transmit_PCB_ID_traits::create (i, f, this));

      if (!Transmit_PCB_ID_.present ())
      {
        this->Transmit_PCB_ID_.set (r);
        continue;
      }
    }

    // Monitor-Temperature
    //
    if (n.name () == "Monitor-Temperature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Temperature_type > r (
        Monitor_Temperature_traits::create (i, f, this));

      if (!Monitor_Temperature_.present ())
      {
        this->Monitor_Temperature_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Mem_Pagefile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-Pagefile",
      "");
  }

  if (!Monitor_3point3V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-3point3V",
      "");
  }

  if (!USER_Objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "USER-Objects",
      "");
  }

  if (!Motor_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-FPGA-Revision",
      "");
  }

  if (!Product_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Product-Name",
      "");
  }

  if (!Build_Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Build-Version",
      "");
  }

  if (!ICB_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-PCB-ID",
      "");
  }

  if (!Software_Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Software-Version",
      "");
  }

  if (!Receive_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-PCB-ID",
      "");
  }

  if (!Receive_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-FPGA-Revision",
      "");
  }

  if (!Monitor_15V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-15V",
      "");
  }

  if (!ICB_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-FPGA-Revision",
      "");
  }

  if (!GDI_Objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GDI-Objects",
      "");
  }

  if (!Mem_WorkingSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-WorkingSet",
      "");
  }

  if (!Mem_Private_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-Private",
      "");
  }

  if (!Switch_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Switch-PCB-ID",
      "");
  }

  if (!Monitor_5V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-5V",
      "");
  }

  if (!Motor_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-PCB-Revision",
      "");
  }

  if (!NE1619_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NE1619",
      "");
  }

  if (!Motor_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-PCB-ID",
      "");
  }

  if (!Transmit_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Transmit-PCB-Revision",
      "");
  }

  if (!MAX1137_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MAX1137",
      "");
  }

  if (!Monitor_Neg15V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Neg15V",
      "");
  }

  if (!Monitor_Neg5V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Neg5V",
      "");
  }

  if (!Switch_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Switch-PCB-Revision",
      "");
  }

  if (!Receive_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-PCB-Revision",
      "");
  }

  if (!ICB_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-PCB-Revision",
      "");
  }

  if (!Transmit_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Transmit-PCB-ID",
      "");
  }

  if (!Monitor_Temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Temperature",
      "");
  }
}

Diag* Diag::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Diag (*this, f, c);
}

Diag::
~Diag ()
{
}

// ECG
//

ECG::
ECG (const Respiration_Threshold_Change_type& Respiration_Threshold_Change,
     const Respiration_Threshold_type& Respiration_Threshold,
     const Pressure_Range_type& Pressure_Range,
     const Respiration_Gate_Delay_type& Respiration_Gate_Delay,
     const Respiration_Timeout_type& Respiration_Timeout,
     const RWave_Max_Change_Factor_Percent_type& RWave_Max_Change_Factor_Percent,
     const Respiration_Period_type& Respiration_Period,
     const Respiration_Subsample_Rate_type& Respiration_Subsample_Rate,
     const Show_RWaves_type& Show_RWaves,
     const Respiration_Minimal_Peak_2_Peak_type& Respiration_Minimal_Peak_2_Peak,
     const Respiration_Window_type& Respiration_Window,
     const Pressure_Zeroed_type& Pressure_Zeroed,
     const Pressure_Systolic_type& Pressure_Systolic,
     const Respiration_Show_Window_type& Respiration_Show_Window,
     const Frequency_type& Frequency,
     const Respiration_Blank_Period_type& Respiration_Blank_Period,
     const Respiration_Range_type& Respiration_Range,
     const Pressure_Zero_type& Pressure_Zero,
     const Temperature_Amplification_type& Temperature_Amplification,
     const P_Wave_Start_type& P_Wave_Start,
     const ECG_Filter_Taps_type& ECG_Filter_Taps,
     const RWave_Future_Search_Time_type& RWave_Future_Search_Time,
     const Respiration_Percent_Peak_type& Respiration_Percent_Peak,
     const T_Wave_Start_type& T_Wave_Start,
     const Strain_Rate_RR_Diff_Ratio_type& Strain_Rate_RR_Diff_Ratio,
     const Pressure_Calibration_Min_Level_type& Pressure_Calibration_Min_Level,
     const Pressure_Calibrated_type& Pressure_Calibrated,
     const DPDT_Range_type& DPDT_Range,
     const Respiration_Show_Event_type& Respiration_Show_Event,
     const Pressure_Diastolic_type& Pressure_Diastolic,
     const Temperature_Calibration_type& Temperature_Calibration,
     const Temperature_type& Temperature,
     const Respiration_Beats_To_Average_type& Respiration_Beats_To_Average,
     const RWave_Thresh_Trigger_Percent_type& RWave_Thresh_Trigger_Percent,
     const Respiration_Time_To_Average_type& Respiration_Time_To_Average,
     const Pressure_Amplification_type& Pressure_Amplification,
     const Heart_Period_type& Heart_Period,
     const Pressure_Show_Event_type& Pressure_Show_Event,
     const RWave_Default_Threshold_type& RWave_Default_Threshold,
     const Show_Filtered_Data_type& Show_Filtered_Data,
     const ECG_Range_type& ECG_Range,
     const RWave_Maxima_Block_Time_type& RWave_Maxima_Block_Time,
     const RWave_Noise_Threshold_type& RWave_Noise_Threshold,
     const Pressure_Calibration_Level_type& Pressure_Calibration_Level,
     const ECG_HP_Filter_type& ECG_HP_Filter,
     const ECG_LP_Filter_type& ECG_LP_Filter,
     const RWave_Max_Change_Period_type& RWave_Max_Change_Period,
     const Pressure_Time_Out_type& Pressure_Time_Out,
     const Pressure_Calibration_type& Pressure_Calibration,
     const RWave_Blank_Time_type& RWave_Blank_Time)
: ::xml_schema::type (),
  Respiration_Threshold_Change_ (Respiration_Threshold_Change, ::xml_schema::flags (), this),
  Respiration_Threshold_ (Respiration_Threshold, ::xml_schema::flags (), this),
  Pressure_Range_ (Pressure_Range, ::xml_schema::flags (), this),
  Respiration_Gate_Delay_ (Respiration_Gate_Delay, ::xml_schema::flags (), this),
  Respiration_Timeout_ (Respiration_Timeout, ::xml_schema::flags (), this),
  RWave_Max_Change_Factor_Percent_ (RWave_Max_Change_Factor_Percent, ::xml_schema::flags (), this),
  Respiration_Period_ (Respiration_Period, ::xml_schema::flags (), this),
  Respiration_Subsample_Rate_ (Respiration_Subsample_Rate, ::xml_schema::flags (), this),
  Show_RWaves_ (Show_RWaves, ::xml_schema::flags (), this),
  Respiration_Minimal_Peak_2_Peak_ (Respiration_Minimal_Peak_2_Peak, ::xml_schema::flags (), this),
  Respiration_Window_ (Respiration_Window, ::xml_schema::flags (), this),
  Pressure_Zeroed_ (Pressure_Zeroed, ::xml_schema::flags (), this),
  Pressure_Systolic_ (Pressure_Systolic, ::xml_schema::flags (), this),
  Respiration_Show_Window_ (Respiration_Show_Window, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Respiration_Blank_Period_ (Respiration_Blank_Period, ::xml_schema::flags (), this),
  Respiration_Range_ (Respiration_Range, ::xml_schema::flags (), this),
  Pressure_Zero_ (Pressure_Zero, ::xml_schema::flags (), this),
  Temperature_Amplification_ (Temperature_Amplification, ::xml_schema::flags (), this),
  P_Wave_Start_ (P_Wave_Start, ::xml_schema::flags (), this),
  ECG_Filter_Taps_ (ECG_Filter_Taps, ::xml_schema::flags (), this),
  RWave_Future_Search_Time_ (RWave_Future_Search_Time, ::xml_schema::flags (), this),
  Respiration_Percent_Peak_ (Respiration_Percent_Peak, ::xml_schema::flags (), this),
  T_Wave_Start_ (T_Wave_Start, ::xml_schema::flags (), this),
  Strain_Rate_RR_Diff_Ratio_ (Strain_Rate_RR_Diff_Ratio, ::xml_schema::flags (), this),
  Pressure_Calibration_Min_Level_ (Pressure_Calibration_Min_Level, ::xml_schema::flags (), this),
  Pressure_Calibrated_ (Pressure_Calibrated, ::xml_schema::flags (), this),
  DPDT_Range_ (DPDT_Range, ::xml_schema::flags (), this),
  Respiration_Show_Event_ (Respiration_Show_Event, ::xml_schema::flags (), this),
  Pressure_Diastolic_ (Pressure_Diastolic, ::xml_schema::flags (), this),
  Temperature_Calibration_ (Temperature_Calibration, ::xml_schema::flags (), this),
  Temperature_ (Temperature, ::xml_schema::flags (), this),
  Respiration_Beats_To_Average_ (Respiration_Beats_To_Average, ::xml_schema::flags (), this),
  RWave_Thresh_Trigger_Percent_ (RWave_Thresh_Trigger_Percent, ::xml_schema::flags (), this),
  Respiration_Time_To_Average_ (Respiration_Time_To_Average, ::xml_schema::flags (), this),
  Pressure_Amplification_ (Pressure_Amplification, ::xml_schema::flags (), this),
  Heart_Period_ (Heart_Period, ::xml_schema::flags (), this),
  Pressure_Show_Event_ (Pressure_Show_Event, ::xml_schema::flags (), this),
  RWave_Default_Threshold_ (RWave_Default_Threshold, ::xml_schema::flags (), this),
  Show_Filtered_Data_ (Show_Filtered_Data, ::xml_schema::flags (), this),
  ECG_Range_ (ECG_Range, ::xml_schema::flags (), this),
  RWave_Maxima_Block_Time_ (RWave_Maxima_Block_Time, ::xml_schema::flags (), this),
  RWave_Noise_Threshold_ (RWave_Noise_Threshold, ::xml_schema::flags (), this),
  Pressure_Calibration_Level_ (Pressure_Calibration_Level, ::xml_schema::flags (), this),
  ECG_HP_Filter_ (ECG_HP_Filter, ::xml_schema::flags (), this),
  ECG_LP_Filter_ (ECG_LP_Filter, ::xml_schema::flags (), this),
  RWave_Max_Change_Period_ (RWave_Max_Change_Period, ::xml_schema::flags (), this),
  Pressure_Time_Out_ (Pressure_Time_Out, ::xml_schema::flags (), this),
  Pressure_Calibration_ (Pressure_Calibration, ::xml_schema::flags (), this),
  RWave_Blank_Time_ (RWave_Blank_Time, ::xml_schema::flags (), this)
{
}

ECG::
ECG (::std::auto_ptr< Respiration_Threshold_Change_type >& Respiration_Threshold_Change,
     const Respiration_Threshold_type& Respiration_Threshold,
     ::std::auto_ptr< Pressure_Range_type >& Pressure_Range,
     ::std::auto_ptr< Respiration_Gate_Delay_type >& Respiration_Gate_Delay,
     ::std::auto_ptr< Respiration_Timeout_type >& Respiration_Timeout,
     ::std::auto_ptr< RWave_Max_Change_Factor_Percent_type >& RWave_Max_Change_Factor_Percent,
     ::std::auto_ptr< Respiration_Period_type >& Respiration_Period,
     ::std::auto_ptr< Respiration_Subsample_Rate_type >& Respiration_Subsample_Rate,
     const Show_RWaves_type& Show_RWaves,
     const Respiration_Minimal_Peak_2_Peak_type& Respiration_Minimal_Peak_2_Peak,
     ::std::auto_ptr< Respiration_Window_type >& Respiration_Window,
     const Pressure_Zeroed_type& Pressure_Zeroed,
     ::std::auto_ptr< Pressure_Systolic_type >& Pressure_Systolic,
     const Respiration_Show_Window_type& Respiration_Show_Window,
     ::std::auto_ptr< Frequency_type >& Frequency,
     ::std::auto_ptr< Respiration_Blank_Period_type >& Respiration_Blank_Period,
     ::std::auto_ptr< Respiration_Range_type >& Respiration_Range,
     ::std::auto_ptr< Pressure_Zero_type >& Pressure_Zero,
     const Temperature_Amplification_type& Temperature_Amplification,
     ::std::auto_ptr< P_Wave_Start_type >& P_Wave_Start,
     const ECG_Filter_Taps_type& ECG_Filter_Taps,
     ::std::auto_ptr< RWave_Future_Search_Time_type >& RWave_Future_Search_Time,
     ::std::auto_ptr< Respiration_Percent_Peak_type >& Respiration_Percent_Peak,
     ::std::auto_ptr< T_Wave_Start_type >& T_Wave_Start,
     ::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type >& Strain_Rate_RR_Diff_Ratio,
     const Pressure_Calibration_Min_Level_type& Pressure_Calibration_Min_Level,
     const Pressure_Calibrated_type& Pressure_Calibrated,
     const DPDT_Range_type& DPDT_Range,
     const Respiration_Show_Event_type& Respiration_Show_Event,
     ::std::auto_ptr< Pressure_Diastolic_type >& Pressure_Diastolic,
     ::std::auto_ptr< Temperature_Calibration_type >& Temperature_Calibration,
     ::std::auto_ptr< Temperature_type >& Temperature,
     ::std::auto_ptr< Respiration_Beats_To_Average_type >& Respiration_Beats_To_Average,
     ::std::auto_ptr< RWave_Thresh_Trigger_Percent_type >& RWave_Thresh_Trigger_Percent,
     ::std::auto_ptr< Respiration_Time_To_Average_type >& Respiration_Time_To_Average,
     const Pressure_Amplification_type& Pressure_Amplification,
     ::std::auto_ptr< Heart_Period_type >& Heart_Period,
     const Pressure_Show_Event_type& Pressure_Show_Event,
     const RWave_Default_Threshold_type& RWave_Default_Threshold,
     const Show_Filtered_Data_type& Show_Filtered_Data,
     ::std::auto_ptr< ECG_Range_type >& ECG_Range,
     ::std::auto_ptr< RWave_Maxima_Block_Time_type >& RWave_Maxima_Block_Time,
     const RWave_Noise_Threshold_type& RWave_Noise_Threshold,
     ::std::auto_ptr< Pressure_Calibration_Level_type >& Pressure_Calibration_Level,
     ::std::auto_ptr< ECG_HP_Filter_type >& ECG_HP_Filter,
     ::std::auto_ptr< ECG_LP_Filter_type >& ECG_LP_Filter,
     ::std::auto_ptr< RWave_Max_Change_Period_type >& RWave_Max_Change_Period,
     const Pressure_Time_Out_type& Pressure_Time_Out,
     ::std::auto_ptr< Pressure_Calibration_type >& Pressure_Calibration,
     ::std::auto_ptr< RWave_Blank_Time_type >& RWave_Blank_Time)
: ::xml_schema::type (),
  Respiration_Threshold_Change_ (Respiration_Threshold_Change, ::xml_schema::flags (), this),
  Respiration_Threshold_ (Respiration_Threshold, ::xml_schema::flags (), this),
  Pressure_Range_ (Pressure_Range, ::xml_schema::flags (), this),
  Respiration_Gate_Delay_ (Respiration_Gate_Delay, ::xml_schema::flags (), this),
  Respiration_Timeout_ (Respiration_Timeout, ::xml_schema::flags (), this),
  RWave_Max_Change_Factor_Percent_ (RWave_Max_Change_Factor_Percent, ::xml_schema::flags (), this),
  Respiration_Period_ (Respiration_Period, ::xml_schema::flags (), this),
  Respiration_Subsample_Rate_ (Respiration_Subsample_Rate, ::xml_schema::flags (), this),
  Show_RWaves_ (Show_RWaves, ::xml_schema::flags (), this),
  Respiration_Minimal_Peak_2_Peak_ (Respiration_Minimal_Peak_2_Peak, ::xml_schema::flags (), this),
  Respiration_Window_ (Respiration_Window, ::xml_schema::flags (), this),
  Pressure_Zeroed_ (Pressure_Zeroed, ::xml_schema::flags (), this),
  Pressure_Systolic_ (Pressure_Systolic, ::xml_schema::flags (), this),
  Respiration_Show_Window_ (Respiration_Show_Window, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Respiration_Blank_Period_ (Respiration_Blank_Period, ::xml_schema::flags (), this),
  Respiration_Range_ (Respiration_Range, ::xml_schema::flags (), this),
  Pressure_Zero_ (Pressure_Zero, ::xml_schema::flags (), this),
  Temperature_Amplification_ (Temperature_Amplification, ::xml_schema::flags (), this),
  P_Wave_Start_ (P_Wave_Start, ::xml_schema::flags (), this),
  ECG_Filter_Taps_ (ECG_Filter_Taps, ::xml_schema::flags (), this),
  RWave_Future_Search_Time_ (RWave_Future_Search_Time, ::xml_schema::flags (), this),
  Respiration_Percent_Peak_ (Respiration_Percent_Peak, ::xml_schema::flags (), this),
  T_Wave_Start_ (T_Wave_Start, ::xml_schema::flags (), this),
  Strain_Rate_RR_Diff_Ratio_ (Strain_Rate_RR_Diff_Ratio, ::xml_schema::flags (), this),
  Pressure_Calibration_Min_Level_ (Pressure_Calibration_Min_Level, ::xml_schema::flags (), this),
  Pressure_Calibrated_ (Pressure_Calibrated, ::xml_schema::flags (), this),
  DPDT_Range_ (DPDT_Range, ::xml_schema::flags (), this),
  Respiration_Show_Event_ (Respiration_Show_Event, ::xml_schema::flags (), this),
  Pressure_Diastolic_ (Pressure_Diastolic, ::xml_schema::flags (), this),
  Temperature_Calibration_ (Temperature_Calibration, ::xml_schema::flags (), this),
  Temperature_ (Temperature, ::xml_schema::flags (), this),
  Respiration_Beats_To_Average_ (Respiration_Beats_To_Average, ::xml_schema::flags (), this),
  RWave_Thresh_Trigger_Percent_ (RWave_Thresh_Trigger_Percent, ::xml_schema::flags (), this),
  Respiration_Time_To_Average_ (Respiration_Time_To_Average, ::xml_schema::flags (), this),
  Pressure_Amplification_ (Pressure_Amplification, ::xml_schema::flags (), this),
  Heart_Period_ (Heart_Period, ::xml_schema::flags (), this),
  Pressure_Show_Event_ (Pressure_Show_Event, ::xml_schema::flags (), this),
  RWave_Default_Threshold_ (RWave_Default_Threshold, ::xml_schema::flags (), this),
  Show_Filtered_Data_ (Show_Filtered_Data, ::xml_schema::flags (), this),
  ECG_Range_ (ECG_Range, ::xml_schema::flags (), this),
  RWave_Maxima_Block_Time_ (RWave_Maxima_Block_Time, ::xml_schema::flags (), this),
  RWave_Noise_Threshold_ (RWave_Noise_Threshold, ::xml_schema::flags (), this),
  Pressure_Calibration_Level_ (Pressure_Calibration_Level, ::xml_schema::flags (), this),
  ECG_HP_Filter_ (ECG_HP_Filter, ::xml_schema::flags (), this),
  ECG_LP_Filter_ (ECG_LP_Filter, ::xml_schema::flags (), this),
  RWave_Max_Change_Period_ (RWave_Max_Change_Period, ::xml_schema::flags (), this),
  Pressure_Time_Out_ (Pressure_Time_Out, ::xml_schema::flags (), this),
  Pressure_Calibration_ (Pressure_Calibration, ::xml_schema::flags (), this),
  RWave_Blank_Time_ (RWave_Blank_Time, ::xml_schema::flags (), this)
{
}

ECG::
ECG (const ECG& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Respiration_Threshold_Change_ (x.Respiration_Threshold_Change_, f, this),
  Respiration_Threshold_ (x.Respiration_Threshold_, f, this),
  Pressure_Range_ (x.Pressure_Range_, f, this),
  Respiration_Gate_Delay_ (x.Respiration_Gate_Delay_, f, this),
  Respiration_Timeout_ (x.Respiration_Timeout_, f, this),
  RWave_Max_Change_Factor_Percent_ (x.RWave_Max_Change_Factor_Percent_, f, this),
  Respiration_Period_ (x.Respiration_Period_, f, this),
  Respiration_Subsample_Rate_ (x.Respiration_Subsample_Rate_, f, this),
  Show_RWaves_ (x.Show_RWaves_, f, this),
  Respiration_Minimal_Peak_2_Peak_ (x.Respiration_Minimal_Peak_2_Peak_, f, this),
  Respiration_Window_ (x.Respiration_Window_, f, this),
  Pressure_Zeroed_ (x.Pressure_Zeroed_, f, this),
  Pressure_Systolic_ (x.Pressure_Systolic_, f, this),
  Respiration_Show_Window_ (x.Respiration_Show_Window_, f, this),
  Frequency_ (x.Frequency_, f, this),
  Respiration_Blank_Period_ (x.Respiration_Blank_Period_, f, this),
  Respiration_Range_ (x.Respiration_Range_, f, this),
  Pressure_Zero_ (x.Pressure_Zero_, f, this),
  Temperature_Amplification_ (x.Temperature_Amplification_, f, this),
  P_Wave_Start_ (x.P_Wave_Start_, f, this),
  ECG_Filter_Taps_ (x.ECG_Filter_Taps_, f, this),
  RWave_Future_Search_Time_ (x.RWave_Future_Search_Time_, f, this),
  Respiration_Percent_Peak_ (x.Respiration_Percent_Peak_, f, this),
  T_Wave_Start_ (x.T_Wave_Start_, f, this),
  Strain_Rate_RR_Diff_Ratio_ (x.Strain_Rate_RR_Diff_Ratio_, f, this),
  Pressure_Calibration_Min_Level_ (x.Pressure_Calibration_Min_Level_, f, this),
  Pressure_Calibrated_ (x.Pressure_Calibrated_, f, this),
  DPDT_Range_ (x.DPDT_Range_, f, this),
  Respiration_Show_Event_ (x.Respiration_Show_Event_, f, this),
  Pressure_Diastolic_ (x.Pressure_Diastolic_, f, this),
  Temperature_Calibration_ (x.Temperature_Calibration_, f, this),
  Temperature_ (x.Temperature_, f, this),
  Respiration_Beats_To_Average_ (x.Respiration_Beats_To_Average_, f, this),
  RWave_Thresh_Trigger_Percent_ (x.RWave_Thresh_Trigger_Percent_, f, this),
  Respiration_Time_To_Average_ (x.Respiration_Time_To_Average_, f, this),
  Pressure_Amplification_ (x.Pressure_Amplification_, f, this),
  Heart_Period_ (x.Heart_Period_, f, this),
  Pressure_Show_Event_ (x.Pressure_Show_Event_, f, this),
  RWave_Default_Threshold_ (x.RWave_Default_Threshold_, f, this),
  Show_Filtered_Data_ (x.Show_Filtered_Data_, f, this),
  ECG_Range_ (x.ECG_Range_, f, this),
  RWave_Maxima_Block_Time_ (x.RWave_Maxima_Block_Time_, f, this),
  RWave_Noise_Threshold_ (x.RWave_Noise_Threshold_, f, this),
  Pressure_Calibration_Level_ (x.Pressure_Calibration_Level_, f, this),
  ECG_HP_Filter_ (x.ECG_HP_Filter_, f, this),
  ECG_LP_Filter_ (x.ECG_LP_Filter_, f, this),
  RWave_Max_Change_Period_ (x.RWave_Max_Change_Period_, f, this),
  Pressure_Time_Out_ (x.Pressure_Time_Out_, f, this),
  Pressure_Calibration_ (x.Pressure_Calibration_, f, this),
  RWave_Blank_Time_ (x.RWave_Blank_Time_, f, this)
{
}

ECG::
ECG (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Respiration_Threshold_Change_ (f, this),
  Respiration_Threshold_ (f, this),
  Pressure_Range_ (f, this),
  Respiration_Gate_Delay_ (f, this),
  Respiration_Timeout_ (f, this),
  RWave_Max_Change_Factor_Percent_ (f, this),
  Respiration_Period_ (f, this),
  Respiration_Subsample_Rate_ (f, this),
  Show_RWaves_ (f, this),
  Respiration_Minimal_Peak_2_Peak_ (f, this),
  Respiration_Window_ (f, this),
  Pressure_Zeroed_ (f, this),
  Pressure_Systolic_ (f, this),
  Respiration_Show_Window_ (f, this),
  Frequency_ (f, this),
  Respiration_Blank_Period_ (f, this),
  Respiration_Range_ (f, this),
  Pressure_Zero_ (f, this),
  Temperature_Amplification_ (f, this),
  P_Wave_Start_ (f, this),
  ECG_Filter_Taps_ (f, this),
  RWave_Future_Search_Time_ (f, this),
  Respiration_Percent_Peak_ (f, this),
  T_Wave_Start_ (f, this),
  Strain_Rate_RR_Diff_Ratio_ (f, this),
  Pressure_Calibration_Min_Level_ (f, this),
  Pressure_Calibrated_ (f, this),
  DPDT_Range_ (f, this),
  Respiration_Show_Event_ (f, this),
  Pressure_Diastolic_ (f, this),
  Temperature_Calibration_ (f, this),
  Temperature_ (f, this),
  Respiration_Beats_To_Average_ (f, this),
  RWave_Thresh_Trigger_Percent_ (f, this),
  Respiration_Time_To_Average_ (f, this),
  Pressure_Amplification_ (f, this),
  Heart_Period_ (f, this),
  Pressure_Show_Event_ (f, this),
  RWave_Default_Threshold_ (f, this),
  Show_Filtered_Data_ (f, this),
  ECG_Range_ (f, this),
  RWave_Maxima_Block_Time_ (f, this),
  RWave_Noise_Threshold_ (f, this),
  Pressure_Calibration_Level_ (f, this),
  ECG_HP_Filter_ (f, this),
  ECG_LP_Filter_ (f, this),
  RWave_Max_Change_Period_ (f, this),
  Pressure_Time_Out_ (f, this),
  Pressure_Calibration_ (f, this),
  RWave_Blank_Time_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ECG::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Respiration-Threshold-Change
    //
    if (n.name () == "Respiration-Threshold-Change" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Threshold_Change_type > r (
        Respiration_Threshold_Change_traits::create (i, f, this));

      if (!Respiration_Threshold_Change_.present ())
      {
        this->Respiration_Threshold_Change_.set (r);
        continue;
      }
    }

    // Respiration-Threshold
    //
    if (n.name () == "Respiration-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Threshold_type > r (
        Respiration_Threshold_traits::create (i, f, this));

      if (!Respiration_Threshold_.present ())
      {
        this->Respiration_Threshold_.set (r);
        continue;
      }
    }

    // Pressure-Range
    //
    if (n.name () == "Pressure-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Range_type > r (
        Pressure_Range_traits::create (i, f, this));

      if (!Pressure_Range_.present ())
      {
        this->Pressure_Range_.set (r);
        continue;
      }
    }

    // Respiration-Gate-Delay
    //
    if (n.name () == "Respiration-Gate-Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Gate_Delay_type > r (
        Respiration_Gate_Delay_traits::create (i, f, this));

      if (!Respiration_Gate_Delay_.present ())
      {
        this->Respiration_Gate_Delay_.set (r);
        continue;
      }
    }

    // Respiration-Timeout
    //
    if (n.name () == "Respiration-Timeout" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Timeout_type > r (
        Respiration_Timeout_traits::create (i, f, this));

      if (!Respiration_Timeout_.present ())
      {
        this->Respiration_Timeout_.set (r);
        continue;
      }
    }

    // RWave-Max-Change-Factor-Percent
    //
    if (n.name () == "RWave-Max-Change-Factor-Percent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Max_Change_Factor_Percent_type > r (
        RWave_Max_Change_Factor_Percent_traits::create (i, f, this));

      if (!RWave_Max_Change_Factor_Percent_.present ())
      {
        this->RWave_Max_Change_Factor_Percent_.set (r);
        continue;
      }
    }

    // Respiration-Period
    //
    if (n.name () == "Respiration-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Period_type > r (
        Respiration_Period_traits::create (i, f, this));

      if (!Respiration_Period_.present ())
      {
        this->Respiration_Period_.set (r);
        continue;
      }
    }

    // Respiration-Subsample-Rate
    //
    if (n.name () == "Respiration-Subsample-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Subsample_Rate_type > r (
        Respiration_Subsample_Rate_traits::create (i, f, this));

      if (!Respiration_Subsample_Rate_.present ())
      {
        this->Respiration_Subsample_Rate_.set (r);
        continue;
      }
    }

    // Show-RWaves
    //
    if (n.name () == "Show-RWaves" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Show_RWaves_type > r (
        Show_RWaves_traits::create (i, f, this));

      if (!Show_RWaves_.present ())
      {
        this->Show_RWaves_.set (r);
        continue;
      }
    }

    // Respiration-Minimal-Peak-2-Peak
    //
    if (n.name () == "Respiration-Minimal-Peak-2-Peak" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Minimal_Peak_2_Peak_type > r (
        Respiration_Minimal_Peak_2_Peak_traits::create (i, f, this));

      if (!Respiration_Minimal_Peak_2_Peak_.present ())
      {
        this->Respiration_Minimal_Peak_2_Peak_.set (r);
        continue;
      }
    }

    // Respiration-Window
    //
    if (n.name () == "Respiration-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Window_type > r (
        Respiration_Window_traits::create (i, f, this));

      if (!Respiration_Window_.present ())
      {
        this->Respiration_Window_.set (r);
        continue;
      }
    }

    // Pressure-Zeroed
    //
    if (n.name () == "Pressure-Zeroed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Zeroed_type > r (
        Pressure_Zeroed_traits::create (i, f, this));

      if (!Pressure_Zeroed_.present ())
      {
        this->Pressure_Zeroed_.set (r);
        continue;
      }
    }

    // Pressure-Systolic
    //
    if (n.name () == "Pressure-Systolic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Systolic_type > r (
        Pressure_Systolic_traits::create (i, f, this));

      if (!Pressure_Systolic_.present ())
      {
        this->Pressure_Systolic_.set (r);
        continue;
      }
    }

    // Respiration-Show-Window
    //
    if (n.name () == "Respiration-Show-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Show_Window_type > r (
        Respiration_Show_Window_traits::create (i, f, this));

      if (!Respiration_Show_Window_.present ())
      {
        this->Respiration_Show_Window_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // Respiration-Blank-Period
    //
    if (n.name () == "Respiration-Blank-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Blank_Period_type > r (
        Respiration_Blank_Period_traits::create (i, f, this));

      if (!Respiration_Blank_Period_.present ())
      {
        this->Respiration_Blank_Period_.set (r);
        continue;
      }
    }

    // Respiration-Range
    //
    if (n.name () == "Respiration-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Range_type > r (
        Respiration_Range_traits::create (i, f, this));

      if (!Respiration_Range_.present ())
      {
        this->Respiration_Range_.set (r);
        continue;
      }
    }

    // Pressure-Zero
    //
    if (n.name () == "Pressure-Zero" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Zero_type > r (
        Pressure_Zero_traits::create (i, f, this));

      if (!Pressure_Zero_.present ())
      {
        this->Pressure_Zero_.set (r);
        continue;
      }
    }

    // Temperature-Amplification
    //
    if (n.name () == "Temperature-Amplification" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Amplification_type > r (
        Temperature_Amplification_traits::create (i, f, this));

      if (!Temperature_Amplification_.present ())
      {
        this->Temperature_Amplification_.set (r);
        continue;
      }
    }

    // P-Wave-Start
    //
    if (n.name () == "P-Wave-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< P_Wave_Start_type > r (
        P_Wave_Start_traits::create (i, f, this));

      if (!P_Wave_Start_.present ())
      {
        this->P_Wave_Start_.set (r);
        continue;
      }
    }

    // ECG-Filter-Taps
    //
    if (n.name () == "ECG-Filter-Taps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Filter_Taps_type > r (
        ECG_Filter_Taps_traits::create (i, f, this));

      if (!ECG_Filter_Taps_.present ())
      {
        this->ECG_Filter_Taps_.set (r);
        continue;
      }
    }

    // RWave-Future-Search-Time
    //
    if (n.name () == "RWave-Future-Search-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Future_Search_Time_type > r (
        RWave_Future_Search_Time_traits::create (i, f, this));

      if (!RWave_Future_Search_Time_.present ())
      {
        this->RWave_Future_Search_Time_.set (r);
        continue;
      }
    }

    // Respiration-Percent-Peak
    //
    if (n.name () == "Respiration-Percent-Peak" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Percent_Peak_type > r (
        Respiration_Percent_Peak_traits::create (i, f, this));

      if (!Respiration_Percent_Peak_.present ())
      {
        this->Respiration_Percent_Peak_.set (r);
        continue;
      }
    }

    // T-Wave-Start
    //
    if (n.name () == "T-Wave-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< T_Wave_Start_type > r (
        T_Wave_Start_traits::create (i, f, this));

      if (!T_Wave_Start_.present ())
      {
        this->T_Wave_Start_.set (r);
        continue;
      }
    }

    // Strain-Rate-RR-Diff-Ratio
    //
    if (n.name () == "Strain-Rate-RR-Diff-Ratio" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type > r (
        Strain_Rate_RR_Diff_Ratio_traits::create (i, f, this));

      if (!Strain_Rate_RR_Diff_Ratio_.present ())
      {
        this->Strain_Rate_RR_Diff_Ratio_.set (r);
        continue;
      }
    }

    // Pressure-Calibration-Min-Level
    //
    if (n.name () == "Pressure-Calibration-Min-Level" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_Min_Level_type > r (
        Pressure_Calibration_Min_Level_traits::create (i, f, this));

      if (!Pressure_Calibration_Min_Level_.present ())
      {
        this->Pressure_Calibration_Min_Level_.set (r);
        continue;
      }
    }

    // Pressure-Calibrated
    //
    if (n.name () == "Pressure-Calibrated" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibrated_type > r (
        Pressure_Calibrated_traits::create (i, f, this));

      if (!Pressure_Calibrated_.present ())
      {
        this->Pressure_Calibrated_.set (r);
        continue;
      }
    }

    // DPDT-Range
    //
    if (n.name () == "DPDT-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DPDT_Range_type > r (
        DPDT_Range_traits::create (i, f, this));

      if (!DPDT_Range_.present ())
      {
        this->DPDT_Range_.set (r);
        continue;
      }
    }

    // Respiration-Show-Event
    //
    if (n.name () == "Respiration-Show-Event" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Show_Event_type > r (
        Respiration_Show_Event_traits::create (i, f, this));

      if (!Respiration_Show_Event_.present ())
      {
        this->Respiration_Show_Event_.set (r);
        continue;
      }
    }

    // Pressure-Diastolic
    //
    if (n.name () == "Pressure-Diastolic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Diastolic_type > r (
        Pressure_Diastolic_traits::create (i, f, this));

      if (!Pressure_Diastolic_.present ())
      {
        this->Pressure_Diastolic_.set (r);
        continue;
      }
    }

    // Temperature-Calibration
    //
    if (n.name () == "Temperature-Calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Calibration_type > r (
        Temperature_Calibration_traits::create (i, f, this));

      if (!Temperature_Calibration_.present ())
      {
        this->Temperature_Calibration_.set (r);
        continue;
      }
    }

    // Temperature
    //
    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_type > r (
        Temperature_traits::create (i, f, this));

      if (!Temperature_.present ())
      {
        this->Temperature_.set (r);
        continue;
      }
    }

    // Respiration-Beats-To-Average
    //
    if (n.name () == "Respiration-Beats-To-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Beats_To_Average_type > r (
        Respiration_Beats_To_Average_traits::create (i, f, this));

      if (!Respiration_Beats_To_Average_.present ())
      {
        this->Respiration_Beats_To_Average_.set (r);
        continue;
      }
    }

    // RWave-Thresh-Trigger-Percent
    //
    if (n.name () == "RWave-Thresh-Trigger-Percent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Thresh_Trigger_Percent_type > r (
        RWave_Thresh_Trigger_Percent_traits::create (i, f, this));

      if (!RWave_Thresh_Trigger_Percent_.present ())
      {
        this->RWave_Thresh_Trigger_Percent_.set (r);
        continue;
      }
    }

    // Respiration-Time-To-Average
    //
    if (n.name () == "Respiration-Time-To-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Time_To_Average_type > r (
        Respiration_Time_To_Average_traits::create (i, f, this));

      if (!Respiration_Time_To_Average_.present ())
      {
        this->Respiration_Time_To_Average_.set (r);
        continue;
      }
    }

    // Pressure-Amplification
    //
    if (n.name () == "Pressure-Amplification" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Amplification_type > r (
        Pressure_Amplification_traits::create (i, f, this));

      if (!Pressure_Amplification_.present ())
      {
        this->Pressure_Amplification_.set (r);
        continue;
      }
    }

    // Heart-Period
    //
    if (n.name () == "Heart-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Heart_Period_type > r (
        Heart_Period_traits::create (i, f, this));

      if (!Heart_Period_.present ())
      {
        this->Heart_Period_.set (r);
        continue;
      }
    }

    // Pressure-Show-Event
    //
    if (n.name () == "Pressure-Show-Event" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Show_Event_type > r (
        Pressure_Show_Event_traits::create (i, f, this));

      if (!Pressure_Show_Event_.present ())
      {
        this->Pressure_Show_Event_.set (r);
        continue;
      }
    }

    // RWave-Default-Threshold
    //
    if (n.name () == "RWave-Default-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Default_Threshold_type > r (
        RWave_Default_Threshold_traits::create (i, f, this));

      if (!RWave_Default_Threshold_.present ())
      {
        this->RWave_Default_Threshold_.set (r);
        continue;
      }
    }

    // Show-Filtered-Data
    //
    if (n.name () == "Show-Filtered-Data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Show_Filtered_Data_type > r (
        Show_Filtered_Data_traits::create (i, f, this));

      if (!Show_Filtered_Data_.present ())
      {
        this->Show_Filtered_Data_.set (r);
        continue;
      }
    }

    // ECG-Range
    //
    if (n.name () == "ECG-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Range_type > r (
        ECG_Range_traits::create (i, f, this));

      if (!ECG_Range_.present ())
      {
        this->ECG_Range_.set (r);
        continue;
      }
    }

    // RWave-Maxima-Block-Time
    //
    if (n.name () == "RWave-Maxima-Block-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Maxima_Block_Time_type > r (
        RWave_Maxima_Block_Time_traits::create (i, f, this));

      if (!RWave_Maxima_Block_Time_.present ())
      {
        this->RWave_Maxima_Block_Time_.set (r);
        continue;
      }
    }

    // RWave-Noise-Threshold
    //
    if (n.name () == "RWave-Noise-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Noise_Threshold_type > r (
        RWave_Noise_Threshold_traits::create (i, f, this));

      if (!RWave_Noise_Threshold_.present ())
      {
        this->RWave_Noise_Threshold_.set (r);
        continue;
      }
    }

    // Pressure-Calibration-Level
    //
    if (n.name () == "Pressure-Calibration-Level" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_Level_type > r (
        Pressure_Calibration_Level_traits::create (i, f, this));

      if (!Pressure_Calibration_Level_.present ())
      {
        this->Pressure_Calibration_Level_.set (r);
        continue;
      }
    }

    // ECG-HP-Filter
    //
    if (n.name () == "ECG-HP-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_HP_Filter_type > r (
        ECG_HP_Filter_traits::create (i, f, this));

      if (!ECG_HP_Filter_.present ())
      {
        this->ECG_HP_Filter_.set (r);
        continue;
      }
    }

    // ECG-LP-Filter
    //
    if (n.name () == "ECG-LP-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_LP_Filter_type > r (
        ECG_LP_Filter_traits::create (i, f, this));

      if (!ECG_LP_Filter_.present ())
      {
        this->ECG_LP_Filter_.set (r);
        continue;
      }
    }

    // RWave-Max-Change-Period
    //
    if (n.name () == "RWave-Max-Change-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Max_Change_Period_type > r (
        RWave_Max_Change_Period_traits::create (i, f, this));

      if (!RWave_Max_Change_Period_.present ())
      {
        this->RWave_Max_Change_Period_.set (r);
        continue;
      }
    }

    // Pressure-Time-Out
    //
    if (n.name () == "Pressure-Time-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Time_Out_type > r (
        Pressure_Time_Out_traits::create (i, f, this));

      if (!Pressure_Time_Out_.present ())
      {
        this->Pressure_Time_Out_.set (r);
        continue;
      }
    }

    // Pressure-Calibration
    //
    if (n.name () == "Pressure-Calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_type > r (
        Pressure_Calibration_traits::create (i, f, this));

      if (!Pressure_Calibration_.present ())
      {
        this->Pressure_Calibration_.set (r);
        continue;
      }
    }

    // RWave-Blank-Time
    //
    if (n.name () == "RWave-Blank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Blank_Time_type > r (
        RWave_Blank_Time_traits::create (i, f, this));

      if (!RWave_Blank_Time_.present ())
      {
        this->RWave_Blank_Time_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Respiration_Threshold_Change_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Threshold-Change",
      "");
  }

  if (!Respiration_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Threshold",
      "");
  }

  if (!Pressure_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Range",
      "");
  }

  if (!Respiration_Gate_Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Gate-Delay",
      "");
  }

  if (!Respiration_Timeout_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Timeout",
      "");
  }

  if (!RWave_Max_Change_Factor_Percent_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Max-Change-Factor-Percent",
      "");
  }

  if (!Respiration_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Period",
      "");
  }

  if (!Respiration_Subsample_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Subsample-Rate",
      "");
  }

  if (!Show_RWaves_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Show-RWaves",
      "");
  }

  if (!Respiration_Minimal_Peak_2_Peak_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Minimal-Peak-2-Peak",
      "");
  }

  if (!Respiration_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Window",
      "");
  }

  if (!Pressure_Zeroed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Zeroed",
      "");
  }

  if (!Pressure_Systolic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Systolic",
      "");
  }

  if (!Respiration_Show_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Show-Window",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!Respiration_Blank_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Blank-Period",
      "");
  }

  if (!Respiration_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Range",
      "");
  }

  if (!Pressure_Zero_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Zero",
      "");
  }

  if (!Temperature_Amplification_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Amplification",
      "");
  }

  if (!P_Wave_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "P-Wave-Start",
      "");
  }

  if (!ECG_Filter_Taps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Filter-Taps",
      "");
  }

  if (!RWave_Future_Search_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Future-Search-Time",
      "");
  }

  if (!Respiration_Percent_Peak_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Percent-Peak",
      "");
  }

  if (!T_Wave_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "T-Wave-Start",
      "");
  }

  if (!Strain_Rate_RR_Diff_Ratio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Strain-Rate-RR-Diff-Ratio",
      "");
  }

  if (!Pressure_Calibration_Min_Level_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration-Min-Level",
      "");
  }

  if (!Pressure_Calibrated_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibrated",
      "");
  }

  if (!DPDT_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DPDT-Range",
      "");
  }

  if (!Respiration_Show_Event_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Show-Event",
      "");
  }

  if (!Pressure_Diastolic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Diastolic",
      "");
  }

  if (!Temperature_Calibration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Calibration",
      "");
  }

  if (!Temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature",
      "");
  }

  if (!Respiration_Beats_To_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Beats-To-Average",
      "");
  }

  if (!RWave_Thresh_Trigger_Percent_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Thresh-Trigger-Percent",
      "");
  }

  if (!Respiration_Time_To_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Time-To-Average",
      "");
  }

  if (!Pressure_Amplification_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Amplification",
      "");
  }

  if (!Heart_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Heart-Period",
      "");
  }

  if (!Pressure_Show_Event_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Show-Event",
      "");
  }

  if (!RWave_Default_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Default-Threshold",
      "");
  }

  if (!Show_Filtered_Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Show-Filtered-Data",
      "");
  }

  if (!ECG_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Range",
      "");
  }

  if (!RWave_Maxima_Block_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Maxima-Block-Time",
      "");
  }

  if (!RWave_Noise_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Noise-Threshold",
      "");
  }

  if (!Pressure_Calibration_Level_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration-Level",
      "");
  }

  if (!ECG_HP_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-HP-Filter",
      "");
  }

  if (!ECG_LP_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-LP-Filter",
      "");
  }

  if (!RWave_Max_Change_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Max-Change-Period",
      "");
  }

  if (!Pressure_Time_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Time-Out",
      "");
  }

  if (!Pressure_Calibration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration",
      "");
  }

  if (!RWave_Blank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Blank-Time",
      "");
  }
}

ECG* ECG::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG (*this, f, c);
}

ECG::
~ECG ()
{
}

// RfModeSoft
//

RfModeSoft::
RfModeSoft (const Amplitude_Height_type& Amplitude_Height,
            const Magnitude_Origin_type& Magnitude_Origin,
            const Frequency_Origin_type& Frequency_Origin,
            const Samples_type& Samples,
            const Saturation_Threshold_type& Saturation_Threshold,
            const Amplitude_Origin_type& Amplitude_Origin,
            const Frame_Selected_type& Frame_Selected,
            const AcqPerLine_type& AcqPerLine,
            const Lines_type& Lines,
            const Windowing_Mode_type& Windowing_Mode,
            const Length_Origin_type& Length_Origin,
            const Line_Selected_type& Line_Selected,
            const V_Lines_Pos_type& V_Lines_Pos,
            const Bounce_Test_AscanData_type& Bounce_Test_AscanData,
            const Vertical_Scale_type& Vertical_Scale,
            const Bounce_Test_RFData_type& Bounce_Test_RFData,
            const SamplesPerSec_type& SamplesPerSec,
            const Frames_type& Frames,
            const Digitizer_type& Digitizer,
            const Magnitude_Height_type& Magnitude_Height,
            const Saturation_type& Saturation,
            const Length_Length_type& Length_Length,
            const Frequency_Length_type& Frequency_Length,
            const State_type& State,
            const SV_Center_type& SV_Center,
            const Continuous_RF_FrameRate_type& Continuous_RF_FrameRate,
            const Quantify_Bounce_Test_type& Quantify_Bounce_Test,
            const X_3D_Volume_type& X_3D_Volume,
            const Shift_RF_Data_type& Shift_RF_Data,
            const V_Lines_type& V_Lines,
            const Graph_Mode_type& Graph_Mode,
            const RF_Path_15Mhz_Time_Correction_type& RF_Path_15Mhz_Time_Correction,
            const RF_Path_23Mhz_Time_Correction_type& RF_Path_23Mhz_Time_Correction,
            const SV_Length_Limits_type& SV_Length_Limits)
: ::xml_schema::type (),
  Amplitude_Height_ (Amplitude_Height, ::xml_schema::flags (), this),
  Magnitude_Origin_ (Magnitude_Origin, ::xml_schema::flags (), this),
  Frequency_Origin_ (Frequency_Origin, ::xml_schema::flags (), this),
  Samples_ (Samples, ::xml_schema::flags (), this),
  Saturation_Threshold_ (Saturation_Threshold, ::xml_schema::flags (), this),
  Amplitude_Origin_ (Amplitude_Origin, ::xml_schema::flags (), this),
  Frame_Selected_ (Frame_Selected, ::xml_schema::flags (), this),
  AcqPerLine_ (AcqPerLine, ::xml_schema::flags (), this),
  Lines_ (Lines, ::xml_schema::flags (), this),
  Windowing_Mode_ (Windowing_Mode, ::xml_schema::flags (), this),
  Length_Origin_ (Length_Origin, ::xml_schema::flags (), this),
  Line_Selected_ (Line_Selected, ::xml_schema::flags (), this),
  V_Lines_Pos_ (V_Lines_Pos, ::xml_schema::flags (), this),
  Bounce_Test_AscanData_ (Bounce_Test_AscanData, ::xml_schema::flags (), this),
  Vertical_Scale_ (Vertical_Scale, ::xml_schema::flags (), this),
  Bounce_Test_RFData_ (Bounce_Test_RFData, ::xml_schema::flags (), this),
  SamplesPerSec_ (SamplesPerSec, ::xml_schema::flags (), this),
  Frames_ (Frames, ::xml_schema::flags (), this),
  Digitizer_ (Digitizer, ::xml_schema::flags (), this),
  Magnitude_Height_ (Magnitude_Height, ::xml_schema::flags (), this),
  Saturation_ (Saturation, ::xml_schema::flags (), this),
  Length_Length_ (Length_Length, ::xml_schema::flags (), this),
  Frequency_Length_ (Frequency_Length, ::xml_schema::flags (), this),
  State_ (State, ::xml_schema::flags (), this),
  SV_Center_ (SV_Center, ::xml_schema::flags (), this),
  Continuous_RF_FrameRate_ (Continuous_RF_FrameRate, ::xml_schema::flags (), this),
  Quantify_Bounce_Test_ (Quantify_Bounce_Test, ::xml_schema::flags (), this),
  X_3D_Volume_ (X_3D_Volume, ::xml_schema::flags (), this),
  Shift_RF_Data_ (Shift_RF_Data, ::xml_schema::flags (), this),
  V_Lines_ (V_Lines, ::xml_schema::flags (), this),
  Graph_Mode_ (Graph_Mode, ::xml_schema::flags (), this),
  RF_Path_15Mhz_Time_Correction_ (RF_Path_15Mhz_Time_Correction, ::xml_schema::flags (), this),
  RF_Path_23Mhz_Time_Correction_ (RF_Path_23Mhz_Time_Correction, ::xml_schema::flags (), this),
  SV_Length_Limits_ (SV_Length_Limits, ::xml_schema::flags (), this)
{
}

RfModeSoft::
RfModeSoft (const Amplitude_Height_type& Amplitude_Height,
            ::std::auto_ptr< Magnitude_Origin_type >& Magnitude_Origin,
            ::std::auto_ptr< Frequency_Origin_type >& Frequency_Origin,
            const Samples_type& Samples,
            const Saturation_Threshold_type& Saturation_Threshold,
            const Amplitude_Origin_type& Amplitude_Origin,
            const Frame_Selected_type& Frame_Selected,
            const AcqPerLine_type& AcqPerLine,
            const Lines_type& Lines,
            const Windowing_Mode_type& Windowing_Mode,
            ::std::auto_ptr< Length_Origin_type >& Length_Origin,
            const Line_Selected_type& Line_Selected,
            const V_Lines_Pos_type& V_Lines_Pos,
            const Bounce_Test_AscanData_type& Bounce_Test_AscanData,
            ::std::auto_ptr< Vertical_Scale_type >& Vertical_Scale,
            const Bounce_Test_RFData_type& Bounce_Test_RFData,
            ::std::auto_ptr< SamplesPerSec_type >& SamplesPerSec,
            const Frames_type& Frames,
            const Digitizer_type& Digitizer,
            ::std::auto_ptr< Magnitude_Height_type >& Magnitude_Height,
            const Saturation_type& Saturation,
            ::std::auto_ptr< Length_Length_type >& Length_Length,
            ::std::auto_ptr< Frequency_Length_type >& Frequency_Length,
            const State_type& State,
            ::std::auto_ptr< SV_Center_type >& SV_Center,
            const Continuous_RF_FrameRate_type& Continuous_RF_FrameRate,
            const Quantify_Bounce_Test_type& Quantify_Bounce_Test,
            const X_3D_Volume_type& X_3D_Volume,
            const Shift_RF_Data_type& Shift_RF_Data,
            const V_Lines_type& V_Lines,
            const Graph_Mode_type& Graph_Mode,
            ::std::auto_ptr< RF_Path_15Mhz_Time_Correction_type >& RF_Path_15Mhz_Time_Correction,
            ::std::auto_ptr< RF_Path_23Mhz_Time_Correction_type >& RF_Path_23Mhz_Time_Correction,
            ::std::auto_ptr< SV_Length_Limits_type >& SV_Length_Limits)
: ::xml_schema::type (),
  Amplitude_Height_ (Amplitude_Height, ::xml_schema::flags (), this),
  Magnitude_Origin_ (Magnitude_Origin, ::xml_schema::flags (), this),
  Frequency_Origin_ (Frequency_Origin, ::xml_schema::flags (), this),
  Samples_ (Samples, ::xml_schema::flags (), this),
  Saturation_Threshold_ (Saturation_Threshold, ::xml_schema::flags (), this),
  Amplitude_Origin_ (Amplitude_Origin, ::xml_schema::flags (), this),
  Frame_Selected_ (Frame_Selected, ::xml_schema::flags (), this),
  AcqPerLine_ (AcqPerLine, ::xml_schema::flags (), this),
  Lines_ (Lines, ::xml_schema::flags (), this),
  Windowing_Mode_ (Windowing_Mode, ::xml_schema::flags (), this),
  Length_Origin_ (Length_Origin, ::xml_schema::flags (), this),
  Line_Selected_ (Line_Selected, ::xml_schema::flags (), this),
  V_Lines_Pos_ (V_Lines_Pos, ::xml_schema::flags (), this),
  Bounce_Test_AscanData_ (Bounce_Test_AscanData, ::xml_schema::flags (), this),
  Vertical_Scale_ (Vertical_Scale, ::xml_schema::flags (), this),
  Bounce_Test_RFData_ (Bounce_Test_RFData, ::xml_schema::flags (), this),
  SamplesPerSec_ (SamplesPerSec, ::xml_schema::flags (), this),
  Frames_ (Frames, ::xml_schema::flags (), this),
  Digitizer_ (Digitizer, ::xml_schema::flags (), this),
  Magnitude_Height_ (Magnitude_Height, ::xml_schema::flags (), this),
  Saturation_ (Saturation, ::xml_schema::flags (), this),
  Length_Length_ (Length_Length, ::xml_schema::flags (), this),
  Frequency_Length_ (Frequency_Length, ::xml_schema::flags (), this),
  State_ (State, ::xml_schema::flags (), this),
  SV_Center_ (SV_Center, ::xml_schema::flags (), this),
  Continuous_RF_FrameRate_ (Continuous_RF_FrameRate, ::xml_schema::flags (), this),
  Quantify_Bounce_Test_ (Quantify_Bounce_Test, ::xml_schema::flags (), this),
  X_3D_Volume_ (X_3D_Volume, ::xml_schema::flags (), this),
  Shift_RF_Data_ (Shift_RF_Data, ::xml_schema::flags (), this),
  V_Lines_ (V_Lines, ::xml_schema::flags (), this),
  Graph_Mode_ (Graph_Mode, ::xml_schema::flags (), this),
  RF_Path_15Mhz_Time_Correction_ (RF_Path_15Mhz_Time_Correction, ::xml_schema::flags (), this),
  RF_Path_23Mhz_Time_Correction_ (RF_Path_23Mhz_Time_Correction, ::xml_schema::flags (), this),
  SV_Length_Limits_ (SV_Length_Limits, ::xml_schema::flags (), this)
{
}

RfModeSoft::
RfModeSoft (const RfModeSoft& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Amplitude_Height_ (x.Amplitude_Height_, f, this),
  Magnitude_Origin_ (x.Magnitude_Origin_, f, this),
  Frequency_Origin_ (x.Frequency_Origin_, f, this),
  Samples_ (x.Samples_, f, this),
  Saturation_Threshold_ (x.Saturation_Threshold_, f, this),
  Amplitude_Origin_ (x.Amplitude_Origin_, f, this),
  Frame_Selected_ (x.Frame_Selected_, f, this),
  AcqPerLine_ (x.AcqPerLine_, f, this),
  Lines_ (x.Lines_, f, this),
  Windowing_Mode_ (x.Windowing_Mode_, f, this),
  Length_Origin_ (x.Length_Origin_, f, this),
  Line_Selected_ (x.Line_Selected_, f, this),
  V_Lines_Pos_ (x.V_Lines_Pos_, f, this),
  Bounce_Test_AscanData_ (x.Bounce_Test_AscanData_, f, this),
  Vertical_Scale_ (x.Vertical_Scale_, f, this),
  Bounce_Test_RFData_ (x.Bounce_Test_RFData_, f, this),
  SamplesPerSec_ (x.SamplesPerSec_, f, this),
  Frames_ (x.Frames_, f, this),
  Digitizer_ (x.Digitizer_, f, this),
  Magnitude_Height_ (x.Magnitude_Height_, f, this),
  Saturation_ (x.Saturation_, f, this),
  Length_Length_ (x.Length_Length_, f, this),
  Frequency_Length_ (x.Frequency_Length_, f, this),
  State_ (x.State_, f, this),
  SV_Center_ (x.SV_Center_, f, this),
  Continuous_RF_FrameRate_ (x.Continuous_RF_FrameRate_, f, this),
  Quantify_Bounce_Test_ (x.Quantify_Bounce_Test_, f, this),
  X_3D_Volume_ (x.X_3D_Volume_, f, this),
  Shift_RF_Data_ (x.Shift_RF_Data_, f, this),
  V_Lines_ (x.V_Lines_, f, this),
  Graph_Mode_ (x.Graph_Mode_, f, this),
  RF_Path_15Mhz_Time_Correction_ (x.RF_Path_15Mhz_Time_Correction_, f, this),
  RF_Path_23Mhz_Time_Correction_ (x.RF_Path_23Mhz_Time_Correction_, f, this),
  SV_Length_Limits_ (x.SV_Length_Limits_, f, this)
{
}

RfModeSoft::
RfModeSoft (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Amplitude_Height_ (f, this),
  Magnitude_Origin_ (f, this),
  Frequency_Origin_ (f, this),
  Samples_ (f, this),
  Saturation_Threshold_ (f, this),
  Amplitude_Origin_ (f, this),
  Frame_Selected_ (f, this),
  AcqPerLine_ (f, this),
  Lines_ (f, this),
  Windowing_Mode_ (f, this),
  Length_Origin_ (f, this),
  Line_Selected_ (f, this),
  V_Lines_Pos_ (f, this),
  Bounce_Test_AscanData_ (f, this),
  Vertical_Scale_ (f, this),
  Bounce_Test_RFData_ (f, this),
  SamplesPerSec_ (f, this),
  Frames_ (f, this),
  Digitizer_ (f, this),
  Magnitude_Height_ (f, this),
  Saturation_ (f, this),
  Length_Length_ (f, this),
  Frequency_Length_ (f, this),
  State_ (f, this),
  SV_Center_ (f, this),
  Continuous_RF_FrameRate_ (f, this),
  Quantify_Bounce_Test_ (f, this),
  X_3D_Volume_ (f, this),
  Shift_RF_Data_ (f, this),
  V_Lines_ (f, this),
  Graph_Mode_ (f, this),
  RF_Path_15Mhz_Time_Correction_ (f, this),
  RF_Path_23Mhz_Time_Correction_ (f, this),
  SV_Length_Limits_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RfModeSoft::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Amplitude-Height
    //
    if (n.name () == "Amplitude-Height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Amplitude_Height_type > r (
        Amplitude_Height_traits::create (i, f, this));

      if (!Amplitude_Height_.present ())
      {
        this->Amplitude_Height_.set (r);
        continue;
      }
    }

    // Magnitude-Origin
    //
    if (n.name () == "Magnitude-Origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Magnitude_Origin_type > r (
        Magnitude_Origin_traits::create (i, f, this));

      if (!Magnitude_Origin_.present ())
      {
        this->Magnitude_Origin_.set (r);
        continue;
      }
    }

    // Frequency-Origin
    //
    if (n.name () == "Frequency-Origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Origin_type > r (
        Frequency_Origin_traits::create (i, f, this));

      if (!Frequency_Origin_.present ())
      {
        this->Frequency_Origin_.set (r);
        continue;
      }
    }

    // Samples
    //
    if (n.name () == "Samples" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Samples_type > r (
        Samples_traits::create (i, f, this));

      if (!Samples_.present ())
      {
        this->Samples_.set (r);
        continue;
      }
    }

    // Saturation-Threshold
    //
    if (n.name () == "Saturation-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Saturation_Threshold_type > r (
        Saturation_Threshold_traits::create (i, f, this));

      if (!Saturation_Threshold_.present ())
      {
        this->Saturation_Threshold_.set (r);
        continue;
      }
    }

    // Amplitude-Origin
    //
    if (n.name () == "Amplitude-Origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Amplitude_Origin_type > r (
        Amplitude_Origin_traits::create (i, f, this));

      if (!Amplitude_Origin_.present ())
      {
        this->Amplitude_Origin_.set (r);
        continue;
      }
    }

    // Frame-Selected
    //
    if (n.name () == "Frame-Selected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frame_Selected_type > r (
        Frame_Selected_traits::create (i, f, this));

      if (!Frame_Selected_.present ())
      {
        this->Frame_Selected_.set (r);
        continue;
      }
    }

    // AcqPerLine
    //
    if (n.name () == "AcqPerLine" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AcqPerLine_type > r (
        AcqPerLine_traits::create (i, f, this));

      if (!AcqPerLine_.present ())
      {
        this->AcqPerLine_.set (r);
        continue;
      }
    }

    // Lines
    //
    if (n.name () == "Lines" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lines_type > r (
        Lines_traits::create (i, f, this));

      if (!Lines_.present ())
      {
        this->Lines_.set (r);
        continue;
      }
    }

    // Windowing-Mode
    //
    if (n.name () == "Windowing-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Windowing_Mode_type > r (
        Windowing_Mode_traits::create (i, f, this));

      if (!Windowing_Mode_.present ())
      {
        this->Windowing_Mode_.set (r);
        continue;
      }
    }

    // Length-Origin
    //
    if (n.name () == "Length-Origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Length_Origin_type > r (
        Length_Origin_traits::create (i, f, this));

      if (!Length_Origin_.present ())
      {
        this->Length_Origin_.set (r);
        continue;
      }
    }

    // Line-Selected
    //
    if (n.name () == "Line-Selected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Line_Selected_type > r (
        Line_Selected_traits::create (i, f, this));

      if (!Line_Selected_.present ())
      {
        this->Line_Selected_.set (r);
        continue;
      }
    }

    // V-Lines-Pos
    //
    if (n.name () == "V-Lines-Pos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Lines_Pos_type > r (
        V_Lines_Pos_traits::create (i, f, this));

      if (!V_Lines_Pos_.present ())
      {
        this->V_Lines_Pos_.set (r);
        continue;
      }
    }

    // Bounce-Test-AscanData
    //
    if (n.name () == "Bounce-Test-AscanData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Bounce_Test_AscanData_type > r (
        Bounce_Test_AscanData_traits::create (i, f, this));

      if (!Bounce_Test_AscanData_.present ())
      {
        this->Bounce_Test_AscanData_.set (r);
        continue;
      }
    }

    // Vertical-Scale
    //
    if (n.name () == "Vertical-Scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Vertical_Scale_type > r (
        Vertical_Scale_traits::create (i, f, this));

      if (!Vertical_Scale_.present ())
      {
        this->Vertical_Scale_.set (r);
        continue;
      }
    }

    // Bounce-Test-RFData
    //
    if (n.name () == "Bounce-Test-RFData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Bounce_Test_RFData_type > r (
        Bounce_Test_RFData_traits::create (i, f, this));

      if (!Bounce_Test_RFData_.present ())
      {
        this->Bounce_Test_RFData_.set (r);
        continue;
      }
    }

    // SamplesPerSec
    //
    if (n.name () == "SamplesPerSec" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SamplesPerSec_type > r (
        SamplesPerSec_traits::create (i, f, this));

      if (!SamplesPerSec_.present ())
      {
        this->SamplesPerSec_.set (r);
        continue;
      }
    }

    // Frames
    //
    if (n.name () == "Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frames_type > r (
        Frames_traits::create (i, f, this));

      if (!Frames_.present ())
      {
        this->Frames_.set (r);
        continue;
      }
    }

    // Digitizer
    //
    if (n.name () == "Digitizer" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Digitizer_type > r (
        Digitizer_traits::create (i, f, this));

      if (!Digitizer_.present ())
      {
        this->Digitizer_.set (r);
        continue;
      }
    }

    // Magnitude-Height
    //
    if (n.name () == "Magnitude-Height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Magnitude_Height_type > r (
        Magnitude_Height_traits::create (i, f, this));

      if (!Magnitude_Height_.present ())
      {
        this->Magnitude_Height_.set (r);
        continue;
      }
    }

    // Saturation
    //
    if (n.name () == "Saturation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Saturation_type > r (
        Saturation_traits::create (i, f, this));

      if (!Saturation_.present ())
      {
        this->Saturation_.set (r);
        continue;
      }
    }

    // Length-Length
    //
    if (n.name () == "Length-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Length_Length_type > r (
        Length_Length_traits::create (i, f, this));

      if (!Length_Length_.present ())
      {
        this->Length_Length_.set (r);
        continue;
      }
    }

    // Frequency-Length
    //
    if (n.name () == "Frequency-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Length_type > r (
        Frequency_Length_traits::create (i, f, this));

      if (!Frequency_Length_.present ())
      {
        this->Frequency_Length_.set (r);
        continue;
      }
    }

    // State
    //
    if (n.name () == "State" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< State_type > r (
        State_traits::create (i, f, this));

      if (!State_.present ())
      {
        this->State_.set (r);
        continue;
      }
    }

    // SV-Center
    //
    if (n.name () == "SV-Center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SV_Center_type > r (
        SV_Center_traits::create (i, f, this));

      if (!SV_Center_.present ())
      {
        this->SV_Center_.set (r);
        continue;
      }
    }

    // Continuous-RF-FrameRate
    //
    if (n.name () == "Continuous-RF-FrameRate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Continuous_RF_FrameRate_type > r (
        Continuous_RF_FrameRate_traits::create (i, f, this));

      if (!Continuous_RF_FrameRate_.present ())
      {
        this->Continuous_RF_FrameRate_.set (r);
        continue;
      }
    }

    // Quantify-Bounce-Test
    //
    if (n.name () == "Quantify-Bounce-Test" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Quantify_Bounce_Test_type > r (
        Quantify_Bounce_Test_traits::create (i, f, this));

      if (!Quantify_Bounce_Test_.present ())
      {
        this->Quantify_Bounce_Test_.set (r);
        continue;
      }
    }

    // X_3D-Volume
    //
    if (n.name () == "X_3D-Volume" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Volume_type > r (
        X_3D_Volume_traits::create (i, f, this));

      if (!X_3D_Volume_.present ())
      {
        this->X_3D_Volume_.set (r);
        continue;
      }
    }

    // Shift-RF-Data
    //
    if (n.name () == "Shift-RF-Data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Shift_RF_Data_type > r (
        Shift_RF_Data_traits::create (i, f, this));

      if (!Shift_RF_Data_.present ())
      {
        this->Shift_RF_Data_.set (r);
        continue;
      }
    }

    // V-Lines
    //
    if (n.name () == "V-Lines" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Lines_type > r (
        V_Lines_traits::create (i, f, this));

      if (!V_Lines_.present ())
      {
        this->V_Lines_.set (r);
        continue;
      }
    }

    // Graph-Mode
    //
    if (n.name () == "Graph-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Graph_Mode_type > r (
        Graph_Mode_traits::create (i, f, this));

      if (!Graph_Mode_.present ())
      {
        this->Graph_Mode_.set (r);
        continue;
      }
    }

    // RF-Path-15Mhz-Time-Correction
    //
    if (n.name () == "RF-Path-15Mhz-Time-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Path_15Mhz_Time_Correction_type > r (
        RF_Path_15Mhz_Time_Correction_traits::create (i, f, this));

      if (!RF_Path_15Mhz_Time_Correction_.present ())
      {
        this->RF_Path_15Mhz_Time_Correction_.set (r);
        continue;
      }
    }

    // RF-Path-23Mhz-Time-Correction
    //
    if (n.name () == "RF-Path-23Mhz-Time-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Path_23Mhz_Time_Correction_type > r (
        RF_Path_23Mhz_Time_Correction_traits::create (i, f, this));

      if (!RF_Path_23Mhz_Time_Correction_.present ())
      {
        this->RF_Path_23Mhz_Time_Correction_.set (r);
        continue;
      }
    }

    // SV-Length-Limits
    //
    if (n.name () == "SV-Length-Limits" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SV_Length_Limits_type > r (
        SV_Length_Limits_traits::create (i, f, this));

      if (!SV_Length_Limits_.present ())
      {
        this->SV_Length_Limits_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Amplitude_Height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Amplitude-Height",
      "");
  }

  if (!Magnitude_Origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Magnitude-Origin",
      "");
  }

  if (!Frequency_Origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Origin",
      "");
  }

  if (!Samples_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Samples",
      "");
  }

  if (!Saturation_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Saturation-Threshold",
      "");
  }

  if (!Amplitude_Origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Amplitude-Origin",
      "");
  }

  if (!Frame_Selected_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frame-Selected",
      "");
  }

  if (!AcqPerLine_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AcqPerLine",
      "");
  }

  if (!Lines_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lines",
      "");
  }

  if (!Windowing_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Windowing-Mode",
      "");
  }

  if (!Length_Origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Length-Origin",
      "");
  }

  if (!Line_Selected_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Line-Selected",
      "");
  }

  if (!V_Lines_Pos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Lines-Pos",
      "");
  }

  if (!Bounce_Test_AscanData_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Bounce-Test-AscanData",
      "");
  }

  if (!Vertical_Scale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Vertical-Scale",
      "");
  }

  if (!Bounce_Test_RFData_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Bounce-Test-RFData",
      "");
  }

  if (!SamplesPerSec_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SamplesPerSec",
      "");
  }

  if (!Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frames",
      "");
  }

  if (!Digitizer_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Digitizer",
      "");
  }

  if (!Magnitude_Height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Magnitude-Height",
      "");
  }

  if (!Saturation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Saturation",
      "");
  }

  if (!Length_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Length-Length",
      "");
  }

  if (!Frequency_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Length",
      "");
  }

  if (!State_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "State",
      "");
  }

  if (!SV_Center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SV-Center",
      "");
  }

  if (!Continuous_RF_FrameRate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Continuous-RF-FrameRate",
      "");
  }

  if (!Quantify_Bounce_Test_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Quantify-Bounce-Test",
      "");
  }

  if (!X_3D_Volume_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Volume",
      "");
  }

  if (!Shift_RF_Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Shift-RF-Data",
      "");
  }

  if (!V_Lines_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Lines",
      "");
  }

  if (!Graph_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Graph-Mode",
      "");
  }

  if (!RF_Path_15Mhz_Time_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Path-15Mhz-Time-Correction",
      "");
  }

  if (!RF_Path_23Mhz_Time_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Path-23Mhz-Time-Correction",
      "");
  }

  if (!SV_Length_Limits_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SV-Length-Limits",
      "");
  }
}

RfModeSoft* RfModeSoft::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RfModeSoft (*this, f, c);
}

RfModeSoft::
~RfModeSoft ()
{
}

// TX
//

TX::
TX (const V_Position_Table_type& V_Position_Table,
    const V_Transmit_Length_type& V_Transmit_Length,
    const Trigger_Counter_Clear_type& Trigger_Counter_Clear,
    const Trigger_Counter_type& Trigger_Counter,
    const Multi_Trigger_Freq_type& Multi_Trigger_Freq,
    const RF_Amp_type& RF_Amp,
    const Trigger_Control_type& Trigger_Control,
    const V_Pulse_Rep_Freq_type& V_Pulse_Rep_Freq,
    const Phase_type& Phase,
    const Frequency_type& Frequency,
    const V_Unblank_Time_type& V_Unblank_Time,
    const V_Frequency_type& V_Frequency,
    const Pulse_Rep_Frequency_type& Pulse_Rep_Frequency,
    const Multi_Trigger_type& Multi_Trigger,
    const Trig_Tbl_Trigs_type& Trig_Tbl_Trigs,
    const Width_type& Width,
    const Unblank_Cycles_type& Unblank_Cycles,
    const V_Width_type& V_Width,
    const Unblank_Time_type& Unblank_Time,
    const Attenuation_type& Attenuation,
    const V_Power_type& V_Power,
    const Computer_Trigger_type& Computer_Trigger)
: ::xml_schema::type (),
  V_Position_Table_ (V_Position_Table, ::xml_schema::flags (), this),
  V_Transmit_Length_ (V_Transmit_Length, ::xml_schema::flags (), this),
  Trigger_Counter_Clear_ (Trigger_Counter_Clear, ::xml_schema::flags (), this),
  Trigger_Counter_ (Trigger_Counter, ::xml_schema::flags (), this),
  Multi_Trigger_Freq_ (Multi_Trigger_Freq, ::xml_schema::flags (), this),
  RF_Amp_ (RF_Amp, ::xml_schema::flags (), this),
  Trigger_Control_ (Trigger_Control, ::xml_schema::flags (), this),
  V_Pulse_Rep_Freq_ (V_Pulse_Rep_Freq, ::xml_schema::flags (), this),
  Phase_ (Phase, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Unblank_Time_ (V_Unblank_Time, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  Pulse_Rep_Frequency_ (Pulse_Rep_Frequency, ::xml_schema::flags (), this),
  Multi_Trigger_ (Multi_Trigger, ::xml_schema::flags (), this),
  Trig_Tbl_Trigs_ (Trig_Tbl_Trigs, ::xml_schema::flags (), this),
  Width_ (Width, ::xml_schema::flags (), this),
  Unblank_Cycles_ (Unblank_Cycles, ::xml_schema::flags (), this),
  V_Width_ (V_Width, ::xml_schema::flags (), this),
  Unblank_Time_ (Unblank_Time, ::xml_schema::flags (), this),
  Attenuation_ (Attenuation, ::xml_schema::flags (), this),
  V_Power_ (V_Power, ::xml_schema::flags (), this),
  Computer_Trigger_ (Computer_Trigger, ::xml_schema::flags (), this)
{
}

TX::
TX (const V_Position_Table_type& V_Position_Table,
    ::std::auto_ptr< V_Transmit_Length_type >& V_Transmit_Length,
    const Trigger_Counter_Clear_type& Trigger_Counter_Clear,
    const Trigger_Counter_type& Trigger_Counter,
    const Multi_Trigger_Freq_type& Multi_Trigger_Freq,
    const RF_Amp_type& RF_Amp,
    const Trigger_Control_type& Trigger_Control,
    ::std::auto_ptr< V_Pulse_Rep_Freq_type >& V_Pulse_Rep_Freq,
    const Phase_type& Phase,
    ::std::auto_ptr< Frequency_type >& Frequency,
    ::std::auto_ptr< V_Unblank_Time_type >& V_Unblank_Time,
    ::std::auto_ptr< V_Frequency_type >& V_Frequency,
    ::std::auto_ptr< Pulse_Rep_Frequency_type >& Pulse_Rep_Frequency,
    const Multi_Trigger_type& Multi_Trigger,
    ::std::auto_ptr< Trig_Tbl_Trigs_type >& Trig_Tbl_Trigs,
    const Width_type& Width,
    ::std::auto_ptr< Unblank_Cycles_type >& Unblank_Cycles,
    const V_Width_type& V_Width,
    ::std::auto_ptr< Unblank_Time_type >& Unblank_Time,
    ::std::auto_ptr< Attenuation_type >& Attenuation,
    ::std::auto_ptr< V_Power_type >& V_Power,
    const Computer_Trigger_type& Computer_Trigger)
: ::xml_schema::type (),
  V_Position_Table_ (V_Position_Table, ::xml_schema::flags (), this),
  V_Transmit_Length_ (V_Transmit_Length, ::xml_schema::flags (), this),
  Trigger_Counter_Clear_ (Trigger_Counter_Clear, ::xml_schema::flags (), this),
  Trigger_Counter_ (Trigger_Counter, ::xml_schema::flags (), this),
  Multi_Trigger_Freq_ (Multi_Trigger_Freq, ::xml_schema::flags (), this),
  RF_Amp_ (RF_Amp, ::xml_schema::flags (), this),
  Trigger_Control_ (Trigger_Control, ::xml_schema::flags (), this),
  V_Pulse_Rep_Freq_ (V_Pulse_Rep_Freq, ::xml_schema::flags (), this),
  Phase_ (Phase, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Unblank_Time_ (V_Unblank_Time, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  Pulse_Rep_Frequency_ (Pulse_Rep_Frequency, ::xml_schema::flags (), this),
  Multi_Trigger_ (Multi_Trigger, ::xml_schema::flags (), this),
  Trig_Tbl_Trigs_ (Trig_Tbl_Trigs, ::xml_schema::flags (), this),
  Width_ (Width, ::xml_schema::flags (), this),
  Unblank_Cycles_ (Unblank_Cycles, ::xml_schema::flags (), this),
  V_Width_ (V_Width, ::xml_schema::flags (), this),
  Unblank_Time_ (Unblank_Time, ::xml_schema::flags (), this),
  Attenuation_ (Attenuation, ::xml_schema::flags (), this),
  V_Power_ (V_Power, ::xml_schema::flags (), this),
  Computer_Trigger_ (Computer_Trigger, ::xml_schema::flags (), this)
{
}

TX::
TX (const TX& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  V_Position_Table_ (x.V_Position_Table_, f, this),
  V_Transmit_Length_ (x.V_Transmit_Length_, f, this),
  Trigger_Counter_Clear_ (x.Trigger_Counter_Clear_, f, this),
  Trigger_Counter_ (x.Trigger_Counter_, f, this),
  Multi_Trigger_Freq_ (x.Multi_Trigger_Freq_, f, this),
  RF_Amp_ (x.RF_Amp_, f, this),
  Trigger_Control_ (x.Trigger_Control_, f, this),
  V_Pulse_Rep_Freq_ (x.V_Pulse_Rep_Freq_, f, this),
  Phase_ (x.Phase_, f, this),
  Frequency_ (x.Frequency_, f, this),
  V_Unblank_Time_ (x.V_Unblank_Time_, f, this),
  V_Frequency_ (x.V_Frequency_, f, this),
  Pulse_Rep_Frequency_ (x.Pulse_Rep_Frequency_, f, this),
  Multi_Trigger_ (x.Multi_Trigger_, f, this),
  Trig_Tbl_Trigs_ (x.Trig_Tbl_Trigs_, f, this),
  Width_ (x.Width_, f, this),
  Unblank_Cycles_ (x.Unblank_Cycles_, f, this),
  V_Width_ (x.V_Width_, f, this),
  Unblank_Time_ (x.Unblank_Time_, f, this),
  Attenuation_ (x.Attenuation_, f, this),
  V_Power_ (x.V_Power_, f, this),
  Computer_Trigger_ (x.Computer_Trigger_, f, this)
{
}

TX::
TX (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  V_Position_Table_ (f, this),
  V_Transmit_Length_ (f, this),
  Trigger_Counter_Clear_ (f, this),
  Trigger_Counter_ (f, this),
  Multi_Trigger_Freq_ (f, this),
  RF_Amp_ (f, this),
  Trigger_Control_ (f, this),
  V_Pulse_Rep_Freq_ (f, this),
  Phase_ (f, this),
  Frequency_ (f, this),
  V_Unblank_Time_ (f, this),
  V_Frequency_ (f, this),
  Pulse_Rep_Frequency_ (f, this),
  Multi_Trigger_ (f, this),
  Trig_Tbl_Trigs_ (f, this),
  Width_ (f, this),
  Unblank_Cycles_ (f, this),
  V_Width_ (f, this),
  Unblank_Time_ (f, this),
  Attenuation_ (f, this),
  V_Power_ (f, this),
  Computer_Trigger_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void TX::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // V-Position-Table
    //
    if (n.name () == "V-Position-Table" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Position_Table_type > r (
        V_Position_Table_traits::create (i, f, this));

      if (!V_Position_Table_.present ())
      {
        this->V_Position_Table_.set (r);
        continue;
      }
    }

    // V-Transmit-Length
    //
    if (n.name () == "V-Transmit-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Transmit_Length_type > r (
        V_Transmit_Length_traits::create (i, f, this));

      if (!V_Transmit_Length_.present ())
      {
        this->V_Transmit_Length_.set (r);
        continue;
      }
    }

    // Trigger-Counter-Clear
    //
    if (n.name () == "Trigger-Counter-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Counter_Clear_type > r (
        Trigger_Counter_Clear_traits::create (i, f, this));

      if (!Trigger_Counter_Clear_.present ())
      {
        this->Trigger_Counter_Clear_.set (r);
        continue;
      }
    }

    // Trigger-Counter
    //
    if (n.name () == "Trigger-Counter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Counter_type > r (
        Trigger_Counter_traits::create (i, f, this));

      if (!Trigger_Counter_.present ())
      {
        this->Trigger_Counter_.set (r);
        continue;
      }
    }

    // Multi-Trigger-Freq
    //
    if (n.name () == "Multi-Trigger-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Multi_Trigger_Freq_type > r (
        Multi_Trigger_Freq_traits::create (i, f, this));

      if (!Multi_Trigger_Freq_.present ())
      {
        this->Multi_Trigger_Freq_.set (r);
        continue;
      }
    }

    // RF-Amp
    //
    if (n.name () == "RF-Amp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Amp_type > r (
        RF_Amp_traits::create (i, f, this));

      if (!RF_Amp_.present ())
      {
        this->RF_Amp_.set (r);
        continue;
      }
    }

    // Trigger-Control
    //
    if (n.name () == "Trigger-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Control_type > r (
        Trigger_Control_traits::create (i, f, this));

      if (!Trigger_Control_.present ())
      {
        this->Trigger_Control_.set (r);
        continue;
      }
    }

    // V-Pulse-Rep-Freq
    //
    if (n.name () == "V-Pulse-Rep-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Pulse_Rep_Freq_type > r (
        V_Pulse_Rep_Freq_traits::create (i, f, this));

      if (!V_Pulse_Rep_Freq_.present ())
      {
        this->V_Pulse_Rep_Freq_.set (r);
        continue;
      }
    }

    // Phase
    //
    if (n.name () == "Phase" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Phase_type > r (
        Phase_traits::create (i, f, this));

      if (!Phase_.present ())
      {
        this->Phase_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // V-Unblank-Time
    //
    if (n.name () == "V-Unblank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Unblank_Time_type > r (
        V_Unblank_Time_traits::create (i, f, this));

      if (!V_Unblank_Time_.present ())
      {
        this->V_Unblank_Time_.set (r);
        continue;
      }
    }

    // V-Frequency
    //
    if (n.name () == "V-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Frequency_type > r (
        V_Frequency_traits::create (i, f, this));

      if (!V_Frequency_.present ())
      {
        this->V_Frequency_.set (r);
        continue;
      }
    }

    // Pulse-Rep-Frequency
    //
    if (n.name () == "Pulse-Rep-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pulse_Rep_Frequency_type > r (
        Pulse_Rep_Frequency_traits::create (i, f, this));

      if (!Pulse_Rep_Frequency_.present ())
      {
        this->Pulse_Rep_Frequency_.set (r);
        continue;
      }
    }

    // Multi-Trigger
    //
    if (n.name () == "Multi-Trigger" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Multi_Trigger_type > r (
        Multi_Trigger_traits::create (i, f, this));

      if (!Multi_Trigger_.present ())
      {
        this->Multi_Trigger_.set (r);
        continue;
      }
    }

    // Trig-Tbl-Trigs
    //
    if (n.name () == "Trig-Tbl-Trigs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trig_Tbl_Trigs_type > r (
        Trig_Tbl_Trigs_traits::create (i, f, this));

      if (!Trig_Tbl_Trigs_.present ())
      {
        this->Trig_Tbl_Trigs_.set (r);
        continue;
      }
    }

    // Width
    //
    if (n.name () == "Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Width_type > r (
        Width_traits::create (i, f, this));

      if (!Width_.present ())
      {
        this->Width_.set (r);
        continue;
      }
    }

    // Unblank-Cycles
    //
    if (n.name () == "Unblank-Cycles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unblank_Cycles_type > r (
        Unblank_Cycles_traits::create (i, f, this));

      if (!Unblank_Cycles_.present ())
      {
        this->Unblank_Cycles_.set (r);
        continue;
      }
    }

    // V-Width
    //
    if (n.name () == "V-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Width_type > r (
        V_Width_traits::create (i, f, this));

      if (!V_Width_.present ())
      {
        this->V_Width_.set (r);
        continue;
      }
    }

    // Unblank-Time
    //
    if (n.name () == "Unblank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unblank_Time_type > r (
        Unblank_Time_traits::create (i, f, this));

      if (!Unblank_Time_.present ())
      {
        this->Unblank_Time_.set (r);
        continue;
      }
    }

    // Attenuation
    //
    if (n.name () == "Attenuation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attenuation_type > r (
        Attenuation_traits::create (i, f, this));

      if (!Attenuation_.present ())
      {
        this->Attenuation_.set (r);
        continue;
      }
    }

    // V-Power
    //
    if (n.name () == "V-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Power_type > r (
        V_Power_traits::create (i, f, this));

      if (!V_Power_.present ())
      {
        this->V_Power_.set (r);
        continue;
      }
    }

    // Computer-Trigger
    //
    if (n.name () == "Computer-Trigger" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Computer_Trigger_type > r (
        Computer_Trigger_traits::create (i, f, this));

      if (!Computer_Trigger_.present ())
      {
        this->Computer_Trigger_.set (r);
        continue;
      }
    }

    break;
  }

  if (!V_Position_Table_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Position-Table",
      "");
  }

  if (!V_Transmit_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Transmit-Length",
      "");
  }

  if (!Trigger_Counter_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Counter-Clear",
      "");
  }

  if (!Trigger_Counter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Counter",
      "");
  }

  if (!Multi_Trigger_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Multi-Trigger-Freq",
      "");
  }

  if (!RF_Amp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Amp",
      "");
  }

  if (!Trigger_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Control",
      "");
  }

  if (!V_Pulse_Rep_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Pulse-Rep-Freq",
      "");
  }

  if (!Phase_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Phase",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!V_Unblank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Unblank-Time",
      "");
  }

  if (!V_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Frequency",
      "");
  }

  if (!Pulse_Rep_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pulse-Rep-Frequency",
      "");
  }

  if (!Multi_Trigger_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Multi-Trigger",
      "");
  }

  if (!Trig_Tbl_Trigs_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trig-Tbl-Trigs",
      "");
  }

  if (!Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Width",
      "");
  }

  if (!Unblank_Cycles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Unblank-Cycles",
      "");
  }

  if (!V_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Width",
      "");
  }

  if (!Unblank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Unblank-Time",
      "");
  }

  if (!Attenuation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Attenuation",
      "");
  }

  if (!V_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Power",
      "");
  }

  if (!Computer_Trigger_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Computer-Trigger",
      "");
  }
}

TX* TX::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TX (*this, f, c);
}

TX::
~TX ()
{
}

// X_3D
//

X_3D::
X_3D (const Speed_type& Speed,
      const Status_type& Status,
      const Motor_Enable_type& Motor_Enable,
      const Scan_Distance_type& Scan_Distance,
      const Error_type& Error,
      const Steps_type& Steps,
      const Max_Scan_Steps_type& Max_Scan_Steps,
      const Position_type& Position,
      const Action_type& Action,
      const Clear_Error_type& Clear_Error,
      const Direction_type& Direction,
      const Step_Size_type& Step_Size)
: ::xml_schema::type (),
  Speed_ (Speed, ::xml_schema::flags (), this),
  Status_ (Status, ::xml_schema::flags (), this),
  Motor_Enable_ (Motor_Enable, ::xml_schema::flags (), this),
  Scan_Distance_ (Scan_Distance, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Max_Scan_Steps_ (Max_Scan_Steps, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  Action_ (Action, ::xml_schema::flags (), this),
  Clear_Error_ (Clear_Error, ::xml_schema::flags (), this),
  Direction_ (Direction, ::xml_schema::flags (), this),
  Step_Size_ (Step_Size, ::xml_schema::flags (), this)
{
}

X_3D::
X_3D (const Speed_type& Speed,
      const Status_type& Status,
      const Motor_Enable_type& Motor_Enable,
      ::std::auto_ptr< Scan_Distance_type >& Scan_Distance,
      const Error_type& Error,
      const Steps_type& Steps,
      const Max_Scan_Steps_type& Max_Scan_Steps,
      const Position_type& Position,
      const Action_type& Action,
      const Clear_Error_type& Clear_Error,
      const Direction_type& Direction,
      ::std::auto_ptr< Step_Size_type >& Step_Size)
: ::xml_schema::type (),
  Speed_ (Speed, ::xml_schema::flags (), this),
  Status_ (Status, ::xml_schema::flags (), this),
  Motor_Enable_ (Motor_Enable, ::xml_schema::flags (), this),
  Scan_Distance_ (Scan_Distance, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Max_Scan_Steps_ (Max_Scan_Steps, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  Action_ (Action, ::xml_schema::flags (), this),
  Clear_Error_ (Clear_Error, ::xml_schema::flags (), this),
  Direction_ (Direction, ::xml_schema::flags (), this),
  Step_Size_ (Step_Size, ::xml_schema::flags (), this)
{
}

X_3D::
X_3D (const X_3D& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Speed_ (x.Speed_, f, this),
  Status_ (x.Status_, f, this),
  Motor_Enable_ (x.Motor_Enable_, f, this),
  Scan_Distance_ (x.Scan_Distance_, f, this),
  Error_ (x.Error_, f, this),
  Steps_ (x.Steps_, f, this),
  Max_Scan_Steps_ (x.Max_Scan_Steps_, f, this),
  Position_ (x.Position_, f, this),
  Action_ (x.Action_, f, this),
  Clear_Error_ (x.Clear_Error_, f, this),
  Direction_ (x.Direction_, f, this),
  Step_Size_ (x.Step_Size_, f, this)
{
}

X_3D::
X_3D (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Speed_ (f, this),
  Status_ (f, this),
  Motor_Enable_ (f, this),
  Scan_Distance_ (f, this),
  Error_ (f, this),
  Steps_ (f, this),
  Max_Scan_Steps_ (f, this),
  Position_ (f, this),
  Action_ (f, this),
  Clear_Error_ (f, this),
  Direction_ (f, this),
  Step_Size_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void X_3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Speed
    //
    if (n.name () == "Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Speed_type > r (
        Speed_traits::create (i, f, this));

      if (!Speed_.present ())
      {
        this->Speed_.set (r);
        continue;
      }
    }

    // Status
    //
    if (n.name () == "Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Status_type > r (
        Status_traits::create (i, f, this));

      if (!Status_.present ())
      {
        this->Status_.set (r);
        continue;
      }
    }

    // Motor-Enable
    //
    if (n.name () == "Motor-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Enable_type > r (
        Motor_Enable_traits::create (i, f, this));

      if (!Motor_Enable_.present ())
      {
        this->Motor_Enable_.set (r);
        continue;
      }
    }

    // Scan-Distance
    //
    if (n.name () == "Scan-Distance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Distance_type > r (
        Scan_Distance_traits::create (i, f, this));

      if (!Scan_Distance_.present ())
      {
        this->Scan_Distance_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // Steps
    //
    if (n.name () == "Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Steps_type > r (
        Steps_traits::create (i, f, this));

      if (!Steps_.present ())
      {
        this->Steps_.set (r);
        continue;
      }
    }

    // Max-Scan-Steps
    //
    if (n.name () == "Max-Scan-Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Scan_Steps_type > r (
        Max_Scan_Steps_traits::create (i, f, this));

      if (!Max_Scan_Steps_.present ())
      {
        this->Max_Scan_Steps_.set (r);
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (r);
        continue;
      }
    }

    // Action
    //
    if (n.name () == "Action" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Action_type > r (
        Action_traits::create (i, f, this));

      if (!Action_.present ())
      {
        this->Action_.set (r);
        continue;
      }
    }

    // Clear-Error
    //
    if (n.name () == "Clear-Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Clear_Error_type > r (
        Clear_Error_traits::create (i, f, this));

      if (!Clear_Error_.present ())
      {
        this->Clear_Error_.set (r);
        continue;
      }
    }

    // Direction
    //
    if (n.name () == "Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Direction_type > r (
        Direction_traits::create (i, f, this));

      if (!Direction_.present ())
      {
        this->Direction_.set (r);
        continue;
      }
    }

    // Step-Size
    //
    if (n.name () == "Step-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Step_Size_type > r (
        Step_Size_traits::create (i, f, this));

      if (!Step_Size_.present ())
      {
        this->Step_Size_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Speed",
      "");
  }

  if (!Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Status",
      "");
  }

  if (!Motor_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Enable",
      "");
  }

  if (!Scan_Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Distance",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Steps",
      "");
  }

  if (!Max_Scan_Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Scan-Steps",
      "");
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!Action_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Action",
      "");
  }

  if (!Clear_Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Clear-Error",
      "");
  }

  if (!Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Direction",
      "");
  }

  if (!Step_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Step-Size",
      "");
  }
}

X_3D* X_3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class X_3D (*this, f, c);
}

X_3D::
~X_3D ()
{
}

// RfAnalysis
//

RfAnalysis::
RfAnalysis (const Reference_type& Reference,
            const Ref_Probe_F_Number_type& Ref_Probe_F_Number,
            const Ref_Probe_Focal_Length_type& Ref_Probe_Focal_Length,
            const Ref_Tx_Frequency_type& Ref_Tx_Frequency,
            const Freq_Range_type& Freq_Range,
            const Ref_Probe_Name_type& Ref_Probe_Name,
            const Graph_Mode_type& Graph_Mode,
            const Normalized_Height_type& Normalized_Height,
            const Ref_Tx_Width_type& Ref_Tx_Width,
            const Normalized_Origin_type& Normalized_Origin,
            const Freq_Range_f_type& Freq_Range_f,
            const FFT_Offset_type& FFT_Offset,
            const Ref_Tx_Power_type& Ref_Tx_Power,
            const Freq_Range_Max_type& Freq_Range_Max,
            const Freq_Range_Min_type& Freq_Range_Min,
            const Ref_Offset_type& Ref_Offset)
: ::xml_schema::type (),
  Reference_ (Reference, ::xml_schema::flags (), this),
  Ref_Probe_F_Number_ (Ref_Probe_F_Number, ::xml_schema::flags (), this),
  Ref_Probe_Focal_Length_ (Ref_Probe_Focal_Length, ::xml_schema::flags (), this),
  Ref_Tx_Frequency_ (Ref_Tx_Frequency, ::xml_schema::flags (), this),
  Freq_Range_ (Freq_Range, ::xml_schema::flags (), this),
  Ref_Probe_Name_ (Ref_Probe_Name, ::xml_schema::flags (), this),
  Graph_Mode_ (Graph_Mode, ::xml_schema::flags (), this),
  Normalized_Height_ (Normalized_Height, ::xml_schema::flags (), this),
  Ref_Tx_Width_ (Ref_Tx_Width, ::xml_schema::flags (), this),
  Normalized_Origin_ (Normalized_Origin, ::xml_schema::flags (), this),
  Freq_Range_f_ (Freq_Range_f, ::xml_schema::flags (), this),
  FFT_Offset_ (FFT_Offset, ::xml_schema::flags (), this),
  Ref_Tx_Power_ (Ref_Tx_Power, ::xml_schema::flags (), this),
  Freq_Range_Max_ (Freq_Range_Max, ::xml_schema::flags (), this),
  Freq_Range_Min_ (Freq_Range_Min, ::xml_schema::flags (), this),
  Ref_Offset_ (Ref_Offset, ::xml_schema::flags (), this)
{
}

RfAnalysis::
RfAnalysis (const Reference_type& Reference,
            const Ref_Probe_F_Number_type& Ref_Probe_F_Number,
            ::std::auto_ptr< Ref_Probe_Focal_Length_type >& Ref_Probe_Focal_Length,
            ::std::auto_ptr< Ref_Tx_Frequency_type >& Ref_Tx_Frequency,
            const Freq_Range_type& Freq_Range,
            const Ref_Probe_Name_type& Ref_Probe_Name,
            const Graph_Mode_type& Graph_Mode,
            ::std::auto_ptr< Normalized_Height_type >& Normalized_Height,
            const Ref_Tx_Width_type& Ref_Tx_Width,
            ::std::auto_ptr< Normalized_Origin_type >& Normalized_Origin,
            const Freq_Range_f_type& Freq_Range_f,
            const FFT_Offset_type& FFT_Offset,
            ::std::auto_ptr< Ref_Tx_Power_type >& Ref_Tx_Power,
            ::std::auto_ptr< Freq_Range_Max_type >& Freq_Range_Max,
            ::std::auto_ptr< Freq_Range_Min_type >& Freq_Range_Min,
            const Ref_Offset_type& Ref_Offset)
: ::xml_schema::type (),
  Reference_ (Reference, ::xml_schema::flags (), this),
  Ref_Probe_F_Number_ (Ref_Probe_F_Number, ::xml_schema::flags (), this),
  Ref_Probe_Focal_Length_ (Ref_Probe_Focal_Length, ::xml_schema::flags (), this),
  Ref_Tx_Frequency_ (Ref_Tx_Frequency, ::xml_schema::flags (), this),
  Freq_Range_ (Freq_Range, ::xml_schema::flags (), this),
  Ref_Probe_Name_ (Ref_Probe_Name, ::xml_schema::flags (), this),
  Graph_Mode_ (Graph_Mode, ::xml_schema::flags (), this),
  Normalized_Height_ (Normalized_Height, ::xml_schema::flags (), this),
  Ref_Tx_Width_ (Ref_Tx_Width, ::xml_schema::flags (), this),
  Normalized_Origin_ (Normalized_Origin, ::xml_schema::flags (), this),
  Freq_Range_f_ (Freq_Range_f, ::xml_schema::flags (), this),
  FFT_Offset_ (FFT_Offset, ::xml_schema::flags (), this),
  Ref_Tx_Power_ (Ref_Tx_Power, ::xml_schema::flags (), this),
  Freq_Range_Max_ (Freq_Range_Max, ::xml_schema::flags (), this),
  Freq_Range_Min_ (Freq_Range_Min, ::xml_schema::flags (), this),
  Ref_Offset_ (Ref_Offset, ::xml_schema::flags (), this)
{
}

RfAnalysis::
RfAnalysis (const RfAnalysis& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Reference_ (x.Reference_, f, this),
  Ref_Probe_F_Number_ (x.Ref_Probe_F_Number_, f, this),
  Ref_Probe_Focal_Length_ (x.Ref_Probe_Focal_Length_, f, this),
  Ref_Tx_Frequency_ (x.Ref_Tx_Frequency_, f, this),
  Freq_Range_ (x.Freq_Range_, f, this),
  Ref_Probe_Name_ (x.Ref_Probe_Name_, f, this),
  Graph_Mode_ (x.Graph_Mode_, f, this),
  Normalized_Height_ (x.Normalized_Height_, f, this),
  Ref_Tx_Width_ (x.Ref_Tx_Width_, f, this),
  Normalized_Origin_ (x.Normalized_Origin_, f, this),
  Freq_Range_f_ (x.Freq_Range_f_, f, this),
  FFT_Offset_ (x.FFT_Offset_, f, this),
  Ref_Tx_Power_ (x.Ref_Tx_Power_, f, this),
  Freq_Range_Max_ (x.Freq_Range_Max_, f, this),
  Freq_Range_Min_ (x.Freq_Range_Min_, f, this),
  Ref_Offset_ (x.Ref_Offset_, f, this)
{
}

RfAnalysis::
RfAnalysis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Reference_ (f, this),
  Ref_Probe_F_Number_ (f, this),
  Ref_Probe_Focal_Length_ (f, this),
  Ref_Tx_Frequency_ (f, this),
  Freq_Range_ (f, this),
  Ref_Probe_Name_ (f, this),
  Graph_Mode_ (f, this),
  Normalized_Height_ (f, this),
  Ref_Tx_Width_ (f, this),
  Normalized_Origin_ (f, this),
  Freq_Range_f_ (f, this),
  FFT_Offset_ (f, this),
  Ref_Tx_Power_ (f, this),
  Freq_Range_Max_ (f, this),
  Freq_Range_Min_ (f, this),
  Ref_Offset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RfAnalysis::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Reference
    //
    if (n.name () == "Reference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_type > r (
        Reference_traits::create (i, f, this));

      if (!Reference_.present ())
      {
        this->Reference_.set (r);
        continue;
      }
    }

    // Ref-Probe-F-Number
    //
    if (n.name () == "Ref-Probe-F-Number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Probe_F_Number_type > r (
        Ref_Probe_F_Number_traits::create (i, f, this));

      if (!Ref_Probe_F_Number_.present ())
      {
        this->Ref_Probe_F_Number_.set (r);
        continue;
      }
    }

    // Ref-Probe-Focal-Length
    //
    if (n.name () == "Ref-Probe-Focal-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Probe_Focal_Length_type > r (
        Ref_Probe_Focal_Length_traits::create (i, f, this));

      if (!Ref_Probe_Focal_Length_.present ())
      {
        this->Ref_Probe_Focal_Length_.set (r);
        continue;
      }
    }

    // Ref-Tx-Frequency
    //
    if (n.name () == "Ref-Tx-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Tx_Frequency_type > r (
        Ref_Tx_Frequency_traits::create (i, f, this));

      if (!Ref_Tx_Frequency_.present ())
      {
        this->Ref_Tx_Frequency_.set (r);
        continue;
      }
    }

    // Freq-Range
    //
    if (n.name () == "Freq-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Freq_Range_type > r (
        Freq_Range_traits::create (i, f, this));

      if (!Freq_Range_.present ())
      {
        this->Freq_Range_.set (r);
        continue;
      }
    }

    // Ref-Probe-Name
    //
    if (n.name () == "Ref-Probe-Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Probe_Name_type > r (
        Ref_Probe_Name_traits::create (i, f, this));

      if (!Ref_Probe_Name_.present ())
      {
        this->Ref_Probe_Name_.set (r);
        continue;
      }
    }

    // Graph-Mode
    //
    if (n.name () == "Graph-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Graph_Mode_type > r (
        Graph_Mode_traits::create (i, f, this));

      if (!Graph_Mode_.present ())
      {
        this->Graph_Mode_.set (r);
        continue;
      }
    }

    // Normalized-Height
    //
    if (n.name () == "Normalized-Height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Normalized_Height_type > r (
        Normalized_Height_traits::create (i, f, this));

      if (!Normalized_Height_.present ())
      {
        this->Normalized_Height_.set (r);
        continue;
      }
    }

    // Ref-Tx-Width
    //
    if (n.name () == "Ref-Tx-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Tx_Width_type > r (
        Ref_Tx_Width_traits::create (i, f, this));

      if (!Ref_Tx_Width_.present ())
      {
        this->Ref_Tx_Width_.set (r);
        continue;
      }
    }

    // Normalized-Origin
    //
    if (n.name () == "Normalized-Origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Normalized_Origin_type > r (
        Normalized_Origin_traits::create (i, f, this));

      if (!Normalized_Origin_.present ())
      {
        this->Normalized_Origin_.set (r);
        continue;
      }
    }

    // Freq-Range-f
    //
    if (n.name () == "Freq-Range-f" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Freq_Range_f_type > r (
        Freq_Range_f_traits::create (i, f, this));

      if (!Freq_Range_f_.present ())
      {
        this->Freq_Range_f_.set (r);
        continue;
      }
    }

    // FFT-Offset
    //
    if (n.name () == "FFT-Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FFT_Offset_type > r (
        FFT_Offset_traits::create (i, f, this));

      if (!FFT_Offset_.present ())
      {
        this->FFT_Offset_.set (r);
        continue;
      }
    }

    // Ref-Tx-Power
    //
    if (n.name () == "Ref-Tx-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Tx_Power_type > r (
        Ref_Tx_Power_traits::create (i, f, this));

      if (!Ref_Tx_Power_.present ())
      {
        this->Ref_Tx_Power_.set (r);
        continue;
      }
    }

    // Freq-Range-Max
    //
    if (n.name () == "Freq-Range-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Freq_Range_Max_type > r (
        Freq_Range_Max_traits::create (i, f, this));

      if (!Freq_Range_Max_.present ())
      {
        this->Freq_Range_Max_.set (r);
        continue;
      }
    }

    // Freq-Range-Min
    //
    if (n.name () == "Freq-Range-Min" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Freq_Range_Min_type > r (
        Freq_Range_Min_traits::create (i, f, this));

      if (!Freq_Range_Min_.present ())
      {
        this->Freq_Range_Min_.set (r);
        continue;
      }
    }

    // Ref-Offset
    //
    if (n.name () == "Ref-Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ref_Offset_type > r (
        Ref_Offset_traits::create (i, f, this));

      if (!Ref_Offset_.present ())
      {
        this->Ref_Offset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Reference_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference",
      "");
  }

  if (!Ref_Probe_F_Number_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Probe-F-Number",
      "");
  }

  if (!Ref_Probe_Focal_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Probe-Focal-Length",
      "");
  }

  if (!Ref_Tx_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Tx-Frequency",
      "");
  }

  if (!Freq_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Freq-Range",
      "");
  }

  if (!Ref_Probe_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Probe-Name",
      "");
  }

  if (!Graph_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Graph-Mode",
      "");
  }

  if (!Normalized_Height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Normalized-Height",
      "");
  }

  if (!Ref_Tx_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Tx-Width",
      "");
  }

  if (!Normalized_Origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Normalized-Origin",
      "");
  }

  if (!Freq_Range_f_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Freq-Range-f",
      "");
  }

  if (!FFT_Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FFT-Offset",
      "");
  }

  if (!Ref_Tx_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Tx-Power",
      "");
  }

  if (!Freq_Range_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Freq-Range-Max",
      "");
  }

  if (!Freq_Range_Min_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Freq-Range-Min",
      "");
  }

  if (!Ref_Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ref-Offset",
      "");
  }
}

RfAnalysis* RfAnalysis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RfAnalysis (*this, f, c);
}

RfAnalysis::
~RfAnalysis ()
{
}

// RX
//

RX::
RX (const AD_IF_type& AD_IF,
    const Sector_Width_Target_type& Sector_Width_Target,
    const RF_Gain_type& RF_Gain,
    const TGC_Enable_type& TGC_Enable,
    const V_Digi_Depth_Imaging_type& V_Digi_Depth_Imaging,
    const RF_Bandwidth_type& RF_Bandwidth,
    const Test_Freq_type& Test_Freq,
    const Line_Number_type& Line_Number,
    const V_TGC_type& V_TGC,
    const IF_Filter_type& IF_Filter,
    const Track_Width_type& Track_Width,
    const DTB_Error_Clr_type& DTB_Error_Clr,
    const Current_Channel_type& Current_Channel,
    const V_IF_Filter_type& V_IF_Filter,
    const IQ_Select_type& IQ_Select,
    const HP_Clutter_type& HP_Clutter,
    const AD_In_type& AD_In,
    const V_TGC_Copy_type& V_TGC_Copy,
    const Image_FIFO_Status_type& Image_FIFO_Status,
    const RF_Filter_type& RF_Filter,
    const DDRS_type& DDRS,
    const ADCA_Out_type& ADCA_Out,
    const AD_Clock_Div_type& AD_Clock_Div,
    const Imaging_Mode_type& Imaging_Mode,
    const V_RF_Filter_type& V_RF_Filter,
    const ADCB_Out_type& ADCB_Out,
    const Delay_type& Delay,
    const AD_Gate_Width_type& AD_Gate_Width,
    const Frequency_type& Frequency,
    const V_Frequency_type& V_Frequency,
    const V_Field_Of_View_type& V_Field_Of_View,
    const Packet_Format_type& Packet_Format,
    const Sector_Height_Target_type& Sector_Height_Target,
    const Low_Speed_FIFO_Status_type& Low_Speed_FIFO_Status,
    const AD_TestIn_type& AD_TestIn,
    const Error_type& Error,
    const Test_On_type& Test_On,
    const AD_DCS_type& AD_DCS,
    const DTB_Tfr_Enable_type& DTB_Tfr_Enable,
    const DTB_Test_Enable_type& DTB_Test_Enable,
    const V_Delay_Length_type& V_Delay_Length,
    const Current_Mode_type& Current_Mode)
: ::xml_schema::type (),
  AD_IF_ (AD_IF, ::xml_schema::flags (), this),
  Sector_Width_Target_ (Sector_Width_Target, ::xml_schema::flags (), this),
  RF_Gain_ (RF_Gain, ::xml_schema::flags (), this),
  TGC_Enable_ (TGC_Enable, ::xml_schema::flags (), this),
  V_Digi_Depth_Imaging_ (V_Digi_Depth_Imaging, ::xml_schema::flags (), this),
  RF_Bandwidth_ (RF_Bandwidth, ::xml_schema::flags (), this),
  Test_Freq_ (Test_Freq, ::xml_schema::flags (), this),
  Line_Number_ (Line_Number, ::xml_schema::flags (), this),
  V_TGC_ (V_TGC, ::xml_schema::flags (), this),
  IF_Filter_ (IF_Filter, ::xml_schema::flags (), this),
  Track_Width_ (Track_Width, ::xml_schema::flags (), this),
  DTB_Error_Clr_ (DTB_Error_Clr, ::xml_schema::flags (), this),
  Current_Channel_ (Current_Channel, ::xml_schema::flags (), this),
  V_IF_Filter_ (V_IF_Filter, ::xml_schema::flags (), this),
  IQ_Select_ (IQ_Select, ::xml_schema::flags (), this),
  HP_Clutter_ (HP_Clutter, ::xml_schema::flags (), this),
  AD_In_ (AD_In, ::xml_schema::flags (), this),
  V_TGC_Copy_ (V_TGC_Copy, ::xml_schema::flags (), this),
  Image_FIFO_Status_ (Image_FIFO_Status, ::xml_schema::flags (), this),
  RF_Filter_ (RF_Filter, ::xml_schema::flags (), this),
  DDRS_ (DDRS, ::xml_schema::flags (), this),
  ADCA_Out_ (ADCA_Out, ::xml_schema::flags (), this),
  AD_Clock_Div_ (AD_Clock_Div, ::xml_schema::flags (), this),
  Imaging_Mode_ (Imaging_Mode, ::xml_schema::flags (), this),
  V_RF_Filter_ (V_RF_Filter, ::xml_schema::flags (), this),
  ADCB_Out_ (ADCB_Out, ::xml_schema::flags (), this),
  Delay_ (Delay, ::xml_schema::flags (), this),
  AD_Gate_Width_ (AD_Gate_Width, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  V_Field_Of_View_ (V_Field_Of_View, ::xml_schema::flags (), this),
  Packet_Format_ (Packet_Format, ::xml_schema::flags (), this),
  Sector_Height_Target_ (Sector_Height_Target, ::xml_schema::flags (), this),
  Low_Speed_FIFO_Status_ (Low_Speed_FIFO_Status, ::xml_schema::flags (), this),
  AD_TestIn_ (AD_TestIn, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Test_On_ (Test_On, ::xml_schema::flags (), this),
  AD_DCS_ (AD_DCS, ::xml_schema::flags (), this),
  DTB_Tfr_Enable_ (DTB_Tfr_Enable, ::xml_schema::flags (), this),
  DTB_Test_Enable_ (DTB_Test_Enable, ::xml_schema::flags (), this),
  V_Delay_Length_ (V_Delay_Length, ::xml_schema::flags (), this),
  Current_Mode_ (Current_Mode, ::xml_schema::flags (), this)
{
}

RX::
RX (const AD_IF_type& AD_IF,
    ::std::auto_ptr< Sector_Width_Target_type >& Sector_Width_Target,
    ::std::auto_ptr< RF_Gain_type >& RF_Gain,
    const TGC_Enable_type& TGC_Enable,
    ::std::auto_ptr< V_Digi_Depth_Imaging_type >& V_Digi_Depth_Imaging,
    const RF_Bandwidth_type& RF_Bandwidth,
    ::std::auto_ptr< Test_Freq_type >& Test_Freq,
    const Line_Number_type& Line_Number,
    const V_TGC_type& V_TGC,
    ::std::auto_ptr< IF_Filter_type >& IF_Filter,
    ::std::auto_ptr< Track_Width_type >& Track_Width,
    const DTB_Error_Clr_type& DTB_Error_Clr,
    const Current_Channel_type& Current_Channel,
    ::std::auto_ptr< V_IF_Filter_type >& V_IF_Filter,
    const IQ_Select_type& IQ_Select,
    ::std::auto_ptr< HP_Clutter_type >& HP_Clutter,
    const AD_In_type& AD_In,
    const V_TGC_Copy_type& V_TGC_Copy,
    const Image_FIFO_Status_type& Image_FIFO_Status,
    ::std::auto_ptr< RF_Filter_type >& RF_Filter,
    const DDRS_type& DDRS,
    const ADCA_Out_type& ADCA_Out,
    const AD_Clock_Div_type& AD_Clock_Div,
    const Imaging_Mode_type& Imaging_Mode,
    ::std::auto_ptr< V_RF_Filter_type >& V_RF_Filter,
    const ADCB_Out_type& ADCB_Out,
    ::std::auto_ptr< Delay_type >& Delay,
    ::std::auto_ptr< AD_Gate_Width_type >& AD_Gate_Width,
    ::std::auto_ptr< Frequency_type >& Frequency,
    ::std::auto_ptr< V_Frequency_type >& V_Frequency,
    ::std::auto_ptr< V_Field_Of_View_type >& V_Field_Of_View,
    const Packet_Format_type& Packet_Format,
    ::std::auto_ptr< Sector_Height_Target_type >& Sector_Height_Target,
    const Low_Speed_FIFO_Status_type& Low_Speed_FIFO_Status,
    ::std::auto_ptr< AD_TestIn_type >& AD_TestIn,
    const Error_type& Error,
    const Test_On_type& Test_On,
    const AD_DCS_type& AD_DCS,
    const DTB_Tfr_Enable_type& DTB_Tfr_Enable,
    const DTB_Test_Enable_type& DTB_Test_Enable,
    ::std::auto_ptr< V_Delay_Length_type >& V_Delay_Length,
    const Current_Mode_type& Current_Mode)
: ::xml_schema::type (),
  AD_IF_ (AD_IF, ::xml_schema::flags (), this),
  Sector_Width_Target_ (Sector_Width_Target, ::xml_schema::flags (), this),
  RF_Gain_ (RF_Gain, ::xml_schema::flags (), this),
  TGC_Enable_ (TGC_Enable, ::xml_schema::flags (), this),
  V_Digi_Depth_Imaging_ (V_Digi_Depth_Imaging, ::xml_schema::flags (), this),
  RF_Bandwidth_ (RF_Bandwidth, ::xml_schema::flags (), this),
  Test_Freq_ (Test_Freq, ::xml_schema::flags (), this),
  Line_Number_ (Line_Number, ::xml_schema::flags (), this),
  V_TGC_ (V_TGC, ::xml_schema::flags (), this),
  IF_Filter_ (IF_Filter, ::xml_schema::flags (), this),
  Track_Width_ (Track_Width, ::xml_schema::flags (), this),
  DTB_Error_Clr_ (DTB_Error_Clr, ::xml_schema::flags (), this),
  Current_Channel_ (Current_Channel, ::xml_schema::flags (), this),
  V_IF_Filter_ (V_IF_Filter, ::xml_schema::flags (), this),
  IQ_Select_ (IQ_Select, ::xml_schema::flags (), this),
  HP_Clutter_ (HP_Clutter, ::xml_schema::flags (), this),
  AD_In_ (AD_In, ::xml_schema::flags (), this),
  V_TGC_Copy_ (V_TGC_Copy, ::xml_schema::flags (), this),
  Image_FIFO_Status_ (Image_FIFO_Status, ::xml_schema::flags (), this),
  RF_Filter_ (RF_Filter, ::xml_schema::flags (), this),
  DDRS_ (DDRS, ::xml_schema::flags (), this),
  ADCA_Out_ (ADCA_Out, ::xml_schema::flags (), this),
  AD_Clock_Div_ (AD_Clock_Div, ::xml_schema::flags (), this),
  Imaging_Mode_ (Imaging_Mode, ::xml_schema::flags (), this),
  V_RF_Filter_ (V_RF_Filter, ::xml_schema::flags (), this),
  ADCB_Out_ (ADCB_Out, ::xml_schema::flags (), this),
  Delay_ (Delay, ::xml_schema::flags (), this),
  AD_Gate_Width_ (AD_Gate_Width, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  V_Field_Of_View_ (V_Field_Of_View, ::xml_schema::flags (), this),
  Packet_Format_ (Packet_Format, ::xml_schema::flags (), this),
  Sector_Height_Target_ (Sector_Height_Target, ::xml_schema::flags (), this),
  Low_Speed_FIFO_Status_ (Low_Speed_FIFO_Status, ::xml_schema::flags (), this),
  AD_TestIn_ (AD_TestIn, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Test_On_ (Test_On, ::xml_schema::flags (), this),
  AD_DCS_ (AD_DCS, ::xml_schema::flags (), this),
  DTB_Tfr_Enable_ (DTB_Tfr_Enable, ::xml_schema::flags (), this),
  DTB_Test_Enable_ (DTB_Test_Enable, ::xml_schema::flags (), this),
  V_Delay_Length_ (V_Delay_Length, ::xml_schema::flags (), this),
  Current_Mode_ (Current_Mode, ::xml_schema::flags (), this)
{
}

RX::
RX (const RX& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AD_IF_ (x.AD_IF_, f, this),
  Sector_Width_Target_ (x.Sector_Width_Target_, f, this),
  RF_Gain_ (x.RF_Gain_, f, this),
  TGC_Enable_ (x.TGC_Enable_, f, this),
  V_Digi_Depth_Imaging_ (x.V_Digi_Depth_Imaging_, f, this),
  RF_Bandwidth_ (x.RF_Bandwidth_, f, this),
  Test_Freq_ (x.Test_Freq_, f, this),
  Line_Number_ (x.Line_Number_, f, this),
  V_TGC_ (x.V_TGC_, f, this),
  IF_Filter_ (x.IF_Filter_, f, this),
  Track_Width_ (x.Track_Width_, f, this),
  DTB_Error_Clr_ (x.DTB_Error_Clr_, f, this),
  Current_Channel_ (x.Current_Channel_, f, this),
  V_IF_Filter_ (x.V_IF_Filter_, f, this),
  IQ_Select_ (x.IQ_Select_, f, this),
  HP_Clutter_ (x.HP_Clutter_, f, this),
  AD_In_ (x.AD_In_, f, this),
  V_TGC_Copy_ (x.V_TGC_Copy_, f, this),
  Image_FIFO_Status_ (x.Image_FIFO_Status_, f, this),
  RF_Filter_ (x.RF_Filter_, f, this),
  DDRS_ (x.DDRS_, f, this),
  ADCA_Out_ (x.ADCA_Out_, f, this),
  AD_Clock_Div_ (x.AD_Clock_Div_, f, this),
  Imaging_Mode_ (x.Imaging_Mode_, f, this),
  V_RF_Filter_ (x.V_RF_Filter_, f, this),
  ADCB_Out_ (x.ADCB_Out_, f, this),
  Delay_ (x.Delay_, f, this),
  AD_Gate_Width_ (x.AD_Gate_Width_, f, this),
  Frequency_ (x.Frequency_, f, this),
  V_Frequency_ (x.V_Frequency_, f, this),
  V_Field_Of_View_ (x.V_Field_Of_View_, f, this),
  Packet_Format_ (x.Packet_Format_, f, this),
  Sector_Height_Target_ (x.Sector_Height_Target_, f, this),
  Low_Speed_FIFO_Status_ (x.Low_Speed_FIFO_Status_, f, this),
  AD_TestIn_ (x.AD_TestIn_, f, this),
  Error_ (x.Error_, f, this),
  Test_On_ (x.Test_On_, f, this),
  AD_DCS_ (x.AD_DCS_, f, this),
  DTB_Tfr_Enable_ (x.DTB_Tfr_Enable_, f, this),
  DTB_Test_Enable_ (x.DTB_Test_Enable_, f, this),
  V_Delay_Length_ (x.V_Delay_Length_, f, this),
  Current_Mode_ (x.Current_Mode_, f, this)
{
}

RX::
RX (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AD_IF_ (f, this),
  Sector_Width_Target_ (f, this),
  RF_Gain_ (f, this),
  TGC_Enable_ (f, this),
  V_Digi_Depth_Imaging_ (f, this),
  RF_Bandwidth_ (f, this),
  Test_Freq_ (f, this),
  Line_Number_ (f, this),
  V_TGC_ (f, this),
  IF_Filter_ (f, this),
  Track_Width_ (f, this),
  DTB_Error_Clr_ (f, this),
  Current_Channel_ (f, this),
  V_IF_Filter_ (f, this),
  IQ_Select_ (f, this),
  HP_Clutter_ (f, this),
  AD_In_ (f, this),
  V_TGC_Copy_ (f, this),
  Image_FIFO_Status_ (f, this),
  RF_Filter_ (f, this),
  DDRS_ (f, this),
  ADCA_Out_ (f, this),
  AD_Clock_Div_ (f, this),
  Imaging_Mode_ (f, this),
  V_RF_Filter_ (f, this),
  ADCB_Out_ (f, this),
  Delay_ (f, this),
  AD_Gate_Width_ (f, this),
  Frequency_ (f, this),
  V_Frequency_ (f, this),
  V_Field_Of_View_ (f, this),
  Packet_Format_ (f, this),
  Sector_Height_Target_ (f, this),
  Low_Speed_FIFO_Status_ (f, this),
  AD_TestIn_ (f, this),
  Error_ (f, this),
  Test_On_ (f, this),
  AD_DCS_ (f, this),
  DTB_Tfr_Enable_ (f, this),
  DTB_Test_Enable_ (f, this),
  V_Delay_Length_ (f, this),
  Current_Mode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RX::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AD-IF
    //
    if (n.name () == "AD-IF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_IF_type > r (
        AD_IF_traits::create (i, f, this));

      if (!AD_IF_.present ())
      {
        this->AD_IF_.set (r);
        continue;
      }
    }

    // Sector-Width-Target
    //
    if (n.name () == "Sector-Width-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Width_Target_type > r (
        Sector_Width_Target_traits::create (i, f, this));

      if (!Sector_Width_Target_.present ())
      {
        this->Sector_Width_Target_.set (r);
        continue;
      }
    }

    // RF-Gain
    //
    if (n.name () == "RF-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Gain_type > r (
        RF_Gain_traits::create (i, f, this));

      if (!RF_Gain_.present ())
      {
        this->RF_Gain_.set (r);
        continue;
      }
    }

    // TGC-Enable
    //
    if (n.name () == "TGC-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TGC_Enable_type > r (
        TGC_Enable_traits::create (i, f, this));

      if (!TGC_Enable_.present ())
      {
        this->TGC_Enable_.set (r);
        continue;
      }
    }

    // V-Digi-Depth-Imaging
    //
    if (n.name () == "V-Digi-Depth-Imaging" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Digi_Depth_Imaging_type > r (
        V_Digi_Depth_Imaging_traits::create (i, f, this));

      if (!V_Digi_Depth_Imaging_.present ())
      {
        this->V_Digi_Depth_Imaging_.set (r);
        continue;
      }
    }

    // RF-Bandwidth
    //
    if (n.name () == "RF-Bandwidth" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Bandwidth_type > r (
        RF_Bandwidth_traits::create (i, f, this));

      if (!RF_Bandwidth_.present ())
      {
        this->RF_Bandwidth_.set (r);
        continue;
      }
    }

    // Test-Freq
    //
    if (n.name () == "Test-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Test_Freq_type > r (
        Test_Freq_traits::create (i, f, this));

      if (!Test_Freq_.present ())
      {
        this->Test_Freq_.set (r);
        continue;
      }
    }

    // Line-Number
    //
    if (n.name () == "Line-Number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Line_Number_type > r (
        Line_Number_traits::create (i, f, this));

      if (!Line_Number_.present ())
      {
        this->Line_Number_.set (r);
        continue;
      }
    }

    // V-TGC
    //
    if (n.name () == "V-TGC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_TGC_type > r (
        V_TGC_traits::create (i, f, this));

      if (!V_TGC_.present ())
      {
        this->V_TGC_.set (r);
        continue;
      }
    }

    // IF-Filter
    //
    if (n.name () == "IF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IF_Filter_type > r (
        IF_Filter_traits::create (i, f, this));

      if (!IF_Filter_.present ())
      {
        this->IF_Filter_.set (r);
        continue;
      }
    }

    // Track-Width
    //
    if (n.name () == "Track-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Track_Width_type > r (
        Track_Width_traits::create (i, f, this));

      if (!Track_Width_.present ())
      {
        this->Track_Width_.set (r);
        continue;
      }
    }

    // DTB-Error-Clr
    //
    if (n.name () == "DTB-Error-Clr" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Error_Clr_type > r (
        DTB_Error_Clr_traits::create (i, f, this));

      if (!DTB_Error_Clr_.present ())
      {
        this->DTB_Error_Clr_.set (r);
        continue;
      }
    }

    // Current-Channel
    //
    if (n.name () == "Current-Channel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Current_Channel_type > r (
        Current_Channel_traits::create (i, f, this));

      if (!Current_Channel_.present ())
      {
        this->Current_Channel_.set (r);
        continue;
      }
    }

    // V-IF-Filter
    //
    if (n.name () == "V-IF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_IF_Filter_type > r (
        V_IF_Filter_traits::create (i, f, this));

      if (!V_IF_Filter_.present ())
      {
        this->V_IF_Filter_.set (r);
        continue;
      }
    }

    // IQ-Select
    //
    if (n.name () == "IQ-Select" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IQ_Select_type > r (
        IQ_Select_traits::create (i, f, this));

      if (!IQ_Select_.present ())
      {
        this->IQ_Select_.set (r);
        continue;
      }
    }

    // HP-Clutter
    //
    if (n.name () == "HP-Clutter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HP_Clutter_type > r (
        HP_Clutter_traits::create (i, f, this));

      if (!HP_Clutter_.present ())
      {
        this->HP_Clutter_.set (r);
        continue;
      }
    }

    // AD-In
    //
    if (n.name () == "AD-In" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_In_type > r (
        AD_In_traits::create (i, f, this));

      if (!AD_In_.present ())
      {
        this->AD_In_.set (r);
        continue;
      }
    }

    // V-TGC-Copy
    //
    if (n.name () == "V-TGC-Copy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_TGC_Copy_type > r (
        V_TGC_Copy_traits::create (i, f, this));

      if (!V_TGC_Copy_.present ())
      {
        this->V_TGC_Copy_.set (r);
        continue;
      }
    }

    // Image-FIFO-Status
    //
    if (n.name () == "Image-FIFO-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_FIFO_Status_type > r (
        Image_FIFO_Status_traits::create (i, f, this));

      if (!Image_FIFO_Status_.present ())
      {
        this->Image_FIFO_Status_.set (r);
        continue;
      }
    }

    // RF-Filter
    //
    if (n.name () == "RF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Filter_type > r (
        RF_Filter_traits::create (i, f, this));

      if (!RF_Filter_.present ())
      {
        this->RF_Filter_.set (r);
        continue;
      }
    }

    // DDRS
    //
    if (n.name () == "DDRS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DDRS_type > r (
        DDRS_traits::create (i, f, this));

      if (!DDRS_.present ())
      {
        this->DDRS_.set (r);
        continue;
      }
    }

    // ADCA-Out
    //
    if (n.name () == "ADCA-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ADCA_Out_type > r (
        ADCA_Out_traits::create (i, f, this));

      if (!ADCA_Out_.present ())
      {
        this->ADCA_Out_.set (r);
        continue;
      }
    }

    // AD-Clock-Div
    //
    if (n.name () == "AD-Clock-Div" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_Clock_Div_type > r (
        AD_Clock_Div_traits::create (i, f, this));

      if (!AD_Clock_Div_.present ())
      {
        this->AD_Clock_Div_.set (r);
        continue;
      }
    }

    // Imaging-Mode
    //
    if (n.name () == "Imaging-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Imaging_Mode_type > r (
        Imaging_Mode_traits::create (i, f, this));

      if (!Imaging_Mode_.present ())
      {
        this->Imaging_Mode_.set (r);
        continue;
      }
    }

    // V-RF-Filter
    //
    if (n.name () == "V-RF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_RF_Filter_type > r (
        V_RF_Filter_traits::create (i, f, this));

      if (!V_RF_Filter_.present ())
      {
        this->V_RF_Filter_.set (r);
        continue;
      }
    }

    // ADCB-Out
    //
    if (n.name () == "ADCB-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ADCB_Out_type > r (
        ADCB_Out_traits::create (i, f, this));

      if (!ADCB_Out_.present ())
      {
        this->ADCB_Out_.set (r);
        continue;
      }
    }

    // Delay
    //
    if (n.name () == "Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Delay_type > r (
        Delay_traits::create (i, f, this));

      if (!Delay_.present ())
      {
        this->Delay_.set (r);
        continue;
      }
    }

    // AD-Gate-Width
    //
    if (n.name () == "AD-Gate-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_Gate_Width_type > r (
        AD_Gate_Width_traits::create (i, f, this));

      if (!AD_Gate_Width_.present ())
      {
        this->AD_Gate_Width_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // V-Frequency
    //
    if (n.name () == "V-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Frequency_type > r (
        V_Frequency_traits::create (i, f, this));

      if (!V_Frequency_.present ())
      {
        this->V_Frequency_.set (r);
        continue;
      }
    }

    // V-Field-Of-View
    //
    if (n.name () == "V-Field-Of-View" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Field_Of_View_type > r (
        V_Field_Of_View_traits::create (i, f, this));

      if (!V_Field_Of_View_.present ())
      {
        this->V_Field_Of_View_.set (r);
        continue;
      }
    }

    // Packet-Format
    //
    if (n.name () == "Packet-Format" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Packet_Format_type > r (
        Packet_Format_traits::create (i, f, this));

      if (!Packet_Format_.present ())
      {
        this->Packet_Format_.set (r);
        continue;
      }
    }

    // Sector-Height-Target
    //
    if (n.name () == "Sector-Height-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Height_Target_type > r (
        Sector_Height_Target_traits::create (i, f, this));

      if (!Sector_Height_Target_.present ())
      {
        this->Sector_Height_Target_.set (r);
        continue;
      }
    }

    // Low-Speed-FIFO-Status
    //
    if (n.name () == "Low-Speed-FIFO-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Low_Speed_FIFO_Status_type > r (
        Low_Speed_FIFO_Status_traits::create (i, f, this));

      if (!Low_Speed_FIFO_Status_.present ())
      {
        this->Low_Speed_FIFO_Status_.set (r);
        continue;
      }
    }

    // AD-TestIn
    //
    if (n.name () == "AD-TestIn" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_TestIn_type > r (
        AD_TestIn_traits::create (i, f, this));

      if (!AD_TestIn_.present ())
      {
        this->AD_TestIn_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // Test-On
    //
    if (n.name () == "Test-On" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Test_On_type > r (
        Test_On_traits::create (i, f, this));

      if (!Test_On_.present ())
      {
        this->Test_On_.set (r);
        continue;
      }
    }

    // AD-DCS
    //
    if (n.name () == "AD-DCS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_DCS_type > r (
        AD_DCS_traits::create (i, f, this));

      if (!AD_DCS_.present ())
      {
        this->AD_DCS_.set (r);
        continue;
      }
    }

    // DTB-Tfr-Enable
    //
    if (n.name () == "DTB-Tfr-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Tfr_Enable_type > r (
        DTB_Tfr_Enable_traits::create (i, f, this));

      if (!DTB_Tfr_Enable_.present ())
      {
        this->DTB_Tfr_Enable_.set (r);
        continue;
      }
    }

    // DTB-Test-Enable
    //
    if (n.name () == "DTB-Test-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Test_Enable_type > r (
        DTB_Test_Enable_traits::create (i, f, this));

      if (!DTB_Test_Enable_.present ())
      {
        this->DTB_Test_Enable_.set (r);
        continue;
      }
    }

    // V-Delay-Length
    //
    if (n.name () == "V-Delay-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Delay_Length_type > r (
        V_Delay_Length_traits::create (i, f, this));

      if (!V_Delay_Length_.present ())
      {
        this->V_Delay_Length_.set (r);
        continue;
      }
    }

    // Current-Mode
    //
    if (n.name () == "Current-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Current_Mode_type > r (
        Current_Mode_traits::create (i, f, this));

      if (!Current_Mode_.present ())
      {
        this->Current_Mode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!AD_IF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-IF",
      "");
  }

  if (!Sector_Width_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Width-Target",
      "");
  }

  if (!RF_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Gain",
      "");
  }

  if (!TGC_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TGC-Enable",
      "");
  }

  if (!V_Digi_Depth_Imaging_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Digi-Depth-Imaging",
      "");
  }

  if (!RF_Bandwidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Bandwidth",
      "");
  }

  if (!Test_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Test-Freq",
      "");
  }

  if (!Line_Number_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Line-Number",
      "");
  }

  if (!V_TGC_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-TGC",
      "");
  }

  if (!IF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IF-Filter",
      "");
  }

  if (!Track_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Track-Width",
      "");
  }

  if (!DTB_Error_Clr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Error-Clr",
      "");
  }

  if (!Current_Channel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Current-Channel",
      "");
  }

  if (!V_IF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-IF-Filter",
      "");
  }

  if (!IQ_Select_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IQ-Select",
      "");
  }

  if (!HP_Clutter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HP-Clutter",
      "");
  }

  if (!AD_In_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-In",
      "");
  }

  if (!V_TGC_Copy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-TGC-Copy",
      "");
  }

  if (!Image_FIFO_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image-FIFO-Status",
      "");
  }

  if (!RF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Filter",
      "");
  }

  if (!DDRS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DDRS",
      "");
  }

  if (!ADCA_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ADCA-Out",
      "");
  }

  if (!AD_Clock_Div_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-Clock-Div",
      "");
  }

  if (!Imaging_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Imaging-Mode",
      "");
  }

  if (!V_RF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-RF-Filter",
      "");
  }

  if (!ADCB_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ADCB-Out",
      "");
  }

  if (!Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Delay",
      "");
  }

  if (!AD_Gate_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-Gate-Width",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!V_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Frequency",
      "");
  }

  if (!V_Field_Of_View_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Field-Of-View",
      "");
  }

  if (!Packet_Format_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Packet-Format",
      "");
  }

  if (!Sector_Height_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Height-Target",
      "");
  }

  if (!Low_Speed_FIFO_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Low-Speed-FIFO-Status",
      "");
  }

  if (!AD_TestIn_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-TestIn",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!Test_On_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Test-On",
      "");
  }

  if (!AD_DCS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-DCS",
      "");
  }

  if (!DTB_Tfr_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Tfr-Enable",
      "");
  }

  if (!DTB_Test_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Test-Enable",
      "");
  }

  if (!V_Delay_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Delay-Length",
      "");
  }

  if (!Current_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Current-Mode",
      "");
  }
}

RX* RX::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RX (*this, f, c);
}

RX::
~RX ()
{
}

// Display
//

Display::
Display (const Direction_type& Direction,
         const X_3D_Gain_type& X_3D_Gain,
         const X_3D_Dynamic_Range_type& X_3D_Dynamic_Range,
         const V_Selection_type& V_Selection,
         const Gain_type& Gain,
         const Dynamic_Range_type& Dynamic_Range,
         const Window_Time_type& Window_Time)
: ::xml_schema::type (),
  Direction_ (Direction, ::xml_schema::flags (), this),
  X_3D_Gain_ (X_3D_Gain, ::xml_schema::flags (), this),
  X_3D_Dynamic_Range_ (X_3D_Dynamic_Range, ::xml_schema::flags (), this),
  V_Selection_ (V_Selection, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  Dynamic_Range_ (Dynamic_Range, ::xml_schema::flags (), this),
  Window_Time_ (Window_Time, ::xml_schema::flags (), this)
{
}

Display::
Display (const Direction_type& Direction,
         const X_3D_Gain_type& X_3D_Gain,
         const X_3D_Dynamic_Range_type& X_3D_Dynamic_Range,
         const V_Selection_type& V_Selection,
         const Gain_type& Gain,
         const Dynamic_Range_type& Dynamic_Range,
         ::std::auto_ptr< Window_Time_type >& Window_Time)
: ::xml_schema::type (),
  Direction_ (Direction, ::xml_schema::flags (), this),
  X_3D_Gain_ (X_3D_Gain, ::xml_schema::flags (), this),
  X_3D_Dynamic_Range_ (X_3D_Dynamic_Range, ::xml_schema::flags (), this),
  V_Selection_ (V_Selection, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  Dynamic_Range_ (Dynamic_Range, ::xml_schema::flags (), this),
  Window_Time_ (Window_Time, ::xml_schema::flags (), this)
{
}

Display::
Display (const Display& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Direction_ (x.Direction_, f, this),
  X_3D_Gain_ (x.X_3D_Gain_, f, this),
  X_3D_Dynamic_Range_ (x.X_3D_Dynamic_Range_, f, this),
  V_Selection_ (x.V_Selection_, f, this),
  Gain_ (x.Gain_, f, this),
  Dynamic_Range_ (x.Dynamic_Range_, f, this),
  Window_Time_ (x.Window_Time_, f, this)
{
}

Display::
Display (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Direction_ (f, this),
  X_3D_Gain_ (f, this),
  X_3D_Dynamic_Range_ (f, this),
  V_Selection_ (f, this),
  Gain_ (f, this),
  Dynamic_Range_ (f, this),
  Window_Time_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Display::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Direction
    //
    if (n.name () == "Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Direction_type > r (
        Direction_traits::create (i, f, this));

      if (!Direction_.present ())
      {
        this->Direction_.set (r);
        continue;
      }
    }

    // X_3D-Gain
    //
    if (n.name () == "X_3D-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Gain_type > r (
        X_3D_Gain_traits::create (i, f, this));

      if (!X_3D_Gain_.present ())
      {
        this->X_3D_Gain_.set (r);
        continue;
      }
    }

    // X_3D-Dynamic-Range
    //
    if (n.name () == "X_3D-Dynamic-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Dynamic_Range_type > r (
        X_3D_Dynamic_Range_traits::create (i, f, this));

      if (!X_3D_Dynamic_Range_.present ())
      {
        this->X_3D_Dynamic_Range_.set (r);
        continue;
      }
    }

    // V-Selection
    //
    if (n.name () == "V-Selection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Selection_type > r (
        V_Selection_traits::create (i, f, this));

      if (!V_Selection_.present ())
      {
        this->V_Selection_.set (r);
        continue;
      }
    }

    // Gain
    //
    if (n.name () == "Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Gain_type > r (
        Gain_traits::create (i, f, this));

      if (!Gain_.present ())
      {
        this->Gain_.set (r);
        continue;
      }
    }

    // Dynamic-Range
    //
    if (n.name () == "Dynamic-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Dynamic_Range_type > r (
        Dynamic_Range_traits::create (i, f, this));

      if (!Dynamic_Range_.present ())
      {
        this->Dynamic_Range_.set (r);
        continue;
      }
    }

    // Window-Time
    //
    if (n.name () == "Window-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Window_Time_type > r (
        Window_Time_traits::create (i, f, this));

      if (!Window_Time_.present ())
      {
        this->Window_Time_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Direction",
      "");
  }

  if (!X_3D_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Gain",
      "");
  }

  if (!X_3D_Dynamic_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Dynamic-Range",
      "");
  }

  if (!V_Selection_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Selection",
      "");
  }

  if (!Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Gain",
      "");
  }

  if (!Dynamic_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dynamic-Range",
      "");
  }

  if (!Window_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Window-Time",
      "");
  }
}

Display* Display::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Display (*this, f, c);
}

Display::
~Display ()
{
}

// Acqiris
//

Acqiris::
Acqiris (const SamplesNom_type& SamplesNom,
         const V_Read_Data_type& V_Read_Data,
         const Mode_type& Mode,
         const Acquire_type& Acquire,
         const Available_type& Available,
         const Force_Trigger_type& Force_Trigger,
         const Control_type& Control,
         const TbSegmentPad_type& TbSegmentPad,
         const Wait_Acq_type& Wait_Acq)
: ::xml_schema::type (),
  SamplesNom_ (SamplesNom, ::xml_schema::flags (), this),
  V_Read_Data_ (V_Read_Data, ::xml_schema::flags (), this),
  Mode_ (Mode, ::xml_schema::flags (), this),
  Acquire_ (Acquire, ::xml_schema::flags (), this),
  Available_ (Available, ::xml_schema::flags (), this),
  Force_Trigger_ (Force_Trigger, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  TbSegmentPad_ (TbSegmentPad, ::xml_schema::flags (), this),
  Wait_Acq_ (Wait_Acq, ::xml_schema::flags (), this)
{
}

Acqiris::
Acqiris (const Acqiris& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SamplesNom_ (x.SamplesNom_, f, this),
  V_Read_Data_ (x.V_Read_Data_, f, this),
  Mode_ (x.Mode_, f, this),
  Acquire_ (x.Acquire_, f, this),
  Available_ (x.Available_, f, this),
  Force_Trigger_ (x.Force_Trigger_, f, this),
  Control_ (x.Control_, f, this),
  TbSegmentPad_ (x.TbSegmentPad_, f, this),
  Wait_Acq_ (x.Wait_Acq_, f, this)
{
}

Acqiris::
Acqiris (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SamplesNom_ (f, this),
  V_Read_Data_ (f, this),
  Mode_ (f, this),
  Acquire_ (f, this),
  Available_ (f, this),
  Force_Trigger_ (f, this),
  Control_ (f, this),
  TbSegmentPad_ (f, this),
  Wait_Acq_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Acqiris::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SamplesNom
    //
    if (n.name () == "SamplesNom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SamplesNom_type > r (
        SamplesNom_traits::create (i, f, this));

      if (!SamplesNom_.present ())
      {
        this->SamplesNom_.set (r);
        continue;
      }
    }

    // V-Read-Data
    //
    if (n.name () == "V-Read-Data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Read_Data_type > r (
        V_Read_Data_traits::create (i, f, this));

      if (!V_Read_Data_.present ())
      {
        this->V_Read_Data_.set (r);
        continue;
      }
    }

    // Mode
    //
    if (n.name () == "Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mode_type > r (
        Mode_traits::create (i, f, this));

      if (!Mode_.present ())
      {
        this->Mode_.set (r);
        continue;
      }
    }

    // Acquire
    //
    if (n.name () == "Acquire" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_type > r (
        Acquire_traits::create (i, f, this));

      if (!Acquire_.present ())
      {
        this->Acquire_.set (r);
        continue;
      }
    }

    // Available
    //
    if (n.name () == "Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Available_type > r (
        Available_traits::create (i, f, this));

      if (!Available_.present ())
      {
        this->Available_.set (r);
        continue;
      }
    }

    // Force-Trigger
    //
    if (n.name () == "Force-Trigger" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Force_Trigger_type > r (
        Force_Trigger_traits::create (i, f, this));

      if (!Force_Trigger_.present ())
      {
        this->Force_Trigger_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    // TbSegmentPad
    //
    if (n.name () == "TbSegmentPad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TbSegmentPad_type > r (
        TbSegmentPad_traits::create (i, f, this));

      if (!TbSegmentPad_.present ())
      {
        this->TbSegmentPad_.set (r);
        continue;
      }
    }

    // Wait-Acq
    //
    if (n.name () == "Wait-Acq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Wait_Acq_type > r (
        Wait_Acq_traits::create (i, f, this));

      if (!Wait_Acq_.present ())
      {
        this->Wait_Acq_.set (r);
        continue;
      }
    }

    break;
  }

  if (!SamplesNom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SamplesNom",
      "");
  }

  if (!V_Read_Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Read-Data",
      "");
  }

  if (!Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mode",
      "");
  }

  if (!Acquire_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire",
      "");
  }

  if (!Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Available",
      "");
  }

  if (!Force_Trigger_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Force-Trigger",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  if (!TbSegmentPad_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TbSegmentPad",
      "");
  }

  if (!Wait_Acq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Wait-Acq",
      "");
  }
}

Acqiris* Acqiris::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acqiris (*this, f, c);
}

Acqiris::
~Acqiris ()
{
}

// ActiveProbe1
//

ActiveProbe1::
ActiveProbe1 (const Notes_type& Notes,
              const Sample_Time_type& Sample_Time,
              const Focal_Length_type& Focal_Length,
              const Acceleration_Limit_Slope_type& Acceleration_Limit_Slope,
              const Type_type& Type,
              const Detect_Id_type& Detect_Id,
              const Default_Scan_Speed_type& Default_Scan_Speed,
              const K1_Power_type& K1_Power,
              const Cutoff_Scan_Speed_type& Cutoff_Scan_Speed,
              const Frequency_Low_type& Frequency_Low,
              const Default_FOV_type& Default_FOV,
              const Frequency_Doppler_Default_type& Frequency_Doppler_Default,
              const Default_SvSize_MMode_type& Default_SvSize_MMode,
              const Axial_Res_Factor_Target_type& Axial_Res_Factor_Target,
              const F_Number_type& F_Number,
              const Acc_Time_Factor_type& Acc_Time_Factor,
              const Axial_Res_type& Axial_Res,
              const Lateral_Res_Factor_Target_type& Lateral_Res_Factor_Target,
              const Pivot_Encoder_Dist_type& Pivot_Encoder_Dist,
              const Encoder_Range_Max_type& Encoder_Range_Max,
              const Encoder_Range_Min_type& Encoder_Range_Min,
              const Lateral_Res_type& Lateral_Res,
              const Max_Scan_Distance_type& Max_Scan_Distance,
              const Default_Rx_Gain_type& Default_Rx_Gain,
              const PID_KD_High_type& PID_KD_High,
              const PID_KI_High_type& PID_KI_High,
              const PID_KP_High_type& PID_KP_High,
              const Frequency_High_type& Frequency_High,
              const Lateral_Res_Factor_Max_type& Lateral_Res_Factor_Max,
              const Scan_Speeds_type& Scan_Speeds,
              const Filter_Doppler_Cutoff_type& Filter_Doppler_Cutoff,
              const Name_type& Name,
              const PID_KD_Low_type& PID_KD_Low,
              const PID_KI_Low_type& PID_KI_Low,
              const PID_KP_Low_type& PID_KP_Low,
              const Peak_Bandwidth_Correction_type& Peak_Bandwidth_Correction,
              const Frequency_Doppler_Low_type& Frequency_Doppler_Low,
              const Pivot_Transducer_Face_Dist_type& Pivot_Transducer_Face_Dist,
              const Filter_Doppler_type& Filter_Doppler,
              const Frequency_type& Frequency,
              const Integration_Limit_type& Integration_Limit,
              const Encoder_Separation_type& Encoder_Separation,
              const Overshoot_type& Overshoot,
              const Attenuation_Shift_type& Attenuation_Shift,
              const Filter_type& Filter,
              const Default_Rx_Gain_Doppler_type& Default_Rx_Gain_Doppler,
              const Peak_Vel_Correction_type& Peak_Vel_Correction,
              const Detect_Ratio_Max_type& Detect_Ratio_Max,
              const Acceleration_Limit_Constant_type& Acceleration_Limit_Constant,
              const Filter_Doppler_Low_type& Filter_Doppler_Low,
              const Frequency_Doppler_type& Frequency_Doppler,
              const Detect_Ratio_Min_type& Detect_Ratio_Min,
              const Derivative_Time_type& Derivative_Time,
              const Filter_High_type& Filter_High,
              const Motor_Overhead_type& Motor_Overhead,
              const Version_type& Version,
              const Filter_Low_type& Filter_Low)
: ::xml_schema::type (),
  Notes_ (Notes, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Focal_Length_ (Focal_Length, ::xml_schema::flags (), this),
  Acceleration_Limit_Slope_ (Acceleration_Limit_Slope, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Detect_Id_ (Detect_Id, ::xml_schema::flags (), this),
  Default_Scan_Speed_ (Default_Scan_Speed, ::xml_schema::flags (), this),
  K1_Power_ (K1_Power, ::xml_schema::flags (), this),
  Cutoff_Scan_Speed_ (Cutoff_Scan_Speed, ::xml_schema::flags (), this),
  Frequency_Low_ (Frequency_Low, ::xml_schema::flags (), this),
  Default_FOV_ (Default_FOV, ::xml_schema::flags (), this),
  Frequency_Doppler_Default_ (Frequency_Doppler_Default, ::xml_schema::flags (), this),
  Default_SvSize_MMode_ (Default_SvSize_MMode, ::xml_schema::flags (), this),
  Axial_Res_Factor_Target_ (Axial_Res_Factor_Target, ::xml_schema::flags (), this),
  F_Number_ (F_Number, ::xml_schema::flags (), this),
  Acc_Time_Factor_ (Acc_Time_Factor, ::xml_schema::flags (), this),
  Axial_Res_ (Axial_Res, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Target_ (Lateral_Res_Factor_Target, ::xml_schema::flags (), this),
  Pivot_Encoder_Dist_ (Pivot_Encoder_Dist, ::xml_schema::flags (), this),
  Encoder_Range_Max_ (Encoder_Range_Max, ::xml_schema::flags (), this),
  Encoder_Range_Min_ (Encoder_Range_Min, ::xml_schema::flags (), this),
  Lateral_Res_ (Lateral_Res, ::xml_schema::flags (), this),
  Max_Scan_Distance_ (Max_Scan_Distance, ::xml_schema::flags (), this),
  Default_Rx_Gain_ (Default_Rx_Gain, ::xml_schema::flags (), this),
  PID_KD_High_ (PID_KD_High, ::xml_schema::flags (), this),
  PID_KI_High_ (PID_KI_High, ::xml_schema::flags (), this),
  PID_KP_High_ (PID_KP_High, ::xml_schema::flags (), this),
  Frequency_High_ (Frequency_High, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Max_ (Lateral_Res_Factor_Max, ::xml_schema::flags (), this),
  Scan_Speeds_ (Scan_Speeds, ::xml_schema::flags (), this),
  Filter_Doppler_Cutoff_ (Filter_Doppler_Cutoff, ::xml_schema::flags (), this),
  Name_ (Name, ::xml_schema::flags (), this),
  PID_KD_Low_ (PID_KD_Low, ::xml_schema::flags (), this),
  PID_KI_Low_ (PID_KI_Low, ::xml_schema::flags (), this),
  PID_KP_Low_ (PID_KP_Low, ::xml_schema::flags (), this),
  Peak_Bandwidth_Correction_ (Peak_Bandwidth_Correction, ::xml_schema::flags (), this),
  Frequency_Doppler_Low_ (Frequency_Doppler_Low, ::xml_schema::flags (), this),
  Pivot_Transducer_Face_Dist_ (Pivot_Transducer_Face_Dist, ::xml_schema::flags (), this),
  Filter_Doppler_ (Filter_Doppler, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  Encoder_Separation_ (Encoder_Separation, ::xml_schema::flags (), this),
  Overshoot_ (Overshoot, ::xml_schema::flags (), this),
  Attenuation_Shift_ (Attenuation_Shift, ::xml_schema::flags (), this),
  Filter_ (Filter, ::xml_schema::flags (), this),
  Default_Rx_Gain_Doppler_ (Default_Rx_Gain_Doppler, ::xml_schema::flags (), this),
  Peak_Vel_Correction_ (Peak_Vel_Correction, ::xml_schema::flags (), this),
  Detect_Ratio_Max_ (Detect_Ratio_Max, ::xml_schema::flags (), this),
  Acceleration_Limit_Constant_ (Acceleration_Limit_Constant, ::xml_schema::flags (), this),
  Filter_Doppler_Low_ (Filter_Doppler_Low, ::xml_schema::flags (), this),
  Frequency_Doppler_ (Frequency_Doppler, ::xml_schema::flags (), this),
  Detect_Ratio_Min_ (Detect_Ratio_Min, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Filter_High_ (Filter_High, ::xml_schema::flags (), this),
  Motor_Overhead_ (Motor_Overhead, ::xml_schema::flags (), this),
  Version_ (Version, ::xml_schema::flags (), this),
  Filter_Low_ (Filter_Low, ::xml_schema::flags (), this)
{
}

ActiveProbe1::
ActiveProbe1 (const Notes_type& Notes,
              ::std::auto_ptr< Sample_Time_type >& Sample_Time,
              ::std::auto_ptr< Focal_Length_type >& Focal_Length,
              const Acceleration_Limit_Slope_type& Acceleration_Limit_Slope,
              const Type_type& Type,
              const Detect_Id_type& Detect_Id,
              ::std::auto_ptr< Default_Scan_Speed_type >& Default_Scan_Speed,
              const K1_Power_type& K1_Power,
              ::std::auto_ptr< Cutoff_Scan_Speed_type >& Cutoff_Scan_Speed,
              ::std::auto_ptr< Frequency_Low_type >& Frequency_Low,
              ::std::auto_ptr< Default_FOV_type >& Default_FOV,
              ::std::auto_ptr< Frequency_Doppler_Default_type >& Frequency_Doppler_Default,
              const Default_SvSize_MMode_type& Default_SvSize_MMode,
              const Axial_Res_Factor_Target_type& Axial_Res_Factor_Target,
              const F_Number_type& F_Number,
              const Acc_Time_Factor_type& Acc_Time_Factor,
              ::std::auto_ptr< Axial_Res_type >& Axial_Res,
              const Lateral_Res_Factor_Target_type& Lateral_Res_Factor_Target,
              ::std::auto_ptr< Pivot_Encoder_Dist_type >& Pivot_Encoder_Dist,
              ::std::auto_ptr< Encoder_Range_Max_type >& Encoder_Range_Max,
              ::std::auto_ptr< Encoder_Range_Min_type >& Encoder_Range_Min,
              ::std::auto_ptr< Lateral_Res_type >& Lateral_Res,
              ::std::auto_ptr< Max_Scan_Distance_type >& Max_Scan_Distance,
              ::std::auto_ptr< Default_Rx_Gain_type >& Default_Rx_Gain,
              const PID_KD_High_type& PID_KD_High,
              const PID_KI_High_type& PID_KI_High,
              const PID_KP_High_type& PID_KP_High,
              ::std::auto_ptr< Frequency_High_type >& Frequency_High,
              const Lateral_Res_Factor_Max_type& Lateral_Res_Factor_Max,
              ::std::auto_ptr< Scan_Speeds_type >& Scan_Speeds,
              ::std::auto_ptr< Filter_Doppler_Cutoff_type >& Filter_Doppler_Cutoff,
              const Name_type& Name,
              const PID_KD_Low_type& PID_KD_Low,
              const PID_KI_Low_type& PID_KI_Low,
              const PID_KP_Low_type& PID_KP_Low,
              const Peak_Bandwidth_Correction_type& Peak_Bandwidth_Correction,
              ::std::auto_ptr< Frequency_Doppler_Low_type >& Frequency_Doppler_Low,
              ::std::auto_ptr< Pivot_Transducer_Face_Dist_type >& Pivot_Transducer_Face_Dist,
              ::std::auto_ptr< Filter_Doppler_type >& Filter_Doppler,
              ::std::auto_ptr< Frequency_type >& Frequency,
              const Integration_Limit_type& Integration_Limit,
              ::std::auto_ptr< Encoder_Separation_type >& Encoder_Separation,
              ::std::auto_ptr< Overshoot_type >& Overshoot,
              const Attenuation_Shift_type& Attenuation_Shift,
              ::std::auto_ptr< Filter_type >& Filter,
              ::std::auto_ptr< Default_Rx_Gain_Doppler_type >& Default_Rx_Gain_Doppler,
              const Peak_Vel_Correction_type& Peak_Vel_Correction,
              const Detect_Ratio_Max_type& Detect_Ratio_Max,
              const Acceleration_Limit_Constant_type& Acceleration_Limit_Constant,
              ::std::auto_ptr< Filter_Doppler_Low_type >& Filter_Doppler_Low,
              ::std::auto_ptr< Frequency_Doppler_type >& Frequency_Doppler,
              const Detect_Ratio_Min_type& Detect_Ratio_Min,
              const Derivative_Time_type& Derivative_Time,
              ::std::auto_ptr< Filter_High_type >& Filter_High,
              ::std::auto_ptr< Motor_Overhead_type >& Motor_Overhead,
              const Version_type& Version,
              ::std::auto_ptr< Filter_Low_type >& Filter_Low)
: ::xml_schema::type (),
  Notes_ (Notes, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Focal_Length_ (Focal_Length, ::xml_schema::flags (), this),
  Acceleration_Limit_Slope_ (Acceleration_Limit_Slope, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Detect_Id_ (Detect_Id, ::xml_schema::flags (), this),
  Default_Scan_Speed_ (Default_Scan_Speed, ::xml_schema::flags (), this),
  K1_Power_ (K1_Power, ::xml_schema::flags (), this),
  Cutoff_Scan_Speed_ (Cutoff_Scan_Speed, ::xml_schema::flags (), this),
  Frequency_Low_ (Frequency_Low, ::xml_schema::flags (), this),
  Default_FOV_ (Default_FOV, ::xml_schema::flags (), this),
  Frequency_Doppler_Default_ (Frequency_Doppler_Default, ::xml_schema::flags (), this),
  Default_SvSize_MMode_ (Default_SvSize_MMode, ::xml_schema::flags (), this),
  Axial_Res_Factor_Target_ (Axial_Res_Factor_Target, ::xml_schema::flags (), this),
  F_Number_ (F_Number, ::xml_schema::flags (), this),
  Acc_Time_Factor_ (Acc_Time_Factor, ::xml_schema::flags (), this),
  Axial_Res_ (Axial_Res, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Target_ (Lateral_Res_Factor_Target, ::xml_schema::flags (), this),
  Pivot_Encoder_Dist_ (Pivot_Encoder_Dist, ::xml_schema::flags (), this),
  Encoder_Range_Max_ (Encoder_Range_Max, ::xml_schema::flags (), this),
  Encoder_Range_Min_ (Encoder_Range_Min, ::xml_schema::flags (), this),
  Lateral_Res_ (Lateral_Res, ::xml_schema::flags (), this),
  Max_Scan_Distance_ (Max_Scan_Distance, ::xml_schema::flags (), this),
  Default_Rx_Gain_ (Default_Rx_Gain, ::xml_schema::flags (), this),
  PID_KD_High_ (PID_KD_High, ::xml_schema::flags (), this),
  PID_KI_High_ (PID_KI_High, ::xml_schema::flags (), this),
  PID_KP_High_ (PID_KP_High, ::xml_schema::flags (), this),
  Frequency_High_ (Frequency_High, ::xml_schema::flags (), this),
  Lateral_Res_Factor_Max_ (Lateral_Res_Factor_Max, ::xml_schema::flags (), this),
  Scan_Speeds_ (Scan_Speeds, ::xml_schema::flags (), this),
  Filter_Doppler_Cutoff_ (Filter_Doppler_Cutoff, ::xml_schema::flags (), this),
  Name_ (Name, ::xml_schema::flags (), this),
  PID_KD_Low_ (PID_KD_Low, ::xml_schema::flags (), this),
  PID_KI_Low_ (PID_KI_Low, ::xml_schema::flags (), this),
  PID_KP_Low_ (PID_KP_Low, ::xml_schema::flags (), this),
  Peak_Bandwidth_Correction_ (Peak_Bandwidth_Correction, ::xml_schema::flags (), this),
  Frequency_Doppler_Low_ (Frequency_Doppler_Low, ::xml_schema::flags (), this),
  Pivot_Transducer_Face_Dist_ (Pivot_Transducer_Face_Dist, ::xml_schema::flags (), this),
  Filter_Doppler_ (Filter_Doppler, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  Encoder_Separation_ (Encoder_Separation, ::xml_schema::flags (), this),
  Overshoot_ (Overshoot, ::xml_schema::flags (), this),
  Attenuation_Shift_ (Attenuation_Shift, ::xml_schema::flags (), this),
  Filter_ (Filter, ::xml_schema::flags (), this),
  Default_Rx_Gain_Doppler_ (Default_Rx_Gain_Doppler, ::xml_schema::flags (), this),
  Peak_Vel_Correction_ (Peak_Vel_Correction, ::xml_schema::flags (), this),
  Detect_Ratio_Max_ (Detect_Ratio_Max, ::xml_schema::flags (), this),
  Acceleration_Limit_Constant_ (Acceleration_Limit_Constant, ::xml_schema::flags (), this),
  Filter_Doppler_Low_ (Filter_Doppler_Low, ::xml_schema::flags (), this),
  Frequency_Doppler_ (Frequency_Doppler, ::xml_schema::flags (), this),
  Detect_Ratio_Min_ (Detect_Ratio_Min, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Filter_High_ (Filter_High, ::xml_schema::flags (), this),
  Motor_Overhead_ (Motor_Overhead, ::xml_schema::flags (), this),
  Version_ (Version, ::xml_schema::flags (), this),
  Filter_Low_ (Filter_Low, ::xml_schema::flags (), this)
{
}

ActiveProbe1::
ActiveProbe1 (const ActiveProbe1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Notes_ (x.Notes_, f, this),
  Sample_Time_ (x.Sample_Time_, f, this),
  Focal_Length_ (x.Focal_Length_, f, this),
  Acceleration_Limit_Slope_ (x.Acceleration_Limit_Slope_, f, this),
  Type_ (x.Type_, f, this),
  Detect_Id_ (x.Detect_Id_, f, this),
  Default_Scan_Speed_ (x.Default_Scan_Speed_, f, this),
  K1_Power_ (x.K1_Power_, f, this),
  Cutoff_Scan_Speed_ (x.Cutoff_Scan_Speed_, f, this),
  Frequency_Low_ (x.Frequency_Low_, f, this),
  Default_FOV_ (x.Default_FOV_, f, this),
  Frequency_Doppler_Default_ (x.Frequency_Doppler_Default_, f, this),
  Default_SvSize_MMode_ (x.Default_SvSize_MMode_, f, this),
  Axial_Res_Factor_Target_ (x.Axial_Res_Factor_Target_, f, this),
  F_Number_ (x.F_Number_, f, this),
  Acc_Time_Factor_ (x.Acc_Time_Factor_, f, this),
  Axial_Res_ (x.Axial_Res_, f, this),
  Lateral_Res_Factor_Target_ (x.Lateral_Res_Factor_Target_, f, this),
  Pivot_Encoder_Dist_ (x.Pivot_Encoder_Dist_, f, this),
  Encoder_Range_Max_ (x.Encoder_Range_Max_, f, this),
  Encoder_Range_Min_ (x.Encoder_Range_Min_, f, this),
  Lateral_Res_ (x.Lateral_Res_, f, this),
  Max_Scan_Distance_ (x.Max_Scan_Distance_, f, this),
  Default_Rx_Gain_ (x.Default_Rx_Gain_, f, this),
  PID_KD_High_ (x.PID_KD_High_, f, this),
  PID_KI_High_ (x.PID_KI_High_, f, this),
  PID_KP_High_ (x.PID_KP_High_, f, this),
  Frequency_High_ (x.Frequency_High_, f, this),
  Lateral_Res_Factor_Max_ (x.Lateral_Res_Factor_Max_, f, this),
  Scan_Speeds_ (x.Scan_Speeds_, f, this),
  Filter_Doppler_Cutoff_ (x.Filter_Doppler_Cutoff_, f, this),
  Name_ (x.Name_, f, this),
  PID_KD_Low_ (x.PID_KD_Low_, f, this),
  PID_KI_Low_ (x.PID_KI_Low_, f, this),
  PID_KP_Low_ (x.PID_KP_Low_, f, this),
  Peak_Bandwidth_Correction_ (x.Peak_Bandwidth_Correction_, f, this),
  Frequency_Doppler_Low_ (x.Frequency_Doppler_Low_, f, this),
  Pivot_Transducer_Face_Dist_ (x.Pivot_Transducer_Face_Dist_, f, this),
  Filter_Doppler_ (x.Filter_Doppler_, f, this),
  Frequency_ (x.Frequency_, f, this),
  Integration_Limit_ (x.Integration_Limit_, f, this),
  Encoder_Separation_ (x.Encoder_Separation_, f, this),
  Overshoot_ (x.Overshoot_, f, this),
  Attenuation_Shift_ (x.Attenuation_Shift_, f, this),
  Filter_ (x.Filter_, f, this),
  Default_Rx_Gain_Doppler_ (x.Default_Rx_Gain_Doppler_, f, this),
  Peak_Vel_Correction_ (x.Peak_Vel_Correction_, f, this),
  Detect_Ratio_Max_ (x.Detect_Ratio_Max_, f, this),
  Acceleration_Limit_Constant_ (x.Acceleration_Limit_Constant_, f, this),
  Filter_Doppler_Low_ (x.Filter_Doppler_Low_, f, this),
  Frequency_Doppler_ (x.Frequency_Doppler_, f, this),
  Detect_Ratio_Min_ (x.Detect_Ratio_Min_, f, this),
  Derivative_Time_ (x.Derivative_Time_, f, this),
  Filter_High_ (x.Filter_High_, f, this),
  Motor_Overhead_ (x.Motor_Overhead_, f, this),
  Version_ (x.Version_, f, this),
  Filter_Low_ (x.Filter_Low_, f, this)
{
}

ActiveProbe1::
ActiveProbe1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Notes_ (f, this),
  Sample_Time_ (f, this),
  Focal_Length_ (f, this),
  Acceleration_Limit_Slope_ (f, this),
  Type_ (f, this),
  Detect_Id_ (f, this),
  Default_Scan_Speed_ (f, this),
  K1_Power_ (f, this),
  Cutoff_Scan_Speed_ (f, this),
  Frequency_Low_ (f, this),
  Default_FOV_ (f, this),
  Frequency_Doppler_Default_ (f, this),
  Default_SvSize_MMode_ (f, this),
  Axial_Res_Factor_Target_ (f, this),
  F_Number_ (f, this),
  Acc_Time_Factor_ (f, this),
  Axial_Res_ (f, this),
  Lateral_Res_Factor_Target_ (f, this),
  Pivot_Encoder_Dist_ (f, this),
  Encoder_Range_Max_ (f, this),
  Encoder_Range_Min_ (f, this),
  Lateral_Res_ (f, this),
  Max_Scan_Distance_ (f, this),
  Default_Rx_Gain_ (f, this),
  PID_KD_High_ (f, this),
  PID_KI_High_ (f, this),
  PID_KP_High_ (f, this),
  Frequency_High_ (f, this),
  Lateral_Res_Factor_Max_ (f, this),
  Scan_Speeds_ (f, this),
  Filter_Doppler_Cutoff_ (f, this),
  Name_ (f, this),
  PID_KD_Low_ (f, this),
  PID_KI_Low_ (f, this),
  PID_KP_Low_ (f, this),
  Peak_Bandwidth_Correction_ (f, this),
  Frequency_Doppler_Low_ (f, this),
  Pivot_Transducer_Face_Dist_ (f, this),
  Filter_Doppler_ (f, this),
  Frequency_ (f, this),
  Integration_Limit_ (f, this),
  Encoder_Separation_ (f, this),
  Overshoot_ (f, this),
  Attenuation_Shift_ (f, this),
  Filter_ (f, this),
  Default_Rx_Gain_Doppler_ (f, this),
  Peak_Vel_Correction_ (f, this),
  Detect_Ratio_Max_ (f, this),
  Acceleration_Limit_Constant_ (f, this),
  Filter_Doppler_Low_ (f, this),
  Frequency_Doppler_ (f, this),
  Detect_Ratio_Min_ (f, this),
  Derivative_Time_ (f, this),
  Filter_High_ (f, this),
  Motor_Overhead_ (f, this),
  Version_ (f, this),
  Filter_Low_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ActiveProbe1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Notes
    //
    if (n.name () == "Notes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Notes_type > r (
        Notes_traits::create (i, f, this));

      if (!Notes_.present ())
      {
        this->Notes_.set (r);
        continue;
      }
    }

    // Sample-Time
    //
    if (n.name () == "Sample-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sample_Time_type > r (
        Sample_Time_traits::create (i, f, this));

      if (!Sample_Time_.present ())
      {
        this->Sample_Time_.set (r);
        continue;
      }
    }

    // Focal-Length
    //
    if (n.name () == "Focal-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Focal_Length_type > r (
        Focal_Length_traits::create (i, f, this));

      if (!Focal_Length_.present ())
      {
        this->Focal_Length_.set (r);
        continue;
      }
    }

    // Acceleration-Limit-Slope
    //
    if (n.name () == "Acceleration-Limit-Slope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Limit_Slope_type > r (
        Acceleration_Limit_Slope_traits::create (i, f, this));

      if (!Acceleration_Limit_Slope_.present ())
      {
        this->Acceleration_Limit_Slope_.set (r);
        continue;
      }
    }

    // Type
    //
    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Type_type > r (
        Type_traits::create (i, f, this));

      if (!Type_.present ())
      {
        this->Type_.set (r);
        continue;
      }
    }

    // Detect-Id
    //
    if (n.name () == "Detect-Id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Id_type > r (
        Detect_Id_traits::create (i, f, this));

      if (!Detect_Id_.present ())
      {
        this->Detect_Id_.set (r);
        continue;
      }
    }

    // Default-Scan-Speed
    //
    if (n.name () == "Default-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Scan_Speed_type > r (
        Default_Scan_Speed_traits::create (i, f, this));

      if (!Default_Scan_Speed_.present ())
      {
        this->Default_Scan_Speed_.set (r);
        continue;
      }
    }

    // K1-Power
    //
    if (n.name () == "K1-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< K1_Power_type > r (
        K1_Power_traits::create (i, f, this));

      if (!K1_Power_.present ())
      {
        this->K1_Power_.set (r);
        continue;
      }
    }

    // Cutoff-Scan-Speed
    //
    if (n.name () == "Cutoff-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cutoff_Scan_Speed_type > r (
        Cutoff_Scan_Speed_traits::create (i, f, this));

      if (!Cutoff_Scan_Speed_.present ())
      {
        this->Cutoff_Scan_Speed_.set (r);
        continue;
      }
    }

    // Frequency-Low
    //
    if (n.name () == "Frequency-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Low_type > r (
        Frequency_Low_traits::create (i, f, this));

      if (!Frequency_Low_.present ())
      {
        this->Frequency_Low_.set (r);
        continue;
      }
    }

    // Default-FOV
    //
    if (n.name () == "Default-FOV" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_FOV_type > r (
        Default_FOV_traits::create (i, f, this));

      if (!Default_FOV_.present ())
      {
        this->Default_FOV_.set (r);
        continue;
      }
    }

    // Frequency-Doppler-Default
    //
    if (n.name () == "Frequency-Doppler-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_Default_type > r (
        Frequency_Doppler_Default_traits::create (i, f, this));

      if (!Frequency_Doppler_Default_.present ())
      {
        this->Frequency_Doppler_Default_.set (r);
        continue;
      }
    }

    // Default-SvSize-MMode
    //
    if (n.name () == "Default-SvSize-MMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_SvSize_MMode_type > r (
        Default_SvSize_MMode_traits::create (i, f, this));

      if (!Default_SvSize_MMode_.present ())
      {
        this->Default_SvSize_MMode_.set (r);
        continue;
      }
    }

    // Axial-Res-Factor-Target
    //
    if (n.name () == "Axial-Res-Factor-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axial_Res_Factor_Target_type > r (
        Axial_Res_Factor_Target_traits::create (i, f, this));

      if (!Axial_Res_Factor_Target_.present ())
      {
        this->Axial_Res_Factor_Target_.set (r);
        continue;
      }
    }

    // F-Number
    //
    if (n.name () == "F-Number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< F_Number_type > r (
        F_Number_traits::create (i, f, this));

      if (!F_Number_.present ())
      {
        this->F_Number_.set (r);
        continue;
      }
    }

    // Acc-Time-Factor
    //
    if (n.name () == "Acc-Time-Factor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acc_Time_Factor_type > r (
        Acc_Time_Factor_traits::create (i, f, this));

      if (!Acc_Time_Factor_.present ())
      {
        this->Acc_Time_Factor_.set (r);
        continue;
      }
    }

    // Axial-Res
    //
    if (n.name () == "Axial-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axial_Res_type > r (
        Axial_Res_traits::create (i, f, this));

      if (!Axial_Res_.present ())
      {
        this->Axial_Res_.set (r);
        continue;
      }
    }

    // Lateral-Res-Factor-Target
    //
    if (n.name () == "Lateral-Res-Factor-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_Factor_Target_type > r (
        Lateral_Res_Factor_Target_traits::create (i, f, this));

      if (!Lateral_Res_Factor_Target_.present ())
      {
        this->Lateral_Res_Factor_Target_.set (r);
        continue;
      }
    }

    // Pivot-Encoder-Dist
    //
    if (n.name () == "Pivot-Encoder-Dist" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pivot_Encoder_Dist_type > r (
        Pivot_Encoder_Dist_traits::create (i, f, this));

      if (!Pivot_Encoder_Dist_.present ())
      {
        this->Pivot_Encoder_Dist_.set (r);
        continue;
      }
    }

    // Encoder-Range-Max
    //
    if (n.name () == "Encoder-Range-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Range_Max_type > r (
        Encoder_Range_Max_traits::create (i, f, this));

      if (!Encoder_Range_Max_.present ())
      {
        this->Encoder_Range_Max_.set (r);
        continue;
      }
    }

    // Encoder-Range-Min
    //
    if (n.name () == "Encoder-Range-Min" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Range_Min_type > r (
        Encoder_Range_Min_traits::create (i, f, this));

      if (!Encoder_Range_Min_.present ())
      {
        this->Encoder_Range_Min_.set (r);
        continue;
      }
    }

    // Lateral-Res
    //
    if (n.name () == "Lateral-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_type > r (
        Lateral_Res_traits::create (i, f, this));

      if (!Lateral_Res_.present ())
      {
        this->Lateral_Res_.set (r);
        continue;
      }
    }

    // Max-Scan-Distance
    //
    if (n.name () == "Max-Scan-Distance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Scan_Distance_type > r (
        Max_Scan_Distance_traits::create (i, f, this));

      if (!Max_Scan_Distance_.present ())
      {
        this->Max_Scan_Distance_.set (r);
        continue;
      }
    }

    // Default-Rx-Gain
    //
    if (n.name () == "Default-Rx-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Rx_Gain_type > r (
        Default_Rx_Gain_traits::create (i, f, this));

      if (!Default_Rx_Gain_.present ())
      {
        this->Default_Rx_Gain_.set (r);
        continue;
      }
    }

    // PID-KD-High
    //
    if (n.name () == "PID-KD-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KD_High_type > r (
        PID_KD_High_traits::create (i, f, this));

      if (!PID_KD_High_.present ())
      {
        this->PID_KD_High_.set (r);
        continue;
      }
    }

    // PID-KI-High
    //
    if (n.name () == "PID-KI-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KI_High_type > r (
        PID_KI_High_traits::create (i, f, this));

      if (!PID_KI_High_.present ())
      {
        this->PID_KI_High_.set (r);
        continue;
      }
    }

    // PID-KP-High
    //
    if (n.name () == "PID-KP-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KP_High_type > r (
        PID_KP_High_traits::create (i, f, this));

      if (!PID_KP_High_.present ())
      {
        this->PID_KP_High_.set (r);
        continue;
      }
    }

    // Frequency-High
    //
    if (n.name () == "Frequency-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_High_type > r (
        Frequency_High_traits::create (i, f, this));

      if (!Frequency_High_.present ())
      {
        this->Frequency_High_.set (r);
        continue;
      }
    }

    // Lateral-Res-Factor-Max
    //
    if (n.name () == "Lateral-Res-Factor-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lateral_Res_Factor_Max_type > r (
        Lateral_Res_Factor_Max_traits::create (i, f, this));

      if (!Lateral_Res_Factor_Max_.present ())
      {
        this->Lateral_Res_Factor_Max_.set (r);
        continue;
      }
    }

    // Scan-Speeds
    //
    if (n.name () == "Scan-Speeds" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Speeds_type > r (
        Scan_Speeds_traits::create (i, f, this));

      if (!Scan_Speeds_.present ())
      {
        this->Scan_Speeds_.set (r);
        continue;
      }
    }

    // Filter-Doppler-Cutoff
    //
    if (n.name () == "Filter-Doppler-Cutoff" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_Cutoff_type > r (
        Filter_Doppler_Cutoff_traits::create (i, f, this));

      if (!Filter_Doppler_Cutoff_.present ())
      {
        this->Filter_Doppler_Cutoff_.set (r);
        continue;
      }
    }

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (r);
        continue;
      }
    }

    // PID-KD-Low
    //
    if (n.name () == "PID-KD-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KD_Low_type > r (
        PID_KD_Low_traits::create (i, f, this));

      if (!PID_KD_Low_.present ())
      {
        this->PID_KD_Low_.set (r);
        continue;
      }
    }

    // PID-KI-Low
    //
    if (n.name () == "PID-KI-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KI_Low_type > r (
        PID_KI_Low_traits::create (i, f, this));

      if (!PID_KI_Low_.present ())
      {
        this->PID_KI_Low_.set (r);
        continue;
      }
    }

    // PID-KP-Low
    //
    if (n.name () == "PID-KP-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PID_KP_Low_type > r (
        PID_KP_Low_traits::create (i, f, this));

      if (!PID_KP_Low_.present ())
      {
        this->PID_KP_Low_.set (r);
        continue;
      }
    }

    // Peak-Bandwidth-Correction
    //
    if (n.name () == "Peak-Bandwidth-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Peak_Bandwidth_Correction_type > r (
        Peak_Bandwidth_Correction_traits::create (i, f, this));

      if (!Peak_Bandwidth_Correction_.present ())
      {
        this->Peak_Bandwidth_Correction_.set (r);
        continue;
      }
    }

    // Frequency-Doppler-Low
    //
    if (n.name () == "Frequency-Doppler-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_Low_type > r (
        Frequency_Doppler_Low_traits::create (i, f, this));

      if (!Frequency_Doppler_Low_.present ())
      {
        this->Frequency_Doppler_Low_.set (r);
        continue;
      }
    }

    // Pivot-Transducer-Face-Dist
    //
    if (n.name () == "Pivot-Transducer-Face-Dist" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pivot_Transducer_Face_Dist_type > r (
        Pivot_Transducer_Face_Dist_traits::create (i, f, this));

      if (!Pivot_Transducer_Face_Dist_.present ())
      {
        this->Pivot_Transducer_Face_Dist_.set (r);
        continue;
      }
    }

    // Filter-Doppler
    //
    if (n.name () == "Filter-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_type > r (
        Filter_Doppler_traits::create (i, f, this));

      if (!Filter_Doppler_.present ())
      {
        this->Filter_Doppler_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // Integration-Limit
    //
    if (n.name () == "Integration-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Integration_Limit_type > r (
        Integration_Limit_traits::create (i, f, this));

      if (!Integration_Limit_.present ())
      {
        this->Integration_Limit_.set (r);
        continue;
      }
    }

    // Encoder-Separation
    //
    if (n.name () == "Encoder-Separation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Separation_type > r (
        Encoder_Separation_traits::create (i, f, this));

      if (!Encoder_Separation_.present ())
      {
        this->Encoder_Separation_.set (r);
        continue;
      }
    }

    // Overshoot
    //
    if (n.name () == "Overshoot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Overshoot_type > r (
        Overshoot_traits::create (i, f, this));

      if (!Overshoot_.present ())
      {
        this->Overshoot_.set (r);
        continue;
      }
    }

    // Attenuation-Shift
    //
    if (n.name () == "Attenuation-Shift" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attenuation_Shift_type > r (
        Attenuation_Shift_traits::create (i, f, this));

      if (!Attenuation_Shift_.present ())
      {
        this->Attenuation_Shift_.set (r);
        continue;
      }
    }

    // Filter
    //
    if (n.name () == "Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_type > r (
        Filter_traits::create (i, f, this));

      if (!Filter_.present ())
      {
        this->Filter_.set (r);
        continue;
      }
    }

    // Default-Rx-Gain-Doppler
    //
    if (n.name () == "Default-Rx-Gain-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Default_Rx_Gain_Doppler_type > r (
        Default_Rx_Gain_Doppler_traits::create (i, f, this));

      if (!Default_Rx_Gain_Doppler_.present ())
      {
        this->Default_Rx_Gain_Doppler_.set (r);
        continue;
      }
    }

    // Peak-Vel-Correction
    //
    if (n.name () == "Peak-Vel-Correction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Peak_Vel_Correction_type > r (
        Peak_Vel_Correction_traits::create (i, f, this));

      if (!Peak_Vel_Correction_.present ())
      {
        this->Peak_Vel_Correction_.set (r);
        continue;
      }
    }

    // Detect-Ratio-Max
    //
    if (n.name () == "Detect-Ratio-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Ratio_Max_type > r (
        Detect_Ratio_Max_traits::create (i, f, this));

      if (!Detect_Ratio_Max_.present ())
      {
        this->Detect_Ratio_Max_.set (r);
        continue;
      }
    }

    // Acceleration-Limit-Constant
    //
    if (n.name () == "Acceleration-Limit-Constant" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Limit_Constant_type > r (
        Acceleration_Limit_Constant_traits::create (i, f, this));

      if (!Acceleration_Limit_Constant_.present ())
      {
        this->Acceleration_Limit_Constant_.set (r);
        continue;
      }
    }

    // Filter-Doppler-Low
    //
    if (n.name () == "Filter-Doppler-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Doppler_Low_type > r (
        Filter_Doppler_Low_traits::create (i, f, this));

      if (!Filter_Doppler_Low_.present ())
      {
        this->Filter_Doppler_Low_.set (r);
        continue;
      }
    }

    // Frequency-Doppler
    //
    if (n.name () == "Frequency-Doppler" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_Doppler_type > r (
        Frequency_Doppler_traits::create (i, f, this));

      if (!Frequency_Doppler_.present ())
      {
        this->Frequency_Doppler_.set (r);
        continue;
      }
    }

    // Detect-Ratio-Min
    //
    if (n.name () == "Detect-Ratio-Min" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Detect_Ratio_Min_type > r (
        Detect_Ratio_Min_traits::create (i, f, this));

      if (!Detect_Ratio_Min_.present ())
      {
        this->Detect_Ratio_Min_.set (r);
        continue;
      }
    }

    // Derivative-Time
    //
    if (n.name () == "Derivative-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Derivative_Time_type > r (
        Derivative_Time_traits::create (i, f, this));

      if (!Derivative_Time_.present ())
      {
        this->Derivative_Time_.set (r);
        continue;
      }
    }

    // Filter-High
    //
    if (n.name () == "Filter-High" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_High_type > r (
        Filter_High_traits::create (i, f, this));

      if (!Filter_High_.present ())
      {
        this->Filter_High_.set (r);
        continue;
      }
    }

    // Motor-Overhead
    //
    if (n.name () == "Motor-Overhead" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Overhead_type > r (
        Motor_Overhead_traits::create (i, f, this));

      if (!Motor_Overhead_.present ())
      {
        this->Motor_Overhead_.set (r);
        continue;
      }
    }

    // Version
    //
    if (n.name () == "Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Version_type > r (
        Version_traits::create (i, f, this));

      if (!Version_.present ())
      {
        this->Version_.set (r);
        continue;
      }
    }

    // Filter-Low
    //
    if (n.name () == "Filter-Low" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Low_type > r (
        Filter_Low_traits::create (i, f, this));

      if (!Filter_Low_.present ())
      {
        this->Filter_Low_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Notes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Notes",
      "");
  }

  if (!Sample_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sample-Time",
      "");
  }

  if (!Focal_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Focal-Length",
      "");
  }

  if (!Acceleration_Limit_Slope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Limit-Slope",
      "");
  }

  if (!Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Type",
      "");
  }

  if (!Detect_Id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Id",
      "");
  }

  if (!Default_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Scan-Speed",
      "");
  }

  if (!K1_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "K1-Power",
      "");
  }

  if (!Cutoff_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cutoff-Scan-Speed",
      "");
  }

  if (!Frequency_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Low",
      "");
  }

  if (!Default_FOV_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-FOV",
      "");
  }

  if (!Frequency_Doppler_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler-Default",
      "");
  }

  if (!Default_SvSize_MMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-SvSize-MMode",
      "");
  }

  if (!Axial_Res_Factor_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axial-Res-Factor-Target",
      "");
  }

  if (!F_Number_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "F-Number",
      "");
  }

  if (!Acc_Time_Factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acc-Time-Factor",
      "");
  }

  if (!Axial_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axial-Res",
      "");
  }

  if (!Lateral_Res_Factor_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res-Factor-Target",
      "");
  }

  if (!Pivot_Encoder_Dist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pivot-Encoder-Dist",
      "");
  }

  if (!Encoder_Range_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Range-Max",
      "");
  }

  if (!Encoder_Range_Min_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Range-Min",
      "");
  }

  if (!Lateral_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res",
      "");
  }

  if (!Max_Scan_Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Scan-Distance",
      "");
  }

  if (!Default_Rx_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Rx-Gain",
      "");
  }

  if (!PID_KD_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KD-High",
      "");
  }

  if (!PID_KI_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KI-High",
      "");
  }

  if (!PID_KP_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KP-High",
      "");
  }

  if (!Frequency_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-High",
      "");
  }

  if (!Lateral_Res_Factor_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Lateral-Res-Factor-Max",
      "");
  }

  if (!Scan_Speeds_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Speeds",
      "");
  }

  if (!Filter_Doppler_Cutoff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler-Cutoff",
      "");
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!PID_KD_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KD-Low",
      "");
  }

  if (!PID_KI_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KI-Low",
      "");
  }

  if (!PID_KP_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PID-KP-Low",
      "");
  }

  if (!Peak_Bandwidth_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Peak-Bandwidth-Correction",
      "");
  }

  if (!Frequency_Doppler_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler-Low",
      "");
  }

  if (!Pivot_Transducer_Face_Dist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pivot-Transducer-Face-Dist",
      "");
  }

  if (!Filter_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!Integration_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Integration-Limit",
      "");
  }

  if (!Encoder_Separation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Separation",
      "");
  }

  if (!Overshoot_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Overshoot",
      "");
  }

  if (!Attenuation_Shift_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Attenuation-Shift",
      "");
  }

  if (!Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter",
      "");
  }

  if (!Default_Rx_Gain_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default-Rx-Gain-Doppler",
      "");
  }

  if (!Peak_Vel_Correction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Peak-Vel-Correction",
      "");
  }

  if (!Detect_Ratio_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Ratio-Max",
      "");
  }

  if (!Acceleration_Limit_Constant_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Limit-Constant",
      "");
  }

  if (!Filter_Doppler_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Doppler-Low",
      "");
  }

  if (!Frequency_Doppler_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency-Doppler",
      "");
  }

  if (!Detect_Ratio_Min_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Detect-Ratio-Min",
      "");
  }

  if (!Derivative_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Derivative-Time",
      "");
  }

  if (!Filter_High_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-High",
      "");
  }

  if (!Motor_Overhead_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Overhead",
      "");
  }

  if (!Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Version",
      "");
  }

  if (!Filter_Low_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Low",
      "");
  }
}

ActiveProbe1* ActiveProbe1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActiveProbe1 (*this, f, c);
}

ActiveProbe1::
~ActiveProbe1 ()
{
}

// BModeSoft1
//

BModeSoft1::
BModeSoft1 (const Anti_Aliasing_type& Anti_Aliasing,
            const V_Relative_Frame_Rate_type& V_Relative_Frame_Rate,
            const Max_Power_Size_Default_type& Max_Power_Size_Default,
            const Buffer_Size_type& Buffer_Size,
            const Sector_Convert_type& Sector_Convert,
            const AVR_Factor_type& AVR_Factor,
            const Flip_Image_type& Flip_Image,
            const AVR_Startup_Frames_type& AVR_Startup_Frames,
            const BMode_Size_Default_type& BMode_Size_Default,
            const Relative_Frame_Rate_type& Relative_Frame_Rate,
            const Overlay_Mode_type& Overlay_Mode,
            const Refresh_Rate_type& Refresh_Rate,
            const Acquisition_Mode_type& Acquisition_Mode,
            const Acquire_Both_Directions_type& Acquire_Both_Directions,
            const Actual_Scan_Rate_type& Actual_Scan_Rate,
            const Acquire_Persist_AVR_type& Acquire_Persist_AVR,
            const Sector_X_Res_type& Sector_X_Res,
            const Sector_Y_Res_type& Sector_Y_Res,
            const Power_Size_Default_type& Power_Size_Default,
            const Sector_X_Start_type& Sector_X_Start,
            const Sector_Y_Start_type& Sector_Y_Start,
            const Max_BMode_Size_Default_type& Max_BMode_Size_Default,
            const Target_Field_Of_View_type& Target_Field_Of_View,
            const Processing_Command_type& Processing_Command)
: ::xml_schema::type (),
  Anti_Aliasing_ (Anti_Aliasing, ::xml_schema::flags (), this),
  V_Relative_Frame_Rate_ (V_Relative_Frame_Rate, ::xml_schema::flags (), this),
  Max_Power_Size_Default_ (Max_Power_Size_Default, ::xml_schema::flags (), this),
  Buffer_Size_ (Buffer_Size, ::xml_schema::flags (), this),
  Sector_Convert_ (Sector_Convert, ::xml_schema::flags (), this),
  AVR_Factor_ (AVR_Factor, ::xml_schema::flags (), this),
  Flip_Image_ (Flip_Image, ::xml_schema::flags (), this),
  AVR_Startup_Frames_ (AVR_Startup_Frames, ::xml_schema::flags (), this),
  BMode_Size_Default_ (BMode_Size_Default, ::xml_schema::flags (), this),
  Relative_Frame_Rate_ (Relative_Frame_Rate, ::xml_schema::flags (), this),
  Overlay_Mode_ (Overlay_Mode, ::xml_schema::flags (), this),
  Refresh_Rate_ (Refresh_Rate, ::xml_schema::flags (), this),
  Acquisition_Mode_ (Acquisition_Mode, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Actual_Scan_Rate_ (Actual_Scan_Rate, ::xml_schema::flags (), this),
  Acquire_Persist_AVR_ (Acquire_Persist_AVR, ::xml_schema::flags (), this),
  Sector_X_Res_ (Sector_X_Res, ::xml_schema::flags (), this),
  Sector_Y_Res_ (Sector_Y_Res, ::xml_schema::flags (), this),
  Power_Size_Default_ (Power_Size_Default, ::xml_schema::flags (), this),
  Sector_X_Start_ (Sector_X_Start, ::xml_schema::flags (), this),
  Sector_Y_Start_ (Sector_Y_Start, ::xml_schema::flags (), this),
  Max_BMode_Size_Default_ (Max_BMode_Size_Default, ::xml_schema::flags (), this),
  Target_Field_Of_View_ (Target_Field_Of_View, ::xml_schema::flags (), this),
  Processing_Command_ (Processing_Command, ::xml_schema::flags (), this)
{
}

BModeSoft1::
BModeSoft1 (const Anti_Aliasing_type& Anti_Aliasing,
            const V_Relative_Frame_Rate_type& V_Relative_Frame_Rate,
            const Max_Power_Size_Default_type& Max_Power_Size_Default,
            ::std::auto_ptr< Buffer_Size_type >& Buffer_Size,
            const Sector_Convert_type& Sector_Convert,
            const AVR_Factor_type& AVR_Factor,
            const Flip_Image_type& Flip_Image,
            const AVR_Startup_Frames_type& AVR_Startup_Frames,
            ::std::auto_ptr< BMode_Size_Default_type >& BMode_Size_Default,
            const Relative_Frame_Rate_type& Relative_Frame_Rate,
            ::std::auto_ptr< Overlay_Mode_type >& Overlay_Mode,
            ::std::auto_ptr< Refresh_Rate_type >& Refresh_Rate,
            ::std::auto_ptr< Acquisition_Mode_type >& Acquisition_Mode,
            const Acquire_Both_Directions_type& Acquire_Both_Directions,
            ::std::auto_ptr< Actual_Scan_Rate_type >& Actual_Scan_Rate,
            const Acquire_Persist_AVR_type& Acquire_Persist_AVR,
            ::std::auto_ptr< Sector_X_Res_type >& Sector_X_Res,
            ::std::auto_ptr< Sector_Y_Res_type >& Sector_Y_Res,
            ::std::auto_ptr< Power_Size_Default_type >& Power_Size_Default,
            ::std::auto_ptr< Sector_X_Start_type >& Sector_X_Start,
            ::std::auto_ptr< Sector_Y_Start_type >& Sector_Y_Start,
            const Max_BMode_Size_Default_type& Max_BMode_Size_Default,
            ::std::auto_ptr< Target_Field_Of_View_type >& Target_Field_Of_View,
            const Processing_Command_type& Processing_Command)
: ::xml_schema::type (),
  Anti_Aliasing_ (Anti_Aliasing, ::xml_schema::flags (), this),
  V_Relative_Frame_Rate_ (V_Relative_Frame_Rate, ::xml_schema::flags (), this),
  Max_Power_Size_Default_ (Max_Power_Size_Default, ::xml_schema::flags (), this),
  Buffer_Size_ (Buffer_Size, ::xml_schema::flags (), this),
  Sector_Convert_ (Sector_Convert, ::xml_schema::flags (), this),
  AVR_Factor_ (AVR_Factor, ::xml_schema::flags (), this),
  Flip_Image_ (Flip_Image, ::xml_schema::flags (), this),
  AVR_Startup_Frames_ (AVR_Startup_Frames, ::xml_schema::flags (), this),
  BMode_Size_Default_ (BMode_Size_Default, ::xml_schema::flags (), this),
  Relative_Frame_Rate_ (Relative_Frame_Rate, ::xml_schema::flags (), this),
  Overlay_Mode_ (Overlay_Mode, ::xml_schema::flags (), this),
  Refresh_Rate_ (Refresh_Rate, ::xml_schema::flags (), this),
  Acquisition_Mode_ (Acquisition_Mode, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Actual_Scan_Rate_ (Actual_Scan_Rate, ::xml_schema::flags (), this),
  Acquire_Persist_AVR_ (Acquire_Persist_AVR, ::xml_schema::flags (), this),
  Sector_X_Res_ (Sector_X_Res, ::xml_schema::flags (), this),
  Sector_Y_Res_ (Sector_Y_Res, ::xml_schema::flags (), this),
  Power_Size_Default_ (Power_Size_Default, ::xml_schema::flags (), this),
  Sector_X_Start_ (Sector_X_Start, ::xml_schema::flags (), this),
  Sector_Y_Start_ (Sector_Y_Start, ::xml_schema::flags (), this),
  Max_BMode_Size_Default_ (Max_BMode_Size_Default, ::xml_schema::flags (), this),
  Target_Field_Of_View_ (Target_Field_Of_View, ::xml_schema::flags (), this),
  Processing_Command_ (Processing_Command, ::xml_schema::flags (), this)
{
}

BModeSoft1::
BModeSoft1 (const BModeSoft1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Anti_Aliasing_ (x.Anti_Aliasing_, f, this),
  V_Relative_Frame_Rate_ (x.V_Relative_Frame_Rate_, f, this),
  Max_Power_Size_Default_ (x.Max_Power_Size_Default_, f, this),
  Buffer_Size_ (x.Buffer_Size_, f, this),
  Sector_Convert_ (x.Sector_Convert_, f, this),
  AVR_Factor_ (x.AVR_Factor_, f, this),
  Flip_Image_ (x.Flip_Image_, f, this),
  AVR_Startup_Frames_ (x.AVR_Startup_Frames_, f, this),
  BMode_Size_Default_ (x.BMode_Size_Default_, f, this),
  Relative_Frame_Rate_ (x.Relative_Frame_Rate_, f, this),
  Overlay_Mode_ (x.Overlay_Mode_, f, this),
  Refresh_Rate_ (x.Refresh_Rate_, f, this),
  Acquisition_Mode_ (x.Acquisition_Mode_, f, this),
  Acquire_Both_Directions_ (x.Acquire_Both_Directions_, f, this),
  Actual_Scan_Rate_ (x.Actual_Scan_Rate_, f, this),
  Acquire_Persist_AVR_ (x.Acquire_Persist_AVR_, f, this),
  Sector_X_Res_ (x.Sector_X_Res_, f, this),
  Sector_Y_Res_ (x.Sector_Y_Res_, f, this),
  Power_Size_Default_ (x.Power_Size_Default_, f, this),
  Sector_X_Start_ (x.Sector_X_Start_, f, this),
  Sector_Y_Start_ (x.Sector_Y_Start_, f, this),
  Max_BMode_Size_Default_ (x.Max_BMode_Size_Default_, f, this),
  Target_Field_Of_View_ (x.Target_Field_Of_View_, f, this),
  Processing_Command_ (x.Processing_Command_, f, this)
{
}

BModeSoft1::
BModeSoft1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Anti_Aliasing_ (f, this),
  V_Relative_Frame_Rate_ (f, this),
  Max_Power_Size_Default_ (f, this),
  Buffer_Size_ (f, this),
  Sector_Convert_ (f, this),
  AVR_Factor_ (f, this),
  Flip_Image_ (f, this),
  AVR_Startup_Frames_ (f, this),
  BMode_Size_Default_ (f, this),
  Relative_Frame_Rate_ (f, this),
  Overlay_Mode_ (f, this),
  Refresh_Rate_ (f, this),
  Acquisition_Mode_ (f, this),
  Acquire_Both_Directions_ (f, this),
  Actual_Scan_Rate_ (f, this),
  Acquire_Persist_AVR_ (f, this),
  Sector_X_Res_ (f, this),
  Sector_Y_Res_ (f, this),
  Power_Size_Default_ (f, this),
  Sector_X_Start_ (f, this),
  Sector_Y_Start_ (f, this),
  Max_BMode_Size_Default_ (f, this),
  Target_Field_Of_View_ (f, this),
  Processing_Command_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void BModeSoft1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anti-Aliasing
    //
    if (n.name () == "Anti-Aliasing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Anti_Aliasing_type > r (
        Anti_Aliasing_traits::create (i, f, this));

      if (!Anti_Aliasing_.present ())
      {
        this->Anti_Aliasing_.set (r);
        continue;
      }
    }

    // V-Relative-Frame-Rate
    //
    if (n.name () == "V-Relative-Frame-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Relative_Frame_Rate_type > r (
        V_Relative_Frame_Rate_traits::create (i, f, this));

      if (!V_Relative_Frame_Rate_.present ())
      {
        this->V_Relative_Frame_Rate_.set (r);
        continue;
      }
    }

    // Max-Power-Size-Default
    //
    if (n.name () == "Max-Power-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Power_Size_Default_type > r (
        Max_Power_Size_Default_traits::create (i, f, this));

      if (!Max_Power_Size_Default_.present ())
      {
        this->Max_Power_Size_Default_.set (r);
        continue;
      }
    }

    // Buffer-Size
    //
    if (n.name () == "Buffer-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Size_type > r (
        Buffer_Size_traits::create (i, f, this));

      if (!Buffer_Size_.present ())
      {
        this->Buffer_Size_.set (r);
        continue;
      }
    }

    // Sector-Convert
    //
    if (n.name () == "Sector-Convert" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Convert_type > r (
        Sector_Convert_traits::create (i, f, this));

      if (!Sector_Convert_.present ())
      {
        this->Sector_Convert_.set (r);
        continue;
      }
    }

    // AVR-Factor
    //
    if (n.name () == "AVR-Factor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AVR_Factor_type > r (
        AVR_Factor_traits::create (i, f, this));

      if (!AVR_Factor_.present ())
      {
        this->AVR_Factor_.set (r);
        continue;
      }
    }

    // Flip-Image
    //
    if (n.name () == "Flip-Image" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Flip_Image_type > r (
        Flip_Image_traits::create (i, f, this));

      if (!Flip_Image_.present ())
      {
        this->Flip_Image_.set (r);
        continue;
      }
    }

    // AVR-Startup-Frames
    //
    if (n.name () == "AVR-Startup-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AVR_Startup_Frames_type > r (
        AVR_Startup_Frames_traits::create (i, f, this));

      if (!AVR_Startup_Frames_.present ())
      {
        this->AVR_Startup_Frames_.set (r);
        continue;
      }
    }

    // BMode-Size-Default
    //
    if (n.name () == "BMode-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BMode_Size_Default_type > r (
        BMode_Size_Default_traits::create (i, f, this));

      if (!BMode_Size_Default_.present ())
      {
        this->BMode_Size_Default_.set (r);
        continue;
      }
    }

    // Relative-Frame-Rate
    //
    if (n.name () == "Relative-Frame-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Relative_Frame_Rate_type > r (
        Relative_Frame_Rate_traits::create (i, f, this));

      if (!Relative_Frame_Rate_.present ())
      {
        this->Relative_Frame_Rate_.set (r);
        continue;
      }
    }

    // Overlay-Mode
    //
    if (n.name () == "Overlay-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Overlay_Mode_type > r (
        Overlay_Mode_traits::create (i, f, this));

      if (!Overlay_Mode_.present ())
      {
        this->Overlay_Mode_.set (r);
        continue;
      }
    }

    // Refresh-Rate
    //
    if (n.name () == "Refresh-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Refresh_Rate_type > r (
        Refresh_Rate_traits::create (i, f, this));

      if (!Refresh_Rate_.present ())
      {
        this->Refresh_Rate_.set (r);
        continue;
      }
    }

    // Acquisition-Mode
    //
    if (n.name () == "Acquisition-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_Mode_type > r (
        Acquisition_Mode_traits::create (i, f, this));

      if (!Acquisition_Mode_.present ())
      {
        this->Acquisition_Mode_.set (r);
        continue;
      }
    }

    // Acquire-Both-Directions
    //
    if (n.name () == "Acquire-Both-Directions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Both_Directions_type > r (
        Acquire_Both_Directions_traits::create (i, f, this));

      if (!Acquire_Both_Directions_.present ())
      {
        this->Acquire_Both_Directions_.set (r);
        continue;
      }
    }

    // Actual-Scan-Rate
    //
    if (n.name () == "Actual-Scan-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Actual_Scan_Rate_type > r (
        Actual_Scan_Rate_traits::create (i, f, this));

      if (!Actual_Scan_Rate_.present ())
      {
        this->Actual_Scan_Rate_.set (r);
        continue;
      }
    }

    // Acquire-Persist-AVR
    //
    if (n.name () == "Acquire-Persist-AVR" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_AVR_type > r (
        Acquire_Persist_AVR_traits::create (i, f, this));

      if (!Acquire_Persist_AVR_.present ())
      {
        this->Acquire_Persist_AVR_.set (r);
        continue;
      }
    }

    // Sector-X-Res
    //
    if (n.name () == "Sector-X-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_X_Res_type > r (
        Sector_X_Res_traits::create (i, f, this));

      if (!Sector_X_Res_.present ())
      {
        this->Sector_X_Res_.set (r);
        continue;
      }
    }

    // Sector-Y-Res
    //
    if (n.name () == "Sector-Y-Res" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Y_Res_type > r (
        Sector_Y_Res_traits::create (i, f, this));

      if (!Sector_Y_Res_.present ())
      {
        this->Sector_Y_Res_.set (r);
        continue;
      }
    }

    // Power-Size-Default
    //
    if (n.name () == "Power-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Power_Size_Default_type > r (
        Power_Size_Default_traits::create (i, f, this));

      if (!Power_Size_Default_.present ())
      {
        this->Power_Size_Default_.set (r);
        continue;
      }
    }

    // Sector-X-Start
    //
    if (n.name () == "Sector-X-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_X_Start_type > r (
        Sector_X_Start_traits::create (i, f, this));

      if (!Sector_X_Start_.present ())
      {
        this->Sector_X_Start_.set (r);
        continue;
      }
    }

    // Sector-Y-Start
    //
    if (n.name () == "Sector-Y-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Y_Start_type > r (
        Sector_Y_Start_traits::create (i, f, this));

      if (!Sector_Y_Start_.present ())
      {
        this->Sector_Y_Start_.set (r);
        continue;
      }
    }

    // Max-BMode-Size-Default
    //
    if (n.name () == "Max-BMode-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_BMode_Size_Default_type > r (
        Max_BMode_Size_Default_traits::create (i, f, this));

      if (!Max_BMode_Size_Default_.present ())
      {
        this->Max_BMode_Size_Default_.set (r);
        continue;
      }
    }

    // Target-Field-Of-View
    //
    if (n.name () == "Target-Field-Of-View" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Target_Field_Of_View_type > r (
        Target_Field_Of_View_traits::create (i, f, this));

      if (!Target_Field_Of_View_.present ())
      {
        this->Target_Field_Of_View_.set (r);
        continue;
      }
    }

    // Processing-Command
    //
    if (n.name () == "Processing-Command" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Processing_Command_type > r (
        Processing_Command_traits::create (i, f, this));

      if (!Processing_Command_.present ())
      {
        this->Processing_Command_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Anti_Aliasing_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Anti-Aliasing",
      "");
  }

  if (!V_Relative_Frame_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Relative-Frame-Rate",
      "");
  }

  if (!Max_Power_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Power-Size-Default",
      "");
  }

  if (!Buffer_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Size",
      "");
  }

  if (!Sector_Convert_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Convert",
      "");
  }

  if (!AVR_Factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AVR-Factor",
      "");
  }

  if (!Flip_Image_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Flip-Image",
      "");
  }

  if (!AVR_Startup_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AVR-Startup-Frames",
      "");
  }

  if (!BMode_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BMode-Size-Default",
      "");
  }

  if (!Relative_Frame_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Relative-Frame-Rate",
      "");
  }

  if (!Overlay_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Overlay-Mode",
      "");
  }

  if (!Refresh_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Refresh-Rate",
      "");
  }

  if (!Acquisition_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition-Mode",
      "");
  }

  if (!Acquire_Both_Directions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Both-Directions",
      "");
  }

  if (!Actual_Scan_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Actual-Scan-Rate",
      "");
  }

  if (!Acquire_Persist_AVR_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-AVR",
      "");
  }

  if (!Sector_X_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-X-Res",
      "");
  }

  if (!Sector_Y_Res_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Y-Res",
      "");
  }

  if (!Power_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Power-Size-Default",
      "");
  }

  if (!Sector_X_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-X-Start",
      "");
  }

  if (!Sector_Y_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Y-Start",
      "");
  }

  if (!Max_BMode_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-BMode-Size-Default",
      "");
  }

  if (!Target_Field_Of_View_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Target-Field-Of-View",
      "");
  }

  if (!Processing_Command_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Processing-Command",
      "");
  }
}

BModeSoft1* BModeSoft1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BModeSoft1 (*this, f, c);
}

BModeSoft1::
~BModeSoft1 ()
{
}

// Sys1
//

Sys1::
Sys1 (const Query_Discard_Loop_On_Save_Frame_type& Query_Discard_Loop_On_Save_Frame,
      const Sound_Speed_type& Sound_Speed,
      const SubMode_type& SubMode,
      const Interrupt_Mask_type& Interrupt_Mask,
      const Calculation_Instances_type& Calculation_Instances,
      const Start_Licence_Date_type& Start_Licence_Date,
      const End_Licence_Date_type& End_Licence_Date,
      const Auto_Save_PreTrig_Loop_type& Auto_Save_PreTrig_Loop,
      const Feature_type& Feature,
      const Acq_Setup_Dialog_type& Acq_Setup_Dialog,
      const Interrupt_Clear_type& Interrupt_Clear,
      const Interrupt_Status_type& Interrupt_Status,
      const Auto_Save_Load_3D_type& Auto_Save_Load_3D,
      const DICOM_Root_ID_type& DICOM_Root_ID,
      const Company_Name_type& Company_Name,
      const Image_To_Auto_Save_On_Label_type& Image_To_Auto_Save_On_Label,
      const DICOM_Encode_Regions_type& DICOM_Encode_Regions,
      const Pipeline_Delay_type& Pipeline_Delay,
      const DDS_Control_type& DDS_Control,
      const Mode_type& Mode,
      const Review_Setup_Dialog_type& Review_Setup_Dialog)
: ::xml_schema::type (),
  Query_Discard_Loop_On_Save_Frame_ (Query_Discard_Loop_On_Save_Frame, ::xml_schema::flags (), this),
  Sound_Speed_ (Sound_Speed, ::xml_schema::flags (), this),
  SubMode_ (SubMode, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Calculation_Instances_ (Calculation_Instances, ::xml_schema::flags (), this),
  Start_Licence_Date_ (Start_Licence_Date, ::xml_schema::flags (), this),
  End_Licence_Date_ (End_Licence_Date, ::xml_schema::flags (), this),
  Auto_Save_PreTrig_Loop_ (Auto_Save_PreTrig_Loop, ::xml_schema::flags (), this),
  Feature_ (Feature, ::xml_schema::flags (), this),
  Acq_Setup_Dialog_ (Acq_Setup_Dialog, ::xml_schema::flags (), this),
  Interrupt_Clear_ (Interrupt_Clear, ::xml_schema::flags (), this),
  Interrupt_Status_ (Interrupt_Status, ::xml_schema::flags (), this),
  Auto_Save_Load_3D_ (Auto_Save_Load_3D, ::xml_schema::flags (), this),
  DICOM_Root_ID_ (DICOM_Root_ID, ::xml_schema::flags (), this),
  Company_Name_ (Company_Name, ::xml_schema::flags (), this),
  Image_To_Auto_Save_On_Label_ (Image_To_Auto_Save_On_Label, ::xml_schema::flags (), this),
  DICOM_Encode_Regions_ (DICOM_Encode_Regions, ::xml_schema::flags (), this),
  Pipeline_Delay_ (Pipeline_Delay, ::xml_schema::flags (), this),
  DDS_Control_ (DDS_Control, ::xml_schema::flags (), this),
  Mode_ (Mode, ::xml_schema::flags (), this),
  Review_Setup_Dialog_ (Review_Setup_Dialog, ::xml_schema::flags (), this)
{
}

Sys1::
Sys1 (const Query_Discard_Loop_On_Save_Frame_type& Query_Discard_Loop_On_Save_Frame,
      ::std::auto_ptr< Sound_Speed_type >& Sound_Speed,
      const SubMode_type& SubMode,
      const Interrupt_Mask_type& Interrupt_Mask,
      const Calculation_Instances_type& Calculation_Instances,
      const Start_Licence_Date_type& Start_Licence_Date,
      const End_Licence_Date_type& End_Licence_Date,
      const Auto_Save_PreTrig_Loop_type& Auto_Save_PreTrig_Loop,
      const Feature_type& Feature,
      const Acq_Setup_Dialog_type& Acq_Setup_Dialog,
      const Interrupt_Clear_type& Interrupt_Clear,
      const Interrupt_Status_type& Interrupt_Status,
      const Auto_Save_Load_3D_type& Auto_Save_Load_3D,
      const DICOM_Root_ID_type& DICOM_Root_ID,
      const Company_Name_type& Company_Name,
      const Image_To_Auto_Save_On_Label_type& Image_To_Auto_Save_On_Label,
      const DICOM_Encode_Regions_type& DICOM_Encode_Regions,
      ::std::auto_ptr< Pipeline_Delay_type >& Pipeline_Delay,
      const DDS_Control_type& DDS_Control,
      const Mode_type& Mode,
      const Review_Setup_Dialog_type& Review_Setup_Dialog)
: ::xml_schema::type (),
  Query_Discard_Loop_On_Save_Frame_ (Query_Discard_Loop_On_Save_Frame, ::xml_schema::flags (), this),
  Sound_Speed_ (Sound_Speed, ::xml_schema::flags (), this),
  SubMode_ (SubMode, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Calculation_Instances_ (Calculation_Instances, ::xml_schema::flags (), this),
  Start_Licence_Date_ (Start_Licence_Date, ::xml_schema::flags (), this),
  End_Licence_Date_ (End_Licence_Date, ::xml_schema::flags (), this),
  Auto_Save_PreTrig_Loop_ (Auto_Save_PreTrig_Loop, ::xml_schema::flags (), this),
  Feature_ (Feature, ::xml_schema::flags (), this),
  Acq_Setup_Dialog_ (Acq_Setup_Dialog, ::xml_schema::flags (), this),
  Interrupt_Clear_ (Interrupt_Clear, ::xml_schema::flags (), this),
  Interrupt_Status_ (Interrupt_Status, ::xml_schema::flags (), this),
  Auto_Save_Load_3D_ (Auto_Save_Load_3D, ::xml_schema::flags (), this),
  DICOM_Root_ID_ (DICOM_Root_ID, ::xml_schema::flags (), this),
  Company_Name_ (Company_Name, ::xml_schema::flags (), this),
  Image_To_Auto_Save_On_Label_ (Image_To_Auto_Save_On_Label, ::xml_schema::flags (), this),
  DICOM_Encode_Regions_ (DICOM_Encode_Regions, ::xml_schema::flags (), this),
  Pipeline_Delay_ (Pipeline_Delay, ::xml_schema::flags (), this),
  DDS_Control_ (DDS_Control, ::xml_schema::flags (), this),
  Mode_ (Mode, ::xml_schema::flags (), this),
  Review_Setup_Dialog_ (Review_Setup_Dialog, ::xml_schema::flags (), this)
{
}

Sys1::
Sys1 (const Sys1& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Query_Discard_Loop_On_Save_Frame_ (x.Query_Discard_Loop_On_Save_Frame_, f, this),
  Sound_Speed_ (x.Sound_Speed_, f, this),
  SubMode_ (x.SubMode_, f, this),
  Interrupt_Mask_ (x.Interrupt_Mask_, f, this),
  Calculation_Instances_ (x.Calculation_Instances_, f, this),
  Start_Licence_Date_ (x.Start_Licence_Date_, f, this),
  End_Licence_Date_ (x.End_Licence_Date_, f, this),
  Auto_Save_PreTrig_Loop_ (x.Auto_Save_PreTrig_Loop_, f, this),
  Feature_ (x.Feature_, f, this),
  Acq_Setup_Dialog_ (x.Acq_Setup_Dialog_, f, this),
  Interrupt_Clear_ (x.Interrupt_Clear_, f, this),
  Interrupt_Status_ (x.Interrupt_Status_, f, this),
  Auto_Save_Load_3D_ (x.Auto_Save_Load_3D_, f, this),
  DICOM_Root_ID_ (x.DICOM_Root_ID_, f, this),
  Company_Name_ (x.Company_Name_, f, this),
  Image_To_Auto_Save_On_Label_ (x.Image_To_Auto_Save_On_Label_, f, this),
  DICOM_Encode_Regions_ (x.DICOM_Encode_Regions_, f, this),
  Pipeline_Delay_ (x.Pipeline_Delay_, f, this),
  DDS_Control_ (x.DDS_Control_, f, this),
  Mode_ (x.Mode_, f, this),
  Review_Setup_Dialog_ (x.Review_Setup_Dialog_, f, this)
{
}

Sys1::
Sys1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Query_Discard_Loop_On_Save_Frame_ (f, this),
  Sound_Speed_ (f, this),
  SubMode_ (f, this),
  Interrupt_Mask_ (f, this),
  Calculation_Instances_ (f, this),
  Start_Licence_Date_ (f, this),
  End_Licence_Date_ (f, this),
  Auto_Save_PreTrig_Loop_ (f, this),
  Feature_ (f, this),
  Acq_Setup_Dialog_ (f, this),
  Interrupt_Clear_ (f, this),
  Interrupt_Status_ (f, this),
  Auto_Save_Load_3D_ (f, this),
  DICOM_Root_ID_ (f, this),
  Company_Name_ (f, this),
  Image_To_Auto_Save_On_Label_ (f, this),
  DICOM_Encode_Regions_ (f, this),
  Pipeline_Delay_ (f, this),
  DDS_Control_ (f, this),
  Mode_ (f, this),
  Review_Setup_Dialog_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sys1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Query-Discard-Loop-On-Save-Frame
    //
    if (n.name () == "Query-Discard-Loop-On-Save-Frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Query_Discard_Loop_On_Save_Frame_type > r (
        Query_Discard_Loop_On_Save_Frame_traits::create (i, f, this));

      if (!Query_Discard_Loop_On_Save_Frame_.present ())
      {
        this->Query_Discard_Loop_On_Save_Frame_.set (r);
        continue;
      }
    }

    // Sound-Speed
    //
    if (n.name () == "Sound-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sound_Speed_type > r (
        Sound_Speed_traits::create (i, f, this));

      if (!Sound_Speed_.present ())
      {
        this->Sound_Speed_.set (r);
        continue;
      }
    }

    // SubMode
    //
    if (n.name () == "SubMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SubMode_type > r (
        SubMode_traits::create (i, f, this));

      if (!SubMode_.present ())
      {
        this->SubMode_.set (r);
        continue;
      }
    }

    // Interrupt-Mask
    //
    if (n.name () == "Interrupt-Mask" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Mask_type > r (
        Interrupt_Mask_traits::create (i, f, this));

      if (!Interrupt_Mask_.present ())
      {
        this->Interrupt_Mask_.set (r);
        continue;
      }
    }

    // Calculation-Instances
    //
    if (n.name () == "Calculation-Instances" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Calculation_Instances_type > r (
        Calculation_Instances_traits::create (i, f, this));

      if (!Calculation_Instances_.present ())
      {
        this->Calculation_Instances_.set (r);
        continue;
      }
    }

    // Start-Licence-Date
    //
    if (n.name () == "Start-Licence-Date" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Start_Licence_Date_type > r (
        Start_Licence_Date_traits::create (i, f, this));

      if (!Start_Licence_Date_.present ())
      {
        this->Start_Licence_Date_.set (r);
        continue;
      }
    }

    // End-Licence-Date
    //
    if (n.name () == "End-Licence-Date" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< End_Licence_Date_type > r (
        End_Licence_Date_traits::create (i, f, this));

      if (!End_Licence_Date_.present ())
      {
        this->End_Licence_Date_.set (r);
        continue;
      }
    }

    // Auto-Save-PreTrig-Loop
    //
    if (n.name () == "Auto-Save-PreTrig-Loop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Auto_Save_PreTrig_Loop_type > r (
        Auto_Save_PreTrig_Loop_traits::create (i, f, this));

      if (!Auto_Save_PreTrig_Loop_.present ())
      {
        this->Auto_Save_PreTrig_Loop_.set (r);
        continue;
      }
    }

    // Feature
    //
    if (n.name () == "Feature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Feature_type > r (
        Feature_traits::create (i, f, this));

      if (!Feature_.present ())
      {
        this->Feature_.set (r);
        continue;
      }
    }

    // Acq-Setup-Dialog
    //
    if (n.name () == "Acq-Setup-Dialog" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acq_Setup_Dialog_type > r (
        Acq_Setup_Dialog_traits::create (i, f, this));

      if (!Acq_Setup_Dialog_.present ())
      {
        this->Acq_Setup_Dialog_.set (r);
        continue;
      }
    }

    // Interrupt-Clear
    //
    if (n.name () == "Interrupt-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Clear_type > r (
        Interrupt_Clear_traits::create (i, f, this));

      if (!Interrupt_Clear_.present ())
      {
        this->Interrupt_Clear_.set (r);
        continue;
      }
    }

    // Interrupt-Status
    //
    if (n.name () == "Interrupt-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Status_type > r (
        Interrupt_Status_traits::create (i, f, this));

      if (!Interrupt_Status_.present ())
      {
        this->Interrupt_Status_.set (r);
        continue;
      }
    }

    // Auto-Save-Load-3D
    //
    if (n.name () == "Auto-Save-Load-3D" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Auto_Save_Load_3D_type > r (
        Auto_Save_Load_3D_traits::create (i, f, this));

      if (!Auto_Save_Load_3D_.present ())
      {
        this->Auto_Save_Load_3D_.set (r);
        continue;
      }
    }

    // DICOM-Root-ID
    //
    if (n.name () == "DICOM-Root-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DICOM_Root_ID_type > r (
        DICOM_Root_ID_traits::create (i, f, this));

      if (!DICOM_Root_ID_.present ())
      {
        this->DICOM_Root_ID_.set (r);
        continue;
      }
    }

    // Company-Name
    //
    if (n.name () == "Company-Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Company_Name_type > r (
        Company_Name_traits::create (i, f, this));

      if (!Company_Name_.present ())
      {
        this->Company_Name_.set (r);
        continue;
      }
    }

    // Image-To-Auto-Save-On-Label
    //
    if (n.name () == "Image-To-Auto-Save-On-Label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_To_Auto_Save_On_Label_type > r (
        Image_To_Auto_Save_On_Label_traits::create (i, f, this));

      if (!Image_To_Auto_Save_On_Label_.present ())
      {
        this->Image_To_Auto_Save_On_Label_.set (r);
        continue;
      }
    }

    // DICOM-Encode-Regions
    //
    if (n.name () == "DICOM-Encode-Regions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DICOM_Encode_Regions_type > r (
        DICOM_Encode_Regions_traits::create (i, f, this));

      if (!DICOM_Encode_Regions_.present ())
      {
        this->DICOM_Encode_Regions_.set (r);
        continue;
      }
    }

    // Pipeline-Delay
    //
    if (n.name () == "Pipeline-Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pipeline_Delay_type > r (
        Pipeline_Delay_traits::create (i, f, this));

      if (!Pipeline_Delay_.present ())
      {
        this->Pipeline_Delay_.set (r);
        continue;
      }
    }

    // DDS-Control
    //
    if (n.name () == "DDS-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DDS_Control_type > r (
        DDS_Control_traits::create (i, f, this));

      if (!DDS_Control_.present ())
      {
        this->DDS_Control_.set (r);
        continue;
      }
    }

    // Mode
    //
    if (n.name () == "Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mode_type > r (
        Mode_traits::create (i, f, this));

      if (!Mode_.present ())
      {
        this->Mode_.set (r);
        continue;
      }
    }

    // Review-Setup-Dialog
    //
    if (n.name () == "Review-Setup-Dialog" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Review_Setup_Dialog_type > r (
        Review_Setup_Dialog_traits::create (i, f, this));

      if (!Review_Setup_Dialog_.present ())
      {
        this->Review_Setup_Dialog_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Query_Discard_Loop_On_Save_Frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Query-Discard-Loop-On-Save-Frame",
      "");
  }

  if (!Sound_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sound-Speed",
      "");
  }

  if (!SubMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SubMode",
      "");
  }

  if (!Interrupt_Mask_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Mask",
      "");
  }

  if (!Calculation_Instances_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Calculation-Instances",
      "");
  }

  if (!Start_Licence_Date_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Start-Licence-Date",
      "");
  }

  if (!End_Licence_Date_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "End-Licence-Date",
      "");
  }

  if (!Auto_Save_PreTrig_Loop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Auto-Save-PreTrig-Loop",
      "");
  }

  if (!Feature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Feature",
      "");
  }

  if (!Acq_Setup_Dialog_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acq-Setup-Dialog",
      "");
  }

  if (!Interrupt_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Clear",
      "");
  }

  if (!Interrupt_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Status",
      "");
  }

  if (!Auto_Save_Load_3D_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Auto-Save-Load-3D",
      "");
  }

  if (!DICOM_Root_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DICOM-Root-ID",
      "");
  }

  if (!Company_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Company-Name",
      "");
  }

  if (!Image_To_Auto_Save_On_Label_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image-To-Auto-Save-On-Label",
      "");
  }

  if (!DICOM_Encode_Regions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DICOM-Encode-Regions",
      "");
  }

  if (!Pipeline_Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pipeline-Delay",
      "");
  }

  if (!DDS_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DDS-Control",
      "");
  }

  if (!Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mode",
      "");
  }

  if (!Review_Setup_Dialog_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Review-Setup-Dialog",
      "");
  }
}

Sys1* Sys1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sys1 (*this, f, c);
}

Sys1::
~Sys1 ()
{
}

// Contrast
//

Contrast::
Contrast (const Acquisition_3D_Volume_type& Acquisition_3D_Volume,
          const Contrast_Linear_Scale_type& Contrast_Linear_Scale,
          const Reference_3D_Step_Size_type& Reference_3D_Step_Size,
          const Remap_Color_type& Remap_Color,
          const Display_Mode_type& Display_Mode,
          const Contrast_Linear_Offset_type& Contrast_Linear_Offset,
          const Contrast_Linear_Slope_type& Contrast_Linear_Slope,
          const Median_Size_Perfusion_type& Median_Size_Perfusion,
          const Contrast_Size_Default_type& Contrast_Size_Default,
          const Median_Size_Default_type& Median_Size_Default,
          const Use_ECG_Gate_type& Use_ECG_Gate,
          const ECG_Gate_Range_type& ECG_Gate_Range,
          const Filter_Size_Perfusion_type& Filter_Size_Perfusion,
          const Max_Contrast_Size_Default_type& Max_Contrast_Size_Default,
          const Filter_Size_Default_type& Filter_Size_Default,
          const Cardiac_Divisions_type& Cardiac_Divisions,
          const Reference_3D_Scan_Distance_type& Reference_3D_Scan_Distance,
          const Median_Size_MIP_type& Median_Size_MIP,
          const Acquire_Both_Directions_type& Acquire_Both_Directions,
          const Data_Display_Scale_Shift_type& Data_Display_Scale_Shift,
          const Reference_Label_type& Reference_Label,
          const X_3D_Display_Mode_type& X_3D_Display_Mode,
          const Filter_Size_MIP_type& Filter_Size_MIP,
          const Contrast_Linear_Lock_Gain_type& Contrast_Linear_Lock_Gain,
          const Persistence_Process_Frames_type& Persistence_Process_Frames,
          const Reference_Range_Start_type& Reference_Range_Start,
          const Blur_MIP_BoxSize_type& Blur_MIP_BoxSize,
          const Threshold_type& Threshold,
          const Process_Direction_type& Process_Direction,
          const Reference_Range_Stop_type& Reference_Range_Stop,
          const Blur_MIP_type& Blur_MIP,
          const Persistence_Mode_type& Persistence_Mode,
          const Reference_3D_Volume_type& Reference_3D_Volume,
          const Gain_type& Gain,
          const Acquire_Persist_MIP_type& Acquire_Persist_MIP,
          const Dynamic_Range2_type& Dynamic_Range2,
          const Contast_3D_Brightness_type& Contast_3D_Brightness,
          const Reference_3D_Steps_type& Reference_3D_Steps)
: ::xml_schema::type (),
  Acquisition_3D_Volume_ (Acquisition_3D_Volume, ::xml_schema::flags (), this),
  Contrast_Linear_Scale_ (Contrast_Linear_Scale, ::xml_schema::flags (), this),
  Reference_3D_Step_Size_ (Reference_3D_Step_Size, ::xml_schema::flags (), this),
  Remap_Color_ (Remap_Color, ::xml_schema::flags (), this),
  Display_Mode_ (Display_Mode, ::xml_schema::flags (), this),
  Contrast_Linear_Offset_ (Contrast_Linear_Offset, ::xml_schema::flags (), this),
  Contrast_Linear_Slope_ (Contrast_Linear_Slope, ::xml_schema::flags (), this),
  Median_Size_Perfusion_ (Median_Size_Perfusion, ::xml_schema::flags (), this),
  Contrast_Size_Default_ (Contrast_Size_Default, ::xml_schema::flags (), this),
  Median_Size_Default_ (Median_Size_Default, ::xml_schema::flags (), this),
  Use_ECG_Gate_ (Use_ECG_Gate, ::xml_schema::flags (), this),
  ECG_Gate_Range_ (ECG_Gate_Range, ::xml_schema::flags (), this),
  Filter_Size_Perfusion_ (Filter_Size_Perfusion, ::xml_schema::flags (), this),
  Max_Contrast_Size_Default_ (Max_Contrast_Size_Default, ::xml_schema::flags (), this),
  Filter_Size_Default_ (Filter_Size_Default, ::xml_schema::flags (), this),
  Cardiac_Divisions_ (Cardiac_Divisions, ::xml_schema::flags (), this),
  Reference_3D_Scan_Distance_ (Reference_3D_Scan_Distance, ::xml_schema::flags (), this),
  Median_Size_MIP_ (Median_Size_MIP, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Data_Display_Scale_Shift_ (Data_Display_Scale_Shift, ::xml_schema::flags (), this),
  Reference_Label_ (Reference_Label, ::xml_schema::flags (), this),
  X_3D_Display_Mode_ (X_3D_Display_Mode, ::xml_schema::flags (), this),
  Filter_Size_MIP_ (Filter_Size_MIP, ::xml_schema::flags (), this),
  Contrast_Linear_Lock_Gain_ (Contrast_Linear_Lock_Gain, ::xml_schema::flags (), this),
  Persistence_Process_Frames_ (Persistence_Process_Frames, ::xml_schema::flags (), this),
  Reference_Range_Start_ (Reference_Range_Start, ::xml_schema::flags (), this),
  Blur_MIP_BoxSize_ (Blur_MIP_BoxSize, ::xml_schema::flags (), this),
  Threshold_ (Threshold, ::xml_schema::flags (), this),
  Process_Direction_ (Process_Direction, ::xml_schema::flags (), this),
  Reference_Range_Stop_ (Reference_Range_Stop, ::xml_schema::flags (), this),
  Blur_MIP_ (Blur_MIP, ::xml_schema::flags (), this),
  Persistence_Mode_ (Persistence_Mode, ::xml_schema::flags (), this),
  Reference_3D_Volume_ (Reference_3D_Volume, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  Acquire_Persist_MIP_ (Acquire_Persist_MIP, ::xml_schema::flags (), this),
  Dynamic_Range2_ (Dynamic_Range2, ::xml_schema::flags (), this),
  Contast_3D_Brightness_ (Contast_3D_Brightness, ::xml_schema::flags (), this),
  Reference_3D_Steps_ (Reference_3D_Steps, ::xml_schema::flags (), this)
{
}

Contrast::
Contrast (const Acquisition_3D_Volume_type& Acquisition_3D_Volume,
          const Contrast_Linear_Scale_type& Contrast_Linear_Scale,
          ::std::auto_ptr< Reference_3D_Step_Size_type >& Reference_3D_Step_Size,
          const Remap_Color_type& Remap_Color,
          const Display_Mode_type& Display_Mode,
          const Contrast_Linear_Offset_type& Contrast_Linear_Offset,
          const Contrast_Linear_Slope_type& Contrast_Linear_Slope,
          const Median_Size_Perfusion_type& Median_Size_Perfusion,
          ::std::auto_ptr< Contrast_Size_Default_type >& Contrast_Size_Default,
          const Median_Size_Default_type& Median_Size_Default,
          const Use_ECG_Gate_type& Use_ECG_Gate,
          const ECG_Gate_Range_type& ECG_Gate_Range,
          const Filter_Size_Perfusion_type& Filter_Size_Perfusion,
          const Max_Contrast_Size_Default_type& Max_Contrast_Size_Default,
          const Filter_Size_Default_type& Filter_Size_Default,
          const Cardiac_Divisions_type& Cardiac_Divisions,
          ::std::auto_ptr< Reference_3D_Scan_Distance_type >& Reference_3D_Scan_Distance,
          const Median_Size_MIP_type& Median_Size_MIP,
          const Acquire_Both_Directions_type& Acquire_Both_Directions,
          const Data_Display_Scale_Shift_type& Data_Display_Scale_Shift,
          const Reference_Label_type& Reference_Label,
          const X_3D_Display_Mode_type& X_3D_Display_Mode,
          const Filter_Size_MIP_type& Filter_Size_MIP,
          const Contrast_Linear_Lock_Gain_type& Contrast_Linear_Lock_Gain,
          const Persistence_Process_Frames_type& Persistence_Process_Frames,
          const Reference_Range_Start_type& Reference_Range_Start,
          const Blur_MIP_BoxSize_type& Blur_MIP_BoxSize,
          const Threshold_type& Threshold,
          const Process_Direction_type& Process_Direction,
          const Reference_Range_Stop_type& Reference_Range_Stop,
          const Blur_MIP_type& Blur_MIP,
          const Persistence_Mode_type& Persistence_Mode,
          const Reference_3D_Volume_type& Reference_3D_Volume,
          const Gain_type& Gain,
          const Acquire_Persist_MIP_type& Acquire_Persist_MIP,
          const Dynamic_Range2_type& Dynamic_Range2,
          const Contast_3D_Brightness_type& Contast_3D_Brightness,
          const Reference_3D_Steps_type& Reference_3D_Steps)
: ::xml_schema::type (),
  Acquisition_3D_Volume_ (Acquisition_3D_Volume, ::xml_schema::flags (), this),
  Contrast_Linear_Scale_ (Contrast_Linear_Scale, ::xml_schema::flags (), this),
  Reference_3D_Step_Size_ (Reference_3D_Step_Size, ::xml_schema::flags (), this),
  Remap_Color_ (Remap_Color, ::xml_schema::flags (), this),
  Display_Mode_ (Display_Mode, ::xml_schema::flags (), this),
  Contrast_Linear_Offset_ (Contrast_Linear_Offset, ::xml_schema::flags (), this),
  Contrast_Linear_Slope_ (Contrast_Linear_Slope, ::xml_schema::flags (), this),
  Median_Size_Perfusion_ (Median_Size_Perfusion, ::xml_schema::flags (), this),
  Contrast_Size_Default_ (Contrast_Size_Default, ::xml_schema::flags (), this),
  Median_Size_Default_ (Median_Size_Default, ::xml_schema::flags (), this),
  Use_ECG_Gate_ (Use_ECG_Gate, ::xml_schema::flags (), this),
  ECG_Gate_Range_ (ECG_Gate_Range, ::xml_schema::flags (), this),
  Filter_Size_Perfusion_ (Filter_Size_Perfusion, ::xml_schema::flags (), this),
  Max_Contrast_Size_Default_ (Max_Contrast_Size_Default, ::xml_schema::flags (), this),
  Filter_Size_Default_ (Filter_Size_Default, ::xml_schema::flags (), this),
  Cardiac_Divisions_ (Cardiac_Divisions, ::xml_schema::flags (), this),
  Reference_3D_Scan_Distance_ (Reference_3D_Scan_Distance, ::xml_schema::flags (), this),
  Median_Size_MIP_ (Median_Size_MIP, ::xml_schema::flags (), this),
  Acquire_Both_Directions_ (Acquire_Both_Directions, ::xml_schema::flags (), this),
  Data_Display_Scale_Shift_ (Data_Display_Scale_Shift, ::xml_schema::flags (), this),
  Reference_Label_ (Reference_Label, ::xml_schema::flags (), this),
  X_3D_Display_Mode_ (X_3D_Display_Mode, ::xml_schema::flags (), this),
  Filter_Size_MIP_ (Filter_Size_MIP, ::xml_schema::flags (), this),
  Contrast_Linear_Lock_Gain_ (Contrast_Linear_Lock_Gain, ::xml_schema::flags (), this),
  Persistence_Process_Frames_ (Persistence_Process_Frames, ::xml_schema::flags (), this),
  Reference_Range_Start_ (Reference_Range_Start, ::xml_schema::flags (), this),
  Blur_MIP_BoxSize_ (Blur_MIP_BoxSize, ::xml_schema::flags (), this),
  Threshold_ (Threshold, ::xml_schema::flags (), this),
  Process_Direction_ (Process_Direction, ::xml_schema::flags (), this),
  Reference_Range_Stop_ (Reference_Range_Stop, ::xml_schema::flags (), this),
  Blur_MIP_ (Blur_MIP, ::xml_schema::flags (), this),
  Persistence_Mode_ (Persistence_Mode, ::xml_schema::flags (), this),
  Reference_3D_Volume_ (Reference_3D_Volume, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  Acquire_Persist_MIP_ (Acquire_Persist_MIP, ::xml_schema::flags (), this),
  Dynamic_Range2_ (Dynamic_Range2, ::xml_schema::flags (), this),
  Contast_3D_Brightness_ (Contast_3D_Brightness, ::xml_schema::flags (), this),
  Reference_3D_Steps_ (Reference_3D_Steps, ::xml_schema::flags (), this)
{
}

Contrast::
Contrast (const Contrast& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Acquisition_3D_Volume_ (x.Acquisition_3D_Volume_, f, this),
  Contrast_Linear_Scale_ (x.Contrast_Linear_Scale_, f, this),
  Reference_3D_Step_Size_ (x.Reference_3D_Step_Size_, f, this),
  Remap_Color_ (x.Remap_Color_, f, this),
  Display_Mode_ (x.Display_Mode_, f, this),
  Contrast_Linear_Offset_ (x.Contrast_Linear_Offset_, f, this),
  Contrast_Linear_Slope_ (x.Contrast_Linear_Slope_, f, this),
  Median_Size_Perfusion_ (x.Median_Size_Perfusion_, f, this),
  Contrast_Size_Default_ (x.Contrast_Size_Default_, f, this),
  Median_Size_Default_ (x.Median_Size_Default_, f, this),
  Use_ECG_Gate_ (x.Use_ECG_Gate_, f, this),
  ECG_Gate_Range_ (x.ECG_Gate_Range_, f, this),
  Filter_Size_Perfusion_ (x.Filter_Size_Perfusion_, f, this),
  Max_Contrast_Size_Default_ (x.Max_Contrast_Size_Default_, f, this),
  Filter_Size_Default_ (x.Filter_Size_Default_, f, this),
  Cardiac_Divisions_ (x.Cardiac_Divisions_, f, this),
  Reference_3D_Scan_Distance_ (x.Reference_3D_Scan_Distance_, f, this),
  Median_Size_MIP_ (x.Median_Size_MIP_, f, this),
  Acquire_Both_Directions_ (x.Acquire_Both_Directions_, f, this),
  Data_Display_Scale_Shift_ (x.Data_Display_Scale_Shift_, f, this),
  Reference_Label_ (x.Reference_Label_, f, this),
  X_3D_Display_Mode_ (x.X_3D_Display_Mode_, f, this),
  Filter_Size_MIP_ (x.Filter_Size_MIP_, f, this),
  Contrast_Linear_Lock_Gain_ (x.Contrast_Linear_Lock_Gain_, f, this),
  Persistence_Process_Frames_ (x.Persistence_Process_Frames_, f, this),
  Reference_Range_Start_ (x.Reference_Range_Start_, f, this),
  Blur_MIP_BoxSize_ (x.Blur_MIP_BoxSize_, f, this),
  Threshold_ (x.Threshold_, f, this),
  Process_Direction_ (x.Process_Direction_, f, this),
  Reference_Range_Stop_ (x.Reference_Range_Stop_, f, this),
  Blur_MIP_ (x.Blur_MIP_, f, this),
  Persistence_Mode_ (x.Persistence_Mode_, f, this),
  Reference_3D_Volume_ (x.Reference_3D_Volume_, f, this),
  Gain_ (x.Gain_, f, this),
  Acquire_Persist_MIP_ (x.Acquire_Persist_MIP_, f, this),
  Dynamic_Range2_ (x.Dynamic_Range2_, f, this),
  Contast_3D_Brightness_ (x.Contast_3D_Brightness_, f, this),
  Reference_3D_Steps_ (x.Reference_3D_Steps_, f, this)
{
}

Contrast::
Contrast (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Acquisition_3D_Volume_ (f, this),
  Contrast_Linear_Scale_ (f, this),
  Reference_3D_Step_Size_ (f, this),
  Remap_Color_ (f, this),
  Display_Mode_ (f, this),
  Contrast_Linear_Offset_ (f, this),
  Contrast_Linear_Slope_ (f, this),
  Median_Size_Perfusion_ (f, this),
  Contrast_Size_Default_ (f, this),
  Median_Size_Default_ (f, this),
  Use_ECG_Gate_ (f, this),
  ECG_Gate_Range_ (f, this),
  Filter_Size_Perfusion_ (f, this),
  Max_Contrast_Size_Default_ (f, this),
  Filter_Size_Default_ (f, this),
  Cardiac_Divisions_ (f, this),
  Reference_3D_Scan_Distance_ (f, this),
  Median_Size_MIP_ (f, this),
  Acquire_Both_Directions_ (f, this),
  Data_Display_Scale_Shift_ (f, this),
  Reference_Label_ (f, this),
  X_3D_Display_Mode_ (f, this),
  Filter_Size_MIP_ (f, this),
  Contrast_Linear_Lock_Gain_ (f, this),
  Persistence_Process_Frames_ (f, this),
  Reference_Range_Start_ (f, this),
  Blur_MIP_BoxSize_ (f, this),
  Threshold_ (f, this),
  Process_Direction_ (f, this),
  Reference_Range_Stop_ (f, this),
  Blur_MIP_ (f, this),
  Persistence_Mode_ (f, this),
  Reference_3D_Volume_ (f, this),
  Gain_ (f, this),
  Acquire_Persist_MIP_ (f, this),
  Dynamic_Range2_ (f, this),
  Contast_3D_Brightness_ (f, this),
  Reference_3D_Steps_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Contrast::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Acquisition-3D-Volume
    //
    if (n.name () == "Acquisition-3D-Volume" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquisition_3D_Volume_type > r (
        Acquisition_3D_Volume_traits::create (i, f, this));

      if (!Acquisition_3D_Volume_.present ())
      {
        this->Acquisition_3D_Volume_.set (r);
        continue;
      }
    }

    // Contrast-Linear-Scale
    //
    if (n.name () == "Contrast-Linear-Scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Linear_Scale_type > r (
        Contrast_Linear_Scale_traits::create (i, f, this));

      if (!Contrast_Linear_Scale_.present ())
      {
        this->Contrast_Linear_Scale_.set (r);
        continue;
      }
    }

    // Reference-3D-Step-Size
    //
    if (n.name () == "Reference-3D-Step-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_3D_Step_Size_type > r (
        Reference_3D_Step_Size_traits::create (i, f, this));

      if (!Reference_3D_Step_Size_.present ())
      {
        this->Reference_3D_Step_Size_.set (r);
        continue;
      }
    }

    // Remap-Color
    //
    if (n.name () == "Remap-Color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Remap_Color_type > r (
        Remap_Color_traits::create (i, f, this));

      if (!Remap_Color_.present ())
      {
        this->Remap_Color_.set (r);
        continue;
      }
    }

    // Display-Mode
    //
    if (n.name () == "Display-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Display_Mode_type > r (
        Display_Mode_traits::create (i, f, this));

      if (!Display_Mode_.present ())
      {
        this->Display_Mode_.set (r);
        continue;
      }
    }

    // Contrast-Linear-Offset
    //
    if (n.name () == "Contrast-Linear-Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Linear_Offset_type > r (
        Contrast_Linear_Offset_traits::create (i, f, this));

      if (!Contrast_Linear_Offset_.present ())
      {
        this->Contrast_Linear_Offset_.set (r);
        continue;
      }
    }

    // Contrast-Linear-Slope
    //
    if (n.name () == "Contrast-Linear-Slope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Linear_Slope_type > r (
        Contrast_Linear_Slope_traits::create (i, f, this));

      if (!Contrast_Linear_Slope_.present ())
      {
        this->Contrast_Linear_Slope_.set (r);
        continue;
      }
    }

    // Median-Size-Perfusion
    //
    if (n.name () == "Median-Size-Perfusion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Median_Size_Perfusion_type > r (
        Median_Size_Perfusion_traits::create (i, f, this));

      if (!Median_Size_Perfusion_.present ())
      {
        this->Median_Size_Perfusion_.set (r);
        continue;
      }
    }

    // Contrast-Size-Default
    //
    if (n.name () == "Contrast-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Size_Default_type > r (
        Contrast_Size_Default_traits::create (i, f, this));

      if (!Contrast_Size_Default_.present ())
      {
        this->Contrast_Size_Default_.set (r);
        continue;
      }
    }

    // Median-Size-Default
    //
    if (n.name () == "Median-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Median_Size_Default_type > r (
        Median_Size_Default_traits::create (i, f, this));

      if (!Median_Size_Default_.present ())
      {
        this->Median_Size_Default_.set (r);
        continue;
      }
    }

    // Use-ECG-Gate
    //
    if (n.name () == "Use-ECG-Gate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Use_ECG_Gate_type > r (
        Use_ECG_Gate_traits::create (i, f, this));

      if (!Use_ECG_Gate_.present ())
      {
        this->Use_ECG_Gate_.set (r);
        continue;
      }
    }

    // ECG-Gate-Range
    //
    if (n.name () == "ECG-Gate-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Gate_Range_type > r (
        ECG_Gate_Range_traits::create (i, f, this));

      if (!ECG_Gate_Range_.present ())
      {
        this->ECG_Gate_Range_.set (r);
        continue;
      }
    }

    // Filter-Size-Perfusion
    //
    if (n.name () == "Filter-Size-Perfusion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Size_Perfusion_type > r (
        Filter_Size_Perfusion_traits::create (i, f, this));

      if (!Filter_Size_Perfusion_.present ())
      {
        this->Filter_Size_Perfusion_.set (r);
        continue;
      }
    }

    // Max-Contrast-Size-Default
    //
    if (n.name () == "Max-Contrast-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Contrast_Size_Default_type > r (
        Max_Contrast_Size_Default_traits::create (i, f, this));

      if (!Max_Contrast_Size_Default_.present ())
      {
        this->Max_Contrast_Size_Default_.set (r);
        continue;
      }
    }

    // Filter-Size-Default
    //
    if (n.name () == "Filter-Size-Default" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Size_Default_type > r (
        Filter_Size_Default_traits::create (i, f, this));

      if (!Filter_Size_Default_.present ())
      {
        this->Filter_Size_Default_.set (r);
        continue;
      }
    }

    // Cardiac-Divisions
    //
    if (n.name () == "Cardiac-Divisions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cardiac_Divisions_type > r (
        Cardiac_Divisions_traits::create (i, f, this));

      if (!Cardiac_Divisions_.present ())
      {
        this->Cardiac_Divisions_.set (r);
        continue;
      }
    }

    // Reference-3D-Scan-Distance
    //
    if (n.name () == "Reference-3D-Scan-Distance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_3D_Scan_Distance_type > r (
        Reference_3D_Scan_Distance_traits::create (i, f, this));

      if (!Reference_3D_Scan_Distance_.present ())
      {
        this->Reference_3D_Scan_Distance_.set (r);
        continue;
      }
    }

    // Median-Size-MIP
    //
    if (n.name () == "Median-Size-MIP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Median_Size_MIP_type > r (
        Median_Size_MIP_traits::create (i, f, this));

      if (!Median_Size_MIP_.present ())
      {
        this->Median_Size_MIP_.set (r);
        continue;
      }
    }

    // Acquire-Both-Directions
    //
    if (n.name () == "Acquire-Both-Directions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Both_Directions_type > r (
        Acquire_Both_Directions_traits::create (i, f, this));

      if (!Acquire_Both_Directions_.present ())
      {
        this->Acquire_Both_Directions_.set (r);
        continue;
      }
    }

    // Data-Display-Scale-Shift
    //
    if (n.name () == "Data-Display-Scale-Shift" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Data_Display_Scale_Shift_type > r (
        Data_Display_Scale_Shift_traits::create (i, f, this));

      if (!Data_Display_Scale_Shift_.present ())
      {
        this->Data_Display_Scale_Shift_.set (r);
        continue;
      }
    }

    // Reference-Label
    //
    if (n.name () == "Reference-Label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_Label_type > r (
        Reference_Label_traits::create (i, f, this));

      if (!Reference_Label_.present ())
      {
        this->Reference_Label_.set (r);
        continue;
      }
    }

    // X_3D-Display-Mode
    //
    if (n.name () == "X_3D-Display-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Display_Mode_type > r (
        X_3D_Display_Mode_traits::create (i, f, this));

      if (!X_3D_Display_Mode_.present ())
      {
        this->X_3D_Display_Mode_.set (r);
        continue;
      }
    }

    // Filter-Size-MIP
    //
    if (n.name () == "Filter-Size-MIP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Filter_Size_MIP_type > r (
        Filter_Size_MIP_traits::create (i, f, this));

      if (!Filter_Size_MIP_.present ())
      {
        this->Filter_Size_MIP_.set (r);
        continue;
      }
    }

    // Contrast-Linear-Lock-Gain
    //
    if (n.name () == "Contrast-Linear-Lock-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Linear_Lock_Gain_type > r (
        Contrast_Linear_Lock_Gain_traits::create (i, f, this));

      if (!Contrast_Linear_Lock_Gain_.present ())
      {
        this->Contrast_Linear_Lock_Gain_.set (r);
        continue;
      }
    }

    // Persistence-Process-Frames
    //
    if (n.name () == "Persistence-Process-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Persistence_Process_Frames_type > r (
        Persistence_Process_Frames_traits::create (i, f, this));

      if (!Persistence_Process_Frames_.present ())
      {
        this->Persistence_Process_Frames_.set (r);
        continue;
      }
    }

    // Reference-Range-Start
    //
    if (n.name () == "Reference-Range-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_Range_Start_type > r (
        Reference_Range_Start_traits::create (i, f, this));

      if (!Reference_Range_Start_.present ())
      {
        this->Reference_Range_Start_.set (r);
        continue;
      }
    }

    // Blur-MIP-BoxSize
    //
    if (n.name () == "Blur-MIP-BoxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Blur_MIP_BoxSize_type > r (
        Blur_MIP_BoxSize_traits::create (i, f, this));

      if (!Blur_MIP_BoxSize_.present ())
      {
        this->Blur_MIP_BoxSize_.set (r);
        continue;
      }
    }

    // Threshold
    //
    if (n.name () == "Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Threshold_type > r (
        Threshold_traits::create (i, f, this));

      if (!Threshold_.present ())
      {
        this->Threshold_.set (r);
        continue;
      }
    }

    // Process-Direction
    //
    if (n.name () == "Process-Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Process_Direction_type > r (
        Process_Direction_traits::create (i, f, this));

      if (!Process_Direction_.present ())
      {
        this->Process_Direction_.set (r);
        continue;
      }
    }

    // Reference-Range-Stop
    //
    if (n.name () == "Reference-Range-Stop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_Range_Stop_type > r (
        Reference_Range_Stop_traits::create (i, f, this));

      if (!Reference_Range_Stop_.present ())
      {
        this->Reference_Range_Stop_.set (r);
        continue;
      }
    }

    // Blur-MIP
    //
    if (n.name () == "Blur-MIP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Blur_MIP_type > r (
        Blur_MIP_traits::create (i, f, this));

      if (!Blur_MIP_.present ())
      {
        this->Blur_MIP_.set (r);
        continue;
      }
    }

    // Persistence-Mode
    //
    if (n.name () == "Persistence-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Persistence_Mode_type > r (
        Persistence_Mode_traits::create (i, f, this));

      if (!Persistence_Mode_.present ())
      {
        this->Persistence_Mode_.set (r);
        continue;
      }
    }

    // Reference-3D-Volume
    //
    if (n.name () == "Reference-3D-Volume" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_3D_Volume_type > r (
        Reference_3D_Volume_traits::create (i, f, this));

      if (!Reference_3D_Volume_.present ())
      {
        this->Reference_3D_Volume_.set (r);
        continue;
      }
    }

    // Gain
    //
    if (n.name () == "Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Gain_type > r (
        Gain_traits::create (i, f, this));

      if (!Gain_.present ())
      {
        this->Gain_.set (r);
        continue;
      }
    }

    // Acquire-Persist-MIP
    //
    if (n.name () == "Acquire-Persist-MIP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_MIP_type > r (
        Acquire_Persist_MIP_traits::create (i, f, this));

      if (!Acquire_Persist_MIP_.present ())
      {
        this->Acquire_Persist_MIP_.set (r);
        continue;
      }
    }

    // Dynamic-Range2
    //
    if (n.name () == "Dynamic-Range2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Dynamic_Range2_type > r (
        Dynamic_Range2_traits::create (i, f, this));

      if (!Dynamic_Range2_.present ())
      {
        this->Dynamic_Range2_.set (r);
        continue;
      }
    }

    // Contast-3D-Brightness
    //
    if (n.name () == "Contast-3D-Brightness" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contast_3D_Brightness_type > r (
        Contast_3D_Brightness_traits::create (i, f, this));

      if (!Contast_3D_Brightness_.present ())
      {
        this->Contast_3D_Brightness_.set (r);
        continue;
      }
    }

    // Reference-3D-Steps
    //
    if (n.name () == "Reference-3D-Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reference_3D_Steps_type > r (
        Reference_3D_Steps_traits::create (i, f, this));

      if (!Reference_3D_Steps_.present ())
      {
        this->Reference_3D_Steps_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Acquisition_3D_Volume_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquisition-3D-Volume",
      "");
  }

  if (!Contrast_Linear_Scale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Linear-Scale",
      "");
  }

  if (!Reference_3D_Step_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-3D-Step-Size",
      "");
  }

  if (!Remap_Color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Remap-Color",
      "");
  }

  if (!Display_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Display-Mode",
      "");
  }

  if (!Contrast_Linear_Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Linear-Offset",
      "");
  }

  if (!Contrast_Linear_Slope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Linear-Slope",
      "");
  }

  if (!Median_Size_Perfusion_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Median-Size-Perfusion",
      "");
  }

  if (!Contrast_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Size-Default",
      "");
  }

  if (!Median_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Median-Size-Default",
      "");
  }

  if (!Use_ECG_Gate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Use-ECG-Gate",
      "");
  }

  if (!ECG_Gate_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Gate-Range",
      "");
  }

  if (!Filter_Size_Perfusion_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Size-Perfusion",
      "");
  }

  if (!Max_Contrast_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Contrast-Size-Default",
      "");
  }

  if (!Filter_Size_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Size-Default",
      "");
  }

  if (!Cardiac_Divisions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cardiac-Divisions",
      "");
  }

  if (!Reference_3D_Scan_Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-3D-Scan-Distance",
      "");
  }

  if (!Median_Size_MIP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Median-Size-MIP",
      "");
  }

  if (!Acquire_Both_Directions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Both-Directions",
      "");
  }

  if (!Data_Display_Scale_Shift_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Data-Display-Scale-Shift",
      "");
  }

  if (!Reference_Label_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-Label",
      "");
  }

  if (!X_3D_Display_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Display-Mode",
      "");
  }

  if (!Filter_Size_MIP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Filter-Size-MIP",
      "");
  }

  if (!Contrast_Linear_Lock_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Linear-Lock-Gain",
      "");
  }

  if (!Persistence_Process_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Persistence-Process-Frames",
      "");
  }

  if (!Reference_Range_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-Range-Start",
      "");
  }

  if (!Blur_MIP_BoxSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Blur-MIP-BoxSize",
      "");
  }

  if (!Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Threshold",
      "");
  }

  if (!Process_Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Process-Direction",
      "");
  }

  if (!Reference_Range_Stop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-Range-Stop",
      "");
  }

  if (!Blur_MIP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Blur-MIP",
      "");
  }

  if (!Persistence_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Persistence-Mode",
      "");
  }

  if (!Reference_3D_Volume_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-3D-Volume",
      "");
  }

  if (!Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Gain",
      "");
  }

  if (!Acquire_Persist_MIP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-MIP",
      "");
  }

  if (!Dynamic_Range2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dynamic-Range2",
      "");
  }

  if (!Contast_3D_Brightness_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contast-3D-Brightness",
      "");
  }

  if (!Reference_3D_Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reference-3D-Steps",
      "");
  }
}

Contrast* Contrast::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Contrast (*this, f, c);
}

Contrast::
~Contrast ()
{
}

// MIS1
//

MIS1::
MIS1 (const ECG_Gain_type& ECG_Gain,
      const ECG_Available_type& ECG_Available,
      const Blood_Pressure_Available_type& Blood_Pressure_Available,
      const Respiration_Gating_type& Respiration_Gating,
      const BP_Gain_type& BP_Gain,
      const Temperature_Available_type& Temperature_Available,
      const Respiration_Available_type& Respiration_Available,
      const Control_type& Control)
: ::xml_schema::type (),
  ECG_Gain_ (ECG_Gain, ::xml_schema::flags (), this),
  ECG_Available_ (ECG_Available, ::xml_schema::flags (), this),
  Blood_Pressure_Available_ (Blood_Pressure_Available, ::xml_schema::flags (), this),
  Respiration_Gating_ (Respiration_Gating, ::xml_schema::flags (), this),
  BP_Gain_ (BP_Gain, ::xml_schema::flags (), this),
  Temperature_Available_ (Temperature_Available, ::xml_schema::flags (), this),
  Respiration_Available_ (Respiration_Available, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this)
{
}

MIS1::
MIS1 (const MIS1& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ECG_Gain_ (x.ECG_Gain_, f, this),
  ECG_Available_ (x.ECG_Available_, f, this),
  Blood_Pressure_Available_ (x.Blood_Pressure_Available_, f, this),
  Respiration_Gating_ (x.Respiration_Gating_, f, this),
  BP_Gain_ (x.BP_Gain_, f, this),
  Temperature_Available_ (x.Temperature_Available_, f, this),
  Respiration_Available_ (x.Respiration_Available_, f, this),
  Control_ (x.Control_, f, this)
{
}

MIS1::
MIS1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ECG_Gain_ (f, this),
  ECG_Available_ (f, this),
  Blood_Pressure_Available_ (f, this),
  Respiration_Gating_ (f, this),
  BP_Gain_ (f, this),
  Temperature_Available_ (f, this),
  Respiration_Available_ (f, this),
  Control_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MIS1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ECG-Gain
    //
    if (n.name () == "ECG-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Gain_type > r (
        ECG_Gain_traits::create (i, f, this));

      if (!ECG_Gain_.present ())
      {
        this->ECG_Gain_.set (r);
        continue;
      }
    }

    // ECG-Available
    //
    if (n.name () == "ECG-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Available_type > r (
        ECG_Available_traits::create (i, f, this));

      if (!ECG_Available_.present ())
      {
        this->ECG_Available_.set (r);
        continue;
      }
    }

    // Blood-Pressure-Available
    //
    if (n.name () == "Blood-Pressure-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Blood_Pressure_Available_type > r (
        Blood_Pressure_Available_traits::create (i, f, this));

      if (!Blood_Pressure_Available_.present ())
      {
        this->Blood_Pressure_Available_.set (r);
        continue;
      }
    }

    // Respiration-Gating
    //
    if (n.name () == "Respiration-Gating" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Gating_type > r (
        Respiration_Gating_traits::create (i, f, this));

      if (!Respiration_Gating_.present ())
      {
        this->Respiration_Gating_.set (r);
        continue;
      }
    }

    // BP-Gain
    //
    if (n.name () == "BP-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BP_Gain_type > r (
        BP_Gain_traits::create (i, f, this));

      if (!BP_Gain_.present ())
      {
        this->BP_Gain_.set (r);
        continue;
      }
    }

    // Temperature-Available
    //
    if (n.name () == "Temperature-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Available_type > r (
        Temperature_Available_traits::create (i, f, this));

      if (!Temperature_Available_.present ())
      {
        this->Temperature_Available_.set (r);
        continue;
      }
    }

    // Respiration-Available
    //
    if (n.name () == "Respiration-Available" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Available_type > r (
        Respiration_Available_traits::create (i, f, this));

      if (!Respiration_Available_.present ())
      {
        this->Respiration_Available_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ECG_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Gain",
      "");
  }

  if (!ECG_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Available",
      "");
  }

  if (!Blood_Pressure_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Blood-Pressure-Available",
      "");
  }

  if (!Respiration_Gating_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Gating",
      "");
  }

  if (!BP_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BP-Gain",
      "");
  }

  if (!Temperature_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Available",
      "");
  }

  if (!Respiration_Available_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Available",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }
}

MIS1* MIS1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MIS1 (*this, f, c);
}

MIS1::
~MIS1 ()
{
}

// Scan1
//

Scan1::
Scan1 (const Encoder_Position_type& Encoder_Position,
       const Center_type& Center,
       const Control_type& Control,
       const Probe_ID1_type& Probe_ID1,
       const Probe_ID2_type& Probe_ID2,
       const V_Scan_Speed_type& V_Scan_Speed,
       const Probe_ID1_Reread_type& Probe_ID1_Reread,
       const Probe_ID1_Valid_type& Probe_ID1_Valid,
       const Probe_ID1_Voltage_type& Probe_ID1_Voltage,
       const Probe_ID2_Reread_type& Probe_ID2_Reread,
       const Probe_ID2_Valid_type& Probe_ID2_Valid,
       const Probe_ID2_Voltage_type& Probe_ID2_Voltage,
       const V_Scan_Rate_type& V_Scan_Rate,
       const Position_Counter_Lock_type& Position_Counter_Lock,
       const Scan_Width_type& Scan_Width,
       const Position_Counter_Reset_type& Position_Counter_Reset)
: ::xml_schema::type (),
  Encoder_Position_ (Encoder_Position, ::xml_schema::flags (), this),
  Center_ (Center, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Probe_ID1_ (Probe_ID1, ::xml_schema::flags (), this),
  Probe_ID2_ (Probe_ID2, ::xml_schema::flags (), this),
  V_Scan_Speed_ (V_Scan_Speed, ::xml_schema::flags (), this),
  Probe_ID1_Reread_ (Probe_ID1_Reread, ::xml_schema::flags (), this),
  Probe_ID1_Valid_ (Probe_ID1_Valid, ::xml_schema::flags (), this),
  Probe_ID1_Voltage_ (Probe_ID1_Voltage, ::xml_schema::flags (), this),
  Probe_ID2_Reread_ (Probe_ID2_Reread, ::xml_schema::flags (), this),
  Probe_ID2_Valid_ (Probe_ID2_Valid, ::xml_schema::flags (), this),
  Probe_ID2_Voltage_ (Probe_ID2_Voltage, ::xml_schema::flags (), this),
  V_Scan_Rate_ (V_Scan_Rate, ::xml_schema::flags (), this),
  Position_Counter_Lock_ (Position_Counter_Lock, ::xml_schema::flags (), this),
  Scan_Width_ (Scan_Width, ::xml_schema::flags (), this),
  Position_Counter_Reset_ (Position_Counter_Reset, ::xml_schema::flags (), this)
{
}

Scan1::
Scan1 (const Encoder_Position_type& Encoder_Position,
       ::std::auto_ptr< Center_type >& Center,
       const Control_type& Control,
       const Probe_ID1_type& Probe_ID1,
       const Probe_ID2_type& Probe_ID2,
       ::std::auto_ptr< V_Scan_Speed_type >& V_Scan_Speed,
       const Probe_ID1_Reread_type& Probe_ID1_Reread,
       const Probe_ID1_Valid_type& Probe_ID1_Valid,
       const Probe_ID1_Voltage_type& Probe_ID1_Voltage,
       const Probe_ID2_Reread_type& Probe_ID2_Reread,
       const Probe_ID2_Valid_type& Probe_ID2_Valid,
       const Probe_ID2_Voltage_type& Probe_ID2_Voltage,
       ::std::auto_ptr< V_Scan_Rate_type >& V_Scan_Rate,
       const Position_Counter_Lock_type& Position_Counter_Lock,
       ::std::auto_ptr< Scan_Width_type >& Scan_Width,
       const Position_Counter_Reset_type& Position_Counter_Reset)
: ::xml_schema::type (),
  Encoder_Position_ (Encoder_Position, ::xml_schema::flags (), this),
  Center_ (Center, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Probe_ID1_ (Probe_ID1, ::xml_schema::flags (), this),
  Probe_ID2_ (Probe_ID2, ::xml_schema::flags (), this),
  V_Scan_Speed_ (V_Scan_Speed, ::xml_schema::flags (), this),
  Probe_ID1_Reread_ (Probe_ID1_Reread, ::xml_schema::flags (), this),
  Probe_ID1_Valid_ (Probe_ID1_Valid, ::xml_schema::flags (), this),
  Probe_ID1_Voltage_ (Probe_ID1_Voltage, ::xml_schema::flags (), this),
  Probe_ID2_Reread_ (Probe_ID2_Reread, ::xml_schema::flags (), this),
  Probe_ID2_Valid_ (Probe_ID2_Valid, ::xml_schema::flags (), this),
  Probe_ID2_Voltage_ (Probe_ID2_Voltage, ::xml_schema::flags (), this),
  V_Scan_Rate_ (V_Scan_Rate, ::xml_schema::flags (), this),
  Position_Counter_Lock_ (Position_Counter_Lock, ::xml_schema::flags (), this),
  Scan_Width_ (Scan_Width, ::xml_schema::flags (), this),
  Position_Counter_Reset_ (Position_Counter_Reset, ::xml_schema::flags (), this)
{
}

Scan1::
Scan1 (const Scan1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Encoder_Position_ (x.Encoder_Position_, f, this),
  Center_ (x.Center_, f, this),
  Control_ (x.Control_, f, this),
  Probe_ID1_ (x.Probe_ID1_, f, this),
  Probe_ID2_ (x.Probe_ID2_, f, this),
  V_Scan_Speed_ (x.V_Scan_Speed_, f, this),
  Probe_ID1_Reread_ (x.Probe_ID1_Reread_, f, this),
  Probe_ID1_Valid_ (x.Probe_ID1_Valid_, f, this),
  Probe_ID1_Voltage_ (x.Probe_ID1_Voltage_, f, this),
  Probe_ID2_Reread_ (x.Probe_ID2_Reread_, f, this),
  Probe_ID2_Valid_ (x.Probe_ID2_Valid_, f, this),
  Probe_ID2_Voltage_ (x.Probe_ID2_Voltage_, f, this),
  V_Scan_Rate_ (x.V_Scan_Rate_, f, this),
  Position_Counter_Lock_ (x.Position_Counter_Lock_, f, this),
  Scan_Width_ (x.Scan_Width_, f, this),
  Position_Counter_Reset_ (x.Position_Counter_Reset_, f, this)
{
}

Scan1::
Scan1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Encoder_Position_ (f, this),
  Center_ (f, this),
  Control_ (f, this),
  Probe_ID1_ (f, this),
  Probe_ID2_ (f, this),
  V_Scan_Speed_ (f, this),
  Probe_ID1_Reread_ (f, this),
  Probe_ID1_Valid_ (f, this),
  Probe_ID1_Voltage_ (f, this),
  Probe_ID2_Reread_ (f, this),
  Probe_ID2_Valid_ (f, this),
  Probe_ID2_Voltage_ (f, this),
  V_Scan_Rate_ (f, this),
  Position_Counter_Lock_ (f, this),
  Scan_Width_ (f, this),
  Position_Counter_Reset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Scan1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Encoder-Position
    //
    if (n.name () == "Encoder-Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Encoder_Position_type > r (
        Encoder_Position_traits::create (i, f, this));

      if (!Encoder_Position_.present ())
      {
        this->Encoder_Position_.set (r);
        continue;
      }
    }

    // Center
    //
    if (n.name () == "Center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Center_type > r (
        Center_traits::create (i, f, this));

      if (!Center_.present ())
      {
        this->Center_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    // Probe-ID1
    //
    if (n.name () == "Probe-ID1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_type > r (
        Probe_ID1_traits::create (i, f, this));

      if (!Probe_ID1_.present ())
      {
        this->Probe_ID1_.set (r);
        continue;
      }
    }

    // Probe-ID2
    //
    if (n.name () == "Probe-ID2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_type > r (
        Probe_ID2_traits::create (i, f, this));

      if (!Probe_ID2_.present ())
      {
        this->Probe_ID2_.set (r);
        continue;
      }
    }

    // V-Scan-Speed
    //
    if (n.name () == "V-Scan-Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Scan_Speed_type > r (
        V_Scan_Speed_traits::create (i, f, this));

      if (!V_Scan_Speed_.present ())
      {
        this->V_Scan_Speed_.set (r);
        continue;
      }
    }

    // Probe-ID1-Reread
    //
    if (n.name () == "Probe-ID1-Reread" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Reread_type > r (
        Probe_ID1_Reread_traits::create (i, f, this));

      if (!Probe_ID1_Reread_.present ())
      {
        this->Probe_ID1_Reread_.set (r);
        continue;
      }
    }

    // Probe-ID1-Valid
    //
    if (n.name () == "Probe-ID1-Valid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Valid_type > r (
        Probe_ID1_Valid_traits::create (i, f, this));

      if (!Probe_ID1_Valid_.present ())
      {
        this->Probe_ID1_Valid_.set (r);
        continue;
      }
    }

    // Probe-ID1-Voltage
    //
    if (n.name () == "Probe-ID1-Voltage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID1_Voltage_type > r (
        Probe_ID1_Voltage_traits::create (i, f, this));

      if (!Probe_ID1_Voltage_.present ())
      {
        this->Probe_ID1_Voltage_.set (r);
        continue;
      }
    }

    // Probe-ID2-Reread
    //
    if (n.name () == "Probe-ID2-Reread" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Reread_type > r (
        Probe_ID2_Reread_traits::create (i, f, this));

      if (!Probe_ID2_Reread_.present ())
      {
        this->Probe_ID2_Reread_.set (r);
        continue;
      }
    }

    // Probe-ID2-Valid
    //
    if (n.name () == "Probe-ID2-Valid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Valid_type > r (
        Probe_ID2_Valid_traits::create (i, f, this));

      if (!Probe_ID2_Valid_.present ())
      {
        this->Probe_ID2_Valid_.set (r);
        continue;
      }
    }

    // Probe-ID2-Voltage
    //
    if (n.name () == "Probe-ID2-Voltage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Probe_ID2_Voltage_type > r (
        Probe_ID2_Voltage_traits::create (i, f, this));

      if (!Probe_ID2_Voltage_.present ())
      {
        this->Probe_ID2_Voltage_.set (r);
        continue;
      }
    }

    // V-Scan-Rate
    //
    if (n.name () == "V-Scan-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Scan_Rate_type > r (
        V_Scan_Rate_traits::create (i, f, this));

      if (!V_Scan_Rate_.present ())
      {
        this->V_Scan_Rate_.set (r);
        continue;
      }
    }

    // Position-Counter-Lock
    //
    if (n.name () == "Position-Counter-Lock" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Counter_Lock_type > r (
        Position_Counter_Lock_traits::create (i, f, this));

      if (!Position_Counter_Lock_.present ())
      {
        this->Position_Counter_Lock_.set (r);
        continue;
      }
    }

    // Scan-Width
    //
    if (n.name () == "Scan-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Width_type > r (
        Scan_Width_traits::create (i, f, this));

      if (!Scan_Width_.present ())
      {
        this->Scan_Width_.set (r);
        continue;
      }
    }

    // Position-Counter-Reset
    //
    if (n.name () == "Position-Counter-Reset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Counter_Reset_type > r (
        Position_Counter_Reset_traits::create (i, f, this));

      if (!Position_Counter_Reset_.present ())
      {
        this->Position_Counter_Reset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Encoder_Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Encoder-Position",
      "");
  }

  if (!Center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Center",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  if (!Probe_ID1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1",
      "");
  }

  if (!Probe_ID2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2",
      "");
  }

  if (!V_Scan_Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Scan-Speed",
      "");
  }

  if (!Probe_ID1_Reread_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Reread",
      "");
  }

  if (!Probe_ID1_Valid_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Valid",
      "");
  }

  if (!Probe_ID1_Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID1-Voltage",
      "");
  }

  if (!Probe_ID2_Reread_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Reread",
      "");
  }

  if (!Probe_ID2_Valid_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Valid",
      "");
  }

  if (!Probe_ID2_Voltage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Probe-ID2-Voltage",
      "");
  }

  if (!V_Scan_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Scan-Rate",
      "");
  }

  if (!Position_Counter_Lock_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Counter-Lock",
      "");
  }

  if (!Scan_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Width",
      "");
  }

  if (!Position_Counter_Reset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Counter-Reset",
      "");
  }
}

Scan1* Scan1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan1 (*this, f, c);
}

Scan1::
~Scan1 ()
{
}

// Motor1
//

Motor1::
Motor1 (const Settle_Time_3d_type& Settle_Time_3d,
        const Position_type& Position,
        const R_Scan_Move_No_Wait_type& R_Scan_Move_No_Wait,
        const Motor_Mode_type& Motor_Mode,
        const Acceleration_type& Acceleration,
        const Serial_Port_Mode_type& Serial_Port_Mode,
        const Limit_Switch_Mode_type& Limit_Switch_Mode,
        const Breakpoint_type& Breakpoint,
        const Update_type& Update,
        const Breakpoint_Value_type& Breakpoint_Value,
        const V_Switch_Limit_type& V_Switch_Limit,
        const R_Retrieve_Trace_type& R_Retrieve_Trace,
        const Velocity_Stationary_type& Velocity_Stationary,
        const Reset_Event_Status_type& Reset_Event_Status,
        const Actual_Position_type& Actual_Position,
        const Buffer_Length_type& Buffer_Length,
        const R_Scan_Move2_type& R_Scan_Move2,
        const Position_Reverse_type& Position_Reverse,
        const Reset_type& Reset,
        const Trace_Count_type& Trace_Count,
        const R_Initialize_type& R_Initialize,
        const Output_Mode_type& Output_Mode,
        const Position2_type& Position2,
        const Integration_Limit_type& Integration_Limit,
        const R_Home_type& R_Home,
        const Error_type& Error,
        const R_Reset_Limit_Switch_type& R_Reset_Limit_Switch,
        const Settle_Window_3d_type& Settle_Window_3d,
        const Interrupt_Mask_type& Interrupt_Mask,
        const Scan_Move_Control_type& Scan_Move_Control,
        const Axis_Out_Source_type& Axis_Out_Source,
        const Trace_Stop_type& Trace_Stop,
        const Velocity_type& Velocity,
        const R_Setup_type& R_Setup,
        const Buffer_Start_type& Buffer_Start,
        const Signal_Sense_type& Signal_Sense,
        const R_Scan_Move_type& R_Scan_Move,
        const Position_Forward_type& Position_Forward,
        const Derivative_Time_type& Derivative_Time,
        const Settle_Window_type& Settle_Window,
        const Trace_Variable1_type& Trace_Variable1,
        const Trace_Variable2_type& Trace_Variable2,
        const Buffer_Read_Index_type& Buffer_Read_Index,
        const Signal_Status_type& Signal_Status,
        const Alarm_Clear_type& Alarm_Clear,
        const Motion_Complete_Mode_type& Motion_Complete_Mode,
        const R_Setup_Abort_type& R_Setup_Abort,
        const Read_Buffer_type& Read_Buffer,
        const Kd_type& Kd,
        const Clear_Interrupt_type& Clear_Interrupt,
        const Profile_Mode_type& Profile_Mode,
        const R_Setup_Trace_type& R_Setup_Trace,
        const No_Operation_type& No_Operation,
        const Ki_type& Ki,
        const Sample_Time_type& Sample_Time,
        const Event_Status_type& Event_Status,
        const Kp_type& Kp,
        const R_Wait_Finish_Scan_Move_type& R_Wait_Finish_Scan_Move,
        const Settle_Time_type& Settle_Time,
        const Acceleration_Stationary_type& Acceleration_Stationary,
        const Trace_Mode_type& Trace_Mode,
        const Trace_Period_type& Trace_Period,
        const Trace_Start_type& Trace_Start)
: ::xml_schema::type (),
  Settle_Time_3d_ (Settle_Time_3d, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  R_Scan_Move_No_Wait_ (R_Scan_Move_No_Wait, ::xml_schema::flags (), this),
  Motor_Mode_ (Motor_Mode, ::xml_schema::flags (), this),
  Acceleration_ (Acceleration, ::xml_schema::flags (), this),
  Serial_Port_Mode_ (Serial_Port_Mode, ::xml_schema::flags (), this),
  Limit_Switch_Mode_ (Limit_Switch_Mode, ::xml_schema::flags (), this),
  Breakpoint_ (Breakpoint, ::xml_schema::flags (), this),
  Update_ (Update, ::xml_schema::flags (), this),
  Breakpoint_Value_ (Breakpoint_Value, ::xml_schema::flags (), this),
  V_Switch_Limit_ (V_Switch_Limit, ::xml_schema::flags (), this),
  R_Retrieve_Trace_ (R_Retrieve_Trace, ::xml_schema::flags (), this),
  Velocity_Stationary_ (Velocity_Stationary, ::xml_schema::flags (), this),
  Reset_Event_Status_ (Reset_Event_Status, ::xml_schema::flags (), this),
  Actual_Position_ (Actual_Position, ::xml_schema::flags (), this),
  Buffer_Length_ (Buffer_Length, ::xml_schema::flags (), this),
  R_Scan_Move2_ (R_Scan_Move2, ::xml_schema::flags (), this),
  Position_Reverse_ (Position_Reverse, ::xml_schema::flags (), this),
  Reset_ (Reset, ::xml_schema::flags (), this),
  Trace_Count_ (Trace_Count, ::xml_schema::flags (), this),
  R_Initialize_ (R_Initialize, ::xml_schema::flags (), this),
  Output_Mode_ (Output_Mode, ::xml_schema::flags (), this),
  Position2_ (Position2, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  R_Home_ (R_Home, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  R_Reset_Limit_Switch_ (R_Reset_Limit_Switch, ::xml_schema::flags (), this),
  Settle_Window_3d_ (Settle_Window_3d, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Scan_Move_Control_ (Scan_Move_Control, ::xml_schema::flags (), this),
  Axis_Out_Source_ (Axis_Out_Source, ::xml_schema::flags (), this),
  Trace_Stop_ (Trace_Stop, ::xml_schema::flags (), this),
  Velocity_ (Velocity, ::xml_schema::flags (), this),
  R_Setup_ (R_Setup, ::xml_schema::flags (), this),
  Buffer_Start_ (Buffer_Start, ::xml_schema::flags (), this),
  Signal_Sense_ (Signal_Sense, ::xml_schema::flags (), this),
  R_Scan_Move_ (R_Scan_Move, ::xml_schema::flags (), this),
  Position_Forward_ (Position_Forward, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Settle_Window_ (Settle_Window, ::xml_schema::flags (), this),
  Trace_Variable1_ (Trace_Variable1, ::xml_schema::flags (), this),
  Trace_Variable2_ (Trace_Variable2, ::xml_schema::flags (), this),
  Buffer_Read_Index_ (Buffer_Read_Index, ::xml_schema::flags (), this),
  Signal_Status_ (Signal_Status, ::xml_schema::flags (), this),
  Alarm_Clear_ (Alarm_Clear, ::xml_schema::flags (), this),
  Motion_Complete_Mode_ (Motion_Complete_Mode, ::xml_schema::flags (), this),
  R_Setup_Abort_ (R_Setup_Abort, ::xml_schema::flags (), this),
  Read_Buffer_ (Read_Buffer, ::xml_schema::flags (), this),
  Kd_ (Kd, ::xml_schema::flags (), this),
  Clear_Interrupt_ (Clear_Interrupt, ::xml_schema::flags (), this),
  Profile_Mode_ (Profile_Mode, ::xml_schema::flags (), this),
  R_Setup_Trace_ (R_Setup_Trace, ::xml_schema::flags (), this),
  No_Operation_ (No_Operation, ::xml_schema::flags (), this),
  Ki_ (Ki, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Event_Status_ (Event_Status, ::xml_schema::flags (), this),
  Kp_ (Kp, ::xml_schema::flags (), this),
  R_Wait_Finish_Scan_Move_ (R_Wait_Finish_Scan_Move, ::xml_schema::flags (), this),
  Settle_Time_ (Settle_Time, ::xml_schema::flags (), this),
  Acceleration_Stationary_ (Acceleration_Stationary, ::xml_schema::flags (), this),
  Trace_Mode_ (Trace_Mode, ::xml_schema::flags (), this),
  Trace_Period_ (Trace_Period, ::xml_schema::flags (), this),
  Trace_Start_ (Trace_Start, ::xml_schema::flags (), this)
{
}

Motor1::
Motor1 (const Settle_Time_3d_type& Settle_Time_3d,
        ::std::auto_ptr< Position_type >& Position,
        ::std::auto_ptr< R_Scan_Move_No_Wait_type >& R_Scan_Move_No_Wait,
        const Motor_Mode_type& Motor_Mode,
        ::std::auto_ptr< Acceleration_type >& Acceleration,
        const Serial_Port_Mode_type& Serial_Port_Mode,
        const Limit_Switch_Mode_type& Limit_Switch_Mode,
        const Breakpoint_type& Breakpoint,
        const Update_type& Update,
        const Breakpoint_Value_type& Breakpoint_Value,
        const V_Switch_Limit_type& V_Switch_Limit,
        const R_Retrieve_Trace_type& R_Retrieve_Trace,
        ::std::auto_ptr< Velocity_Stationary_type >& Velocity_Stationary,
        const Reset_Event_Status_type& Reset_Event_Status,
        const Actual_Position_type& Actual_Position,
        const Buffer_Length_type& Buffer_Length,
        ::std::auto_ptr< R_Scan_Move2_type >& R_Scan_Move2,
        ::std::auto_ptr< Position_Reverse_type >& Position_Reverse,
        const Reset_type& Reset,
        const Trace_Count_type& Trace_Count,
        const R_Initialize_type& R_Initialize,
        const Output_Mode_type& Output_Mode,
        ::std::auto_ptr< Position2_type >& Position2,
        const Integration_Limit_type& Integration_Limit,
        const R_Home_type& R_Home,
        const Error_type& Error,
        const R_Reset_Limit_Switch_type& R_Reset_Limit_Switch,
        const Settle_Window_3d_type& Settle_Window_3d,
        const Interrupt_Mask_type& Interrupt_Mask,
        const Scan_Move_Control_type& Scan_Move_Control,
        const Axis_Out_Source_type& Axis_Out_Source,
        const Trace_Stop_type& Trace_Stop,
        ::std::auto_ptr< Velocity_type >& Velocity,
        const R_Setup_type& R_Setup,
        const Buffer_Start_type& Buffer_Start,
        const Signal_Sense_type& Signal_Sense,
        ::std::auto_ptr< R_Scan_Move_type >& R_Scan_Move,
        ::std::auto_ptr< Position_Forward_type >& Position_Forward,
        const Derivative_Time_type& Derivative_Time,
        const Settle_Window_type& Settle_Window,
        const Trace_Variable1_type& Trace_Variable1,
        const Trace_Variable2_type& Trace_Variable2,
        const Buffer_Read_Index_type& Buffer_Read_Index,
        const Signal_Status_type& Signal_Status,
        const Alarm_Clear_type& Alarm_Clear,
        const Motion_Complete_Mode_type& Motion_Complete_Mode,
        const R_Setup_Abort_type& R_Setup_Abort,
        const Read_Buffer_type& Read_Buffer,
        const Kd_type& Kd,
        const Clear_Interrupt_type& Clear_Interrupt,
        const Profile_Mode_type& Profile_Mode,
        const R_Setup_Trace_type& R_Setup_Trace,
        const No_Operation_type& No_Operation,
        const Ki_type& Ki,
        const Sample_Time_type& Sample_Time,
        const Event_Status_type& Event_Status,
        const Kp_type& Kp,
        const R_Wait_Finish_Scan_Move_type& R_Wait_Finish_Scan_Move,
        const Settle_Time_type& Settle_Time,
        ::std::auto_ptr< Acceleration_Stationary_type >& Acceleration_Stationary,
        const Trace_Mode_type& Trace_Mode,
        const Trace_Period_type& Trace_Period,
        const Trace_Start_type& Trace_Start)
: ::xml_schema::type (),
  Settle_Time_3d_ (Settle_Time_3d, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this),
  R_Scan_Move_No_Wait_ (R_Scan_Move_No_Wait, ::xml_schema::flags (), this),
  Motor_Mode_ (Motor_Mode, ::xml_schema::flags (), this),
  Acceleration_ (Acceleration, ::xml_schema::flags (), this),
  Serial_Port_Mode_ (Serial_Port_Mode, ::xml_schema::flags (), this),
  Limit_Switch_Mode_ (Limit_Switch_Mode, ::xml_schema::flags (), this),
  Breakpoint_ (Breakpoint, ::xml_schema::flags (), this),
  Update_ (Update, ::xml_schema::flags (), this),
  Breakpoint_Value_ (Breakpoint_Value, ::xml_schema::flags (), this),
  V_Switch_Limit_ (V_Switch_Limit, ::xml_schema::flags (), this),
  R_Retrieve_Trace_ (R_Retrieve_Trace, ::xml_schema::flags (), this),
  Velocity_Stationary_ (Velocity_Stationary, ::xml_schema::flags (), this),
  Reset_Event_Status_ (Reset_Event_Status, ::xml_schema::flags (), this),
  Actual_Position_ (Actual_Position, ::xml_schema::flags (), this),
  Buffer_Length_ (Buffer_Length, ::xml_schema::flags (), this),
  R_Scan_Move2_ (R_Scan_Move2, ::xml_schema::flags (), this),
  Position_Reverse_ (Position_Reverse, ::xml_schema::flags (), this),
  Reset_ (Reset, ::xml_schema::flags (), this),
  Trace_Count_ (Trace_Count, ::xml_schema::flags (), this),
  R_Initialize_ (R_Initialize, ::xml_schema::flags (), this),
  Output_Mode_ (Output_Mode, ::xml_schema::flags (), this),
  Position2_ (Position2, ::xml_schema::flags (), this),
  Integration_Limit_ (Integration_Limit, ::xml_schema::flags (), this),
  R_Home_ (R_Home, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  R_Reset_Limit_Switch_ (R_Reset_Limit_Switch, ::xml_schema::flags (), this),
  Settle_Window_3d_ (Settle_Window_3d, ::xml_schema::flags (), this),
  Interrupt_Mask_ (Interrupt_Mask, ::xml_schema::flags (), this),
  Scan_Move_Control_ (Scan_Move_Control, ::xml_schema::flags (), this),
  Axis_Out_Source_ (Axis_Out_Source, ::xml_schema::flags (), this),
  Trace_Stop_ (Trace_Stop, ::xml_schema::flags (), this),
  Velocity_ (Velocity, ::xml_schema::flags (), this),
  R_Setup_ (R_Setup, ::xml_schema::flags (), this),
  Buffer_Start_ (Buffer_Start, ::xml_schema::flags (), this),
  Signal_Sense_ (Signal_Sense, ::xml_schema::flags (), this),
  R_Scan_Move_ (R_Scan_Move, ::xml_schema::flags (), this),
  Position_Forward_ (Position_Forward, ::xml_schema::flags (), this),
  Derivative_Time_ (Derivative_Time, ::xml_schema::flags (), this),
  Settle_Window_ (Settle_Window, ::xml_schema::flags (), this),
  Trace_Variable1_ (Trace_Variable1, ::xml_schema::flags (), this),
  Trace_Variable2_ (Trace_Variable2, ::xml_schema::flags (), this),
  Buffer_Read_Index_ (Buffer_Read_Index, ::xml_schema::flags (), this),
  Signal_Status_ (Signal_Status, ::xml_schema::flags (), this),
  Alarm_Clear_ (Alarm_Clear, ::xml_schema::flags (), this),
  Motion_Complete_Mode_ (Motion_Complete_Mode, ::xml_schema::flags (), this),
  R_Setup_Abort_ (R_Setup_Abort, ::xml_schema::flags (), this),
  Read_Buffer_ (Read_Buffer, ::xml_schema::flags (), this),
  Kd_ (Kd, ::xml_schema::flags (), this),
  Clear_Interrupt_ (Clear_Interrupt, ::xml_schema::flags (), this),
  Profile_Mode_ (Profile_Mode, ::xml_schema::flags (), this),
  R_Setup_Trace_ (R_Setup_Trace, ::xml_schema::flags (), this),
  No_Operation_ (No_Operation, ::xml_schema::flags (), this),
  Ki_ (Ki, ::xml_schema::flags (), this),
  Sample_Time_ (Sample_Time, ::xml_schema::flags (), this),
  Event_Status_ (Event_Status, ::xml_schema::flags (), this),
  Kp_ (Kp, ::xml_schema::flags (), this),
  R_Wait_Finish_Scan_Move_ (R_Wait_Finish_Scan_Move, ::xml_schema::flags (), this),
  Settle_Time_ (Settle_Time, ::xml_schema::flags (), this),
  Acceleration_Stationary_ (Acceleration_Stationary, ::xml_schema::flags (), this),
  Trace_Mode_ (Trace_Mode, ::xml_schema::flags (), this),
  Trace_Period_ (Trace_Period, ::xml_schema::flags (), this),
  Trace_Start_ (Trace_Start, ::xml_schema::flags (), this)
{
}

Motor1::
Motor1 (const Motor1& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Settle_Time_3d_ (x.Settle_Time_3d_, f, this),
  Position_ (x.Position_, f, this),
  R_Scan_Move_No_Wait_ (x.R_Scan_Move_No_Wait_, f, this),
  Motor_Mode_ (x.Motor_Mode_, f, this),
  Acceleration_ (x.Acceleration_, f, this),
  Serial_Port_Mode_ (x.Serial_Port_Mode_, f, this),
  Limit_Switch_Mode_ (x.Limit_Switch_Mode_, f, this),
  Breakpoint_ (x.Breakpoint_, f, this),
  Update_ (x.Update_, f, this),
  Breakpoint_Value_ (x.Breakpoint_Value_, f, this),
  V_Switch_Limit_ (x.V_Switch_Limit_, f, this),
  R_Retrieve_Trace_ (x.R_Retrieve_Trace_, f, this),
  Velocity_Stationary_ (x.Velocity_Stationary_, f, this),
  Reset_Event_Status_ (x.Reset_Event_Status_, f, this),
  Actual_Position_ (x.Actual_Position_, f, this),
  Buffer_Length_ (x.Buffer_Length_, f, this),
  R_Scan_Move2_ (x.R_Scan_Move2_, f, this),
  Position_Reverse_ (x.Position_Reverse_, f, this),
  Reset_ (x.Reset_, f, this),
  Trace_Count_ (x.Trace_Count_, f, this),
  R_Initialize_ (x.R_Initialize_, f, this),
  Output_Mode_ (x.Output_Mode_, f, this),
  Position2_ (x.Position2_, f, this),
  Integration_Limit_ (x.Integration_Limit_, f, this),
  R_Home_ (x.R_Home_, f, this),
  Error_ (x.Error_, f, this),
  R_Reset_Limit_Switch_ (x.R_Reset_Limit_Switch_, f, this),
  Settle_Window_3d_ (x.Settle_Window_3d_, f, this),
  Interrupt_Mask_ (x.Interrupt_Mask_, f, this),
  Scan_Move_Control_ (x.Scan_Move_Control_, f, this),
  Axis_Out_Source_ (x.Axis_Out_Source_, f, this),
  Trace_Stop_ (x.Trace_Stop_, f, this),
  Velocity_ (x.Velocity_, f, this),
  R_Setup_ (x.R_Setup_, f, this),
  Buffer_Start_ (x.Buffer_Start_, f, this),
  Signal_Sense_ (x.Signal_Sense_, f, this),
  R_Scan_Move_ (x.R_Scan_Move_, f, this),
  Position_Forward_ (x.Position_Forward_, f, this),
  Derivative_Time_ (x.Derivative_Time_, f, this),
  Settle_Window_ (x.Settle_Window_, f, this),
  Trace_Variable1_ (x.Trace_Variable1_, f, this),
  Trace_Variable2_ (x.Trace_Variable2_, f, this),
  Buffer_Read_Index_ (x.Buffer_Read_Index_, f, this),
  Signal_Status_ (x.Signal_Status_, f, this),
  Alarm_Clear_ (x.Alarm_Clear_, f, this),
  Motion_Complete_Mode_ (x.Motion_Complete_Mode_, f, this),
  R_Setup_Abort_ (x.R_Setup_Abort_, f, this),
  Read_Buffer_ (x.Read_Buffer_, f, this),
  Kd_ (x.Kd_, f, this),
  Clear_Interrupt_ (x.Clear_Interrupt_, f, this),
  Profile_Mode_ (x.Profile_Mode_, f, this),
  R_Setup_Trace_ (x.R_Setup_Trace_, f, this),
  No_Operation_ (x.No_Operation_, f, this),
  Ki_ (x.Ki_, f, this),
  Sample_Time_ (x.Sample_Time_, f, this),
  Event_Status_ (x.Event_Status_, f, this),
  Kp_ (x.Kp_, f, this),
  R_Wait_Finish_Scan_Move_ (x.R_Wait_Finish_Scan_Move_, f, this),
  Settle_Time_ (x.Settle_Time_, f, this),
  Acceleration_Stationary_ (x.Acceleration_Stationary_, f, this),
  Trace_Mode_ (x.Trace_Mode_, f, this),
  Trace_Period_ (x.Trace_Period_, f, this),
  Trace_Start_ (x.Trace_Start_, f, this)
{
}

Motor1::
Motor1 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Settle_Time_3d_ (f, this),
  Position_ (f, this),
  R_Scan_Move_No_Wait_ (f, this),
  Motor_Mode_ (f, this),
  Acceleration_ (f, this),
  Serial_Port_Mode_ (f, this),
  Limit_Switch_Mode_ (f, this),
  Breakpoint_ (f, this),
  Update_ (f, this),
  Breakpoint_Value_ (f, this),
  V_Switch_Limit_ (f, this),
  R_Retrieve_Trace_ (f, this),
  Velocity_Stationary_ (f, this),
  Reset_Event_Status_ (f, this),
  Actual_Position_ (f, this),
  Buffer_Length_ (f, this),
  R_Scan_Move2_ (f, this),
  Position_Reverse_ (f, this),
  Reset_ (f, this),
  Trace_Count_ (f, this),
  R_Initialize_ (f, this),
  Output_Mode_ (f, this),
  Position2_ (f, this),
  Integration_Limit_ (f, this),
  R_Home_ (f, this),
  Error_ (f, this),
  R_Reset_Limit_Switch_ (f, this),
  Settle_Window_3d_ (f, this),
  Interrupt_Mask_ (f, this),
  Scan_Move_Control_ (f, this),
  Axis_Out_Source_ (f, this),
  Trace_Stop_ (f, this),
  Velocity_ (f, this),
  R_Setup_ (f, this),
  Buffer_Start_ (f, this),
  Signal_Sense_ (f, this),
  R_Scan_Move_ (f, this),
  Position_Forward_ (f, this),
  Derivative_Time_ (f, this),
  Settle_Window_ (f, this),
  Trace_Variable1_ (f, this),
  Trace_Variable2_ (f, this),
  Buffer_Read_Index_ (f, this),
  Signal_Status_ (f, this),
  Alarm_Clear_ (f, this),
  Motion_Complete_Mode_ (f, this),
  R_Setup_Abort_ (f, this),
  Read_Buffer_ (f, this),
  Kd_ (f, this),
  Clear_Interrupt_ (f, this),
  Profile_Mode_ (f, this),
  R_Setup_Trace_ (f, this),
  No_Operation_ (f, this),
  Ki_ (f, this),
  Sample_Time_ (f, this),
  Event_Status_ (f, this),
  Kp_ (f, this),
  R_Wait_Finish_Scan_Move_ (f, this),
  Settle_Time_ (f, this),
  Acceleration_Stationary_ (f, this),
  Trace_Mode_ (f, this),
  Trace_Period_ (f, this),
  Trace_Start_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Motor1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Settle-Time-3d
    //
    if (n.name () == "Settle-Time-3d" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Time_3d_type > r (
        Settle_Time_3d_traits::create (i, f, this));

      if (!Settle_Time_3d_.present ())
      {
        this->Settle_Time_3d_.set (r);
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (r);
        continue;
      }
    }

    // R-Scan-Move-No-Wait
    //
    if (n.name () == "R-Scan-Move-No-Wait" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move_No_Wait_type > r (
        R_Scan_Move_No_Wait_traits::create (i, f, this));

      if (!R_Scan_Move_No_Wait_.present ())
      {
        this->R_Scan_Move_No_Wait_.set (r);
        continue;
      }
    }

    // Motor-Mode
    //
    if (n.name () == "Motor-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Mode_type > r (
        Motor_Mode_traits::create (i, f, this));

      if (!Motor_Mode_.present ())
      {
        this->Motor_Mode_.set (r);
        continue;
      }
    }

    // Acceleration
    //
    if (n.name () == "Acceleration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_type > r (
        Acceleration_traits::create (i, f, this));

      if (!Acceleration_.present ())
      {
        this->Acceleration_.set (r);
        continue;
      }
    }

    // Serial-Port-Mode
    //
    if (n.name () == "Serial-Port-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Serial_Port_Mode_type > r (
        Serial_Port_Mode_traits::create (i, f, this));

      if (!Serial_Port_Mode_.present ())
      {
        this->Serial_Port_Mode_.set (r);
        continue;
      }
    }

    // Limit-Switch-Mode
    //
    if (n.name () == "Limit-Switch-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Limit_Switch_Mode_type > r (
        Limit_Switch_Mode_traits::create (i, f, this));

      if (!Limit_Switch_Mode_.present ())
      {
        this->Limit_Switch_Mode_.set (r);
        continue;
      }
    }

    // Breakpoint
    //
    if (n.name () == "Breakpoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Breakpoint_type > r (
        Breakpoint_traits::create (i, f, this));

      if (!Breakpoint_.present ())
      {
        this->Breakpoint_.set (r);
        continue;
      }
    }

    // Update
    //
    if (n.name () == "Update" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Update_type > r (
        Update_traits::create (i, f, this));

      if (!Update_.present ())
      {
        this->Update_.set (r);
        continue;
      }
    }

    // Breakpoint-Value
    //
    if (n.name () == "Breakpoint-Value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Breakpoint_Value_type > r (
        Breakpoint_Value_traits::create (i, f, this));

      if (!Breakpoint_Value_.present ())
      {
        this->Breakpoint_Value_.set (r);
        continue;
      }
    }

    // V-Switch-Limit
    //
    if (n.name () == "V-Switch-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Switch_Limit_type > r (
        V_Switch_Limit_traits::create (i, f, this));

      if (!V_Switch_Limit_.present ())
      {
        this->V_Switch_Limit_.set (r);
        continue;
      }
    }

    // R-Retrieve-Trace
    //
    if (n.name () == "R-Retrieve-Trace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Retrieve_Trace_type > r (
        R_Retrieve_Trace_traits::create (i, f, this));

      if (!R_Retrieve_Trace_.present ())
      {
        this->R_Retrieve_Trace_.set (r);
        continue;
      }
    }

    // Velocity-Stationary
    //
    if (n.name () == "Velocity-Stationary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Velocity_Stationary_type > r (
        Velocity_Stationary_traits::create (i, f, this));

      if (!Velocity_Stationary_.present ())
      {
        this->Velocity_Stationary_.set (r);
        continue;
      }
    }

    // Reset-Event-Status
    //
    if (n.name () == "Reset-Event-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reset_Event_Status_type > r (
        Reset_Event_Status_traits::create (i, f, this));

      if (!Reset_Event_Status_.present ())
      {
        this->Reset_Event_Status_.set (r);
        continue;
      }
    }

    // Actual-Position
    //
    if (n.name () == "Actual-Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Actual_Position_type > r (
        Actual_Position_traits::create (i, f, this));

      if (!Actual_Position_.present ())
      {
        this->Actual_Position_.set (r);
        continue;
      }
    }

    // Buffer-Length
    //
    if (n.name () == "Buffer-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Length_type > r (
        Buffer_Length_traits::create (i, f, this));

      if (!Buffer_Length_.present ())
      {
        this->Buffer_Length_.set (r);
        continue;
      }
    }

    // R-Scan-Move2
    //
    if (n.name () == "R-Scan-Move2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move2_type > r (
        R_Scan_Move2_traits::create (i, f, this));

      if (!R_Scan_Move2_.present ())
      {
        this->R_Scan_Move2_.set (r);
        continue;
      }
    }

    // Position-Reverse
    //
    if (n.name () == "Position-Reverse" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Reverse_type > r (
        Position_Reverse_traits::create (i, f, this));

      if (!Position_Reverse_.present ())
      {
        this->Position_Reverse_.set (r);
        continue;
      }
    }

    // Reset
    //
    if (n.name () == "Reset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Reset_type > r (
        Reset_traits::create (i, f, this));

      if (!Reset_.present ())
      {
        this->Reset_.set (r);
        continue;
      }
    }

    // Trace-Count
    //
    if (n.name () == "Trace-Count" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Count_type > r (
        Trace_Count_traits::create (i, f, this));

      if (!Trace_Count_.present ())
      {
        this->Trace_Count_.set (r);
        continue;
      }
    }

    // R-Initialize
    //
    if (n.name () == "R-Initialize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Initialize_type > r (
        R_Initialize_traits::create (i, f, this));

      if (!R_Initialize_.present ())
      {
        this->R_Initialize_.set (r);
        continue;
      }
    }

    // Output-Mode
    //
    if (n.name () == "Output-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Output_Mode_type > r (
        Output_Mode_traits::create (i, f, this));

      if (!Output_Mode_.present ())
      {
        this->Output_Mode_.set (r);
        continue;
      }
    }

    // Position2
    //
    if (n.name () == "Position2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position2_type > r (
        Position2_traits::create (i, f, this));

      if (!Position2_.present ())
      {
        this->Position2_.set (r);
        continue;
      }
    }

    // Integration-Limit
    //
    if (n.name () == "Integration-Limit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Integration_Limit_type > r (
        Integration_Limit_traits::create (i, f, this));

      if (!Integration_Limit_.present ())
      {
        this->Integration_Limit_.set (r);
        continue;
      }
    }

    // R-Home
    //
    if (n.name () == "R-Home" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Home_type > r (
        R_Home_traits::create (i, f, this));

      if (!R_Home_.present ())
      {
        this->R_Home_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // R-Reset-Limit-Switch
    //
    if (n.name () == "R-Reset-Limit-Switch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Reset_Limit_Switch_type > r (
        R_Reset_Limit_Switch_traits::create (i, f, this));

      if (!R_Reset_Limit_Switch_.present ())
      {
        this->R_Reset_Limit_Switch_.set (r);
        continue;
      }
    }

    // Settle-Window-3d
    //
    if (n.name () == "Settle-Window-3d" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Window_3d_type > r (
        Settle_Window_3d_traits::create (i, f, this));

      if (!Settle_Window_3d_.present ())
      {
        this->Settle_Window_3d_.set (r);
        continue;
      }
    }

    // Interrupt-Mask
    //
    if (n.name () == "Interrupt-Mask" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interrupt_Mask_type > r (
        Interrupt_Mask_traits::create (i, f, this));

      if (!Interrupt_Mask_.present ())
      {
        this->Interrupt_Mask_.set (r);
        continue;
      }
    }

    // Scan-Move-Control
    //
    if (n.name () == "Scan-Move-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Move_Control_type > r (
        Scan_Move_Control_traits::create (i, f, this));

      if (!Scan_Move_Control_.present ())
      {
        this->Scan_Move_Control_.set (r);
        continue;
      }
    }

    // Axis-Out-Source
    //
    if (n.name () == "Axis-Out-Source" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axis_Out_Source_type > r (
        Axis_Out_Source_traits::create (i, f, this));

      if (!Axis_Out_Source_.present ())
      {
        this->Axis_Out_Source_.set (r);
        continue;
      }
    }

    // Trace-Stop
    //
    if (n.name () == "Trace-Stop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Stop_type > r (
        Trace_Stop_traits::create (i, f, this));

      if (!Trace_Stop_.present ())
      {
        this->Trace_Stop_.set (r);
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (r);
        continue;
      }
    }

    // R-Setup
    //
    if (n.name () == "R-Setup" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_type > r (
        R_Setup_traits::create (i, f, this));

      if (!R_Setup_.present ())
      {
        this->R_Setup_.set (r);
        continue;
      }
    }

    // Buffer-Start
    //
    if (n.name () == "Buffer-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Start_type > r (
        Buffer_Start_traits::create (i, f, this));

      if (!Buffer_Start_.present ())
      {
        this->Buffer_Start_.set (r);
        continue;
      }
    }

    // Signal-Sense
    //
    if (n.name () == "Signal-Sense" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Signal_Sense_type > r (
        Signal_Sense_traits::create (i, f, this));

      if (!Signal_Sense_.present ())
      {
        this->Signal_Sense_.set (r);
        continue;
      }
    }

    // R-Scan-Move
    //
    if (n.name () == "R-Scan-Move" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Scan_Move_type > r (
        R_Scan_Move_traits::create (i, f, this));

      if (!R_Scan_Move_.present ())
      {
        this->R_Scan_Move_.set (r);
        continue;
      }
    }

    // Position-Forward
    //
    if (n.name () == "Position-Forward" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_Forward_type > r (
        Position_Forward_traits::create (i, f, this));

      if (!Position_Forward_.present ())
      {
        this->Position_Forward_.set (r);
        continue;
      }
    }

    // Derivative-Time
    //
    if (n.name () == "Derivative-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Derivative_Time_type > r (
        Derivative_Time_traits::create (i, f, this));

      if (!Derivative_Time_.present ())
      {
        this->Derivative_Time_.set (r);
        continue;
      }
    }

    // Settle-Window
    //
    if (n.name () == "Settle-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Window_type > r (
        Settle_Window_traits::create (i, f, this));

      if (!Settle_Window_.present ())
      {
        this->Settle_Window_.set (r);
        continue;
      }
    }

    // Trace-Variable1
    //
    if (n.name () == "Trace-Variable1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Variable1_type > r (
        Trace_Variable1_traits::create (i, f, this));

      if (!Trace_Variable1_.present ())
      {
        this->Trace_Variable1_.set (r);
        continue;
      }
    }

    // Trace-Variable2
    //
    if (n.name () == "Trace-Variable2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Variable2_type > r (
        Trace_Variable2_traits::create (i, f, this));

      if (!Trace_Variable2_.present ())
      {
        this->Trace_Variable2_.set (r);
        continue;
      }
    }

    // Buffer-Read-Index
    //
    if (n.name () == "Buffer-Read-Index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Buffer_Read_Index_type > r (
        Buffer_Read_Index_traits::create (i, f, this));

      if (!Buffer_Read_Index_.present ())
      {
        this->Buffer_Read_Index_.set (r);
        continue;
      }
    }

    // Signal-Status
    //
    if (n.name () == "Signal-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Signal_Status_type > r (
        Signal_Status_traits::create (i, f, this));

      if (!Signal_Status_.present ())
      {
        this->Signal_Status_.set (r);
        continue;
      }
    }

    // Alarm-Clear
    //
    if (n.name () == "Alarm-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Alarm_Clear_type > r (
        Alarm_Clear_traits::create (i, f, this));

      if (!Alarm_Clear_.present ())
      {
        this->Alarm_Clear_.set (r);
        continue;
      }
    }

    // Motion-Complete-Mode
    //
    if (n.name () == "Motion-Complete-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motion_Complete_Mode_type > r (
        Motion_Complete_Mode_traits::create (i, f, this));

      if (!Motion_Complete_Mode_.present ())
      {
        this->Motion_Complete_Mode_.set (r);
        continue;
      }
    }

    // R-Setup-Abort
    //
    if (n.name () == "R-Setup-Abort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_Abort_type > r (
        R_Setup_Abort_traits::create (i, f, this));

      if (!R_Setup_Abort_.present ())
      {
        this->R_Setup_Abort_.set (r);
        continue;
      }
    }

    // Read-Buffer
    //
    if (n.name () == "Read-Buffer" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Read_Buffer_type > r (
        Read_Buffer_traits::create (i, f, this));

      if (!Read_Buffer_.present ())
      {
        this->Read_Buffer_.set (r);
        continue;
      }
    }

    // Kd
    //
    if (n.name () == "Kd" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Kd_type > r (
        Kd_traits::create (i, f, this));

      if (!Kd_.present ())
      {
        this->Kd_.set (r);
        continue;
      }
    }

    // Clear-Interrupt
    //
    if (n.name () == "Clear-Interrupt" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Clear_Interrupt_type > r (
        Clear_Interrupt_traits::create (i, f, this));

      if (!Clear_Interrupt_.present ())
      {
        this->Clear_Interrupt_.set (r);
        continue;
      }
    }

    // Profile-Mode
    //
    if (n.name () == "Profile-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Profile_Mode_type > r (
        Profile_Mode_traits::create (i, f, this));

      if (!Profile_Mode_.present ())
      {
        this->Profile_Mode_.set (r);
        continue;
      }
    }

    // R-Setup-Trace
    //
    if (n.name () == "R-Setup-Trace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Setup_Trace_type > r (
        R_Setup_Trace_traits::create (i, f, this));

      if (!R_Setup_Trace_.present ())
      {
        this->R_Setup_Trace_.set (r);
        continue;
      }
    }

    // No-Operation
    //
    if (n.name () == "No-Operation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< No_Operation_type > r (
        No_Operation_traits::create (i, f, this));

      if (!No_Operation_.present ())
      {
        this->No_Operation_.set (r);
        continue;
      }
    }

    // Ki
    //
    if (n.name () == "Ki" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ki_type > r (
        Ki_traits::create (i, f, this));

      if (!Ki_.present ())
      {
        this->Ki_.set (r);
        continue;
      }
    }

    // Sample-Time
    //
    if (n.name () == "Sample-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sample_Time_type > r (
        Sample_Time_traits::create (i, f, this));

      if (!Sample_Time_.present ())
      {
        this->Sample_Time_.set (r);
        continue;
      }
    }

    // Event-Status
    //
    if (n.name () == "Event-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Event_Status_type > r (
        Event_Status_traits::create (i, f, this));

      if (!Event_Status_.present ())
      {
        this->Event_Status_.set (r);
        continue;
      }
    }

    // Kp
    //
    if (n.name () == "Kp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Kp_type > r (
        Kp_traits::create (i, f, this));

      if (!Kp_.present ())
      {
        this->Kp_.set (r);
        continue;
      }
    }

    // R-Wait-Finish-Scan-Move
    //
    if (n.name () == "R-Wait-Finish-Scan-Move" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< R_Wait_Finish_Scan_Move_type > r (
        R_Wait_Finish_Scan_Move_traits::create (i, f, this));

      if (!R_Wait_Finish_Scan_Move_.present ())
      {
        this->R_Wait_Finish_Scan_Move_.set (r);
        continue;
      }
    }

    // Settle-Time
    //
    if (n.name () == "Settle-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Settle_Time_type > r (
        Settle_Time_traits::create (i, f, this));

      if (!Settle_Time_.present ())
      {
        this->Settle_Time_.set (r);
        continue;
      }
    }

    // Acceleration-Stationary
    //
    if (n.name () == "Acceleration-Stationary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acceleration_Stationary_type > r (
        Acceleration_Stationary_traits::create (i, f, this));

      if (!Acceleration_Stationary_.present ())
      {
        this->Acceleration_Stationary_.set (r);
        continue;
      }
    }

    // Trace-Mode
    //
    if (n.name () == "Trace-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Mode_type > r (
        Trace_Mode_traits::create (i, f, this));

      if (!Trace_Mode_.present ())
      {
        this->Trace_Mode_.set (r);
        continue;
      }
    }

    // Trace-Period
    //
    if (n.name () == "Trace-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Period_type > r (
        Trace_Period_traits::create (i, f, this));

      if (!Trace_Period_.present ())
      {
        this->Trace_Period_.set (r);
        continue;
      }
    }

    // Trace-Start
    //
    if (n.name () == "Trace-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trace_Start_type > r (
        Trace_Start_traits::create (i, f, this));

      if (!Trace_Start_.present ())
      {
        this->Trace_Start_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Settle_Time_3d_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Time-3d",
      "");
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!R_Scan_Move_No_Wait_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move-No-Wait",
      "");
  }

  if (!Motor_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Mode",
      "");
  }

  if (!Acceleration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration",
      "");
  }

  if (!Serial_Port_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Serial-Port-Mode",
      "");
  }

  if (!Limit_Switch_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Limit-Switch-Mode",
      "");
  }

  if (!Breakpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Breakpoint",
      "");
  }

  if (!Update_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Update",
      "");
  }

  if (!Breakpoint_Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Breakpoint-Value",
      "");
  }

  if (!V_Switch_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Switch-Limit",
      "");
  }

  if (!R_Retrieve_Trace_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Retrieve-Trace",
      "");
  }

  if (!Velocity_Stationary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity-Stationary",
      "");
  }

  if (!Reset_Event_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reset-Event-Status",
      "");
  }

  if (!Actual_Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Actual-Position",
      "");
  }

  if (!Buffer_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Length",
      "");
  }

  if (!R_Scan_Move2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move2",
      "");
  }

  if (!Position_Reverse_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Reverse",
      "");
  }

  if (!Reset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Reset",
      "");
  }

  if (!Trace_Count_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Count",
      "");
  }

  if (!R_Initialize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Initialize",
      "");
  }

  if (!Output_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Output-Mode",
      "");
  }

  if (!Position2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position2",
      "");
  }

  if (!Integration_Limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Integration-Limit",
      "");
  }

  if (!R_Home_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Home",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!R_Reset_Limit_Switch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Reset-Limit-Switch",
      "");
  }

  if (!Settle_Window_3d_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Window-3d",
      "");
  }

  if (!Interrupt_Mask_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interrupt-Mask",
      "");
  }

  if (!Scan_Move_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Move-Control",
      "");
  }

  if (!Axis_Out_Source_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axis-Out-Source",
      "");
  }

  if (!Trace_Stop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Stop",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  if (!R_Setup_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup",
      "");
  }

  if (!Buffer_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Start",
      "");
  }

  if (!Signal_Sense_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Signal-Sense",
      "");
  }

  if (!R_Scan_Move_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Scan-Move",
      "");
  }

  if (!Position_Forward_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position-Forward",
      "");
  }

  if (!Derivative_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Derivative-Time",
      "");
  }

  if (!Settle_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Window",
      "");
  }

  if (!Trace_Variable1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Variable1",
      "");
  }

  if (!Trace_Variable2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Variable2",
      "");
  }

  if (!Buffer_Read_Index_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Buffer-Read-Index",
      "");
  }

  if (!Signal_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Signal-Status",
      "");
  }

  if (!Alarm_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Alarm-Clear",
      "");
  }

  if (!Motion_Complete_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motion-Complete-Mode",
      "");
  }

  if (!R_Setup_Abort_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup-Abort",
      "");
  }

  if (!Read_Buffer_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Read-Buffer",
      "");
  }

  if (!Kd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Kd",
      "");
  }

  if (!Clear_Interrupt_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Clear-Interrupt",
      "");
  }

  if (!Profile_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Profile-Mode",
      "");
  }

  if (!R_Setup_Trace_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Setup-Trace",
      "");
  }

  if (!No_Operation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "No-Operation",
      "");
  }

  if (!Ki_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ki",
      "");
  }

  if (!Sample_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sample-Time",
      "");
  }

  if (!Event_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Event-Status",
      "");
  }

  if (!Kp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Kp",
      "");
  }

  if (!R_Wait_Finish_Scan_Move_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "R-Wait-Finish-Scan-Move",
      "");
  }

  if (!Settle_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Settle-Time",
      "");
  }

  if (!Acceleration_Stationary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acceleration-Stationary",
      "");
  }

  if (!Trace_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Mode",
      "");
  }

  if (!Trace_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Period",
      "");
  }

  if (!Trace_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trace-Start",
      "");
  }
}

Motor1* Motor1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Motor1 (*this, f, c);
}

Motor1::
~Motor1 ()
{
}

// ContrastDlg
//

ContrastDlg::
ContrastDlg (const Contrast_YAxis_Auto_Scale_type& Contrast_YAxis_Auto_Scale,
             const Draw_Cardiac_Average_type& Draw_Cardiac_Average,
             const Average_Frames_type& Average_Frames,
             const Contrast_YAxis_Max_type& Contrast_YAxis_Max,
             const Draw_Destroy_Markers_type& Draw_Destroy_Markers,
             const Draw_Time_Axis_type& Draw_Time_Axis,
             const Draw_Cardiac_Grayscale_type& Draw_Cardiac_Grayscale,
             const Draw_Grayscale_type& Draw_Grayscale,
             const Draw_Markers_type& Draw_Markers,
             const Contrast_Linear_type& Contrast_Linear,
             const Cardiac_YAxis_Max_type& Cardiac_YAxis_Max,
             const Cardiac_YAxis_Auto_Scale_type& Cardiac_YAxis_Auto_Scale,
             const Draw_Moving_Average_type& Draw_Moving_Average,
             const Draw_Percent_Area_type& Draw_Percent_Area,
             const Percent_Area_Thresh_type& Percent_Area_Thresh,
             const Cardiac_Display_Frame_type& Cardiac_Display_Frame)
: ::xml_schema::type (),
  Contrast_YAxis_Auto_Scale_ (Contrast_YAxis_Auto_Scale, ::xml_schema::flags (), this),
  Draw_Cardiac_Average_ (Draw_Cardiac_Average, ::xml_schema::flags (), this),
  Average_Frames_ (Average_Frames, ::xml_schema::flags (), this),
  Contrast_YAxis_Max_ (Contrast_YAxis_Max, ::xml_schema::flags (), this),
  Draw_Destroy_Markers_ (Draw_Destroy_Markers, ::xml_schema::flags (), this),
  Draw_Time_Axis_ (Draw_Time_Axis, ::xml_schema::flags (), this),
  Draw_Cardiac_Grayscale_ (Draw_Cardiac_Grayscale, ::xml_schema::flags (), this),
  Draw_Grayscale_ (Draw_Grayscale, ::xml_schema::flags (), this),
  Draw_Markers_ (Draw_Markers, ::xml_schema::flags (), this),
  Contrast_Linear_ (Contrast_Linear, ::xml_schema::flags (), this),
  Cardiac_YAxis_Max_ (Cardiac_YAxis_Max, ::xml_schema::flags (), this),
  Cardiac_YAxis_Auto_Scale_ (Cardiac_YAxis_Auto_Scale, ::xml_schema::flags (), this),
  Draw_Moving_Average_ (Draw_Moving_Average, ::xml_schema::flags (), this),
  Draw_Percent_Area_ (Draw_Percent_Area, ::xml_schema::flags (), this),
  Percent_Area_Thresh_ (Percent_Area_Thresh, ::xml_schema::flags (), this),
  Cardiac_Display_Frame_ (Cardiac_Display_Frame, ::xml_schema::flags (), this)
{
}

ContrastDlg::
ContrastDlg (const ContrastDlg& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Contrast_YAxis_Auto_Scale_ (x.Contrast_YAxis_Auto_Scale_, f, this),
  Draw_Cardiac_Average_ (x.Draw_Cardiac_Average_, f, this),
  Average_Frames_ (x.Average_Frames_, f, this),
  Contrast_YAxis_Max_ (x.Contrast_YAxis_Max_, f, this),
  Draw_Destroy_Markers_ (x.Draw_Destroy_Markers_, f, this),
  Draw_Time_Axis_ (x.Draw_Time_Axis_, f, this),
  Draw_Cardiac_Grayscale_ (x.Draw_Cardiac_Grayscale_, f, this),
  Draw_Grayscale_ (x.Draw_Grayscale_, f, this),
  Draw_Markers_ (x.Draw_Markers_, f, this),
  Contrast_Linear_ (x.Contrast_Linear_, f, this),
  Cardiac_YAxis_Max_ (x.Cardiac_YAxis_Max_, f, this),
  Cardiac_YAxis_Auto_Scale_ (x.Cardiac_YAxis_Auto_Scale_, f, this),
  Draw_Moving_Average_ (x.Draw_Moving_Average_, f, this),
  Draw_Percent_Area_ (x.Draw_Percent_Area_, f, this),
  Percent_Area_Thresh_ (x.Percent_Area_Thresh_, f, this),
  Cardiac_Display_Frame_ (x.Cardiac_Display_Frame_, f, this)
{
}

ContrastDlg::
ContrastDlg (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Contrast_YAxis_Auto_Scale_ (f, this),
  Draw_Cardiac_Average_ (f, this),
  Average_Frames_ (f, this),
  Contrast_YAxis_Max_ (f, this),
  Draw_Destroy_Markers_ (f, this),
  Draw_Time_Axis_ (f, this),
  Draw_Cardiac_Grayscale_ (f, this),
  Draw_Grayscale_ (f, this),
  Draw_Markers_ (f, this),
  Contrast_Linear_ (f, this),
  Cardiac_YAxis_Max_ (f, this),
  Cardiac_YAxis_Auto_Scale_ (f, this),
  Draw_Moving_Average_ (f, this),
  Draw_Percent_Area_ (f, this),
  Percent_Area_Thresh_ (f, this),
  Cardiac_Display_Frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ContrastDlg::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Contrast-YAxis-Auto-Scale
    //
    if (n.name () == "Contrast-YAxis-Auto-Scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_YAxis_Auto_Scale_type > r (
        Contrast_YAxis_Auto_Scale_traits::create (i, f, this));

      if (!Contrast_YAxis_Auto_Scale_.present ())
      {
        this->Contrast_YAxis_Auto_Scale_.set (r);
        continue;
      }
    }

    // Draw-Cardiac-Average
    //
    if (n.name () == "Draw-Cardiac-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Cardiac_Average_type > r (
        Draw_Cardiac_Average_traits::create (i, f, this));

      if (!Draw_Cardiac_Average_.present ())
      {
        this->Draw_Cardiac_Average_.set (r);
        continue;
      }
    }

    // Average-Frames
    //
    if (n.name () == "Average-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Average_Frames_type > r (
        Average_Frames_traits::create (i, f, this));

      if (!Average_Frames_.present ())
      {
        this->Average_Frames_.set (r);
        continue;
      }
    }

    // Contrast-YAxis-Max
    //
    if (n.name () == "Contrast-YAxis-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_YAxis_Max_type > r (
        Contrast_YAxis_Max_traits::create (i, f, this));

      if (!Contrast_YAxis_Max_.present ())
      {
        this->Contrast_YAxis_Max_.set (r);
        continue;
      }
    }

    // Draw-Destroy-Markers
    //
    if (n.name () == "Draw-Destroy-Markers" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Destroy_Markers_type > r (
        Draw_Destroy_Markers_traits::create (i, f, this));

      if (!Draw_Destroy_Markers_.present ())
      {
        this->Draw_Destroy_Markers_.set (r);
        continue;
      }
    }

    // Draw-Time-Axis
    //
    if (n.name () == "Draw-Time-Axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Time_Axis_type > r (
        Draw_Time_Axis_traits::create (i, f, this));

      if (!Draw_Time_Axis_.present ())
      {
        this->Draw_Time_Axis_.set (r);
        continue;
      }
    }

    // Draw-Cardiac-Grayscale
    //
    if (n.name () == "Draw-Cardiac-Grayscale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Cardiac_Grayscale_type > r (
        Draw_Cardiac_Grayscale_traits::create (i, f, this));

      if (!Draw_Cardiac_Grayscale_.present ())
      {
        this->Draw_Cardiac_Grayscale_.set (r);
        continue;
      }
    }

    // Draw-Grayscale
    //
    if (n.name () == "Draw-Grayscale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Grayscale_type > r (
        Draw_Grayscale_traits::create (i, f, this));

      if (!Draw_Grayscale_.present ())
      {
        this->Draw_Grayscale_.set (r);
        continue;
      }
    }

    // Draw-Markers
    //
    if (n.name () == "Draw-Markers" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Markers_type > r (
        Draw_Markers_traits::create (i, f, this));

      if (!Draw_Markers_.present ())
      {
        this->Draw_Markers_.set (r);
        continue;
      }
    }

    // Contrast-Linear
    //
    if (n.name () == "Contrast-Linear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Contrast_Linear_type > r (
        Contrast_Linear_traits::create (i, f, this));

      if (!Contrast_Linear_.present ())
      {
        this->Contrast_Linear_.set (r);
        continue;
      }
    }

    // Cardiac-YAxis-Max
    //
    if (n.name () == "Cardiac-YAxis-Max" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cardiac_YAxis_Max_type > r (
        Cardiac_YAxis_Max_traits::create (i, f, this));

      if (!Cardiac_YAxis_Max_.present ())
      {
        this->Cardiac_YAxis_Max_.set (r);
        continue;
      }
    }

    // Cardiac-YAxis-Auto-Scale
    //
    if (n.name () == "Cardiac-YAxis-Auto-Scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cardiac_YAxis_Auto_Scale_type > r (
        Cardiac_YAxis_Auto_Scale_traits::create (i, f, this));

      if (!Cardiac_YAxis_Auto_Scale_.present ())
      {
        this->Cardiac_YAxis_Auto_Scale_.set (r);
        continue;
      }
    }

    // Draw-Moving-Average
    //
    if (n.name () == "Draw-Moving-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Moving_Average_type > r (
        Draw_Moving_Average_traits::create (i, f, this));

      if (!Draw_Moving_Average_.present ())
      {
        this->Draw_Moving_Average_.set (r);
        continue;
      }
    }

    // Draw-Percent-Area
    //
    if (n.name () == "Draw-Percent-Area" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Draw_Percent_Area_type > r (
        Draw_Percent_Area_traits::create (i, f, this));

      if (!Draw_Percent_Area_.present ())
      {
        this->Draw_Percent_Area_.set (r);
        continue;
      }
    }

    // Percent-Area-Thresh
    //
    if (n.name () == "Percent-Area-Thresh" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Percent_Area_Thresh_type > r (
        Percent_Area_Thresh_traits::create (i, f, this));

      if (!Percent_Area_Thresh_.present ())
      {
        this->Percent_Area_Thresh_.set (r);
        continue;
      }
    }

    // Cardiac-Display-Frame
    //
    if (n.name () == "Cardiac-Display-Frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cardiac_Display_Frame_type > r (
        Cardiac_Display_Frame_traits::create (i, f, this));

      if (!Cardiac_Display_Frame_.present ())
      {
        this->Cardiac_Display_Frame_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Contrast_YAxis_Auto_Scale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-YAxis-Auto-Scale",
      "");
  }

  if (!Draw_Cardiac_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Cardiac-Average",
      "");
  }

  if (!Average_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Average-Frames",
      "");
  }

  if (!Contrast_YAxis_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-YAxis-Max",
      "");
  }

  if (!Draw_Destroy_Markers_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Destroy-Markers",
      "");
  }

  if (!Draw_Time_Axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Time-Axis",
      "");
  }

  if (!Draw_Cardiac_Grayscale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Cardiac-Grayscale",
      "");
  }

  if (!Draw_Grayscale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Grayscale",
      "");
  }

  if (!Draw_Markers_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Markers",
      "");
  }

  if (!Contrast_Linear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Contrast-Linear",
      "");
  }

  if (!Cardiac_YAxis_Max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cardiac-YAxis-Max",
      "");
  }

  if (!Cardiac_YAxis_Auto_Scale_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cardiac-YAxis-Auto-Scale",
      "");
  }

  if (!Draw_Moving_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Moving-Average",
      "");
  }

  if (!Draw_Percent_Area_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Draw-Percent-Area",
      "");
  }

  if (!Percent_Area_Thresh_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Percent-Area-Thresh",
      "");
  }

  if (!Cardiac_Display_Frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cardiac-Display-Frame",
      "");
  }
}

ContrastDlg* ContrastDlg::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ContrastDlg (*this, f, c);
}

ContrastDlg::
~ContrastDlg ()
{
}

// Diag1
//

Diag1::
Diag1 (const Mem_Pagefile_type& Mem_Pagefile,
       const Monitor_3point3V_type& Monitor_3point3V,
       const USER_Objects_type& USER_Objects,
       const Motor_FPGA_Revision_type& Motor_FPGA_Revision,
       const Product_Name_type& Product_Name,
       const Build_Version_type& Build_Version,
       const ICB_PCB_ID_type& ICB_PCB_ID,
       const Software_Version_type& Software_Version,
       const Receive_PCB_ID_type& Receive_PCB_ID,
       const Mem_Private_type& Mem_Private,
       const Monitor_5V_type& Monitor_5V,
       const Motor_PCB_Revision_type& Motor_PCB_Revision,
       const NE1619_type& NE1619,
       const Motor_PCB_ID_type& Motor_PCB_ID,
       const Transmit_PCB_Revision_type& Transmit_PCB_Revision,
       const MAX1137_type& MAX1137,
       const Monitor_Neg15V_type& Monitor_Neg15V,
       const Monitor_Neg5V_type& Monitor_Neg5V,
       const Switch_PCB_Revision_type& Switch_PCB_Revision,
       const Receive_PCB_Revision_type& Receive_PCB_Revision,
       const ICB_PCB_Revision_type& ICB_PCB_Revision,
       const Transmit_PCB_ID_type& Transmit_PCB_ID,
       const Monitor_Temperature_type& Monitor_Temperature,
       const Receive_FPGA_Revision_type& Receive_FPGA_Revision,
       const Monitor_15V_type& Monitor_15V,
       const ICB_FPGA_Revision_type& ICB_FPGA_Revision,
       const GDI_Objects_type& GDI_Objects,
       const Mem_WorkingSet_type& Mem_WorkingSet,
       const Switch_PCB_ID_type& Switch_PCB_ID)
: ::xml_schema::type (),
  Mem_Pagefile_ (Mem_Pagefile, ::xml_schema::flags (), this),
  Monitor_3point3V_ (Monitor_3point3V, ::xml_schema::flags (), this),
  USER_Objects_ (USER_Objects, ::xml_schema::flags (), this),
  Motor_FPGA_Revision_ (Motor_FPGA_Revision, ::xml_schema::flags (), this),
  Product_Name_ (Product_Name, ::xml_schema::flags (), this),
  Build_Version_ (Build_Version, ::xml_schema::flags (), this),
  ICB_PCB_ID_ (ICB_PCB_ID, ::xml_schema::flags (), this),
  Software_Version_ (Software_Version, ::xml_schema::flags (), this),
  Receive_PCB_ID_ (Receive_PCB_ID, ::xml_schema::flags (), this),
  Mem_Private_ (Mem_Private, ::xml_schema::flags (), this),
  Monitor_5V_ (Monitor_5V, ::xml_schema::flags (), this),
  Motor_PCB_Revision_ (Motor_PCB_Revision, ::xml_schema::flags (), this),
  NE1619_ (NE1619, ::xml_schema::flags (), this),
  Motor_PCB_ID_ (Motor_PCB_ID, ::xml_schema::flags (), this),
  Transmit_PCB_Revision_ (Transmit_PCB_Revision, ::xml_schema::flags (), this),
  MAX1137_ (MAX1137, ::xml_schema::flags (), this),
  Monitor_Neg15V_ (Monitor_Neg15V, ::xml_schema::flags (), this),
  Monitor_Neg5V_ (Monitor_Neg5V, ::xml_schema::flags (), this),
  Switch_PCB_Revision_ (Switch_PCB_Revision, ::xml_schema::flags (), this),
  Receive_PCB_Revision_ (Receive_PCB_Revision, ::xml_schema::flags (), this),
  ICB_PCB_Revision_ (ICB_PCB_Revision, ::xml_schema::flags (), this),
  Transmit_PCB_ID_ (Transmit_PCB_ID, ::xml_schema::flags (), this),
  Monitor_Temperature_ (Monitor_Temperature, ::xml_schema::flags (), this),
  Receive_FPGA_Revision_ (Receive_FPGA_Revision, ::xml_schema::flags (), this),
  Monitor_15V_ (Monitor_15V, ::xml_schema::flags (), this),
  ICB_FPGA_Revision_ (ICB_FPGA_Revision, ::xml_schema::flags (), this),
  GDI_Objects_ (GDI_Objects, ::xml_schema::flags (), this),
  Mem_WorkingSet_ (Mem_WorkingSet, ::xml_schema::flags (), this),
  Switch_PCB_ID_ (Switch_PCB_ID, ::xml_schema::flags (), this)
{
}

Diag1::
Diag1 (const Mem_Pagefile_type& Mem_Pagefile,
       ::std::auto_ptr< Monitor_3point3V_type >& Monitor_3point3V,
       const USER_Objects_type& USER_Objects,
       const Motor_FPGA_Revision_type& Motor_FPGA_Revision,
       const Product_Name_type& Product_Name,
       const Build_Version_type& Build_Version,
       const ICB_PCB_ID_type& ICB_PCB_ID,
       const Software_Version_type& Software_Version,
       const Receive_PCB_ID_type& Receive_PCB_ID,
       const Mem_Private_type& Mem_Private,
       ::std::auto_ptr< Monitor_5V_type >& Monitor_5V,
       const Motor_PCB_Revision_type& Motor_PCB_Revision,
       const NE1619_type& NE1619,
       const Motor_PCB_ID_type& Motor_PCB_ID,
       const Transmit_PCB_Revision_type& Transmit_PCB_Revision,
       const MAX1137_type& MAX1137,
       ::std::auto_ptr< Monitor_Neg15V_type >& Monitor_Neg15V,
       ::std::auto_ptr< Monitor_Neg5V_type >& Monitor_Neg5V,
       const Switch_PCB_Revision_type& Switch_PCB_Revision,
       const Receive_PCB_Revision_type& Receive_PCB_Revision,
       const ICB_PCB_Revision_type& ICB_PCB_Revision,
       const Transmit_PCB_ID_type& Transmit_PCB_ID,
       const Monitor_Temperature_type& Monitor_Temperature,
       const Receive_FPGA_Revision_type& Receive_FPGA_Revision,
       ::std::auto_ptr< Monitor_15V_type >& Monitor_15V,
       const ICB_FPGA_Revision_type& ICB_FPGA_Revision,
       const GDI_Objects_type& GDI_Objects,
       const Mem_WorkingSet_type& Mem_WorkingSet,
       const Switch_PCB_ID_type& Switch_PCB_ID)
: ::xml_schema::type (),
  Mem_Pagefile_ (Mem_Pagefile, ::xml_schema::flags (), this),
  Monitor_3point3V_ (Monitor_3point3V, ::xml_schema::flags (), this),
  USER_Objects_ (USER_Objects, ::xml_schema::flags (), this),
  Motor_FPGA_Revision_ (Motor_FPGA_Revision, ::xml_schema::flags (), this),
  Product_Name_ (Product_Name, ::xml_schema::flags (), this),
  Build_Version_ (Build_Version, ::xml_schema::flags (), this),
  ICB_PCB_ID_ (ICB_PCB_ID, ::xml_schema::flags (), this),
  Software_Version_ (Software_Version, ::xml_schema::flags (), this),
  Receive_PCB_ID_ (Receive_PCB_ID, ::xml_schema::flags (), this),
  Mem_Private_ (Mem_Private, ::xml_schema::flags (), this),
  Monitor_5V_ (Monitor_5V, ::xml_schema::flags (), this),
  Motor_PCB_Revision_ (Motor_PCB_Revision, ::xml_schema::flags (), this),
  NE1619_ (NE1619, ::xml_schema::flags (), this),
  Motor_PCB_ID_ (Motor_PCB_ID, ::xml_schema::flags (), this),
  Transmit_PCB_Revision_ (Transmit_PCB_Revision, ::xml_schema::flags (), this),
  MAX1137_ (MAX1137, ::xml_schema::flags (), this),
  Monitor_Neg15V_ (Monitor_Neg15V, ::xml_schema::flags (), this),
  Monitor_Neg5V_ (Monitor_Neg5V, ::xml_schema::flags (), this),
  Switch_PCB_Revision_ (Switch_PCB_Revision, ::xml_schema::flags (), this),
  Receive_PCB_Revision_ (Receive_PCB_Revision, ::xml_schema::flags (), this),
  ICB_PCB_Revision_ (ICB_PCB_Revision, ::xml_schema::flags (), this),
  Transmit_PCB_ID_ (Transmit_PCB_ID, ::xml_schema::flags (), this),
  Monitor_Temperature_ (Monitor_Temperature, ::xml_schema::flags (), this),
  Receive_FPGA_Revision_ (Receive_FPGA_Revision, ::xml_schema::flags (), this),
  Monitor_15V_ (Monitor_15V, ::xml_schema::flags (), this),
  ICB_FPGA_Revision_ (ICB_FPGA_Revision, ::xml_schema::flags (), this),
  GDI_Objects_ (GDI_Objects, ::xml_schema::flags (), this),
  Mem_WorkingSet_ (Mem_WorkingSet, ::xml_schema::flags (), this),
  Switch_PCB_ID_ (Switch_PCB_ID, ::xml_schema::flags (), this)
{
}

Diag1::
Diag1 (const Diag1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Mem_Pagefile_ (x.Mem_Pagefile_, f, this),
  Monitor_3point3V_ (x.Monitor_3point3V_, f, this),
  USER_Objects_ (x.USER_Objects_, f, this),
  Motor_FPGA_Revision_ (x.Motor_FPGA_Revision_, f, this),
  Product_Name_ (x.Product_Name_, f, this),
  Build_Version_ (x.Build_Version_, f, this),
  ICB_PCB_ID_ (x.ICB_PCB_ID_, f, this),
  Software_Version_ (x.Software_Version_, f, this),
  Receive_PCB_ID_ (x.Receive_PCB_ID_, f, this),
  Mem_Private_ (x.Mem_Private_, f, this),
  Monitor_5V_ (x.Monitor_5V_, f, this),
  Motor_PCB_Revision_ (x.Motor_PCB_Revision_, f, this),
  NE1619_ (x.NE1619_, f, this),
  Motor_PCB_ID_ (x.Motor_PCB_ID_, f, this),
  Transmit_PCB_Revision_ (x.Transmit_PCB_Revision_, f, this),
  MAX1137_ (x.MAX1137_, f, this),
  Monitor_Neg15V_ (x.Monitor_Neg15V_, f, this),
  Monitor_Neg5V_ (x.Monitor_Neg5V_, f, this),
  Switch_PCB_Revision_ (x.Switch_PCB_Revision_, f, this),
  Receive_PCB_Revision_ (x.Receive_PCB_Revision_, f, this),
  ICB_PCB_Revision_ (x.ICB_PCB_Revision_, f, this),
  Transmit_PCB_ID_ (x.Transmit_PCB_ID_, f, this),
  Monitor_Temperature_ (x.Monitor_Temperature_, f, this),
  Receive_FPGA_Revision_ (x.Receive_FPGA_Revision_, f, this),
  Monitor_15V_ (x.Monitor_15V_, f, this),
  ICB_FPGA_Revision_ (x.ICB_FPGA_Revision_, f, this),
  GDI_Objects_ (x.GDI_Objects_, f, this),
  Mem_WorkingSet_ (x.Mem_WorkingSet_, f, this),
  Switch_PCB_ID_ (x.Switch_PCB_ID_, f, this)
{
}

Diag1::
Diag1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Mem_Pagefile_ (f, this),
  Monitor_3point3V_ (f, this),
  USER_Objects_ (f, this),
  Motor_FPGA_Revision_ (f, this),
  Product_Name_ (f, this),
  Build_Version_ (f, this),
  ICB_PCB_ID_ (f, this),
  Software_Version_ (f, this),
  Receive_PCB_ID_ (f, this),
  Mem_Private_ (f, this),
  Monitor_5V_ (f, this),
  Motor_PCB_Revision_ (f, this),
  NE1619_ (f, this),
  Motor_PCB_ID_ (f, this),
  Transmit_PCB_Revision_ (f, this),
  MAX1137_ (f, this),
  Monitor_Neg15V_ (f, this),
  Monitor_Neg5V_ (f, this),
  Switch_PCB_Revision_ (f, this),
  Receive_PCB_Revision_ (f, this),
  ICB_PCB_Revision_ (f, this),
  Transmit_PCB_ID_ (f, this),
  Monitor_Temperature_ (f, this),
  Receive_FPGA_Revision_ (f, this),
  Monitor_15V_ (f, this),
  ICB_FPGA_Revision_ (f, this),
  GDI_Objects_ (f, this),
  Mem_WorkingSet_ (f, this),
  Switch_PCB_ID_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Diag1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Mem-Pagefile
    //
    if (n.name () == "Mem-Pagefile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_Pagefile_type > r (
        Mem_Pagefile_traits::create (i, f, this));

      if (!Mem_Pagefile_.present ())
      {
        this->Mem_Pagefile_.set (r);
        continue;
      }
    }

    // Monitor-3point3V
    //
    if (n.name () == "Monitor-3point3V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_3point3V_type > r (
        Monitor_3point3V_traits::create (i, f, this));

      if (!Monitor_3point3V_.present ())
      {
        this->Monitor_3point3V_.set (r);
        continue;
      }
    }

    // USER-Objects
    //
    if (n.name () == "USER-Objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USER_Objects_type > r (
        USER_Objects_traits::create (i, f, this));

      if (!USER_Objects_.present ())
      {
        this->USER_Objects_.set (r);
        continue;
      }
    }

    // Motor-FPGA-Revision
    //
    if (n.name () == "Motor-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_FPGA_Revision_type > r (
        Motor_FPGA_Revision_traits::create (i, f, this));

      if (!Motor_FPGA_Revision_.present ())
      {
        this->Motor_FPGA_Revision_.set (r);
        continue;
      }
    }

    // Product-Name
    //
    if (n.name () == "Product-Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Product_Name_type > r (
        Product_Name_traits::create (i, f, this));

      if (!Product_Name_.present ())
      {
        this->Product_Name_.set (r);
        continue;
      }
    }

    // Build-Version
    //
    if (n.name () == "Build-Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Build_Version_type > r (
        Build_Version_traits::create (i, f, this));

      if (!Build_Version_.present ())
      {
        this->Build_Version_.set (r);
        continue;
      }
    }

    // ICB-PCB-ID
    //
    if (n.name () == "ICB-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_PCB_ID_type > r (
        ICB_PCB_ID_traits::create (i, f, this));

      if (!ICB_PCB_ID_.present ())
      {
        this->ICB_PCB_ID_.set (r);
        continue;
      }
    }

    // Software-Version
    //
    if (n.name () == "Software-Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Software_Version_type > r (
        Software_Version_traits::create (i, f, this));

      if (!Software_Version_.present ())
      {
        this->Software_Version_.set (r);
        continue;
      }
    }

    // Receive-PCB-ID
    //
    if (n.name () == "Receive-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_PCB_ID_type > r (
        Receive_PCB_ID_traits::create (i, f, this));

      if (!Receive_PCB_ID_.present ())
      {
        this->Receive_PCB_ID_.set (r);
        continue;
      }
    }

    // Mem-Private
    //
    if (n.name () == "Mem-Private" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_Private_type > r (
        Mem_Private_traits::create (i, f, this));

      if (!Mem_Private_.present ())
      {
        this->Mem_Private_.set (r);
        continue;
      }
    }

    // Monitor-5V
    //
    if (n.name () == "Monitor-5V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_5V_type > r (
        Monitor_5V_traits::create (i, f, this));

      if (!Monitor_5V_.present ())
      {
        this->Monitor_5V_.set (r);
        continue;
      }
    }

    // Motor-PCB-Revision
    //
    if (n.name () == "Motor-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_PCB_Revision_type > r (
        Motor_PCB_Revision_traits::create (i, f, this));

      if (!Motor_PCB_Revision_.present ())
      {
        this->Motor_PCB_Revision_.set (r);
        continue;
      }
    }

    // NE1619
    //
    if (n.name () == "NE1619" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NE1619_type > r (
        NE1619_traits::create (i, f, this));

      if (!NE1619_.present ())
      {
        this->NE1619_.set (r);
        continue;
      }
    }

    // Motor-PCB-ID
    //
    if (n.name () == "Motor-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_PCB_ID_type > r (
        Motor_PCB_ID_traits::create (i, f, this));

      if (!Motor_PCB_ID_.present ())
      {
        this->Motor_PCB_ID_.set (r);
        continue;
      }
    }

    // Transmit-PCB-Revision
    //
    if (n.name () == "Transmit-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Transmit_PCB_Revision_type > r (
        Transmit_PCB_Revision_traits::create (i, f, this));

      if (!Transmit_PCB_Revision_.present ())
      {
        this->Transmit_PCB_Revision_.set (r);
        continue;
      }
    }

    // MAX1137
    //
    if (n.name () == "MAX1137" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MAX1137_type > r (
        MAX1137_traits::create (i, f, this));

      if (!MAX1137_.present ())
      {
        this->MAX1137_.set (r);
        continue;
      }
    }

    // Monitor-Neg15V
    //
    if (n.name () == "Monitor-Neg15V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Neg15V_type > r (
        Monitor_Neg15V_traits::create (i, f, this));

      if (!Monitor_Neg15V_.present ())
      {
        this->Monitor_Neg15V_.set (r);
        continue;
      }
    }

    // Monitor-Neg5V
    //
    if (n.name () == "Monitor-Neg5V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Neg5V_type > r (
        Monitor_Neg5V_traits::create (i, f, this));

      if (!Monitor_Neg5V_.present ())
      {
        this->Monitor_Neg5V_.set (r);
        continue;
      }
    }

    // Switch-PCB-Revision
    //
    if (n.name () == "Switch-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Switch_PCB_Revision_type > r (
        Switch_PCB_Revision_traits::create (i, f, this));

      if (!Switch_PCB_Revision_.present ())
      {
        this->Switch_PCB_Revision_.set (r);
        continue;
      }
    }

    // Receive-PCB-Revision
    //
    if (n.name () == "Receive-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_PCB_Revision_type > r (
        Receive_PCB_Revision_traits::create (i, f, this));

      if (!Receive_PCB_Revision_.present ())
      {
        this->Receive_PCB_Revision_.set (r);
        continue;
      }
    }

    // ICB-PCB-Revision
    //
    if (n.name () == "ICB-PCB-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_PCB_Revision_type > r (
        ICB_PCB_Revision_traits::create (i, f, this));

      if (!ICB_PCB_Revision_.present ())
      {
        this->ICB_PCB_Revision_.set (r);
        continue;
      }
    }

    // Transmit-PCB-ID
    //
    if (n.name () == "Transmit-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Transmit_PCB_ID_type > r (
        Transmit_PCB_ID_traits::create (i, f, this));

      if (!Transmit_PCB_ID_.present ())
      {
        this->Transmit_PCB_ID_.set (r);
        continue;
      }
    }

    // Monitor-Temperature
    //
    if (n.name () == "Monitor-Temperature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_Temperature_type > r (
        Monitor_Temperature_traits::create (i, f, this));

      if (!Monitor_Temperature_.present ())
      {
        this->Monitor_Temperature_.set (r);
        continue;
      }
    }

    // Receive-FPGA-Revision
    //
    if (n.name () == "Receive-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Receive_FPGA_Revision_type > r (
        Receive_FPGA_Revision_traits::create (i, f, this));

      if (!Receive_FPGA_Revision_.present ())
      {
        this->Receive_FPGA_Revision_.set (r);
        continue;
      }
    }

    // Monitor-15V
    //
    if (n.name () == "Monitor-15V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Monitor_15V_type > r (
        Monitor_15V_traits::create (i, f, this));

      if (!Monitor_15V_.present ())
      {
        this->Monitor_15V_.set (r);
        continue;
      }
    }

    // ICB-FPGA-Revision
    //
    if (n.name () == "ICB-FPGA-Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ICB_FPGA_Revision_type > r (
        ICB_FPGA_Revision_traits::create (i, f, this));

      if (!ICB_FPGA_Revision_.present ())
      {
        this->ICB_FPGA_Revision_.set (r);
        continue;
      }
    }

    // GDI-Objects
    //
    if (n.name () == "GDI-Objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< GDI_Objects_type > r (
        GDI_Objects_traits::create (i, f, this));

      if (!GDI_Objects_.present ())
      {
        this->GDI_Objects_.set (r);
        continue;
      }
    }

    // Mem-WorkingSet
    //
    if (n.name () == "Mem-WorkingSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mem_WorkingSet_type > r (
        Mem_WorkingSet_traits::create (i, f, this));

      if (!Mem_WorkingSet_.present ())
      {
        this->Mem_WorkingSet_.set (r);
        continue;
      }
    }

    // Switch-PCB-ID
    //
    if (n.name () == "Switch-PCB-ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Switch_PCB_ID_type > r (
        Switch_PCB_ID_traits::create (i, f, this));

      if (!Switch_PCB_ID_.present ())
      {
        this->Switch_PCB_ID_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Mem_Pagefile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-Pagefile",
      "");
  }

  if (!Monitor_3point3V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-3point3V",
      "");
  }

  if (!USER_Objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "USER-Objects",
      "");
  }

  if (!Motor_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-FPGA-Revision",
      "");
  }

  if (!Product_Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Product-Name",
      "");
  }

  if (!Build_Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Build-Version",
      "");
  }

  if (!ICB_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-PCB-ID",
      "");
  }

  if (!Software_Version_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Software-Version",
      "");
  }

  if (!Receive_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-PCB-ID",
      "");
  }

  if (!Mem_Private_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-Private",
      "");
  }

  if (!Monitor_5V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-5V",
      "");
  }

  if (!Motor_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-PCB-Revision",
      "");
  }

  if (!NE1619_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NE1619",
      "");
  }

  if (!Motor_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-PCB-ID",
      "");
  }

  if (!Transmit_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Transmit-PCB-Revision",
      "");
  }

  if (!MAX1137_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MAX1137",
      "");
  }

  if (!Monitor_Neg15V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Neg15V",
      "");
  }

  if (!Monitor_Neg5V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Neg5V",
      "");
  }

  if (!Switch_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Switch-PCB-Revision",
      "");
  }

  if (!Receive_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-PCB-Revision",
      "");
  }

  if (!ICB_PCB_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-PCB-Revision",
      "");
  }

  if (!Transmit_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Transmit-PCB-ID",
      "");
  }

  if (!Monitor_Temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-Temperature",
      "");
  }

  if (!Receive_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Receive-FPGA-Revision",
      "");
  }

  if (!Monitor_15V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Monitor-15V",
      "");
  }

  if (!ICB_FPGA_Revision_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ICB-FPGA-Revision",
      "");
  }

  if (!GDI_Objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GDI-Objects",
      "");
  }

  if (!Mem_WorkingSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Mem-WorkingSet",
      "");
  }

  if (!Switch_PCB_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Switch-PCB-ID",
      "");
  }
}

Diag1* Diag1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Diag1 (*this, f, c);
}

Diag1::
~Diag1 ()
{
}

// ECG1
//

ECG1::
ECG1 (const Respiration_Threshold_Change_type& Respiration_Threshold_Change,
      const Respiration_Threshold_type& Respiration_Threshold,
      const Pressure_Range_type& Pressure_Range,
      const Respiration_Gate_Delay_type& Respiration_Gate_Delay,
      const Respiration_Timeout_type& Respiration_Timeout,
      const RWave_Max_Change_Factor_Percent_type& RWave_Max_Change_Factor_Percent,
      const Respiration_Period_type& Respiration_Period,
      const Respiration_Subsample_Rate_type& Respiration_Subsample_Rate,
      const Show_RWaves_type& Show_RWaves,
      const Respiration_Minimal_Peak_2_Peak_type& Respiration_Minimal_Peak_2_Peak,
      const Respiration_Window_type& Respiration_Window,
      const Pressure_Zeroed_type& Pressure_Zeroed,
      const Pressure_Systolic_type& Pressure_Systolic,
      const Respiration_Show_Window_type& Respiration_Show_Window,
      const Frequency_type& Frequency,
      const Respiration_Blank_Period_type& Respiration_Blank_Period,
      const Respiration_Range_type& Respiration_Range,
      const Pressure_Zero_type& Pressure_Zero,
      const Temperature_Amplification_type& Temperature_Amplification,
      const P_Wave_Start_type& P_Wave_Start,
      const ECG_Filter_Taps_type& ECG_Filter_Taps,
      const Respiration_Percent_Peak_type& Respiration_Percent_Peak,
      const T_Wave_Start_type& T_Wave_Start,
      const Strain_Rate_RR_Diff_Ratio_type& Strain_Rate_RR_Diff_Ratio,
      const Pressure_Calibration_Min_Level_type& Pressure_Calibration_Min_Level,
      const DPDT_Range_type& DPDT_Range,
      const Respiration_Show_Event_type& Respiration_Show_Event,
      const Pressure_Diastolic_type& Pressure_Diastolic,
      const Temperature_Calibration_type& Temperature_Calibration,
      const Temperature_type& Temperature,
      const Respiration_Beats_To_Average_type& Respiration_Beats_To_Average,
      const RWave_Thresh_Trigger_Percent_type& RWave_Thresh_Trigger_Percent,
      const Respiration_Time_To_Average_type& Respiration_Time_To_Average,
      const Pressure_Amplification_type& Pressure_Amplification,
      const Heart_Period_type& Heart_Period,
      const Pressure_Show_Event_type& Pressure_Show_Event,
      const RWave_Default_Threshold_type& RWave_Default_Threshold,
      const Show_Filtered_Data_type& Show_Filtered_Data,
      const ECG_Range_type& ECG_Range,
      const RWave_Maxima_Block_Time_type& RWave_Maxima_Block_Time,
      const RWave_Noise_Threshold_type& RWave_Noise_Threshold,
      const Pressure_Calibration_Level_type& Pressure_Calibration_Level,
      const ECG_HP_Filter_type& ECG_HP_Filter,
      const ECG_LP_Filter_type& ECG_LP_Filter,
      const RWave_Max_Change_Period_type& RWave_Max_Change_Period,
      const Pressure_Time_Out_type& Pressure_Time_Out,
      const Pressure_Calibration_type& Pressure_Calibration,
      const RWave_Blank_Time_type& RWave_Blank_Time,
      const RWave_Future_Search_Time_type& RWave_Future_Search_Time,
      const Pressure_Calibrated_type& Pressure_Calibrated)
: ::xml_schema::type (),
  Respiration_Threshold_Change_ (Respiration_Threshold_Change, ::xml_schema::flags (), this),
  Respiration_Threshold_ (Respiration_Threshold, ::xml_schema::flags (), this),
  Pressure_Range_ (Pressure_Range, ::xml_schema::flags (), this),
  Respiration_Gate_Delay_ (Respiration_Gate_Delay, ::xml_schema::flags (), this),
  Respiration_Timeout_ (Respiration_Timeout, ::xml_schema::flags (), this),
  RWave_Max_Change_Factor_Percent_ (RWave_Max_Change_Factor_Percent, ::xml_schema::flags (), this),
  Respiration_Period_ (Respiration_Period, ::xml_schema::flags (), this),
  Respiration_Subsample_Rate_ (Respiration_Subsample_Rate, ::xml_schema::flags (), this),
  Show_RWaves_ (Show_RWaves, ::xml_schema::flags (), this),
  Respiration_Minimal_Peak_2_Peak_ (Respiration_Minimal_Peak_2_Peak, ::xml_schema::flags (), this),
  Respiration_Window_ (Respiration_Window, ::xml_schema::flags (), this),
  Pressure_Zeroed_ (Pressure_Zeroed, ::xml_schema::flags (), this),
  Pressure_Systolic_ (Pressure_Systolic, ::xml_schema::flags (), this),
  Respiration_Show_Window_ (Respiration_Show_Window, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Respiration_Blank_Period_ (Respiration_Blank_Period, ::xml_schema::flags (), this),
  Respiration_Range_ (Respiration_Range, ::xml_schema::flags (), this),
  Pressure_Zero_ (Pressure_Zero, ::xml_schema::flags (), this),
  Temperature_Amplification_ (Temperature_Amplification, ::xml_schema::flags (), this),
  P_Wave_Start_ (P_Wave_Start, ::xml_schema::flags (), this),
  ECG_Filter_Taps_ (ECG_Filter_Taps, ::xml_schema::flags (), this),
  Respiration_Percent_Peak_ (Respiration_Percent_Peak, ::xml_schema::flags (), this),
  T_Wave_Start_ (T_Wave_Start, ::xml_schema::flags (), this),
  Strain_Rate_RR_Diff_Ratio_ (Strain_Rate_RR_Diff_Ratio, ::xml_schema::flags (), this),
  Pressure_Calibration_Min_Level_ (Pressure_Calibration_Min_Level, ::xml_schema::flags (), this),
  DPDT_Range_ (DPDT_Range, ::xml_schema::flags (), this),
  Respiration_Show_Event_ (Respiration_Show_Event, ::xml_schema::flags (), this),
  Pressure_Diastolic_ (Pressure_Diastolic, ::xml_schema::flags (), this),
  Temperature_Calibration_ (Temperature_Calibration, ::xml_schema::flags (), this),
  Temperature_ (Temperature, ::xml_schema::flags (), this),
  Respiration_Beats_To_Average_ (Respiration_Beats_To_Average, ::xml_schema::flags (), this),
  RWave_Thresh_Trigger_Percent_ (RWave_Thresh_Trigger_Percent, ::xml_schema::flags (), this),
  Respiration_Time_To_Average_ (Respiration_Time_To_Average, ::xml_schema::flags (), this),
  Pressure_Amplification_ (Pressure_Amplification, ::xml_schema::flags (), this),
  Heart_Period_ (Heart_Period, ::xml_schema::flags (), this),
  Pressure_Show_Event_ (Pressure_Show_Event, ::xml_schema::flags (), this),
  RWave_Default_Threshold_ (RWave_Default_Threshold, ::xml_schema::flags (), this),
  Show_Filtered_Data_ (Show_Filtered_Data, ::xml_schema::flags (), this),
  ECG_Range_ (ECG_Range, ::xml_schema::flags (), this),
  RWave_Maxima_Block_Time_ (RWave_Maxima_Block_Time, ::xml_schema::flags (), this),
  RWave_Noise_Threshold_ (RWave_Noise_Threshold, ::xml_schema::flags (), this),
  Pressure_Calibration_Level_ (Pressure_Calibration_Level, ::xml_schema::flags (), this),
  ECG_HP_Filter_ (ECG_HP_Filter, ::xml_schema::flags (), this),
  ECG_LP_Filter_ (ECG_LP_Filter, ::xml_schema::flags (), this),
  RWave_Max_Change_Period_ (RWave_Max_Change_Period, ::xml_schema::flags (), this),
  Pressure_Time_Out_ (Pressure_Time_Out, ::xml_schema::flags (), this),
  Pressure_Calibration_ (Pressure_Calibration, ::xml_schema::flags (), this),
  RWave_Blank_Time_ (RWave_Blank_Time, ::xml_schema::flags (), this),
  RWave_Future_Search_Time_ (RWave_Future_Search_Time, ::xml_schema::flags (), this),
  Pressure_Calibrated_ (Pressure_Calibrated, ::xml_schema::flags (), this)
{
}

ECG1::
ECG1 (::std::auto_ptr< Respiration_Threshold_Change_type >& Respiration_Threshold_Change,
      const Respiration_Threshold_type& Respiration_Threshold,
      ::std::auto_ptr< Pressure_Range_type >& Pressure_Range,
      ::std::auto_ptr< Respiration_Gate_Delay_type >& Respiration_Gate_Delay,
      ::std::auto_ptr< Respiration_Timeout_type >& Respiration_Timeout,
      ::std::auto_ptr< RWave_Max_Change_Factor_Percent_type >& RWave_Max_Change_Factor_Percent,
      ::std::auto_ptr< Respiration_Period_type >& Respiration_Period,
      ::std::auto_ptr< Respiration_Subsample_Rate_type >& Respiration_Subsample_Rate,
      const Show_RWaves_type& Show_RWaves,
      const Respiration_Minimal_Peak_2_Peak_type& Respiration_Minimal_Peak_2_Peak,
      ::std::auto_ptr< Respiration_Window_type >& Respiration_Window,
      const Pressure_Zeroed_type& Pressure_Zeroed,
      ::std::auto_ptr< Pressure_Systolic_type >& Pressure_Systolic,
      const Respiration_Show_Window_type& Respiration_Show_Window,
      ::std::auto_ptr< Frequency_type >& Frequency,
      ::std::auto_ptr< Respiration_Blank_Period_type >& Respiration_Blank_Period,
      ::std::auto_ptr< Respiration_Range_type >& Respiration_Range,
      ::std::auto_ptr< Pressure_Zero_type >& Pressure_Zero,
      const Temperature_Amplification_type& Temperature_Amplification,
      ::std::auto_ptr< P_Wave_Start_type >& P_Wave_Start,
      const ECG_Filter_Taps_type& ECG_Filter_Taps,
      ::std::auto_ptr< Respiration_Percent_Peak_type >& Respiration_Percent_Peak,
      ::std::auto_ptr< T_Wave_Start_type >& T_Wave_Start,
      ::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type >& Strain_Rate_RR_Diff_Ratio,
      const Pressure_Calibration_Min_Level_type& Pressure_Calibration_Min_Level,
      const DPDT_Range_type& DPDT_Range,
      const Respiration_Show_Event_type& Respiration_Show_Event,
      ::std::auto_ptr< Pressure_Diastolic_type >& Pressure_Diastolic,
      ::std::auto_ptr< Temperature_Calibration_type >& Temperature_Calibration,
      ::std::auto_ptr< Temperature_type >& Temperature,
      ::std::auto_ptr< Respiration_Beats_To_Average_type >& Respiration_Beats_To_Average,
      ::std::auto_ptr< RWave_Thresh_Trigger_Percent_type >& RWave_Thresh_Trigger_Percent,
      ::std::auto_ptr< Respiration_Time_To_Average_type >& Respiration_Time_To_Average,
      const Pressure_Amplification_type& Pressure_Amplification,
      ::std::auto_ptr< Heart_Period_type >& Heart_Period,
      const Pressure_Show_Event_type& Pressure_Show_Event,
      const RWave_Default_Threshold_type& RWave_Default_Threshold,
      const Show_Filtered_Data_type& Show_Filtered_Data,
      ::std::auto_ptr< ECG_Range_type >& ECG_Range,
      ::std::auto_ptr< RWave_Maxima_Block_Time_type >& RWave_Maxima_Block_Time,
      const RWave_Noise_Threshold_type& RWave_Noise_Threshold,
      ::std::auto_ptr< Pressure_Calibration_Level_type >& Pressure_Calibration_Level,
      ::std::auto_ptr< ECG_HP_Filter_type >& ECG_HP_Filter,
      ::std::auto_ptr< ECG_LP_Filter_type >& ECG_LP_Filter,
      ::std::auto_ptr< RWave_Max_Change_Period_type >& RWave_Max_Change_Period,
      const Pressure_Time_Out_type& Pressure_Time_Out,
      ::std::auto_ptr< Pressure_Calibration_type >& Pressure_Calibration,
      ::std::auto_ptr< RWave_Blank_Time_type >& RWave_Blank_Time,
      ::std::auto_ptr< RWave_Future_Search_Time_type >& RWave_Future_Search_Time,
      const Pressure_Calibrated_type& Pressure_Calibrated)
: ::xml_schema::type (),
  Respiration_Threshold_Change_ (Respiration_Threshold_Change, ::xml_schema::flags (), this),
  Respiration_Threshold_ (Respiration_Threshold, ::xml_schema::flags (), this),
  Pressure_Range_ (Pressure_Range, ::xml_schema::flags (), this),
  Respiration_Gate_Delay_ (Respiration_Gate_Delay, ::xml_schema::flags (), this),
  Respiration_Timeout_ (Respiration_Timeout, ::xml_schema::flags (), this),
  RWave_Max_Change_Factor_Percent_ (RWave_Max_Change_Factor_Percent, ::xml_schema::flags (), this),
  Respiration_Period_ (Respiration_Period, ::xml_schema::flags (), this),
  Respiration_Subsample_Rate_ (Respiration_Subsample_Rate, ::xml_schema::flags (), this),
  Show_RWaves_ (Show_RWaves, ::xml_schema::flags (), this),
  Respiration_Minimal_Peak_2_Peak_ (Respiration_Minimal_Peak_2_Peak, ::xml_schema::flags (), this),
  Respiration_Window_ (Respiration_Window, ::xml_schema::flags (), this),
  Pressure_Zeroed_ (Pressure_Zeroed, ::xml_schema::flags (), this),
  Pressure_Systolic_ (Pressure_Systolic, ::xml_schema::flags (), this),
  Respiration_Show_Window_ (Respiration_Show_Window, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  Respiration_Blank_Period_ (Respiration_Blank_Period, ::xml_schema::flags (), this),
  Respiration_Range_ (Respiration_Range, ::xml_schema::flags (), this),
  Pressure_Zero_ (Pressure_Zero, ::xml_schema::flags (), this),
  Temperature_Amplification_ (Temperature_Amplification, ::xml_schema::flags (), this),
  P_Wave_Start_ (P_Wave_Start, ::xml_schema::flags (), this),
  ECG_Filter_Taps_ (ECG_Filter_Taps, ::xml_schema::flags (), this),
  Respiration_Percent_Peak_ (Respiration_Percent_Peak, ::xml_schema::flags (), this),
  T_Wave_Start_ (T_Wave_Start, ::xml_schema::flags (), this),
  Strain_Rate_RR_Diff_Ratio_ (Strain_Rate_RR_Diff_Ratio, ::xml_schema::flags (), this),
  Pressure_Calibration_Min_Level_ (Pressure_Calibration_Min_Level, ::xml_schema::flags (), this),
  DPDT_Range_ (DPDT_Range, ::xml_schema::flags (), this),
  Respiration_Show_Event_ (Respiration_Show_Event, ::xml_schema::flags (), this),
  Pressure_Diastolic_ (Pressure_Diastolic, ::xml_schema::flags (), this),
  Temperature_Calibration_ (Temperature_Calibration, ::xml_schema::flags (), this),
  Temperature_ (Temperature, ::xml_schema::flags (), this),
  Respiration_Beats_To_Average_ (Respiration_Beats_To_Average, ::xml_schema::flags (), this),
  RWave_Thresh_Trigger_Percent_ (RWave_Thresh_Trigger_Percent, ::xml_schema::flags (), this),
  Respiration_Time_To_Average_ (Respiration_Time_To_Average, ::xml_schema::flags (), this),
  Pressure_Amplification_ (Pressure_Amplification, ::xml_schema::flags (), this),
  Heart_Period_ (Heart_Period, ::xml_schema::flags (), this),
  Pressure_Show_Event_ (Pressure_Show_Event, ::xml_schema::flags (), this),
  RWave_Default_Threshold_ (RWave_Default_Threshold, ::xml_schema::flags (), this),
  Show_Filtered_Data_ (Show_Filtered_Data, ::xml_schema::flags (), this),
  ECG_Range_ (ECG_Range, ::xml_schema::flags (), this),
  RWave_Maxima_Block_Time_ (RWave_Maxima_Block_Time, ::xml_schema::flags (), this),
  RWave_Noise_Threshold_ (RWave_Noise_Threshold, ::xml_schema::flags (), this),
  Pressure_Calibration_Level_ (Pressure_Calibration_Level, ::xml_schema::flags (), this),
  ECG_HP_Filter_ (ECG_HP_Filter, ::xml_schema::flags (), this),
  ECG_LP_Filter_ (ECG_LP_Filter, ::xml_schema::flags (), this),
  RWave_Max_Change_Period_ (RWave_Max_Change_Period, ::xml_schema::flags (), this),
  Pressure_Time_Out_ (Pressure_Time_Out, ::xml_schema::flags (), this),
  Pressure_Calibration_ (Pressure_Calibration, ::xml_schema::flags (), this),
  RWave_Blank_Time_ (RWave_Blank_Time, ::xml_schema::flags (), this),
  RWave_Future_Search_Time_ (RWave_Future_Search_Time, ::xml_schema::flags (), this),
  Pressure_Calibrated_ (Pressure_Calibrated, ::xml_schema::flags (), this)
{
}

ECG1::
ECG1 (const ECG1& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Respiration_Threshold_Change_ (x.Respiration_Threshold_Change_, f, this),
  Respiration_Threshold_ (x.Respiration_Threshold_, f, this),
  Pressure_Range_ (x.Pressure_Range_, f, this),
  Respiration_Gate_Delay_ (x.Respiration_Gate_Delay_, f, this),
  Respiration_Timeout_ (x.Respiration_Timeout_, f, this),
  RWave_Max_Change_Factor_Percent_ (x.RWave_Max_Change_Factor_Percent_, f, this),
  Respiration_Period_ (x.Respiration_Period_, f, this),
  Respiration_Subsample_Rate_ (x.Respiration_Subsample_Rate_, f, this),
  Show_RWaves_ (x.Show_RWaves_, f, this),
  Respiration_Minimal_Peak_2_Peak_ (x.Respiration_Minimal_Peak_2_Peak_, f, this),
  Respiration_Window_ (x.Respiration_Window_, f, this),
  Pressure_Zeroed_ (x.Pressure_Zeroed_, f, this),
  Pressure_Systolic_ (x.Pressure_Systolic_, f, this),
  Respiration_Show_Window_ (x.Respiration_Show_Window_, f, this),
  Frequency_ (x.Frequency_, f, this),
  Respiration_Blank_Period_ (x.Respiration_Blank_Period_, f, this),
  Respiration_Range_ (x.Respiration_Range_, f, this),
  Pressure_Zero_ (x.Pressure_Zero_, f, this),
  Temperature_Amplification_ (x.Temperature_Amplification_, f, this),
  P_Wave_Start_ (x.P_Wave_Start_, f, this),
  ECG_Filter_Taps_ (x.ECG_Filter_Taps_, f, this),
  Respiration_Percent_Peak_ (x.Respiration_Percent_Peak_, f, this),
  T_Wave_Start_ (x.T_Wave_Start_, f, this),
  Strain_Rate_RR_Diff_Ratio_ (x.Strain_Rate_RR_Diff_Ratio_, f, this),
  Pressure_Calibration_Min_Level_ (x.Pressure_Calibration_Min_Level_, f, this),
  DPDT_Range_ (x.DPDT_Range_, f, this),
  Respiration_Show_Event_ (x.Respiration_Show_Event_, f, this),
  Pressure_Diastolic_ (x.Pressure_Diastolic_, f, this),
  Temperature_Calibration_ (x.Temperature_Calibration_, f, this),
  Temperature_ (x.Temperature_, f, this),
  Respiration_Beats_To_Average_ (x.Respiration_Beats_To_Average_, f, this),
  RWave_Thresh_Trigger_Percent_ (x.RWave_Thresh_Trigger_Percent_, f, this),
  Respiration_Time_To_Average_ (x.Respiration_Time_To_Average_, f, this),
  Pressure_Amplification_ (x.Pressure_Amplification_, f, this),
  Heart_Period_ (x.Heart_Period_, f, this),
  Pressure_Show_Event_ (x.Pressure_Show_Event_, f, this),
  RWave_Default_Threshold_ (x.RWave_Default_Threshold_, f, this),
  Show_Filtered_Data_ (x.Show_Filtered_Data_, f, this),
  ECG_Range_ (x.ECG_Range_, f, this),
  RWave_Maxima_Block_Time_ (x.RWave_Maxima_Block_Time_, f, this),
  RWave_Noise_Threshold_ (x.RWave_Noise_Threshold_, f, this),
  Pressure_Calibration_Level_ (x.Pressure_Calibration_Level_, f, this),
  ECG_HP_Filter_ (x.ECG_HP_Filter_, f, this),
  ECG_LP_Filter_ (x.ECG_LP_Filter_, f, this),
  RWave_Max_Change_Period_ (x.RWave_Max_Change_Period_, f, this),
  Pressure_Time_Out_ (x.Pressure_Time_Out_, f, this),
  Pressure_Calibration_ (x.Pressure_Calibration_, f, this),
  RWave_Blank_Time_ (x.RWave_Blank_Time_, f, this),
  RWave_Future_Search_Time_ (x.RWave_Future_Search_Time_, f, this),
  Pressure_Calibrated_ (x.Pressure_Calibrated_, f, this)
{
}

ECG1::
ECG1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Respiration_Threshold_Change_ (f, this),
  Respiration_Threshold_ (f, this),
  Pressure_Range_ (f, this),
  Respiration_Gate_Delay_ (f, this),
  Respiration_Timeout_ (f, this),
  RWave_Max_Change_Factor_Percent_ (f, this),
  Respiration_Period_ (f, this),
  Respiration_Subsample_Rate_ (f, this),
  Show_RWaves_ (f, this),
  Respiration_Minimal_Peak_2_Peak_ (f, this),
  Respiration_Window_ (f, this),
  Pressure_Zeroed_ (f, this),
  Pressure_Systolic_ (f, this),
  Respiration_Show_Window_ (f, this),
  Frequency_ (f, this),
  Respiration_Blank_Period_ (f, this),
  Respiration_Range_ (f, this),
  Pressure_Zero_ (f, this),
  Temperature_Amplification_ (f, this),
  P_Wave_Start_ (f, this),
  ECG_Filter_Taps_ (f, this),
  Respiration_Percent_Peak_ (f, this),
  T_Wave_Start_ (f, this),
  Strain_Rate_RR_Diff_Ratio_ (f, this),
  Pressure_Calibration_Min_Level_ (f, this),
  DPDT_Range_ (f, this),
  Respiration_Show_Event_ (f, this),
  Pressure_Diastolic_ (f, this),
  Temperature_Calibration_ (f, this),
  Temperature_ (f, this),
  Respiration_Beats_To_Average_ (f, this),
  RWave_Thresh_Trigger_Percent_ (f, this),
  Respiration_Time_To_Average_ (f, this),
  Pressure_Amplification_ (f, this),
  Heart_Period_ (f, this),
  Pressure_Show_Event_ (f, this),
  RWave_Default_Threshold_ (f, this),
  Show_Filtered_Data_ (f, this),
  ECG_Range_ (f, this),
  RWave_Maxima_Block_Time_ (f, this),
  RWave_Noise_Threshold_ (f, this),
  Pressure_Calibration_Level_ (f, this),
  ECG_HP_Filter_ (f, this),
  ECG_LP_Filter_ (f, this),
  RWave_Max_Change_Period_ (f, this),
  Pressure_Time_Out_ (f, this),
  Pressure_Calibration_ (f, this),
  RWave_Blank_Time_ (f, this),
  RWave_Future_Search_Time_ (f, this),
  Pressure_Calibrated_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ECG1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Respiration-Threshold-Change
    //
    if (n.name () == "Respiration-Threshold-Change" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Threshold_Change_type > r (
        Respiration_Threshold_Change_traits::create (i, f, this));

      if (!Respiration_Threshold_Change_.present ())
      {
        this->Respiration_Threshold_Change_.set (r);
        continue;
      }
    }

    // Respiration-Threshold
    //
    if (n.name () == "Respiration-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Threshold_type > r (
        Respiration_Threshold_traits::create (i, f, this));

      if (!Respiration_Threshold_.present ())
      {
        this->Respiration_Threshold_.set (r);
        continue;
      }
    }

    // Pressure-Range
    //
    if (n.name () == "Pressure-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Range_type > r (
        Pressure_Range_traits::create (i, f, this));

      if (!Pressure_Range_.present ())
      {
        this->Pressure_Range_.set (r);
        continue;
      }
    }

    // Respiration-Gate-Delay
    //
    if (n.name () == "Respiration-Gate-Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Gate_Delay_type > r (
        Respiration_Gate_Delay_traits::create (i, f, this));

      if (!Respiration_Gate_Delay_.present ())
      {
        this->Respiration_Gate_Delay_.set (r);
        continue;
      }
    }

    // Respiration-Timeout
    //
    if (n.name () == "Respiration-Timeout" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Timeout_type > r (
        Respiration_Timeout_traits::create (i, f, this));

      if (!Respiration_Timeout_.present ())
      {
        this->Respiration_Timeout_.set (r);
        continue;
      }
    }

    // RWave-Max-Change-Factor-Percent
    //
    if (n.name () == "RWave-Max-Change-Factor-Percent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Max_Change_Factor_Percent_type > r (
        RWave_Max_Change_Factor_Percent_traits::create (i, f, this));

      if (!RWave_Max_Change_Factor_Percent_.present ())
      {
        this->RWave_Max_Change_Factor_Percent_.set (r);
        continue;
      }
    }

    // Respiration-Period
    //
    if (n.name () == "Respiration-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Period_type > r (
        Respiration_Period_traits::create (i, f, this));

      if (!Respiration_Period_.present ())
      {
        this->Respiration_Period_.set (r);
        continue;
      }
    }

    // Respiration-Subsample-Rate
    //
    if (n.name () == "Respiration-Subsample-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Subsample_Rate_type > r (
        Respiration_Subsample_Rate_traits::create (i, f, this));

      if (!Respiration_Subsample_Rate_.present ())
      {
        this->Respiration_Subsample_Rate_.set (r);
        continue;
      }
    }

    // Show-RWaves
    //
    if (n.name () == "Show-RWaves" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Show_RWaves_type > r (
        Show_RWaves_traits::create (i, f, this));

      if (!Show_RWaves_.present ())
      {
        this->Show_RWaves_.set (r);
        continue;
      }
    }

    // Respiration-Minimal-Peak-2-Peak
    //
    if (n.name () == "Respiration-Minimal-Peak-2-Peak" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Minimal_Peak_2_Peak_type > r (
        Respiration_Minimal_Peak_2_Peak_traits::create (i, f, this));

      if (!Respiration_Minimal_Peak_2_Peak_.present ())
      {
        this->Respiration_Minimal_Peak_2_Peak_.set (r);
        continue;
      }
    }

    // Respiration-Window
    //
    if (n.name () == "Respiration-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Window_type > r (
        Respiration_Window_traits::create (i, f, this));

      if (!Respiration_Window_.present ())
      {
        this->Respiration_Window_.set (r);
        continue;
      }
    }

    // Pressure-Zeroed
    //
    if (n.name () == "Pressure-Zeroed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Zeroed_type > r (
        Pressure_Zeroed_traits::create (i, f, this));

      if (!Pressure_Zeroed_.present ())
      {
        this->Pressure_Zeroed_.set (r);
        continue;
      }
    }

    // Pressure-Systolic
    //
    if (n.name () == "Pressure-Systolic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Systolic_type > r (
        Pressure_Systolic_traits::create (i, f, this));

      if (!Pressure_Systolic_.present ())
      {
        this->Pressure_Systolic_.set (r);
        continue;
      }
    }

    // Respiration-Show-Window
    //
    if (n.name () == "Respiration-Show-Window" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Show_Window_type > r (
        Respiration_Show_Window_traits::create (i, f, this));

      if (!Respiration_Show_Window_.present ())
      {
        this->Respiration_Show_Window_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // Respiration-Blank-Period
    //
    if (n.name () == "Respiration-Blank-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Blank_Period_type > r (
        Respiration_Blank_Period_traits::create (i, f, this));

      if (!Respiration_Blank_Period_.present ())
      {
        this->Respiration_Blank_Period_.set (r);
        continue;
      }
    }

    // Respiration-Range
    //
    if (n.name () == "Respiration-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Range_type > r (
        Respiration_Range_traits::create (i, f, this));

      if (!Respiration_Range_.present ())
      {
        this->Respiration_Range_.set (r);
        continue;
      }
    }

    // Pressure-Zero
    //
    if (n.name () == "Pressure-Zero" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Zero_type > r (
        Pressure_Zero_traits::create (i, f, this));

      if (!Pressure_Zero_.present ())
      {
        this->Pressure_Zero_.set (r);
        continue;
      }
    }

    // Temperature-Amplification
    //
    if (n.name () == "Temperature-Amplification" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Amplification_type > r (
        Temperature_Amplification_traits::create (i, f, this));

      if (!Temperature_Amplification_.present ())
      {
        this->Temperature_Amplification_.set (r);
        continue;
      }
    }

    // P-Wave-Start
    //
    if (n.name () == "P-Wave-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< P_Wave_Start_type > r (
        P_Wave_Start_traits::create (i, f, this));

      if (!P_Wave_Start_.present ())
      {
        this->P_Wave_Start_.set (r);
        continue;
      }
    }

    // ECG-Filter-Taps
    //
    if (n.name () == "ECG-Filter-Taps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Filter_Taps_type > r (
        ECG_Filter_Taps_traits::create (i, f, this));

      if (!ECG_Filter_Taps_.present ())
      {
        this->ECG_Filter_Taps_.set (r);
        continue;
      }
    }

    // Respiration-Percent-Peak
    //
    if (n.name () == "Respiration-Percent-Peak" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Percent_Peak_type > r (
        Respiration_Percent_Peak_traits::create (i, f, this));

      if (!Respiration_Percent_Peak_.present ())
      {
        this->Respiration_Percent_Peak_.set (r);
        continue;
      }
    }

    // T-Wave-Start
    //
    if (n.name () == "T-Wave-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< T_Wave_Start_type > r (
        T_Wave_Start_traits::create (i, f, this));

      if (!T_Wave_Start_.present ())
      {
        this->T_Wave_Start_.set (r);
        continue;
      }
    }

    // Strain-Rate-RR-Diff-Ratio
    //
    if (n.name () == "Strain-Rate-RR-Diff-Ratio" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Strain_Rate_RR_Diff_Ratio_type > r (
        Strain_Rate_RR_Diff_Ratio_traits::create (i, f, this));

      if (!Strain_Rate_RR_Diff_Ratio_.present ())
      {
        this->Strain_Rate_RR_Diff_Ratio_.set (r);
        continue;
      }
    }

    // Pressure-Calibration-Min-Level
    //
    if (n.name () == "Pressure-Calibration-Min-Level" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_Min_Level_type > r (
        Pressure_Calibration_Min_Level_traits::create (i, f, this));

      if (!Pressure_Calibration_Min_Level_.present ())
      {
        this->Pressure_Calibration_Min_Level_.set (r);
        continue;
      }
    }

    // DPDT-Range
    //
    if (n.name () == "DPDT-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DPDT_Range_type > r (
        DPDT_Range_traits::create (i, f, this));

      if (!DPDT_Range_.present ())
      {
        this->DPDT_Range_.set (r);
        continue;
      }
    }

    // Respiration-Show-Event
    //
    if (n.name () == "Respiration-Show-Event" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Show_Event_type > r (
        Respiration_Show_Event_traits::create (i, f, this));

      if (!Respiration_Show_Event_.present ())
      {
        this->Respiration_Show_Event_.set (r);
        continue;
      }
    }

    // Pressure-Diastolic
    //
    if (n.name () == "Pressure-Diastolic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Diastolic_type > r (
        Pressure_Diastolic_traits::create (i, f, this));

      if (!Pressure_Diastolic_.present ())
      {
        this->Pressure_Diastolic_.set (r);
        continue;
      }
    }

    // Temperature-Calibration
    //
    if (n.name () == "Temperature-Calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_Calibration_type > r (
        Temperature_Calibration_traits::create (i, f, this));

      if (!Temperature_Calibration_.present ())
      {
        this->Temperature_Calibration_.set (r);
        continue;
      }
    }

    // Temperature
    //
    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Temperature_type > r (
        Temperature_traits::create (i, f, this));

      if (!Temperature_.present ())
      {
        this->Temperature_.set (r);
        continue;
      }
    }

    // Respiration-Beats-To-Average
    //
    if (n.name () == "Respiration-Beats-To-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Beats_To_Average_type > r (
        Respiration_Beats_To_Average_traits::create (i, f, this));

      if (!Respiration_Beats_To_Average_.present ())
      {
        this->Respiration_Beats_To_Average_.set (r);
        continue;
      }
    }

    // RWave-Thresh-Trigger-Percent
    //
    if (n.name () == "RWave-Thresh-Trigger-Percent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Thresh_Trigger_Percent_type > r (
        RWave_Thresh_Trigger_Percent_traits::create (i, f, this));

      if (!RWave_Thresh_Trigger_Percent_.present ())
      {
        this->RWave_Thresh_Trigger_Percent_.set (r);
        continue;
      }
    }

    // Respiration-Time-To-Average
    //
    if (n.name () == "Respiration-Time-To-Average" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Respiration_Time_To_Average_type > r (
        Respiration_Time_To_Average_traits::create (i, f, this));

      if (!Respiration_Time_To_Average_.present ())
      {
        this->Respiration_Time_To_Average_.set (r);
        continue;
      }
    }

    // Pressure-Amplification
    //
    if (n.name () == "Pressure-Amplification" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Amplification_type > r (
        Pressure_Amplification_traits::create (i, f, this));

      if (!Pressure_Amplification_.present ())
      {
        this->Pressure_Amplification_.set (r);
        continue;
      }
    }

    // Heart-Period
    //
    if (n.name () == "Heart-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Heart_Period_type > r (
        Heart_Period_traits::create (i, f, this));

      if (!Heart_Period_.present ())
      {
        this->Heart_Period_.set (r);
        continue;
      }
    }

    // Pressure-Show-Event
    //
    if (n.name () == "Pressure-Show-Event" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Show_Event_type > r (
        Pressure_Show_Event_traits::create (i, f, this));

      if (!Pressure_Show_Event_.present ())
      {
        this->Pressure_Show_Event_.set (r);
        continue;
      }
    }

    // RWave-Default-Threshold
    //
    if (n.name () == "RWave-Default-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Default_Threshold_type > r (
        RWave_Default_Threshold_traits::create (i, f, this));

      if (!RWave_Default_Threshold_.present ())
      {
        this->RWave_Default_Threshold_.set (r);
        continue;
      }
    }

    // Show-Filtered-Data
    //
    if (n.name () == "Show-Filtered-Data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Show_Filtered_Data_type > r (
        Show_Filtered_Data_traits::create (i, f, this));

      if (!Show_Filtered_Data_.present ())
      {
        this->Show_Filtered_Data_.set (r);
        continue;
      }
    }

    // ECG-Range
    //
    if (n.name () == "ECG-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_Range_type > r (
        ECG_Range_traits::create (i, f, this));

      if (!ECG_Range_.present ())
      {
        this->ECG_Range_.set (r);
        continue;
      }
    }

    // RWave-Maxima-Block-Time
    //
    if (n.name () == "RWave-Maxima-Block-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Maxima_Block_Time_type > r (
        RWave_Maxima_Block_Time_traits::create (i, f, this));

      if (!RWave_Maxima_Block_Time_.present ())
      {
        this->RWave_Maxima_Block_Time_.set (r);
        continue;
      }
    }

    // RWave-Noise-Threshold
    //
    if (n.name () == "RWave-Noise-Threshold" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Noise_Threshold_type > r (
        RWave_Noise_Threshold_traits::create (i, f, this));

      if (!RWave_Noise_Threshold_.present ())
      {
        this->RWave_Noise_Threshold_.set (r);
        continue;
      }
    }

    // Pressure-Calibration-Level
    //
    if (n.name () == "Pressure-Calibration-Level" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_Level_type > r (
        Pressure_Calibration_Level_traits::create (i, f, this));

      if (!Pressure_Calibration_Level_.present ())
      {
        this->Pressure_Calibration_Level_.set (r);
        continue;
      }
    }

    // ECG-HP-Filter
    //
    if (n.name () == "ECG-HP-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_HP_Filter_type > r (
        ECG_HP_Filter_traits::create (i, f, this));

      if (!ECG_HP_Filter_.present ())
      {
        this->ECG_HP_Filter_.set (r);
        continue;
      }
    }

    // ECG-LP-Filter
    //
    if (n.name () == "ECG-LP-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ECG_LP_Filter_type > r (
        ECG_LP_Filter_traits::create (i, f, this));

      if (!ECG_LP_Filter_.present ())
      {
        this->ECG_LP_Filter_.set (r);
        continue;
      }
    }

    // RWave-Max-Change-Period
    //
    if (n.name () == "RWave-Max-Change-Period" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Max_Change_Period_type > r (
        RWave_Max_Change_Period_traits::create (i, f, this));

      if (!RWave_Max_Change_Period_.present ())
      {
        this->RWave_Max_Change_Period_.set (r);
        continue;
      }
    }

    // Pressure-Time-Out
    //
    if (n.name () == "Pressure-Time-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Time_Out_type > r (
        Pressure_Time_Out_traits::create (i, f, this));

      if (!Pressure_Time_Out_.present ())
      {
        this->Pressure_Time_Out_.set (r);
        continue;
      }
    }

    // Pressure-Calibration
    //
    if (n.name () == "Pressure-Calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibration_type > r (
        Pressure_Calibration_traits::create (i, f, this));

      if (!Pressure_Calibration_.present ())
      {
        this->Pressure_Calibration_.set (r);
        continue;
      }
    }

    // RWave-Blank-Time
    //
    if (n.name () == "RWave-Blank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Blank_Time_type > r (
        RWave_Blank_Time_traits::create (i, f, this));

      if (!RWave_Blank_Time_.present ())
      {
        this->RWave_Blank_Time_.set (r);
        continue;
      }
    }

    // RWave-Future-Search-Time
    //
    if (n.name () == "RWave-Future-Search-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Future_Search_Time_type > r (
        RWave_Future_Search_Time_traits::create (i, f, this));

      if (!RWave_Future_Search_Time_.present ())
      {
        this->RWave_Future_Search_Time_.set (r);
        continue;
      }
    }

    // Pressure-Calibrated
    //
    if (n.name () == "Pressure-Calibrated" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pressure_Calibrated_type > r (
        Pressure_Calibrated_traits::create (i, f, this));

      if (!Pressure_Calibrated_.present ())
      {
        this->Pressure_Calibrated_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Respiration_Threshold_Change_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Threshold-Change",
      "");
  }

  if (!Respiration_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Threshold",
      "");
  }

  if (!Pressure_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Range",
      "");
  }

  if (!Respiration_Gate_Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Gate-Delay",
      "");
  }

  if (!Respiration_Timeout_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Timeout",
      "");
  }

  if (!RWave_Max_Change_Factor_Percent_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Max-Change-Factor-Percent",
      "");
  }

  if (!Respiration_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Period",
      "");
  }

  if (!Respiration_Subsample_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Subsample-Rate",
      "");
  }

  if (!Show_RWaves_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Show-RWaves",
      "");
  }

  if (!Respiration_Minimal_Peak_2_Peak_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Minimal-Peak-2-Peak",
      "");
  }

  if (!Respiration_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Window",
      "");
  }

  if (!Pressure_Zeroed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Zeroed",
      "");
  }

  if (!Pressure_Systolic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Systolic",
      "");
  }

  if (!Respiration_Show_Window_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Show-Window",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!Respiration_Blank_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Blank-Period",
      "");
  }

  if (!Respiration_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Range",
      "");
  }

  if (!Pressure_Zero_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Zero",
      "");
  }

  if (!Temperature_Amplification_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Amplification",
      "");
  }

  if (!P_Wave_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "P-Wave-Start",
      "");
  }

  if (!ECG_Filter_Taps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Filter-Taps",
      "");
  }

  if (!Respiration_Percent_Peak_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Percent-Peak",
      "");
  }

  if (!T_Wave_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "T-Wave-Start",
      "");
  }

  if (!Strain_Rate_RR_Diff_Ratio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Strain-Rate-RR-Diff-Ratio",
      "");
  }

  if (!Pressure_Calibration_Min_Level_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration-Min-Level",
      "");
  }

  if (!DPDT_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DPDT-Range",
      "");
  }

  if (!Respiration_Show_Event_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Show-Event",
      "");
  }

  if (!Pressure_Diastolic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Diastolic",
      "");
  }

  if (!Temperature_Calibration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature-Calibration",
      "");
  }

  if (!Temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Temperature",
      "");
  }

  if (!Respiration_Beats_To_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Beats-To-Average",
      "");
  }

  if (!RWave_Thresh_Trigger_Percent_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Thresh-Trigger-Percent",
      "");
  }

  if (!Respiration_Time_To_Average_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Respiration-Time-To-Average",
      "");
  }

  if (!Pressure_Amplification_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Amplification",
      "");
  }

  if (!Heart_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Heart-Period",
      "");
  }

  if (!Pressure_Show_Event_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Show-Event",
      "");
  }

  if (!RWave_Default_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Default-Threshold",
      "");
  }

  if (!Show_Filtered_Data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Show-Filtered-Data",
      "");
  }

  if (!ECG_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-Range",
      "");
  }

  if (!RWave_Maxima_Block_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Maxima-Block-Time",
      "");
  }

  if (!RWave_Noise_Threshold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Noise-Threshold",
      "");
  }

  if (!Pressure_Calibration_Level_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration-Level",
      "");
  }

  if (!ECG_HP_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-HP-Filter",
      "");
  }

  if (!ECG_LP_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ECG-LP-Filter",
      "");
  }

  if (!RWave_Max_Change_Period_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Max-Change-Period",
      "");
  }

  if (!Pressure_Time_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Time-Out",
      "");
  }

  if (!Pressure_Calibration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibration",
      "");
  }

  if (!RWave_Blank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Blank-Time",
      "");
  }

  if (!RWave_Future_Search_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Future-Search-Time",
      "");
  }

  if (!Pressure_Calibrated_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pressure-Calibrated",
      "");
  }
}

ECG1* ECG1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG1 (*this, f, c);
}

ECG1::
~ECG1 ()
{
}

// TX1
//

TX1::
TX1 (const V_Position_Table_type& V_Position_Table,
     const V_Transmit_Length_type& V_Transmit_Length,
     const Trigger_Counter_Clear_type& Trigger_Counter_Clear,
     const Trigger_Counter_type& Trigger_Counter,
     const RF_Amp_type& RF_Amp,
     const Trigger_Control_type& Trigger_Control,
     const V_Pulse_Rep_Freq_type& V_Pulse_Rep_Freq,
     const Phase_type& Phase,
     const Frequency_type& Frequency,
     const V_Unblank_Time_type& V_Unblank_Time,
     const V_Frequency_type& V_Frequency,
     const Pulse_Rep_Frequency_type& Pulse_Rep_Frequency,
     const Multi_Trigger_type& Multi_Trigger,
     const Trig_Tbl_Trigs_type& Trig_Tbl_Trigs,
     const Width_type& Width,
     const Unblank_Cycles_type& Unblank_Cycles,
     const V_Width_type& V_Width,
     const Unblank_Time_type& Unblank_Time,
     const Attenuation_type& Attenuation,
     const V_Power_type& V_Power,
     const Computer_Trigger_type& Computer_Trigger,
     const Multi_Trigger_Freq_type& Multi_Trigger_Freq)
: ::xml_schema::type (),
  V_Position_Table_ (V_Position_Table, ::xml_schema::flags (), this),
  V_Transmit_Length_ (V_Transmit_Length, ::xml_schema::flags (), this),
  Trigger_Counter_Clear_ (Trigger_Counter_Clear, ::xml_schema::flags (), this),
  Trigger_Counter_ (Trigger_Counter, ::xml_schema::flags (), this),
  RF_Amp_ (RF_Amp, ::xml_schema::flags (), this),
  Trigger_Control_ (Trigger_Control, ::xml_schema::flags (), this),
  V_Pulse_Rep_Freq_ (V_Pulse_Rep_Freq, ::xml_schema::flags (), this),
  Phase_ (Phase, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Unblank_Time_ (V_Unblank_Time, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  Pulse_Rep_Frequency_ (Pulse_Rep_Frequency, ::xml_schema::flags (), this),
  Multi_Trigger_ (Multi_Trigger, ::xml_schema::flags (), this),
  Trig_Tbl_Trigs_ (Trig_Tbl_Trigs, ::xml_schema::flags (), this),
  Width_ (Width, ::xml_schema::flags (), this),
  Unblank_Cycles_ (Unblank_Cycles, ::xml_schema::flags (), this),
  V_Width_ (V_Width, ::xml_schema::flags (), this),
  Unblank_Time_ (Unblank_Time, ::xml_schema::flags (), this),
  Attenuation_ (Attenuation, ::xml_schema::flags (), this),
  V_Power_ (V_Power, ::xml_schema::flags (), this),
  Computer_Trigger_ (Computer_Trigger, ::xml_schema::flags (), this),
  Multi_Trigger_Freq_ (Multi_Trigger_Freq, ::xml_schema::flags (), this)
{
}

TX1::
TX1 (const V_Position_Table_type& V_Position_Table,
     ::std::auto_ptr< V_Transmit_Length_type >& V_Transmit_Length,
     const Trigger_Counter_Clear_type& Trigger_Counter_Clear,
     const Trigger_Counter_type& Trigger_Counter,
     const RF_Amp_type& RF_Amp,
     const Trigger_Control_type& Trigger_Control,
     ::std::auto_ptr< V_Pulse_Rep_Freq_type >& V_Pulse_Rep_Freq,
     const Phase_type& Phase,
     ::std::auto_ptr< Frequency_type >& Frequency,
     ::std::auto_ptr< V_Unblank_Time_type >& V_Unblank_Time,
     ::std::auto_ptr< V_Frequency_type >& V_Frequency,
     ::std::auto_ptr< Pulse_Rep_Frequency_type >& Pulse_Rep_Frequency,
     const Multi_Trigger_type& Multi_Trigger,
     ::std::auto_ptr< Trig_Tbl_Trigs_type >& Trig_Tbl_Trigs,
     const Width_type& Width,
     ::std::auto_ptr< Unblank_Cycles_type >& Unblank_Cycles,
     const V_Width_type& V_Width,
     ::std::auto_ptr< Unblank_Time_type >& Unblank_Time,
     ::std::auto_ptr< Attenuation_type >& Attenuation,
     ::std::auto_ptr< V_Power_type >& V_Power,
     const Computer_Trigger_type& Computer_Trigger,
     const Multi_Trigger_Freq_type& Multi_Trigger_Freq)
: ::xml_schema::type (),
  V_Position_Table_ (V_Position_Table, ::xml_schema::flags (), this),
  V_Transmit_Length_ (V_Transmit_Length, ::xml_schema::flags (), this),
  Trigger_Counter_Clear_ (Trigger_Counter_Clear, ::xml_schema::flags (), this),
  Trigger_Counter_ (Trigger_Counter, ::xml_schema::flags (), this),
  RF_Amp_ (RF_Amp, ::xml_schema::flags (), this),
  Trigger_Control_ (Trigger_Control, ::xml_schema::flags (), this),
  V_Pulse_Rep_Freq_ (V_Pulse_Rep_Freq, ::xml_schema::flags (), this),
  Phase_ (Phase, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Unblank_Time_ (V_Unblank_Time, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  Pulse_Rep_Frequency_ (Pulse_Rep_Frequency, ::xml_schema::flags (), this),
  Multi_Trigger_ (Multi_Trigger, ::xml_schema::flags (), this),
  Trig_Tbl_Trigs_ (Trig_Tbl_Trigs, ::xml_schema::flags (), this),
  Width_ (Width, ::xml_schema::flags (), this),
  Unblank_Cycles_ (Unblank_Cycles, ::xml_schema::flags (), this),
  V_Width_ (V_Width, ::xml_schema::flags (), this),
  Unblank_Time_ (Unblank_Time, ::xml_schema::flags (), this),
  Attenuation_ (Attenuation, ::xml_schema::flags (), this),
  V_Power_ (V_Power, ::xml_schema::flags (), this),
  Computer_Trigger_ (Computer_Trigger, ::xml_schema::flags (), this),
  Multi_Trigger_Freq_ (Multi_Trigger_Freq, ::xml_schema::flags (), this)
{
}

TX1::
TX1 (const TX1& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  V_Position_Table_ (x.V_Position_Table_, f, this),
  V_Transmit_Length_ (x.V_Transmit_Length_, f, this),
  Trigger_Counter_Clear_ (x.Trigger_Counter_Clear_, f, this),
  Trigger_Counter_ (x.Trigger_Counter_, f, this),
  RF_Amp_ (x.RF_Amp_, f, this),
  Trigger_Control_ (x.Trigger_Control_, f, this),
  V_Pulse_Rep_Freq_ (x.V_Pulse_Rep_Freq_, f, this),
  Phase_ (x.Phase_, f, this),
  Frequency_ (x.Frequency_, f, this),
  V_Unblank_Time_ (x.V_Unblank_Time_, f, this),
  V_Frequency_ (x.V_Frequency_, f, this),
  Pulse_Rep_Frequency_ (x.Pulse_Rep_Frequency_, f, this),
  Multi_Trigger_ (x.Multi_Trigger_, f, this),
  Trig_Tbl_Trigs_ (x.Trig_Tbl_Trigs_, f, this),
  Width_ (x.Width_, f, this),
  Unblank_Cycles_ (x.Unblank_Cycles_, f, this),
  V_Width_ (x.V_Width_, f, this),
  Unblank_Time_ (x.Unblank_Time_, f, this),
  Attenuation_ (x.Attenuation_, f, this),
  V_Power_ (x.V_Power_, f, this),
  Computer_Trigger_ (x.Computer_Trigger_, f, this),
  Multi_Trigger_Freq_ (x.Multi_Trigger_Freq_, f, this)
{
}

TX1::
TX1 (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  V_Position_Table_ (f, this),
  V_Transmit_Length_ (f, this),
  Trigger_Counter_Clear_ (f, this),
  Trigger_Counter_ (f, this),
  RF_Amp_ (f, this),
  Trigger_Control_ (f, this),
  V_Pulse_Rep_Freq_ (f, this),
  Phase_ (f, this),
  Frequency_ (f, this),
  V_Unblank_Time_ (f, this),
  V_Frequency_ (f, this),
  Pulse_Rep_Frequency_ (f, this),
  Multi_Trigger_ (f, this),
  Trig_Tbl_Trigs_ (f, this),
  Width_ (f, this),
  Unblank_Cycles_ (f, this),
  V_Width_ (f, this),
  Unblank_Time_ (f, this),
  Attenuation_ (f, this),
  V_Power_ (f, this),
  Computer_Trigger_ (f, this),
  Multi_Trigger_Freq_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void TX1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // V-Position-Table
    //
    if (n.name () == "V-Position-Table" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Position_Table_type > r (
        V_Position_Table_traits::create (i, f, this));

      if (!V_Position_Table_.present ())
      {
        this->V_Position_Table_.set (r);
        continue;
      }
    }

    // V-Transmit-Length
    //
    if (n.name () == "V-Transmit-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Transmit_Length_type > r (
        V_Transmit_Length_traits::create (i, f, this));

      if (!V_Transmit_Length_.present ())
      {
        this->V_Transmit_Length_.set (r);
        continue;
      }
    }

    // Trigger-Counter-Clear
    //
    if (n.name () == "Trigger-Counter-Clear" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Counter_Clear_type > r (
        Trigger_Counter_Clear_traits::create (i, f, this));

      if (!Trigger_Counter_Clear_.present ())
      {
        this->Trigger_Counter_Clear_.set (r);
        continue;
      }
    }

    // Trigger-Counter
    //
    if (n.name () == "Trigger-Counter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Counter_type > r (
        Trigger_Counter_traits::create (i, f, this));

      if (!Trigger_Counter_.present ())
      {
        this->Trigger_Counter_.set (r);
        continue;
      }
    }

    // RF-Amp
    //
    if (n.name () == "RF-Amp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Amp_type > r (
        RF_Amp_traits::create (i, f, this));

      if (!RF_Amp_.present ())
      {
        this->RF_Amp_.set (r);
        continue;
      }
    }

    // Trigger-Control
    //
    if (n.name () == "Trigger-Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trigger_Control_type > r (
        Trigger_Control_traits::create (i, f, this));

      if (!Trigger_Control_.present ())
      {
        this->Trigger_Control_.set (r);
        continue;
      }
    }

    // V-Pulse-Rep-Freq
    //
    if (n.name () == "V-Pulse-Rep-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Pulse_Rep_Freq_type > r (
        V_Pulse_Rep_Freq_traits::create (i, f, this));

      if (!V_Pulse_Rep_Freq_.present ())
      {
        this->V_Pulse_Rep_Freq_.set (r);
        continue;
      }
    }

    // Phase
    //
    if (n.name () == "Phase" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Phase_type > r (
        Phase_traits::create (i, f, this));

      if (!Phase_.present ())
      {
        this->Phase_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // V-Unblank-Time
    //
    if (n.name () == "V-Unblank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Unblank_Time_type > r (
        V_Unblank_Time_traits::create (i, f, this));

      if (!V_Unblank_Time_.present ())
      {
        this->V_Unblank_Time_.set (r);
        continue;
      }
    }

    // V-Frequency
    //
    if (n.name () == "V-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Frequency_type > r (
        V_Frequency_traits::create (i, f, this));

      if (!V_Frequency_.present ())
      {
        this->V_Frequency_.set (r);
        continue;
      }
    }

    // Pulse-Rep-Frequency
    //
    if (n.name () == "Pulse-Rep-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pulse_Rep_Frequency_type > r (
        Pulse_Rep_Frequency_traits::create (i, f, this));

      if (!Pulse_Rep_Frequency_.present ())
      {
        this->Pulse_Rep_Frequency_.set (r);
        continue;
      }
    }

    // Multi-Trigger
    //
    if (n.name () == "Multi-Trigger" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Multi_Trigger_type > r (
        Multi_Trigger_traits::create (i, f, this));

      if (!Multi_Trigger_.present ())
      {
        this->Multi_Trigger_.set (r);
        continue;
      }
    }

    // Trig-Tbl-Trigs
    //
    if (n.name () == "Trig-Tbl-Trigs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Trig_Tbl_Trigs_type > r (
        Trig_Tbl_Trigs_traits::create (i, f, this));

      if (!Trig_Tbl_Trigs_.present ())
      {
        this->Trig_Tbl_Trigs_.set (r);
        continue;
      }
    }

    // Width
    //
    if (n.name () == "Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Width_type > r (
        Width_traits::create (i, f, this));

      if (!Width_.present ())
      {
        this->Width_.set (r);
        continue;
      }
    }

    // Unblank-Cycles
    //
    if (n.name () == "Unblank-Cycles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unblank_Cycles_type > r (
        Unblank_Cycles_traits::create (i, f, this));

      if (!Unblank_Cycles_.present ())
      {
        this->Unblank_Cycles_.set (r);
        continue;
      }
    }

    // V-Width
    //
    if (n.name () == "V-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Width_type > r (
        V_Width_traits::create (i, f, this));

      if (!V_Width_.present ())
      {
        this->V_Width_.set (r);
        continue;
      }
    }

    // Unblank-Time
    //
    if (n.name () == "Unblank-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unblank_Time_type > r (
        Unblank_Time_traits::create (i, f, this));

      if (!Unblank_Time_.present ())
      {
        this->Unblank_Time_.set (r);
        continue;
      }
    }

    // Attenuation
    //
    if (n.name () == "Attenuation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attenuation_type > r (
        Attenuation_traits::create (i, f, this));

      if (!Attenuation_.present ())
      {
        this->Attenuation_.set (r);
        continue;
      }
    }

    // V-Power
    //
    if (n.name () == "V-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Power_type > r (
        V_Power_traits::create (i, f, this));

      if (!V_Power_.present ())
      {
        this->V_Power_.set (r);
        continue;
      }
    }

    // Computer-Trigger
    //
    if (n.name () == "Computer-Trigger" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Computer_Trigger_type > r (
        Computer_Trigger_traits::create (i, f, this));

      if (!Computer_Trigger_.present ())
      {
        this->Computer_Trigger_.set (r);
        continue;
      }
    }

    // Multi-Trigger-Freq
    //
    if (n.name () == "Multi-Trigger-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Multi_Trigger_Freq_type > r (
        Multi_Trigger_Freq_traits::create (i, f, this));

      if (!Multi_Trigger_Freq_.present ())
      {
        this->Multi_Trigger_Freq_.set (r);
        continue;
      }
    }

    break;
  }

  if (!V_Position_Table_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Position-Table",
      "");
  }

  if (!V_Transmit_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Transmit-Length",
      "");
  }

  if (!Trigger_Counter_Clear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Counter-Clear",
      "");
  }

  if (!Trigger_Counter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Counter",
      "");
  }

  if (!RF_Amp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Amp",
      "");
  }

  if (!Trigger_Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trigger-Control",
      "");
  }

  if (!V_Pulse_Rep_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Pulse-Rep-Freq",
      "");
  }

  if (!Phase_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Phase",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!V_Unblank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Unblank-Time",
      "");
  }

  if (!V_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Frequency",
      "");
  }

  if (!Pulse_Rep_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pulse-Rep-Frequency",
      "");
  }

  if (!Multi_Trigger_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Multi-Trigger",
      "");
  }

  if (!Trig_Tbl_Trigs_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Trig-Tbl-Trigs",
      "");
  }

  if (!Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Width",
      "");
  }

  if (!Unblank_Cycles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Unblank-Cycles",
      "");
  }

  if (!V_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Width",
      "");
  }

  if (!Unblank_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Unblank-Time",
      "");
  }

  if (!Attenuation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Attenuation",
      "");
  }

  if (!V_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Power",
      "");
  }

  if (!Computer_Trigger_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Computer-Trigger",
      "");
  }

  if (!Multi_Trigger_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Multi-Trigger-Freq",
      "");
  }
}

TX1* TX1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TX1 (*this, f, c);
}

TX1::
~TX1 ()
{
}

// ContrastDestroy
//

ContrastDestroy::
ContrastDestroy (const Tx_Width_type& Tx_Width,
                 const Destroy_External_type& Destroy_External,
                 const Frames_type& Frames,
                 const Frame_Rate_type& Frame_Rate,
                 const Tx_PRF_type& Tx_PRF,
                 const Tx_Power_type& Tx_Power,
                 const Duration_type& Duration,
                 const Control_type& Control,
                 const Tx_Frequency_type& Tx_Frequency,
                 const Destroy_Sequence_Active_type& Destroy_Sequence_Active,
                 const Destroy_Sequence_Position_type& Destroy_Sequence_Position)
: ::xml_schema::type (),
  Tx_Width_ (Tx_Width, ::xml_schema::flags (), this),
  Destroy_External_ (Destroy_External, ::xml_schema::flags (), this),
  Frames_ (Frames, ::xml_schema::flags (), this),
  Frame_Rate_ (Frame_Rate, ::xml_schema::flags (), this),
  Tx_PRF_ (Tx_PRF, ::xml_schema::flags (), this),
  Tx_Power_ (Tx_Power, ::xml_schema::flags (), this),
  Duration_ (Duration, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Tx_Frequency_ (Tx_Frequency, ::xml_schema::flags (), this),
  Destroy_Sequence_Active_ (Destroy_Sequence_Active, ::xml_schema::flags (), this),
  Destroy_Sequence_Position_ (Destroy_Sequence_Position, ::xml_schema::flags (), this)
{
}

ContrastDestroy::
ContrastDestroy (const Tx_Width_type& Tx_Width,
                 const Destroy_External_type& Destroy_External,
                 ::std::auto_ptr< Frames_type >& Frames,
                 ::std::auto_ptr< Frame_Rate_type >& Frame_Rate,
                 ::std::auto_ptr< Tx_PRF_type >& Tx_PRF,
                 ::std::auto_ptr< Tx_Power_type >& Tx_Power,
                 ::std::auto_ptr< Duration_type >& Duration,
                 const Control_type& Control,
                 ::std::auto_ptr< Tx_Frequency_type >& Tx_Frequency,
                 const Destroy_Sequence_Active_type& Destroy_Sequence_Active,
                 ::std::auto_ptr< Destroy_Sequence_Position_type >& Destroy_Sequence_Position)
: ::xml_schema::type (),
  Tx_Width_ (Tx_Width, ::xml_schema::flags (), this),
  Destroy_External_ (Destroy_External, ::xml_schema::flags (), this),
  Frames_ (Frames, ::xml_schema::flags (), this),
  Frame_Rate_ (Frame_Rate, ::xml_schema::flags (), this),
  Tx_PRF_ (Tx_PRF, ::xml_schema::flags (), this),
  Tx_Power_ (Tx_Power, ::xml_schema::flags (), this),
  Duration_ (Duration, ::xml_schema::flags (), this),
  Control_ (Control, ::xml_schema::flags (), this),
  Tx_Frequency_ (Tx_Frequency, ::xml_schema::flags (), this),
  Destroy_Sequence_Active_ (Destroy_Sequence_Active, ::xml_schema::flags (), this),
  Destroy_Sequence_Position_ (Destroy_Sequence_Position, ::xml_schema::flags (), this)
{
}

ContrastDestroy::
ContrastDestroy (const ContrastDestroy& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Tx_Width_ (x.Tx_Width_, f, this),
  Destroy_External_ (x.Destroy_External_, f, this),
  Frames_ (x.Frames_, f, this),
  Frame_Rate_ (x.Frame_Rate_, f, this),
  Tx_PRF_ (x.Tx_PRF_, f, this),
  Tx_Power_ (x.Tx_Power_, f, this),
  Duration_ (x.Duration_, f, this),
  Control_ (x.Control_, f, this),
  Tx_Frequency_ (x.Tx_Frequency_, f, this),
  Destroy_Sequence_Active_ (x.Destroy_Sequence_Active_, f, this),
  Destroy_Sequence_Position_ (x.Destroy_Sequence_Position_, f, this)
{
}

ContrastDestroy::
ContrastDestroy (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Tx_Width_ (f, this),
  Destroy_External_ (f, this),
  Frames_ (f, this),
  Frame_Rate_ (f, this),
  Tx_PRF_ (f, this),
  Tx_Power_ (f, this),
  Duration_ (f, this),
  Control_ (f, this),
  Tx_Frequency_ (f, this),
  Destroy_Sequence_Active_ (f, this),
  Destroy_Sequence_Position_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ContrastDestroy::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Tx-Width
    //
    if (n.name () == "Tx-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Tx_Width_type > r (
        Tx_Width_traits::create (i, f, this));

      if (!Tx_Width_.present ())
      {
        this->Tx_Width_.set (r);
        continue;
      }
    }

    // Destroy-External
    //
    if (n.name () == "Destroy-External" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Destroy_External_type > r (
        Destroy_External_traits::create (i, f, this));

      if (!Destroy_External_.present ())
      {
        this->Destroy_External_.set (r);
        continue;
      }
    }

    // Frames
    //
    if (n.name () == "Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frames_type > r (
        Frames_traits::create (i, f, this));

      if (!Frames_.present ())
      {
        this->Frames_.set (r);
        continue;
      }
    }

    // Frame-Rate
    //
    if (n.name () == "Frame-Rate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frame_Rate_type > r (
        Frame_Rate_traits::create (i, f, this));

      if (!Frame_Rate_.present ())
      {
        this->Frame_Rate_.set (r);
        continue;
      }
    }

    // Tx-PRF
    //
    if (n.name () == "Tx-PRF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Tx_PRF_type > r (
        Tx_PRF_traits::create (i, f, this));

      if (!Tx_PRF_.present ())
      {
        this->Tx_PRF_.set (r);
        continue;
      }
    }

    // Tx-Power
    //
    if (n.name () == "Tx-Power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Tx_Power_type > r (
        Tx_Power_traits::create (i, f, this));

      if (!Tx_Power_.present ())
      {
        this->Tx_Power_.set (r);
        continue;
      }
    }

    // Duration
    //
    if (n.name () == "Duration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Duration_type > r (
        Duration_traits::create (i, f, this));

      if (!Duration_.present ())
      {
        this->Duration_.set (r);
        continue;
      }
    }

    // Control
    //
    if (n.name () == "Control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Control_type > r (
        Control_traits::create (i, f, this));

      if (!Control_.present ())
      {
        this->Control_.set (r);
        continue;
      }
    }

    // Tx-Frequency
    //
    if (n.name () == "Tx-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Tx_Frequency_type > r (
        Tx_Frequency_traits::create (i, f, this));

      if (!Tx_Frequency_.present ())
      {
        this->Tx_Frequency_.set (r);
        continue;
      }
    }

    // Destroy-Sequence-Active
    //
    if (n.name () == "Destroy-Sequence-Active" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Destroy_Sequence_Active_type > r (
        Destroy_Sequence_Active_traits::create (i, f, this));

      if (!Destroy_Sequence_Active_.present ())
      {
        this->Destroy_Sequence_Active_.set (r);
        continue;
      }
    }

    // Destroy-Sequence-Position
    //
    if (n.name () == "Destroy-Sequence-Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Destroy_Sequence_Position_type > r (
        Destroy_Sequence_Position_traits::create (i, f, this));

      if (!Destroy_Sequence_Position_.present ())
      {
        this->Destroy_Sequence_Position_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Tx_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tx-Width",
      "");
  }

  if (!Destroy_External_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Destroy-External",
      "");
  }

  if (!Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frames",
      "");
  }

  if (!Frame_Rate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frame-Rate",
      "");
  }

  if (!Tx_PRF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tx-PRF",
      "");
  }

  if (!Tx_Power_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tx-Power",
      "");
  }

  if (!Duration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Duration",
      "");
  }

  if (!Control_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Control",
      "");
  }

  if (!Tx_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tx-Frequency",
      "");
  }

  if (!Destroy_Sequence_Active_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Destroy-Sequence-Active",
      "");
  }

  if (!Destroy_Sequence_Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Destroy-Sequence-Position",
      "");
  }
}

ContrastDestroy* ContrastDestroy::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ContrastDestroy (*this, f, c);
}

ContrastDestroy::
~ContrastDestroy ()
{
}

// X_3D1
//

X_3D1::
X_3D1 (const Speed_type& Speed,
       const Status_type& Status,
       const Motor_Enable_type& Motor_Enable,
       const Scan_Distance_type& Scan_Distance,
       const Error_type& Error,
       const Steps_type& Steps,
       const Action_type& Action,
       const Clear_Error_type& Clear_Error,
       const Direction_type& Direction,
       const Step_Size_type& Step_Size,
       const Max_Scan_Steps_type& Max_Scan_Steps,
       const Position_type& Position)
: ::xml_schema::type (),
  Speed_ (Speed, ::xml_schema::flags (), this),
  Status_ (Status, ::xml_schema::flags (), this),
  Motor_Enable_ (Motor_Enable, ::xml_schema::flags (), this),
  Scan_Distance_ (Scan_Distance, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Action_ (Action, ::xml_schema::flags (), this),
  Clear_Error_ (Clear_Error, ::xml_schema::flags (), this),
  Direction_ (Direction, ::xml_schema::flags (), this),
  Step_Size_ (Step_Size, ::xml_schema::flags (), this),
  Max_Scan_Steps_ (Max_Scan_Steps, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this)
{
}

X_3D1::
X_3D1 (const Speed_type& Speed,
       const Status_type& Status,
       const Motor_Enable_type& Motor_Enable,
       ::std::auto_ptr< Scan_Distance_type >& Scan_Distance,
       const Error_type& Error,
       const Steps_type& Steps,
       const Action_type& Action,
       const Clear_Error_type& Clear_Error,
       const Direction_type& Direction,
       ::std::auto_ptr< Step_Size_type >& Step_Size,
       const Max_Scan_Steps_type& Max_Scan_Steps,
       const Position_type& Position)
: ::xml_schema::type (),
  Speed_ (Speed, ::xml_schema::flags (), this),
  Status_ (Status, ::xml_schema::flags (), this),
  Motor_Enable_ (Motor_Enable, ::xml_schema::flags (), this),
  Scan_Distance_ (Scan_Distance, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Action_ (Action, ::xml_schema::flags (), this),
  Clear_Error_ (Clear_Error, ::xml_schema::flags (), this),
  Direction_ (Direction, ::xml_schema::flags (), this),
  Step_Size_ (Step_Size, ::xml_schema::flags (), this),
  Max_Scan_Steps_ (Max_Scan_Steps, ::xml_schema::flags (), this),
  Position_ (Position, ::xml_schema::flags (), this)
{
}

X_3D1::
X_3D1 (const X_3D1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Speed_ (x.Speed_, f, this),
  Status_ (x.Status_, f, this),
  Motor_Enable_ (x.Motor_Enable_, f, this),
  Scan_Distance_ (x.Scan_Distance_, f, this),
  Error_ (x.Error_, f, this),
  Steps_ (x.Steps_, f, this),
  Action_ (x.Action_, f, this),
  Clear_Error_ (x.Clear_Error_, f, this),
  Direction_ (x.Direction_, f, this),
  Step_Size_ (x.Step_Size_, f, this),
  Max_Scan_Steps_ (x.Max_Scan_Steps_, f, this),
  Position_ (x.Position_, f, this)
{
}

X_3D1::
X_3D1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Speed_ (f, this),
  Status_ (f, this),
  Motor_Enable_ (f, this),
  Scan_Distance_ (f, this),
  Error_ (f, this),
  Steps_ (f, this),
  Action_ (f, this),
  Clear_Error_ (f, this),
  Direction_ (f, this),
  Step_Size_ (f, this),
  Max_Scan_Steps_ (f, this),
  Position_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void X_3D1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Speed
    //
    if (n.name () == "Speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Speed_type > r (
        Speed_traits::create (i, f, this));

      if (!Speed_.present ())
      {
        this->Speed_.set (r);
        continue;
      }
    }

    // Status
    //
    if (n.name () == "Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Status_type > r (
        Status_traits::create (i, f, this));

      if (!Status_.present ())
      {
        this->Status_.set (r);
        continue;
      }
    }

    // Motor-Enable
    //
    if (n.name () == "Motor-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Motor_Enable_type > r (
        Motor_Enable_traits::create (i, f, this));

      if (!Motor_Enable_.present ())
      {
        this->Motor_Enable_.set (r);
        continue;
      }
    }

    // Scan-Distance
    //
    if (n.name () == "Scan-Distance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Scan_Distance_type > r (
        Scan_Distance_traits::create (i, f, this));

      if (!Scan_Distance_.present ())
      {
        this->Scan_Distance_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // Steps
    //
    if (n.name () == "Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Steps_type > r (
        Steps_traits::create (i, f, this));

      if (!Steps_.present ())
      {
        this->Steps_.set (r);
        continue;
      }
    }

    // Action
    //
    if (n.name () == "Action" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Action_type > r (
        Action_traits::create (i, f, this));

      if (!Action_.present ())
      {
        this->Action_.set (r);
        continue;
      }
    }

    // Clear-Error
    //
    if (n.name () == "Clear-Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Clear_Error_type > r (
        Clear_Error_traits::create (i, f, this));

      if (!Clear_Error_.present ())
      {
        this->Clear_Error_.set (r);
        continue;
      }
    }

    // Direction
    //
    if (n.name () == "Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Direction_type > r (
        Direction_traits::create (i, f, this));

      if (!Direction_.present ())
      {
        this->Direction_.set (r);
        continue;
      }
    }

    // Step-Size
    //
    if (n.name () == "Step-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Step_Size_type > r (
        Step_Size_traits::create (i, f, this));

      if (!Step_Size_.present ())
      {
        this->Step_Size_.set (r);
        continue;
      }
    }

    // Max-Scan-Steps
    //
    if (n.name () == "Max-Scan-Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Max_Scan_Steps_type > r (
        Max_Scan_Steps_traits::create (i, f, this));

      if (!Max_Scan_Steps_.present ())
      {
        this->Max_Scan_Steps_.set (r);
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Speed",
      "");
  }

  if (!Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Status",
      "");
  }

  if (!Motor_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Motor-Enable",
      "");
  }

  if (!Scan_Distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scan-Distance",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Steps",
      "");
  }

  if (!Action_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Action",
      "");
  }

  if (!Clear_Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Clear-Error",
      "");
  }

  if (!Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Direction",
      "");
  }

  if (!Step_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Step-Size",
      "");
  }

  if (!Max_Scan_Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Max-Scan-Steps",
      "");
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }
}

X_3D1* X_3D1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class X_3D1 (*this, f, c);
}

X_3D1::
~X_3D1 ()
{
}

// X_3DSoft
//

X_3DSoft::
X_3DSoft (const Acquire_Persist_3DMIP_type& Acquire_Persist_3DMIP,
          const Acquire_Persist_3D_Frames_type& Acquire_Persist_3D_Frames,
          const Acquire_Persist_3DAVR_type& Acquire_Persist_3DAVR,
          const Rotational_Direction_type& Rotational_Direction,
          const Sigma_type& Sigma,
          const Dilation_Iteration_type& Dilation_Iteration,
          const Parallel_Direction_type& Parallel_Direction,
          const Class_type& Class,
          const Orientation_Length_type& Orientation_Length,
          const External_Force_type& External_Force,
          const Interpolation_Resolution_type& Interpolation_Resolution,
          const Steps_type& Steps,
          const Parallel_Recon_Resolution_type& Parallel_Recon_Resolution,
          const Iteration_type& Iteration,
          const Type_type& Type,
          const Rotational_Step_Size_type& Rotational_Step_Size,
          const Internal_Force_type& Internal_Force,
          const Parallel_Step_Size_type& Parallel_Step_Size)
: ::xml_schema::type (),
  Acquire_Persist_3DMIP_ (Acquire_Persist_3DMIP, ::xml_schema::flags (), this),
  Acquire_Persist_3D_Frames_ (Acquire_Persist_3D_Frames, ::xml_schema::flags (), this),
  Acquire_Persist_3DAVR_ (Acquire_Persist_3DAVR, ::xml_schema::flags (), this),
  Rotational_Direction_ (Rotational_Direction, ::xml_schema::flags (), this),
  Sigma_ (Sigma, ::xml_schema::flags (), this),
  Dilation_Iteration_ (Dilation_Iteration, ::xml_schema::flags (), this),
  Parallel_Direction_ (Parallel_Direction, ::xml_schema::flags (), this),
  Class_ (Class, ::xml_schema::flags (), this),
  Orientation_Length_ (Orientation_Length, ::xml_schema::flags (), this),
  External_Force_ (External_Force, ::xml_schema::flags (), this),
  Interpolation_Resolution_ (Interpolation_Resolution, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Parallel_Recon_Resolution_ (Parallel_Recon_Resolution, ::xml_schema::flags (), this),
  Iteration_ (Iteration, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Rotational_Step_Size_ (Rotational_Step_Size, ::xml_schema::flags (), this),
  Internal_Force_ (Internal_Force, ::xml_schema::flags (), this),
  Parallel_Step_Size_ (Parallel_Step_Size, ::xml_schema::flags (), this)
{
}

X_3DSoft::
X_3DSoft (const Acquire_Persist_3DMIP_type& Acquire_Persist_3DMIP,
          const Acquire_Persist_3D_Frames_type& Acquire_Persist_3D_Frames,
          const Acquire_Persist_3DAVR_type& Acquire_Persist_3DAVR,
          const Rotational_Direction_type& Rotational_Direction,
          const Sigma_type& Sigma,
          const Dilation_Iteration_type& Dilation_Iteration,
          const Parallel_Direction_type& Parallel_Direction,
          const Class_type& Class,
          const Orientation_Length_type& Orientation_Length,
          const External_Force_type& External_Force,
          const Interpolation_Resolution_type& Interpolation_Resolution,
          const Steps_type& Steps,
          const Parallel_Recon_Resolution_type& Parallel_Recon_Resolution,
          const Iteration_type& Iteration,
          const Type_type& Type,
          const Rotational_Step_Size_type& Rotational_Step_Size,
          const Internal_Force_type& Internal_Force,
          ::std::auto_ptr< Parallel_Step_Size_type >& Parallel_Step_Size)
: ::xml_schema::type (),
  Acquire_Persist_3DMIP_ (Acquire_Persist_3DMIP, ::xml_schema::flags (), this),
  Acquire_Persist_3D_Frames_ (Acquire_Persist_3D_Frames, ::xml_schema::flags (), this),
  Acquire_Persist_3DAVR_ (Acquire_Persist_3DAVR, ::xml_schema::flags (), this),
  Rotational_Direction_ (Rotational_Direction, ::xml_schema::flags (), this),
  Sigma_ (Sigma, ::xml_schema::flags (), this),
  Dilation_Iteration_ (Dilation_Iteration, ::xml_schema::flags (), this),
  Parallel_Direction_ (Parallel_Direction, ::xml_schema::flags (), this),
  Class_ (Class, ::xml_schema::flags (), this),
  Orientation_Length_ (Orientation_Length, ::xml_schema::flags (), this),
  External_Force_ (External_Force, ::xml_schema::flags (), this),
  Interpolation_Resolution_ (Interpolation_Resolution, ::xml_schema::flags (), this),
  Steps_ (Steps, ::xml_schema::flags (), this),
  Parallel_Recon_Resolution_ (Parallel_Recon_Resolution, ::xml_schema::flags (), this),
  Iteration_ (Iteration, ::xml_schema::flags (), this),
  Type_ (Type, ::xml_schema::flags (), this),
  Rotational_Step_Size_ (Rotational_Step_Size, ::xml_schema::flags (), this),
  Internal_Force_ (Internal_Force, ::xml_schema::flags (), this),
  Parallel_Step_Size_ (Parallel_Step_Size, ::xml_schema::flags (), this)
{
}

X_3DSoft::
X_3DSoft (const X_3DSoft& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Acquire_Persist_3DMIP_ (x.Acquire_Persist_3DMIP_, f, this),
  Acquire_Persist_3D_Frames_ (x.Acquire_Persist_3D_Frames_, f, this),
  Acquire_Persist_3DAVR_ (x.Acquire_Persist_3DAVR_, f, this),
  Rotational_Direction_ (x.Rotational_Direction_, f, this),
  Sigma_ (x.Sigma_, f, this),
  Dilation_Iteration_ (x.Dilation_Iteration_, f, this),
  Parallel_Direction_ (x.Parallel_Direction_, f, this),
  Class_ (x.Class_, f, this),
  Orientation_Length_ (x.Orientation_Length_, f, this),
  External_Force_ (x.External_Force_, f, this),
  Interpolation_Resolution_ (x.Interpolation_Resolution_, f, this),
  Steps_ (x.Steps_, f, this),
  Parallel_Recon_Resolution_ (x.Parallel_Recon_Resolution_, f, this),
  Iteration_ (x.Iteration_, f, this),
  Type_ (x.Type_, f, this),
  Rotational_Step_Size_ (x.Rotational_Step_Size_, f, this),
  Internal_Force_ (x.Internal_Force_, f, this),
  Parallel_Step_Size_ (x.Parallel_Step_Size_, f, this)
{
}

X_3DSoft::
X_3DSoft (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Acquire_Persist_3DMIP_ (f, this),
  Acquire_Persist_3D_Frames_ (f, this),
  Acquire_Persist_3DAVR_ (f, this),
  Rotational_Direction_ (f, this),
  Sigma_ (f, this),
  Dilation_Iteration_ (f, this),
  Parallel_Direction_ (f, this),
  Class_ (f, this),
  Orientation_Length_ (f, this),
  External_Force_ (f, this),
  Interpolation_Resolution_ (f, this),
  Steps_ (f, this),
  Parallel_Recon_Resolution_ (f, this),
  Iteration_ (f, this),
  Type_ (f, this),
  Rotational_Step_Size_ (f, this),
  Internal_Force_ (f, this),
  Parallel_Step_Size_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void X_3DSoft::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Acquire-Persist-3DMIP
    //
    if (n.name () == "Acquire-Persist-3DMIP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_3DMIP_type > r (
        Acquire_Persist_3DMIP_traits::create (i, f, this));

      if (!Acquire_Persist_3DMIP_.present ())
      {
        this->Acquire_Persist_3DMIP_.set (r);
        continue;
      }
    }

    // Acquire-Persist-3D-Frames
    //
    if (n.name () == "Acquire-Persist-3D-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_3D_Frames_type > r (
        Acquire_Persist_3D_Frames_traits::create (i, f, this));

      if (!Acquire_Persist_3D_Frames_.present ())
      {
        this->Acquire_Persist_3D_Frames_.set (r);
        continue;
      }
    }

    // Acquire-Persist-3DAVR
    //
    if (n.name () == "Acquire-Persist-3DAVR" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Acquire_Persist_3DAVR_type > r (
        Acquire_Persist_3DAVR_traits::create (i, f, this));

      if (!Acquire_Persist_3DAVR_.present ())
      {
        this->Acquire_Persist_3DAVR_.set (r);
        continue;
      }
    }

    // Rotational-Direction
    //
    if (n.name () == "Rotational-Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Rotational_Direction_type > r (
        Rotational_Direction_traits::create (i, f, this));

      if (!Rotational_Direction_.present ())
      {
        this->Rotational_Direction_.set (r);
        continue;
      }
    }

    // Sigma
    //
    if (n.name () == "Sigma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sigma_type > r (
        Sigma_traits::create (i, f, this));

      if (!Sigma_.present ())
      {
        this->Sigma_.set (r);
        continue;
      }
    }

    // Dilation-Iteration
    //
    if (n.name () == "Dilation-Iteration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Dilation_Iteration_type > r (
        Dilation_Iteration_traits::create (i, f, this));

      if (!Dilation_Iteration_.present ())
      {
        this->Dilation_Iteration_.set (r);
        continue;
      }
    }

    // Parallel-Direction
    //
    if (n.name () == "Parallel-Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Parallel_Direction_type > r (
        Parallel_Direction_traits::create (i, f, this));

      if (!Parallel_Direction_.present ())
      {
        this->Parallel_Direction_.set (r);
        continue;
      }
    }

    // Class
    //
    if (n.name () == "Class" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Class_type > r (
        Class_traits::create (i, f, this));

      if (!Class_.present ())
      {
        this->Class_.set (r);
        continue;
      }
    }

    // Orientation-Length
    //
    if (n.name () == "Orientation-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Orientation_Length_type > r (
        Orientation_Length_traits::create (i, f, this));

      if (!Orientation_Length_.present ())
      {
        this->Orientation_Length_.set (r);
        continue;
      }
    }

    // External-Force
    //
    if (n.name () == "External-Force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< External_Force_type > r (
        External_Force_traits::create (i, f, this));

      if (!External_Force_.present ())
      {
        this->External_Force_.set (r);
        continue;
      }
    }

    // Interpolation-Resolution
    //
    if (n.name () == "Interpolation-Resolution" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Interpolation_Resolution_type > r (
        Interpolation_Resolution_traits::create (i, f, this));

      if (!Interpolation_Resolution_.present ())
      {
        this->Interpolation_Resolution_.set (r);
        continue;
      }
    }

    // Steps
    //
    if (n.name () == "Steps" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Steps_type > r (
        Steps_traits::create (i, f, this));

      if (!Steps_.present ())
      {
        this->Steps_.set (r);
        continue;
      }
    }

    // Parallel-Recon-Resolution
    //
    if (n.name () == "Parallel-Recon-Resolution" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Parallel_Recon_Resolution_type > r (
        Parallel_Recon_Resolution_traits::create (i, f, this));

      if (!Parallel_Recon_Resolution_.present ())
      {
        this->Parallel_Recon_Resolution_.set (r);
        continue;
      }
    }

    // Iteration
    //
    if (n.name () == "Iteration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Iteration_type > r (
        Iteration_traits::create (i, f, this));

      if (!Iteration_.present ())
      {
        this->Iteration_.set (r);
        continue;
      }
    }

    // Type
    //
    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Type_type > r (
        Type_traits::create (i, f, this));

      if (!Type_.present ())
      {
        this->Type_.set (r);
        continue;
      }
    }

    // Rotational-Step-Size
    //
    if (n.name () == "Rotational-Step-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Rotational_Step_Size_type > r (
        Rotational_Step_Size_traits::create (i, f, this));

      if (!Rotational_Step_Size_.present ())
      {
        this->Rotational_Step_Size_.set (r);
        continue;
      }
    }

    // Internal-Force
    //
    if (n.name () == "Internal-Force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Internal_Force_type > r (
        Internal_Force_traits::create (i, f, this));

      if (!Internal_Force_.present ())
      {
        this->Internal_Force_.set (r);
        continue;
      }
    }

    // Parallel-Step-Size
    //
    if (n.name () == "Parallel-Step-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Parallel_Step_Size_type > r (
        Parallel_Step_Size_traits::create (i, f, this));

      if (!Parallel_Step_Size_.present ())
      {
        this->Parallel_Step_Size_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Acquire_Persist_3DMIP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-3DMIP",
      "");
  }

  if (!Acquire_Persist_3D_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-3D-Frames",
      "");
  }

  if (!Acquire_Persist_3DAVR_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Acquire-Persist-3DAVR",
      "");
  }

  if (!Rotational_Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Rotational-Direction",
      "");
  }

  if (!Sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sigma",
      "");
  }

  if (!Dilation_Iteration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dilation-Iteration",
      "");
  }

  if (!Parallel_Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Parallel-Direction",
      "");
  }

  if (!Class_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Class",
      "");
  }

  if (!Orientation_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Orientation-Length",
      "");
  }

  if (!External_Force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "External-Force",
      "");
  }

  if (!Interpolation_Resolution_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Interpolation-Resolution",
      "");
  }

  if (!Steps_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Steps",
      "");
  }

  if (!Parallel_Recon_Resolution_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Parallel-Recon-Resolution",
      "");
  }

  if (!Iteration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Iteration",
      "");
  }

  if (!Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Type",
      "");
  }

  if (!Rotational_Step_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Rotational-Step-Size",
      "");
  }

  if (!Internal_Force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Internal-Force",
      "");
  }

  if (!Parallel_Step_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Parallel-Step-Size",
      "");
  }
}

X_3DSoft* X_3DSoft::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class X_3DSoft (*this, f, c);
}

X_3DSoft::
~X_3DSoft ()
{
}

// RX1
//

RX1::
RX1 (const AD_IF_type& AD_IF,
     const Sector_Width_Target_type& Sector_Width_Target,
     const RF_Gain_type& RF_Gain,
     const TGC_Enable_type& TGC_Enable,
     const V_Digi_Depth_Imaging_type& V_Digi_Depth_Imaging,
     const RF_Bandwidth_type& RF_Bandwidth,
     const Test_Freq_type& Test_Freq,
     const V_TGC_type& V_TGC,
     const Current_Channel_type& Current_Channel,
     const AD_In_type& AD_In,
     const Image_FIFO_Status_type& Image_FIFO_Status,
     const RF_Filter_type& RF_Filter,
     const DDRS_type& DDRS,
     const ADCA_Out_type& ADCA_Out,
     const AD_Clock_Div_type& AD_Clock_Div,
     const Imaging_Mode_type& Imaging_Mode,
     const V_RF_Filter_type& V_RF_Filter,
     const ADCB_Out_type& ADCB_Out,
     const Delay_type& Delay,
     const AD_Gate_Width_type& AD_Gate_Width,
     const Frequency_type& Frequency,
     const V_Frequency_type& V_Frequency,
     const V_Field_Of_View_type& V_Field_Of_View,
     const Packet_Format_type& Packet_Format,
     const Sector_Height_Target_type& Sector_Height_Target,
     const Low_Speed_FIFO_Status_type& Low_Speed_FIFO_Status,
     const AD_TestIn_type& AD_TestIn,
     const Error_type& Error,
     const Test_On_type& Test_On,
     const AD_DCS_type& AD_DCS,
     const DTB_Tfr_Enable_type& DTB_Tfr_Enable,
     const DTB_Test_Enable_type& DTB_Test_Enable,
     const V_Delay_Length_type& V_Delay_Length,
     const Current_Mode_type& Current_Mode,
     const Line_Number_type& Line_Number,
     const IF_Filter_type& IF_Filter,
     const Track_Width_type& Track_Width,
     const DTB_Error_Clr_type& DTB_Error_Clr,
     const V_IF_Filter_type& V_IF_Filter,
     const IQ_Select_type& IQ_Select,
     const HP_Clutter_type& HP_Clutter,
     const V_TGC_Copy_type& V_TGC_Copy)
: ::xml_schema::type (),
  AD_IF_ (AD_IF, ::xml_schema::flags (), this),
  Sector_Width_Target_ (Sector_Width_Target, ::xml_schema::flags (), this),
  RF_Gain_ (RF_Gain, ::xml_schema::flags (), this),
  TGC_Enable_ (TGC_Enable, ::xml_schema::flags (), this),
  V_Digi_Depth_Imaging_ (V_Digi_Depth_Imaging, ::xml_schema::flags (), this),
  RF_Bandwidth_ (RF_Bandwidth, ::xml_schema::flags (), this),
  Test_Freq_ (Test_Freq, ::xml_schema::flags (), this),
  V_TGC_ (V_TGC, ::xml_schema::flags (), this),
  Current_Channel_ (Current_Channel, ::xml_schema::flags (), this),
  AD_In_ (AD_In, ::xml_schema::flags (), this),
  Image_FIFO_Status_ (Image_FIFO_Status, ::xml_schema::flags (), this),
  RF_Filter_ (RF_Filter, ::xml_schema::flags (), this),
  DDRS_ (DDRS, ::xml_schema::flags (), this),
  ADCA_Out_ (ADCA_Out, ::xml_schema::flags (), this),
  AD_Clock_Div_ (AD_Clock_Div, ::xml_schema::flags (), this),
  Imaging_Mode_ (Imaging_Mode, ::xml_schema::flags (), this),
  V_RF_Filter_ (V_RF_Filter, ::xml_schema::flags (), this),
  ADCB_Out_ (ADCB_Out, ::xml_schema::flags (), this),
  Delay_ (Delay, ::xml_schema::flags (), this),
  AD_Gate_Width_ (AD_Gate_Width, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  V_Field_Of_View_ (V_Field_Of_View, ::xml_schema::flags (), this),
  Packet_Format_ (Packet_Format, ::xml_schema::flags (), this),
  Sector_Height_Target_ (Sector_Height_Target, ::xml_schema::flags (), this),
  Low_Speed_FIFO_Status_ (Low_Speed_FIFO_Status, ::xml_schema::flags (), this),
  AD_TestIn_ (AD_TestIn, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Test_On_ (Test_On, ::xml_schema::flags (), this),
  AD_DCS_ (AD_DCS, ::xml_schema::flags (), this),
  DTB_Tfr_Enable_ (DTB_Tfr_Enable, ::xml_schema::flags (), this),
  DTB_Test_Enable_ (DTB_Test_Enable, ::xml_schema::flags (), this),
  V_Delay_Length_ (V_Delay_Length, ::xml_schema::flags (), this),
  Current_Mode_ (Current_Mode, ::xml_schema::flags (), this),
  Line_Number_ (Line_Number, ::xml_schema::flags (), this),
  IF_Filter_ (IF_Filter, ::xml_schema::flags (), this),
  Track_Width_ (Track_Width, ::xml_schema::flags (), this),
  DTB_Error_Clr_ (DTB_Error_Clr, ::xml_schema::flags (), this),
  V_IF_Filter_ (V_IF_Filter, ::xml_schema::flags (), this),
  IQ_Select_ (IQ_Select, ::xml_schema::flags (), this),
  HP_Clutter_ (HP_Clutter, ::xml_schema::flags (), this),
  V_TGC_Copy_ (V_TGC_Copy, ::xml_schema::flags (), this)
{
}

RX1::
RX1 (const AD_IF_type& AD_IF,
     ::std::auto_ptr< Sector_Width_Target_type >& Sector_Width_Target,
     ::std::auto_ptr< RF_Gain_type >& RF_Gain,
     const TGC_Enable_type& TGC_Enable,
     ::std::auto_ptr< V_Digi_Depth_Imaging_type >& V_Digi_Depth_Imaging,
     const RF_Bandwidth_type& RF_Bandwidth,
     ::std::auto_ptr< Test_Freq_type >& Test_Freq,
     const V_TGC_type& V_TGC,
     const Current_Channel_type& Current_Channel,
     const AD_In_type& AD_In,
     const Image_FIFO_Status_type& Image_FIFO_Status,
     ::std::auto_ptr< RF_Filter_type >& RF_Filter,
     const DDRS_type& DDRS,
     const ADCA_Out_type& ADCA_Out,
     const AD_Clock_Div_type& AD_Clock_Div,
     const Imaging_Mode_type& Imaging_Mode,
     ::std::auto_ptr< V_RF_Filter_type >& V_RF_Filter,
     const ADCB_Out_type& ADCB_Out,
     ::std::auto_ptr< Delay_type >& Delay,
     ::std::auto_ptr< AD_Gate_Width_type >& AD_Gate_Width,
     ::std::auto_ptr< Frequency_type >& Frequency,
     ::std::auto_ptr< V_Frequency_type >& V_Frequency,
     ::std::auto_ptr< V_Field_Of_View_type >& V_Field_Of_View,
     const Packet_Format_type& Packet_Format,
     ::std::auto_ptr< Sector_Height_Target_type >& Sector_Height_Target,
     const Low_Speed_FIFO_Status_type& Low_Speed_FIFO_Status,
     ::std::auto_ptr< AD_TestIn_type >& AD_TestIn,
     const Error_type& Error,
     const Test_On_type& Test_On,
     const AD_DCS_type& AD_DCS,
     const DTB_Tfr_Enable_type& DTB_Tfr_Enable,
     const DTB_Test_Enable_type& DTB_Test_Enable,
     ::std::auto_ptr< V_Delay_Length_type >& V_Delay_Length,
     const Current_Mode_type& Current_Mode,
     const Line_Number_type& Line_Number,
     ::std::auto_ptr< IF_Filter_type >& IF_Filter,
     ::std::auto_ptr< Track_Width_type >& Track_Width,
     const DTB_Error_Clr_type& DTB_Error_Clr,
     ::std::auto_ptr< V_IF_Filter_type >& V_IF_Filter,
     const IQ_Select_type& IQ_Select,
     ::std::auto_ptr< HP_Clutter_type >& HP_Clutter,
     const V_TGC_Copy_type& V_TGC_Copy)
: ::xml_schema::type (),
  AD_IF_ (AD_IF, ::xml_schema::flags (), this),
  Sector_Width_Target_ (Sector_Width_Target, ::xml_schema::flags (), this),
  RF_Gain_ (RF_Gain, ::xml_schema::flags (), this),
  TGC_Enable_ (TGC_Enable, ::xml_schema::flags (), this),
  V_Digi_Depth_Imaging_ (V_Digi_Depth_Imaging, ::xml_schema::flags (), this),
  RF_Bandwidth_ (RF_Bandwidth, ::xml_schema::flags (), this),
  Test_Freq_ (Test_Freq, ::xml_schema::flags (), this),
  V_TGC_ (V_TGC, ::xml_schema::flags (), this),
  Current_Channel_ (Current_Channel, ::xml_schema::flags (), this),
  AD_In_ (AD_In, ::xml_schema::flags (), this),
  Image_FIFO_Status_ (Image_FIFO_Status, ::xml_schema::flags (), this),
  RF_Filter_ (RF_Filter, ::xml_schema::flags (), this),
  DDRS_ (DDRS, ::xml_schema::flags (), this),
  ADCA_Out_ (ADCA_Out, ::xml_schema::flags (), this),
  AD_Clock_Div_ (AD_Clock_Div, ::xml_schema::flags (), this),
  Imaging_Mode_ (Imaging_Mode, ::xml_schema::flags (), this),
  V_RF_Filter_ (V_RF_Filter, ::xml_schema::flags (), this),
  ADCB_Out_ (ADCB_Out, ::xml_schema::flags (), this),
  Delay_ (Delay, ::xml_schema::flags (), this),
  AD_Gate_Width_ (AD_Gate_Width, ::xml_schema::flags (), this),
  Frequency_ (Frequency, ::xml_schema::flags (), this),
  V_Frequency_ (V_Frequency, ::xml_schema::flags (), this),
  V_Field_Of_View_ (V_Field_Of_View, ::xml_schema::flags (), this),
  Packet_Format_ (Packet_Format, ::xml_schema::flags (), this),
  Sector_Height_Target_ (Sector_Height_Target, ::xml_schema::flags (), this),
  Low_Speed_FIFO_Status_ (Low_Speed_FIFO_Status, ::xml_schema::flags (), this),
  AD_TestIn_ (AD_TestIn, ::xml_schema::flags (), this),
  Error_ (Error, ::xml_schema::flags (), this),
  Test_On_ (Test_On, ::xml_schema::flags (), this),
  AD_DCS_ (AD_DCS, ::xml_schema::flags (), this),
  DTB_Tfr_Enable_ (DTB_Tfr_Enable, ::xml_schema::flags (), this),
  DTB_Test_Enable_ (DTB_Test_Enable, ::xml_schema::flags (), this),
  V_Delay_Length_ (V_Delay_Length, ::xml_schema::flags (), this),
  Current_Mode_ (Current_Mode, ::xml_schema::flags (), this),
  Line_Number_ (Line_Number, ::xml_schema::flags (), this),
  IF_Filter_ (IF_Filter, ::xml_schema::flags (), this),
  Track_Width_ (Track_Width, ::xml_schema::flags (), this),
  DTB_Error_Clr_ (DTB_Error_Clr, ::xml_schema::flags (), this),
  V_IF_Filter_ (V_IF_Filter, ::xml_schema::flags (), this),
  IQ_Select_ (IQ_Select, ::xml_schema::flags (), this),
  HP_Clutter_ (HP_Clutter, ::xml_schema::flags (), this),
  V_TGC_Copy_ (V_TGC_Copy, ::xml_schema::flags (), this)
{
}

RX1::
RX1 (const RX1& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AD_IF_ (x.AD_IF_, f, this),
  Sector_Width_Target_ (x.Sector_Width_Target_, f, this),
  RF_Gain_ (x.RF_Gain_, f, this),
  TGC_Enable_ (x.TGC_Enable_, f, this),
  V_Digi_Depth_Imaging_ (x.V_Digi_Depth_Imaging_, f, this),
  RF_Bandwidth_ (x.RF_Bandwidth_, f, this),
  Test_Freq_ (x.Test_Freq_, f, this),
  V_TGC_ (x.V_TGC_, f, this),
  Current_Channel_ (x.Current_Channel_, f, this),
  AD_In_ (x.AD_In_, f, this),
  Image_FIFO_Status_ (x.Image_FIFO_Status_, f, this),
  RF_Filter_ (x.RF_Filter_, f, this),
  DDRS_ (x.DDRS_, f, this),
  ADCA_Out_ (x.ADCA_Out_, f, this),
  AD_Clock_Div_ (x.AD_Clock_Div_, f, this),
  Imaging_Mode_ (x.Imaging_Mode_, f, this),
  V_RF_Filter_ (x.V_RF_Filter_, f, this),
  ADCB_Out_ (x.ADCB_Out_, f, this),
  Delay_ (x.Delay_, f, this),
  AD_Gate_Width_ (x.AD_Gate_Width_, f, this),
  Frequency_ (x.Frequency_, f, this),
  V_Frequency_ (x.V_Frequency_, f, this),
  V_Field_Of_View_ (x.V_Field_Of_View_, f, this),
  Packet_Format_ (x.Packet_Format_, f, this),
  Sector_Height_Target_ (x.Sector_Height_Target_, f, this),
  Low_Speed_FIFO_Status_ (x.Low_Speed_FIFO_Status_, f, this),
  AD_TestIn_ (x.AD_TestIn_, f, this),
  Error_ (x.Error_, f, this),
  Test_On_ (x.Test_On_, f, this),
  AD_DCS_ (x.AD_DCS_, f, this),
  DTB_Tfr_Enable_ (x.DTB_Tfr_Enable_, f, this),
  DTB_Test_Enable_ (x.DTB_Test_Enable_, f, this),
  V_Delay_Length_ (x.V_Delay_Length_, f, this),
  Current_Mode_ (x.Current_Mode_, f, this),
  Line_Number_ (x.Line_Number_, f, this),
  IF_Filter_ (x.IF_Filter_, f, this),
  Track_Width_ (x.Track_Width_, f, this),
  DTB_Error_Clr_ (x.DTB_Error_Clr_, f, this),
  V_IF_Filter_ (x.V_IF_Filter_, f, this),
  IQ_Select_ (x.IQ_Select_, f, this),
  HP_Clutter_ (x.HP_Clutter_, f, this),
  V_TGC_Copy_ (x.V_TGC_Copy_, f, this)
{
}

RX1::
RX1 (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AD_IF_ (f, this),
  Sector_Width_Target_ (f, this),
  RF_Gain_ (f, this),
  TGC_Enable_ (f, this),
  V_Digi_Depth_Imaging_ (f, this),
  RF_Bandwidth_ (f, this),
  Test_Freq_ (f, this),
  V_TGC_ (f, this),
  Current_Channel_ (f, this),
  AD_In_ (f, this),
  Image_FIFO_Status_ (f, this),
  RF_Filter_ (f, this),
  DDRS_ (f, this),
  ADCA_Out_ (f, this),
  AD_Clock_Div_ (f, this),
  Imaging_Mode_ (f, this),
  V_RF_Filter_ (f, this),
  ADCB_Out_ (f, this),
  Delay_ (f, this),
  AD_Gate_Width_ (f, this),
  Frequency_ (f, this),
  V_Frequency_ (f, this),
  V_Field_Of_View_ (f, this),
  Packet_Format_ (f, this),
  Sector_Height_Target_ (f, this),
  Low_Speed_FIFO_Status_ (f, this),
  AD_TestIn_ (f, this),
  Error_ (f, this),
  Test_On_ (f, this),
  AD_DCS_ (f, this),
  DTB_Tfr_Enable_ (f, this),
  DTB_Test_Enable_ (f, this),
  V_Delay_Length_ (f, this),
  Current_Mode_ (f, this),
  Line_Number_ (f, this),
  IF_Filter_ (f, this),
  Track_Width_ (f, this),
  DTB_Error_Clr_ (f, this),
  V_IF_Filter_ (f, this),
  IQ_Select_ (f, this),
  HP_Clutter_ (f, this),
  V_TGC_Copy_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RX1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AD-IF
    //
    if (n.name () == "AD-IF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_IF_type > r (
        AD_IF_traits::create (i, f, this));

      if (!AD_IF_.present ())
      {
        this->AD_IF_.set (r);
        continue;
      }
    }

    // Sector-Width-Target
    //
    if (n.name () == "Sector-Width-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Width_Target_type > r (
        Sector_Width_Target_traits::create (i, f, this));

      if (!Sector_Width_Target_.present ())
      {
        this->Sector_Width_Target_.set (r);
        continue;
      }
    }

    // RF-Gain
    //
    if (n.name () == "RF-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Gain_type > r (
        RF_Gain_traits::create (i, f, this));

      if (!RF_Gain_.present ())
      {
        this->RF_Gain_.set (r);
        continue;
      }
    }

    // TGC-Enable
    //
    if (n.name () == "TGC-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TGC_Enable_type > r (
        TGC_Enable_traits::create (i, f, this));

      if (!TGC_Enable_.present ())
      {
        this->TGC_Enable_.set (r);
        continue;
      }
    }

    // V-Digi-Depth-Imaging
    //
    if (n.name () == "V-Digi-Depth-Imaging" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Digi_Depth_Imaging_type > r (
        V_Digi_Depth_Imaging_traits::create (i, f, this));

      if (!V_Digi_Depth_Imaging_.present ())
      {
        this->V_Digi_Depth_Imaging_.set (r);
        continue;
      }
    }

    // RF-Bandwidth
    //
    if (n.name () == "RF-Bandwidth" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Bandwidth_type > r (
        RF_Bandwidth_traits::create (i, f, this));

      if (!RF_Bandwidth_.present ())
      {
        this->RF_Bandwidth_.set (r);
        continue;
      }
    }

    // Test-Freq
    //
    if (n.name () == "Test-Freq" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Test_Freq_type > r (
        Test_Freq_traits::create (i, f, this));

      if (!Test_Freq_.present ())
      {
        this->Test_Freq_.set (r);
        continue;
      }
    }

    // V-TGC
    //
    if (n.name () == "V-TGC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_TGC_type > r (
        V_TGC_traits::create (i, f, this));

      if (!V_TGC_.present ())
      {
        this->V_TGC_.set (r);
        continue;
      }
    }

    // Current-Channel
    //
    if (n.name () == "Current-Channel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Current_Channel_type > r (
        Current_Channel_traits::create (i, f, this));

      if (!Current_Channel_.present ())
      {
        this->Current_Channel_.set (r);
        continue;
      }
    }

    // AD-In
    //
    if (n.name () == "AD-In" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_In_type > r (
        AD_In_traits::create (i, f, this));

      if (!AD_In_.present ())
      {
        this->AD_In_.set (r);
        continue;
      }
    }

    // Image-FIFO-Status
    //
    if (n.name () == "Image-FIFO-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Image_FIFO_Status_type > r (
        Image_FIFO_Status_traits::create (i, f, this));

      if (!Image_FIFO_Status_.present ())
      {
        this->Image_FIFO_Status_.set (r);
        continue;
      }
    }

    // RF-Filter
    //
    if (n.name () == "RF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RF_Filter_type > r (
        RF_Filter_traits::create (i, f, this));

      if (!RF_Filter_.present ())
      {
        this->RF_Filter_.set (r);
        continue;
      }
    }

    // DDRS
    //
    if (n.name () == "DDRS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DDRS_type > r (
        DDRS_traits::create (i, f, this));

      if (!DDRS_.present ())
      {
        this->DDRS_.set (r);
        continue;
      }
    }

    // ADCA-Out
    //
    if (n.name () == "ADCA-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ADCA_Out_type > r (
        ADCA_Out_traits::create (i, f, this));

      if (!ADCA_Out_.present ())
      {
        this->ADCA_Out_.set (r);
        continue;
      }
    }

    // AD-Clock-Div
    //
    if (n.name () == "AD-Clock-Div" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_Clock_Div_type > r (
        AD_Clock_Div_traits::create (i, f, this));

      if (!AD_Clock_Div_.present ())
      {
        this->AD_Clock_Div_.set (r);
        continue;
      }
    }

    // Imaging-Mode
    //
    if (n.name () == "Imaging-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Imaging_Mode_type > r (
        Imaging_Mode_traits::create (i, f, this));

      if (!Imaging_Mode_.present ())
      {
        this->Imaging_Mode_.set (r);
        continue;
      }
    }

    // V-RF-Filter
    //
    if (n.name () == "V-RF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_RF_Filter_type > r (
        V_RF_Filter_traits::create (i, f, this));

      if (!V_RF_Filter_.present ())
      {
        this->V_RF_Filter_.set (r);
        continue;
      }
    }

    // ADCB-Out
    //
    if (n.name () == "ADCB-Out" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ADCB_Out_type > r (
        ADCB_Out_traits::create (i, f, this));

      if (!ADCB_Out_.present ())
      {
        this->ADCB_Out_.set (r);
        continue;
      }
    }

    // Delay
    //
    if (n.name () == "Delay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Delay_type > r (
        Delay_traits::create (i, f, this));

      if (!Delay_.present ())
      {
        this->Delay_.set (r);
        continue;
      }
    }

    // AD-Gate-Width
    //
    if (n.name () == "AD-Gate-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_Gate_Width_type > r (
        AD_Gate_Width_traits::create (i, f, this));

      if (!AD_Gate_Width_.present ())
      {
        this->AD_Gate_Width_.set (r);
        continue;
      }
    }

    // Frequency
    //
    if (n.name () == "Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Frequency_type > r (
        Frequency_traits::create (i, f, this));

      if (!Frequency_.present ())
      {
        this->Frequency_.set (r);
        continue;
      }
    }

    // V-Frequency
    //
    if (n.name () == "V-Frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Frequency_type > r (
        V_Frequency_traits::create (i, f, this));

      if (!V_Frequency_.present ())
      {
        this->V_Frequency_.set (r);
        continue;
      }
    }

    // V-Field-Of-View
    //
    if (n.name () == "V-Field-Of-View" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Field_Of_View_type > r (
        V_Field_Of_View_traits::create (i, f, this));

      if (!V_Field_Of_View_.present ())
      {
        this->V_Field_Of_View_.set (r);
        continue;
      }
    }

    // Packet-Format
    //
    if (n.name () == "Packet-Format" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Packet_Format_type > r (
        Packet_Format_traits::create (i, f, this));

      if (!Packet_Format_.present ())
      {
        this->Packet_Format_.set (r);
        continue;
      }
    }

    // Sector-Height-Target
    //
    if (n.name () == "Sector-Height-Target" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sector_Height_Target_type > r (
        Sector_Height_Target_traits::create (i, f, this));

      if (!Sector_Height_Target_.present ())
      {
        this->Sector_Height_Target_.set (r);
        continue;
      }
    }

    // Low-Speed-FIFO-Status
    //
    if (n.name () == "Low-Speed-FIFO-Status" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Low_Speed_FIFO_Status_type > r (
        Low_Speed_FIFO_Status_traits::create (i, f, this));

      if (!Low_Speed_FIFO_Status_.present ())
      {
        this->Low_Speed_FIFO_Status_.set (r);
        continue;
      }
    }

    // AD-TestIn
    //
    if (n.name () == "AD-TestIn" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_TestIn_type > r (
        AD_TestIn_traits::create (i, f, this));

      if (!AD_TestIn_.present ())
      {
        this->AD_TestIn_.set (r);
        continue;
      }
    }

    // Error
    //
    if (n.name () == "Error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Error_type > r (
        Error_traits::create (i, f, this));

      if (!Error_.present ())
      {
        this->Error_.set (r);
        continue;
      }
    }

    // Test-On
    //
    if (n.name () == "Test-On" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Test_On_type > r (
        Test_On_traits::create (i, f, this));

      if (!Test_On_.present ())
      {
        this->Test_On_.set (r);
        continue;
      }
    }

    // AD-DCS
    //
    if (n.name () == "AD-DCS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AD_DCS_type > r (
        AD_DCS_traits::create (i, f, this));

      if (!AD_DCS_.present ())
      {
        this->AD_DCS_.set (r);
        continue;
      }
    }

    // DTB-Tfr-Enable
    //
    if (n.name () == "DTB-Tfr-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Tfr_Enable_type > r (
        DTB_Tfr_Enable_traits::create (i, f, this));

      if (!DTB_Tfr_Enable_.present ())
      {
        this->DTB_Tfr_Enable_.set (r);
        continue;
      }
    }

    // DTB-Test-Enable
    //
    if (n.name () == "DTB-Test-Enable" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Test_Enable_type > r (
        DTB_Test_Enable_traits::create (i, f, this));

      if (!DTB_Test_Enable_.present ())
      {
        this->DTB_Test_Enable_.set (r);
        continue;
      }
    }

    // V-Delay-Length
    //
    if (n.name () == "V-Delay-Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_Delay_Length_type > r (
        V_Delay_Length_traits::create (i, f, this));

      if (!V_Delay_Length_.present ())
      {
        this->V_Delay_Length_.set (r);
        continue;
      }
    }

    // Current-Mode
    //
    if (n.name () == "Current-Mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Current_Mode_type > r (
        Current_Mode_traits::create (i, f, this));

      if (!Current_Mode_.present ())
      {
        this->Current_Mode_.set (r);
        continue;
      }
    }

    // Line-Number
    //
    if (n.name () == "Line-Number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Line_Number_type > r (
        Line_Number_traits::create (i, f, this));

      if (!Line_Number_.present ())
      {
        this->Line_Number_.set (r);
        continue;
      }
    }

    // IF-Filter
    //
    if (n.name () == "IF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IF_Filter_type > r (
        IF_Filter_traits::create (i, f, this));

      if (!IF_Filter_.present ())
      {
        this->IF_Filter_.set (r);
        continue;
      }
    }

    // Track-Width
    //
    if (n.name () == "Track-Width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Track_Width_type > r (
        Track_Width_traits::create (i, f, this));

      if (!Track_Width_.present ())
      {
        this->Track_Width_.set (r);
        continue;
      }
    }

    // DTB-Error-Clr
    //
    if (n.name () == "DTB-Error-Clr" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DTB_Error_Clr_type > r (
        DTB_Error_Clr_traits::create (i, f, this));

      if (!DTB_Error_Clr_.present ())
      {
        this->DTB_Error_Clr_.set (r);
        continue;
      }
    }

    // V-IF-Filter
    //
    if (n.name () == "V-IF-Filter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_IF_Filter_type > r (
        V_IF_Filter_traits::create (i, f, this));

      if (!V_IF_Filter_.present ())
      {
        this->V_IF_Filter_.set (r);
        continue;
      }
    }

    // IQ-Select
    //
    if (n.name () == "IQ-Select" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IQ_Select_type > r (
        IQ_Select_traits::create (i, f, this));

      if (!IQ_Select_.present ())
      {
        this->IQ_Select_.set (r);
        continue;
      }
    }

    // HP-Clutter
    //
    if (n.name () == "HP-Clutter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HP_Clutter_type > r (
        HP_Clutter_traits::create (i, f, this));

      if (!HP_Clutter_.present ())
      {
        this->HP_Clutter_.set (r);
        continue;
      }
    }

    // V-TGC-Copy
    //
    if (n.name () == "V-TGC-Copy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_TGC_Copy_type > r (
        V_TGC_Copy_traits::create (i, f, this));

      if (!V_TGC_Copy_.present ())
      {
        this->V_TGC_Copy_.set (r);
        continue;
      }
    }

    break;
  }

  if (!AD_IF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-IF",
      "");
  }

  if (!Sector_Width_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Width-Target",
      "");
  }

  if (!RF_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Gain",
      "");
  }

  if (!TGC_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TGC-Enable",
      "");
  }

  if (!V_Digi_Depth_Imaging_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Digi-Depth-Imaging",
      "");
  }

  if (!RF_Bandwidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Bandwidth",
      "");
  }

  if (!Test_Freq_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Test-Freq",
      "");
  }

  if (!V_TGC_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-TGC",
      "");
  }

  if (!Current_Channel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Current-Channel",
      "");
  }

  if (!AD_In_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-In",
      "");
  }

  if (!Image_FIFO_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Image-FIFO-Status",
      "");
  }

  if (!RF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RF-Filter",
      "");
  }

  if (!DDRS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DDRS",
      "");
  }

  if (!ADCA_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ADCA-Out",
      "");
  }

  if (!AD_Clock_Div_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-Clock-Div",
      "");
  }

  if (!Imaging_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Imaging-Mode",
      "");
  }

  if (!V_RF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-RF-Filter",
      "");
  }

  if (!ADCB_Out_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ADCB-Out",
      "");
  }

  if (!Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Delay",
      "");
  }

  if (!AD_Gate_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-Gate-Width",
      "");
  }

  if (!Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Frequency",
      "");
  }

  if (!V_Frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Frequency",
      "");
  }

  if (!V_Field_Of_View_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Field-Of-View",
      "");
  }

  if (!Packet_Format_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Packet-Format",
      "");
  }

  if (!Sector_Height_Target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Sector-Height-Target",
      "");
  }

  if (!Low_Speed_FIFO_Status_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Low-Speed-FIFO-Status",
      "");
  }

  if (!AD_TestIn_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-TestIn",
      "");
  }

  if (!Error_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Error",
      "");
  }

  if (!Test_On_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Test-On",
      "");
  }

  if (!AD_DCS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AD-DCS",
      "");
  }

  if (!DTB_Tfr_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Tfr-Enable",
      "");
  }

  if (!DTB_Test_Enable_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Test-Enable",
      "");
  }

  if (!V_Delay_Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-Delay-Length",
      "");
  }

  if (!Current_Mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Current-Mode",
      "");
  }

  if (!Line_Number_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Line-Number",
      "");
  }

  if (!IF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IF-Filter",
      "");
  }

  if (!Track_Width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Track-Width",
      "");
  }

  if (!DTB_Error_Clr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DTB-Error-Clr",
      "");
  }

  if (!V_IF_Filter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-IF-Filter",
      "");
  }

  if (!IQ_Select_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IQ-Select",
      "");
  }

  if (!HP_Clutter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HP-Clutter",
      "");
  }

  if (!V_TGC_Copy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-TGC-Copy",
      "");
  }
}

RX1* RX1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RX1 (*this, f, c);
}

RX1::
~RX1 ()
{
}

// Display1
//

Display1::
Display1 (const Direction_type& Direction,
          const V_SV_TissueMode_type& V_SV_TissueMode,
          const V_SV_MMode_type& V_SV_MMode,
          const X_3D_Gain_type& X_3D_Gain,
          const X_3D_Dynamic_Range_type& X_3D_Dynamic_Range,
          const Gain_type& Gain,
          const V_SV_RfMode_type& V_SV_RfMode,
          const V_SV_EkvMode_type& V_SV_EkvMode,
          const Dynamic_Range_type& Dynamic_Range,
          const Window_Time_type& Window_Time,
          const V_SV_DopplerMode_type& V_SV_DopplerMode,
          const V_SV_NeedleGuide_type& V_SV_NeedleGuide,
          const V_SV_ColorMode_type& V_SV_ColorMode)
: ::xml_schema::type (),
  Direction_ (Direction, ::xml_schema::flags (), this),
  V_SV_TissueMode_ (V_SV_TissueMode, ::xml_schema::flags (), this),
  V_SV_MMode_ (V_SV_MMode, ::xml_schema::flags (), this),
  X_3D_Gain_ (X_3D_Gain, ::xml_schema::flags (), this),
  X_3D_Dynamic_Range_ (X_3D_Dynamic_Range, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  V_SV_RfMode_ (V_SV_RfMode, ::xml_schema::flags (), this),
  V_SV_EkvMode_ (V_SV_EkvMode, ::xml_schema::flags (), this),
  Dynamic_Range_ (Dynamic_Range, ::xml_schema::flags (), this),
  Window_Time_ (Window_Time, ::xml_schema::flags (), this),
  V_SV_DopplerMode_ (V_SV_DopplerMode, ::xml_schema::flags (), this),
  V_SV_NeedleGuide_ (V_SV_NeedleGuide, ::xml_schema::flags (), this),
  V_SV_ColorMode_ (V_SV_ColorMode, ::xml_schema::flags (), this)
{
}

Display1::
Display1 (const Direction_type& Direction,
          const V_SV_TissueMode_type& V_SV_TissueMode,
          const V_SV_MMode_type& V_SV_MMode,
          const X_3D_Gain_type& X_3D_Gain,
          const X_3D_Dynamic_Range_type& X_3D_Dynamic_Range,
          const Gain_type& Gain,
          const V_SV_RfMode_type& V_SV_RfMode,
          const V_SV_EkvMode_type& V_SV_EkvMode,
          const Dynamic_Range_type& Dynamic_Range,
          ::std::auto_ptr< Window_Time_type >& Window_Time,
          const V_SV_DopplerMode_type& V_SV_DopplerMode,
          const V_SV_NeedleGuide_type& V_SV_NeedleGuide,
          const V_SV_ColorMode_type& V_SV_ColorMode)
: ::xml_schema::type (),
  Direction_ (Direction, ::xml_schema::flags (), this),
  V_SV_TissueMode_ (V_SV_TissueMode, ::xml_schema::flags (), this),
  V_SV_MMode_ (V_SV_MMode, ::xml_schema::flags (), this),
  X_3D_Gain_ (X_3D_Gain, ::xml_schema::flags (), this),
  X_3D_Dynamic_Range_ (X_3D_Dynamic_Range, ::xml_schema::flags (), this),
  Gain_ (Gain, ::xml_schema::flags (), this),
  V_SV_RfMode_ (V_SV_RfMode, ::xml_schema::flags (), this),
  V_SV_EkvMode_ (V_SV_EkvMode, ::xml_schema::flags (), this),
  Dynamic_Range_ (Dynamic_Range, ::xml_schema::flags (), this),
  Window_Time_ (Window_Time, ::xml_schema::flags (), this),
  V_SV_DopplerMode_ (V_SV_DopplerMode, ::xml_schema::flags (), this),
  V_SV_NeedleGuide_ (V_SV_NeedleGuide, ::xml_schema::flags (), this),
  V_SV_ColorMode_ (V_SV_ColorMode, ::xml_schema::flags (), this)
{
}

Display1::
Display1 (const Display1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Direction_ (x.Direction_, f, this),
  V_SV_TissueMode_ (x.V_SV_TissueMode_, f, this),
  V_SV_MMode_ (x.V_SV_MMode_, f, this),
  X_3D_Gain_ (x.X_3D_Gain_, f, this),
  X_3D_Dynamic_Range_ (x.X_3D_Dynamic_Range_, f, this),
  Gain_ (x.Gain_, f, this),
  V_SV_RfMode_ (x.V_SV_RfMode_, f, this),
  V_SV_EkvMode_ (x.V_SV_EkvMode_, f, this),
  Dynamic_Range_ (x.Dynamic_Range_, f, this),
  Window_Time_ (x.Window_Time_, f, this),
  V_SV_DopplerMode_ (x.V_SV_DopplerMode_, f, this),
  V_SV_NeedleGuide_ (x.V_SV_NeedleGuide_, f, this),
  V_SV_ColorMode_ (x.V_SV_ColorMode_, f, this)
{
}

Display1::
Display1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Direction_ (f, this),
  V_SV_TissueMode_ (f, this),
  V_SV_MMode_ (f, this),
  X_3D_Gain_ (f, this),
  X_3D_Dynamic_Range_ (f, this),
  Gain_ (f, this),
  V_SV_RfMode_ (f, this),
  V_SV_EkvMode_ (f, this),
  Dynamic_Range_ (f, this),
  Window_Time_ (f, this),
  V_SV_DopplerMode_ (f, this),
  V_SV_NeedleGuide_ (f, this),
  V_SV_ColorMode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Display1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Direction
    //
    if (n.name () == "Direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Direction_type > r (
        Direction_traits::create (i, f, this));

      if (!Direction_.present ())
      {
        this->Direction_.set (r);
        continue;
      }
    }

    // V-SV-TissueMode
    //
    if (n.name () == "V-SV-TissueMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_TissueMode_type > r (
        V_SV_TissueMode_traits::create (i, f, this));

      if (!V_SV_TissueMode_.present ())
      {
        this->V_SV_TissueMode_.set (r);
        continue;
      }
    }

    // V-SV-MMode
    //
    if (n.name () == "V-SV-MMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_MMode_type > r (
        V_SV_MMode_traits::create (i, f, this));

      if (!V_SV_MMode_.present ())
      {
        this->V_SV_MMode_.set (r);
        continue;
      }
    }

    // X_3D-Gain
    //
    if (n.name () == "X_3D-Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Gain_type > r (
        X_3D_Gain_traits::create (i, f, this));

      if (!X_3D_Gain_.present ())
      {
        this->X_3D_Gain_.set (r);
        continue;
      }
    }

    // X_3D-Dynamic-Range
    //
    if (n.name () == "X_3D-Dynamic-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_3D_Dynamic_Range_type > r (
        X_3D_Dynamic_Range_traits::create (i, f, this));

      if (!X_3D_Dynamic_Range_.present ())
      {
        this->X_3D_Dynamic_Range_.set (r);
        continue;
      }
    }

    // Gain
    //
    if (n.name () == "Gain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Gain_type > r (
        Gain_traits::create (i, f, this));

      if (!Gain_.present ())
      {
        this->Gain_.set (r);
        continue;
      }
    }

    // V-SV-RfMode
    //
    if (n.name () == "V-SV-RfMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_RfMode_type > r (
        V_SV_RfMode_traits::create (i, f, this));

      if (!V_SV_RfMode_.present ())
      {
        this->V_SV_RfMode_.set (r);
        continue;
      }
    }

    // V-SV-EkvMode
    //
    if (n.name () == "V-SV-EkvMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_EkvMode_type > r (
        V_SV_EkvMode_traits::create (i, f, this));

      if (!V_SV_EkvMode_.present ())
      {
        this->V_SV_EkvMode_.set (r);
        continue;
      }
    }

    // Dynamic-Range
    //
    if (n.name () == "Dynamic-Range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Dynamic_Range_type > r (
        Dynamic_Range_traits::create (i, f, this));

      if (!Dynamic_Range_.present ())
      {
        this->Dynamic_Range_.set (r);
        continue;
      }
    }

    // Window-Time
    //
    if (n.name () == "Window-Time" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Window_Time_type > r (
        Window_Time_traits::create (i, f, this));

      if (!Window_Time_.present ())
      {
        this->Window_Time_.set (r);
        continue;
      }
    }

    // V-SV-DopplerMode
    //
    if (n.name () == "V-SV-DopplerMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_DopplerMode_type > r (
        V_SV_DopplerMode_traits::create (i, f, this));

      if (!V_SV_DopplerMode_.present ())
      {
        this->V_SV_DopplerMode_.set (r);
        continue;
      }
    }

    // V-SV-NeedleGuide
    //
    if (n.name () == "V-SV-NeedleGuide" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_NeedleGuide_type > r (
        V_SV_NeedleGuide_traits::create (i, f, this));

      if (!V_SV_NeedleGuide_.present ())
      {
        this->V_SV_NeedleGuide_.set (r);
        continue;
      }
    }

    // V-SV-ColorMode
    //
    if (n.name () == "V-SV-ColorMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_SV_ColorMode_type > r (
        V_SV_ColorMode_traits::create (i, f, this));

      if (!V_SV_ColorMode_.present ())
      {
        this->V_SV_ColorMode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Direction",
      "");
  }

  if (!V_SV_TissueMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-TissueMode",
      "");
  }

  if (!V_SV_MMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-MMode",
      "");
  }

  if (!X_3D_Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Gain",
      "");
  }

  if (!X_3D_Dynamic_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X_3D-Dynamic-Range",
      "");
  }

  if (!Gain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Gain",
      "");
  }

  if (!V_SV_RfMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-RfMode",
      "");
  }

  if (!V_SV_EkvMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-EkvMode",
      "");
  }

  if (!Dynamic_Range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dynamic-Range",
      "");
  }

  if (!Window_Time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Window-Time",
      "");
  }

  if (!V_SV_DopplerMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-DopplerMode",
      "");
  }

  if (!V_SV_NeedleGuide_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-NeedleGuide",
      "");
  }

  if (!V_SV_ColorMode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V-SV-ColorMode",
      "");
  }
}

Display1* Display1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Display1 (*this, f, c);
}

Display1::
~Display1 ()
{
}

// EKVModeSoft
//

EKVModeSoft::
EKVModeSoft (const RWave_Time_Tollerance_type& RWave_Time_Tollerance,
             const EKV_Start_type& EKV_Start,
             const EKV_Stop_type& EKV_Stop,
             const EKV_Quality_Times_type& EKV_Quality_Times,
             const EKV_Quality_type& EKV_Quality,
             const EKV_Quality_Resolution_type& EKV_Quality_Resolution,
             const Difference_Percent_Periods_Keep_type& Difference_Percent_Periods_Keep,
             const EKV_Advanced_type& EKV_Advanced,
             const EKV_Variance_type& EKV_Variance,
             const EKV_Triggers_type& EKV_Triggers)
: ::xml_schema::type (),
  RWave_Time_Tollerance_ (RWave_Time_Tollerance, ::xml_schema::flags (), this),
  EKV_Start_ (EKV_Start, ::xml_schema::flags (), this),
  EKV_Stop_ (EKV_Stop, ::xml_schema::flags (), this),
  EKV_Quality_Times_ (EKV_Quality_Times, ::xml_schema::flags (), this),
  EKV_Quality_ (EKV_Quality, ::xml_schema::flags (), this),
  EKV_Quality_Resolution_ (EKV_Quality_Resolution, ::xml_schema::flags (), this),
  Difference_Percent_Periods_Keep_ (Difference_Percent_Periods_Keep, ::xml_schema::flags (), this),
  EKV_Advanced_ (EKV_Advanced, ::xml_schema::flags (), this),
  EKV_Variance_ (EKV_Variance, ::xml_schema::flags (), this),
  EKV_Triggers_ (EKV_Triggers, ::xml_schema::flags (), this)
{
}

EKVModeSoft::
EKVModeSoft (const RWave_Time_Tollerance_type& RWave_Time_Tollerance,
             ::std::auto_ptr< EKV_Start_type >& EKV_Start,
             ::std::auto_ptr< EKV_Stop_type >& EKV_Stop,
             ::std::auto_ptr< EKV_Quality_Times_type >& EKV_Quality_Times,
             ::std::auto_ptr< EKV_Quality_type >& EKV_Quality,
             ::std::auto_ptr< EKV_Quality_Resolution_type >& EKV_Quality_Resolution,
             const Difference_Percent_Periods_Keep_type& Difference_Percent_Periods_Keep,
             const EKV_Advanced_type& EKV_Advanced,
             ::std::auto_ptr< EKV_Variance_type >& EKV_Variance,
             ::std::auto_ptr< EKV_Triggers_type >& EKV_Triggers)
: ::xml_schema::type (),
  RWave_Time_Tollerance_ (RWave_Time_Tollerance, ::xml_schema::flags (), this),
  EKV_Start_ (EKV_Start, ::xml_schema::flags (), this),
  EKV_Stop_ (EKV_Stop, ::xml_schema::flags (), this),
  EKV_Quality_Times_ (EKV_Quality_Times, ::xml_schema::flags (), this),
  EKV_Quality_ (EKV_Quality, ::xml_schema::flags (), this),
  EKV_Quality_Resolution_ (EKV_Quality_Resolution, ::xml_schema::flags (), this),
  Difference_Percent_Periods_Keep_ (Difference_Percent_Periods_Keep, ::xml_schema::flags (), this),
  EKV_Advanced_ (EKV_Advanced, ::xml_schema::flags (), this),
  EKV_Variance_ (EKV_Variance, ::xml_schema::flags (), this),
  EKV_Triggers_ (EKV_Triggers, ::xml_schema::flags (), this)
{
}

EKVModeSoft::
EKVModeSoft (const EKVModeSoft& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  RWave_Time_Tollerance_ (x.RWave_Time_Tollerance_, f, this),
  EKV_Start_ (x.EKV_Start_, f, this),
  EKV_Stop_ (x.EKV_Stop_, f, this),
  EKV_Quality_Times_ (x.EKV_Quality_Times_, f, this),
  EKV_Quality_ (x.EKV_Quality_, f, this),
  EKV_Quality_Resolution_ (x.EKV_Quality_Resolution_, f, this),
  Difference_Percent_Periods_Keep_ (x.Difference_Percent_Periods_Keep_, f, this),
  EKV_Advanced_ (x.EKV_Advanced_, f, this),
  EKV_Variance_ (x.EKV_Variance_, f, this),
  EKV_Triggers_ (x.EKV_Triggers_, f, this)
{
}

EKVModeSoft::
EKVModeSoft (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  RWave_Time_Tollerance_ (f, this),
  EKV_Start_ (f, this),
  EKV_Stop_ (f, this),
  EKV_Quality_Times_ (f, this),
  EKV_Quality_ (f, this),
  EKV_Quality_Resolution_ (f, this),
  Difference_Percent_Periods_Keep_ (f, this),
  EKV_Advanced_ (f, this),
  EKV_Variance_ (f, this),
  EKV_Triggers_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void EKVModeSoft::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RWave-Time-Tollerance
    //
    if (n.name () == "RWave-Time-Tollerance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RWave_Time_Tollerance_type > r (
        RWave_Time_Tollerance_traits::create (i, f, this));

      if (!RWave_Time_Tollerance_.present ())
      {
        this->RWave_Time_Tollerance_.set (r);
        continue;
      }
    }

    // EKV-Start
    //
    if (n.name () == "EKV-Start" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Start_type > r (
        EKV_Start_traits::create (i, f, this));

      if (!EKV_Start_.present ())
      {
        this->EKV_Start_.set (r);
        continue;
      }
    }

    // EKV-Stop
    //
    if (n.name () == "EKV-Stop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Stop_type > r (
        EKV_Stop_traits::create (i, f, this));

      if (!EKV_Stop_.present ())
      {
        this->EKV_Stop_.set (r);
        continue;
      }
    }

    // EKV-Quality-Times
    //
    if (n.name () == "EKV-Quality-Times" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Quality_Times_type > r (
        EKV_Quality_Times_traits::create (i, f, this));

      if (!EKV_Quality_Times_.present ())
      {
        this->EKV_Quality_Times_.set (r);
        continue;
      }
    }

    // EKV-Quality
    //
    if (n.name () == "EKV-Quality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Quality_type > r (
        EKV_Quality_traits::create (i, f, this));

      if (!EKV_Quality_.present ())
      {
        this->EKV_Quality_.set (r);
        continue;
      }
    }

    // EKV-Quality-Resolution
    //
    if (n.name () == "EKV-Quality-Resolution" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Quality_Resolution_type > r (
        EKV_Quality_Resolution_traits::create (i, f, this));

      if (!EKV_Quality_Resolution_.present ())
      {
        this->EKV_Quality_Resolution_.set (r);
        continue;
      }
    }

    // Difference-Percent-Periods-Keep
    //
    if (n.name () == "Difference-Percent-Periods-Keep" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Difference_Percent_Periods_Keep_type > r (
        Difference_Percent_Periods_Keep_traits::create (i, f, this));

      if (!Difference_Percent_Periods_Keep_.present ())
      {
        this->Difference_Percent_Periods_Keep_.set (r);
        continue;
      }
    }

    // EKV-Advanced
    //
    if (n.name () == "EKV-Advanced" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Advanced_type > r (
        EKV_Advanced_traits::create (i, f, this));

      if (!EKV_Advanced_.present ())
      {
        this->EKV_Advanced_.set (r);
        continue;
      }
    }

    // EKV-Variance
    //
    if (n.name () == "EKV-Variance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Variance_type > r (
        EKV_Variance_traits::create (i, f, this));

      if (!EKV_Variance_.present ())
      {
        this->EKV_Variance_.set (r);
        continue;
      }
    }

    // EKV-Triggers
    //
    if (n.name () == "EKV-Triggers" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Triggers_type > r (
        EKV_Triggers_traits::create (i, f, this));

      if (!EKV_Triggers_.present ())
      {
        this->EKV_Triggers_.set (r);
        continue;
      }
    }

    break;
  }

  if (!RWave_Time_Tollerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RWave-Time-Tollerance",
      "");
  }

  if (!EKV_Start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Start",
      "");
  }

  if (!EKV_Stop_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Stop",
      "");
  }

  if (!EKV_Quality_Times_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Quality-Times",
      "");
  }

  if (!EKV_Quality_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Quality",
      "");
  }

  if (!EKV_Quality_Resolution_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Quality-Resolution",
      "");
  }

  if (!Difference_Percent_Periods_Keep_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Difference-Percent-Periods-Keep",
      "");
  }

  if (!EKV_Advanced_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Advanced",
      "");
  }

  if (!EKV_Variance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Variance",
      "");
  }

  if (!EKV_Triggers_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Triggers",
      "");
  }
}

EKVModeSoft* EKVModeSoft::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKVModeSoft (*this, f, c);
}

EKVModeSoft::
~EKVModeSoft ()
{
}

// BModeLVAnalysis
//

BModeLVAnalysis::
BModeLVAnalysis (const Cycles_Cardiac_Region_type& Cycles_Cardiac_Region,
                 const Cycles_type& Cycles,
                 const Spline_Process_Points_type& Spline_Process_Points,
                 const Speckle_Search_Size_type& Speckle_Search_Size,
                 const Speckle_Compare_Size_type& Speckle_Compare_Size,
                 const EKV_Frames_type& EKV_Frames,
                 const Axis_type& Axis,
                 const Cardinal_Tension_type& Cardinal_Tension)
: ::xml_schema::type (),
  Cycles_Cardiac_Region_ (Cycles_Cardiac_Region, ::xml_schema::flags (), this),
  Cycles_ (Cycles, ::xml_schema::flags (), this),
  Spline_Process_Points_ (Spline_Process_Points, ::xml_schema::flags (), this),
  Speckle_Search_Size_ (Speckle_Search_Size, ::xml_schema::flags (), this),
  Speckle_Compare_Size_ (Speckle_Compare_Size, ::xml_schema::flags (), this),
  EKV_Frames_ (EKV_Frames, ::xml_schema::flags (), this),
  Axis_ (Axis, ::xml_schema::flags (), this),
  Cardinal_Tension_ (Cardinal_Tension, ::xml_schema::flags (), this)
{
}

BModeLVAnalysis::
BModeLVAnalysis (const BModeLVAnalysis& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Cycles_Cardiac_Region_ (x.Cycles_Cardiac_Region_, f, this),
  Cycles_ (x.Cycles_, f, this),
  Spline_Process_Points_ (x.Spline_Process_Points_, f, this),
  Speckle_Search_Size_ (x.Speckle_Search_Size_, f, this),
  Speckle_Compare_Size_ (x.Speckle_Compare_Size_, f, this),
  EKV_Frames_ (x.EKV_Frames_, f, this),
  Axis_ (x.Axis_, f, this),
  Cardinal_Tension_ (x.Cardinal_Tension_, f, this)
{
}

BModeLVAnalysis::
BModeLVAnalysis (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Cycles_Cardiac_Region_ (f, this),
  Cycles_ (f, this),
  Spline_Process_Points_ (f, this),
  Speckle_Search_Size_ (f, this),
  Speckle_Compare_Size_ (f, this),
  EKV_Frames_ (f, this),
  Axis_ (f, this),
  Cardinal_Tension_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void BModeLVAnalysis::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Cycles-Cardiac-Region
    //
    if (n.name () == "Cycles-Cardiac-Region" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cycles_Cardiac_Region_type > r (
        Cycles_Cardiac_Region_traits::create (i, f, this));

      if (!Cycles_Cardiac_Region_.present ())
      {
        this->Cycles_Cardiac_Region_.set (r);
        continue;
      }
    }

    // Cycles
    //
    if (n.name () == "Cycles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cycles_type > r (
        Cycles_traits::create (i, f, this));

      if (!Cycles_.present ())
      {
        this->Cycles_.set (r);
        continue;
      }
    }

    // Spline-Process-Points
    //
    if (n.name () == "Spline-Process-Points" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Spline_Process_Points_type > r (
        Spline_Process_Points_traits::create (i, f, this));

      if (!Spline_Process_Points_.present ())
      {
        this->Spline_Process_Points_.set (r);
        continue;
      }
    }

    // Speckle-Search-Size
    //
    if (n.name () == "Speckle-Search-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Speckle_Search_Size_type > r (
        Speckle_Search_Size_traits::create (i, f, this));

      if (!Speckle_Search_Size_.present ())
      {
        this->Speckle_Search_Size_.set (r);
        continue;
      }
    }

    // Speckle-Compare-Size
    //
    if (n.name () == "Speckle-Compare-Size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Speckle_Compare_Size_type > r (
        Speckle_Compare_Size_traits::create (i, f, this));

      if (!Speckle_Compare_Size_.present ())
      {
        this->Speckle_Compare_Size_.set (r);
        continue;
      }
    }

    // EKV-Frames
    //
    if (n.name () == "EKV-Frames" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EKV_Frames_type > r (
        EKV_Frames_traits::create (i, f, this));

      if (!EKV_Frames_.present ())
      {
        this->EKV_Frames_.set (r);
        continue;
      }
    }

    // Axis
    //
    if (n.name () == "Axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axis_type > r (
        Axis_traits::create (i, f, this));

      if (!Axis_.present ())
      {
        this->Axis_.set (r);
        continue;
      }
    }

    // Cardinal-Tension
    //
    if (n.name () == "Cardinal-Tension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cardinal_Tension_type > r (
        Cardinal_Tension_traits::create (i, f, this));

      if (!Cardinal_Tension_.present ())
      {
        this->Cardinal_Tension_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Cycles_Cardiac_Region_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cycles-Cardiac-Region",
      "");
  }

  if (!Cycles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cycles",
      "");
  }

  if (!Spline_Process_Points_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Spline-Process-Points",
      "");
  }

  if (!Speckle_Search_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Speckle-Search-Size",
      "");
  }

  if (!Speckle_Compare_Size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Speckle-Compare-Size",
      "");
  }

  if (!EKV_Frames_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EKV-Frames",
      "");
  }

  if (!Axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axis",
      "");
  }

  if (!Cardinal_Tension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cardinal-Tension",
      "");
  }
}

BModeLVAnalysis* BModeLVAnalysis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BModeLVAnalysis (*this, f, c);
}

BModeLVAnalysis::
~BModeLVAnalysis ()
{
}

// Sample_Time
//

Sample_Time::
Sample_Time (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sample_Time::
Sample_Time (const Sample_Time& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sample_Time::
Sample_Time (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sample_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sample_Time* Sample_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sample_Time (*this, f, c);
}

Sample_Time::
~Sample_Time ()
{
}

// Focal_Length
//

Focal_Length::
Focal_Length (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Focal_Length::
Focal_Length (const Focal_Length& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Focal_Length::
Focal_Length (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Focal_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Focal_Length* Focal_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Focal_Length (*this, f, c);
}

Focal_Length::
~Focal_Length ()
{
}

// Default_Scan_Speed
//

Default_Scan_Speed::
Default_Scan_Speed (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Scan_Speed::
Default_Scan_Speed (const Default_Scan_Speed& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Scan_Speed::
Default_Scan_Speed (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Scan_Speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Scan_Speed* Default_Scan_Speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Scan_Speed (*this, f, c);
}

Default_Scan_Speed::
~Default_Scan_Speed ()
{
}

// Cutoff_Scan_Speed
//

Cutoff_Scan_Speed::
Cutoff_Scan_Speed (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Cutoff_Scan_Speed::
Cutoff_Scan_Speed (const Cutoff_Scan_Speed& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Cutoff_Scan_Speed::
Cutoff_Scan_Speed (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Cutoff_Scan_Speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Cutoff_Scan_Speed* Cutoff_Scan_Speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Cutoff_Scan_Speed (*this, f, c);
}

Cutoff_Scan_Speed::
~Cutoff_Scan_Speed ()
{
}

// Frequency_Low
//

Frequency_Low::
Frequency_Low (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Low::
Frequency_Low (const Frequency_Low& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Low::
Frequency_Low (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Low::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Low* Frequency_Low::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Low (*this, f, c);
}

Frequency_Low::
~Frequency_Low ()
{
}

// Default_FOV
//

Default_FOV::
Default_FOV (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_FOV::
Default_FOV (const Default_FOV& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_FOV::
Default_FOV (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_FOV::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_FOV* Default_FOV::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_FOV (*this, f, c);
}

Default_FOV::
~Default_FOV ()
{
}

// Frequency_Doppler_Default
//

Frequency_Doppler_Default::
Frequency_Doppler_Default (const ::xml_schema::float_& _xsd_float__base,
                           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler_Default::
Frequency_Doppler_Default (const Frequency_Doppler_Default& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler_Default::
Frequency_Doppler_Default (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler_Default::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler_Default* Frequency_Doppler_Default::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler_Default (*this, f, c);
}

Frequency_Doppler_Default::
~Frequency_Doppler_Default ()
{
}

// Frequency_Doppler
//

Frequency_Doppler::
Frequency_Doppler (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler::
Frequency_Doppler (const Frequency_Doppler& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler::
Frequency_Doppler (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler* Frequency_Doppler::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler (*this, f, c);
}

Frequency_Doppler::
~Frequency_Doppler ()
{
}

// Axial_Res
//

Axial_Res::
Axial_Res (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res::
Axial_Res (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res::
Axial_Res (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res::
Axial_Res (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res::
Axial_Res (const Axial_Res& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Axial_Res::
Axial_Res (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Axial_Res::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Axial_Res* Axial_Res::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Axial_Res (*this, f, c);
}

Axial_Res::
~Axial_Res ()
{
}

// Filter_High
//

Filter_High::
Filter_High (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_High::
Filter_High (const Filter_High& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_High::
Filter_High (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_High::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_High* Filter_High::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_High (*this, f, c);
}

Filter_High::
~Filter_High ()
{
}

// Pivot_Encoder_Dist
//

Pivot_Encoder_Dist::
Pivot_Encoder_Dist (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pivot_Encoder_Dist::
Pivot_Encoder_Dist (const Pivot_Encoder_Dist& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Pivot_Encoder_Dist::
Pivot_Encoder_Dist (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pivot_Encoder_Dist::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pivot_Encoder_Dist* Pivot_Encoder_Dist::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pivot_Encoder_Dist (*this, f, c);
}

Pivot_Encoder_Dist::
~Pivot_Encoder_Dist ()
{
}

// Encoder_Range_Max
//

Encoder_Range_Max::
Encoder_Range_Max (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Range_Max::
Encoder_Range_Max (const Encoder_Range_Max& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Range_Max::
Encoder_Range_Max (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Range_Max::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Range_Max* Encoder_Range_Max::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Range_Max (*this, f, c);
}

Encoder_Range_Max::
~Encoder_Range_Max ()
{
}

// Encoder_Range_Min
//

Encoder_Range_Min::
Encoder_Range_Min (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Range_Min::
Encoder_Range_Min (const Encoder_Range_Min& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Range_Min::
Encoder_Range_Min (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Range_Min::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Range_Min* Encoder_Range_Min::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Range_Min (*this, f, c);
}

Encoder_Range_Min::
~Encoder_Range_Min ()
{
}

// Lateral_Res
//

Lateral_Res::
Lateral_Res (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res::
Lateral_Res (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res::
Lateral_Res (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res::
Lateral_Res (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res::
Lateral_Res (const Lateral_Res& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Lateral_Res::
Lateral_Res (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Lateral_Res::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Lateral_Res* Lateral_Res::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Lateral_Res (*this, f, c);
}

Lateral_Res::
~Lateral_Res ()
{
}

// Motor_Overhead
//

Motor_Overhead::
Motor_Overhead (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead::
Motor_Overhead (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead::
Motor_Overhead (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead::
Motor_Overhead (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead::
Motor_Overhead (const Motor_Overhead& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Motor_Overhead::
Motor_Overhead (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Motor_Overhead::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Motor_Overhead* Motor_Overhead::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Motor_Overhead (*this, f, c);
}

Motor_Overhead::
~Motor_Overhead ()
{
}

// Max_Scan_Distance
//

Max_Scan_Distance::
Max_Scan_Distance (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Max_Scan_Distance::
Max_Scan_Distance (const Max_Scan_Distance& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Max_Scan_Distance::
Max_Scan_Distance (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Max_Scan_Distance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Max_Scan_Distance* Max_Scan_Distance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Max_Scan_Distance (*this, f, c);
}

Max_Scan_Distance::
~Max_Scan_Distance ()
{
}

// Default_Rx_Gain
//

Default_Rx_Gain::
Default_Rx_Gain (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain::
Default_Rx_Gain (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain::
Default_Rx_Gain (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain::
Default_Rx_Gain (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain::
Default_Rx_Gain (const Default_Rx_Gain& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Rx_Gain::
Default_Rx_Gain (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Rx_Gain::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Rx_Gain* Default_Rx_Gain::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Rx_Gain (*this, f, c);
}

Default_Rx_Gain::
~Default_Rx_Gain ()
{
}

// Filter_Low
//

Filter_Low::
Filter_Low (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Low::
Filter_Low (const Filter_Low& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Low::
Filter_Low (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Low::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Low* Filter_Low::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Low (*this, f, c);
}

Filter_Low::
~Filter_Low ()
{
}

// Frequency_High
//

Frequency_High::
Frequency_High (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_High::
Frequency_High (const Frequency_High& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_High::
Frequency_High (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_High::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_High* Frequency_High::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_High (*this, f, c);
}

Frequency_High::
~Frequency_High ()
{
}

// Scan_Speeds
//

Scan_Speeds::
Scan_Speeds (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Speeds::
Scan_Speeds (const Scan_Speeds& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Speeds::
Scan_Speeds (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Speeds::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Speeds* Scan_Speeds::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Speeds (*this, f, c);
}

Scan_Speeds::
~Scan_Speeds ()
{
}

// Filter_Doppler_Cutoff
//

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const char* _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const ::std::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const ::xml_schema::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const Filter_Doppler_Cutoff& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler_Cutoff::
Filter_Doppler_Cutoff (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler_Cutoff::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler_Cutoff* Filter_Doppler_Cutoff::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler_Cutoff (*this, f, c);
}

Filter_Doppler_Cutoff::
~Filter_Doppler_Cutoff ()
{
}

// Frequency_Doppler_Low
//

Frequency_Doppler_Low::
Frequency_Doppler_Low (const ::xml_schema::float_& _xsd_float__base,
                       const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler_Low::
Frequency_Doppler_Low (const Frequency_Doppler_Low& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler_Low::
Frequency_Doppler_Low (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler_Low::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler_Low* Frequency_Doppler_Low::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler_Low (*this, f, c);
}

Frequency_Doppler_Low::
~Frequency_Doppler_Low ()
{
}

// Pivot_Transducer_Face_Dist
//

Pivot_Transducer_Face_Dist::
Pivot_Transducer_Face_Dist (const ::xml_schema::float_& _xsd_float__base,
                            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pivot_Transducer_Face_Dist::
Pivot_Transducer_Face_Dist (const Pivot_Transducer_Face_Dist& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Pivot_Transducer_Face_Dist::
Pivot_Transducer_Face_Dist (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pivot_Transducer_Face_Dist::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pivot_Transducer_Face_Dist* Pivot_Transducer_Face_Dist::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pivot_Transducer_Face_Dist (*this, f, c);
}

Pivot_Transducer_Face_Dist::
~Pivot_Transducer_Face_Dist ()
{
}

// Filter_Doppler
//

Filter_Doppler::
Filter_Doppler (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler::
Filter_Doppler (const Filter_Doppler& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler::
Filter_Doppler (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler* Filter_Doppler::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler (*this, f, c);
}

Filter_Doppler::
~Filter_Doppler ()
{
}

// Frequency
//

Frequency::
Frequency (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency::
Frequency (const Frequency& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency::
Frequency (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency* Frequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency (*this, f, c);
}

Frequency::
~Frequency ()
{
}

// Encoder_Separation
//

Encoder_Separation::
Encoder_Separation (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Separation::
Encoder_Separation (const Encoder_Separation& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Separation::
Encoder_Separation (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Separation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Separation* Encoder_Separation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Separation (*this, f, c);
}

Encoder_Separation::
~Encoder_Separation ()
{
}

// Overshoot
//

Overshoot::
Overshoot (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overshoot::
Overshoot (const Overshoot& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Overshoot::
Overshoot (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Overshoot::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Overshoot* Overshoot::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Overshoot (*this, f, c);
}

Overshoot::
~Overshoot ()
{
}

// Filter
//

Filter::
Filter (const ::xml_schema::float_& _xsd_float__base,
        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter::
Filter (const Filter& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter::
Filter (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter* Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter (*this, f, c);
}

Filter::
~Filter ()
{
}

// Default_Rx_Gain_Doppler
//

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const Default_Rx_Gain_Doppler& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Rx_Gain_Doppler::
Default_Rx_Gain_Doppler (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Rx_Gain_Doppler::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Rx_Gain_Doppler* Default_Rx_Gain_Doppler::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Rx_Gain_Doppler (*this, f, c);
}

Default_Rx_Gain_Doppler::
~Default_Rx_Gain_Doppler ()
{
}

// Filter_Doppler_Low
//

Filter_Doppler_Low::
Filter_Doppler_Low (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Low::
Filter_Doppler_Low (const Filter_Doppler_Low& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler_Low::
Filter_Doppler_Low (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler_Low::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler_Low* Filter_Doppler_Low::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler_Low (*this, f, c);
}

Filter_Doppler_Low::
~Filter_Doppler_Low ()
{
}

// Buffer_Size
//

Buffer_Size::
Buffer_Size (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size::
Buffer_Size (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size::
Buffer_Size (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size::
Buffer_Size (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size::
Buffer_Size (const Buffer_Size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Buffer_Size::
Buffer_Size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Buffer_Size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Buffer_Size* Buffer_Size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Buffer_Size (*this, f, c);
}

Buffer_Size::
~Buffer_Size ()
{
}

// BMode_Size_Default
//

BMode_Size_Default::
BMode_Size_Default (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default::
BMode_Size_Default (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default::
BMode_Size_Default (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default::
BMode_Size_Default (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default::
BMode_Size_Default (const BMode_Size_Default& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

BMode_Size_Default::
BMode_Size_Default (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void BMode_Size_Default::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

BMode_Size_Default* BMode_Size_Default::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BMode_Size_Default (*this, f, c);
}

BMode_Size_Default::
~BMode_Size_Default ()
{
}

// Refresh_Rate
//

Refresh_Rate::
Refresh_Rate (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate::
Refresh_Rate (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate::
Refresh_Rate (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate::
Refresh_Rate (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate::
Refresh_Rate (const Refresh_Rate& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Refresh_Rate::
Refresh_Rate (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Refresh_Rate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Refresh_Rate* Refresh_Rate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Refresh_Rate (*this, f, c);
}

Refresh_Rate::
~Refresh_Rate ()
{
}

// Power_Size_Default
//

Power_Size_Default::
Power_Size_Default (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default::
Power_Size_Default (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default::
Power_Size_Default (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default::
Power_Size_Default (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default::
Power_Size_Default (const Power_Size_Default& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Power_Size_Default::
Power_Size_Default (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Power_Size_Default::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Power_Size_Default* Power_Size_Default::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Power_Size_Default (*this, f, c);
}

Power_Size_Default::
~Power_Size_Default ()
{
}

// Target_Field_Of_View
//

Target_Field_Of_View::
Target_Field_Of_View (const ::xml_schema::float_& _xsd_float__base,
                      const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Target_Field_Of_View::
Target_Field_Of_View (const Target_Field_Of_View& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Target_Field_Of_View::
Target_Field_Of_View (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Target_Field_Of_View::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Target_Field_Of_View* Target_Field_Of_View::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Target_Field_Of_View (*this, f, c);
}

Target_Field_Of_View::
~Target_Field_Of_View ()
{
}

// Sound_Speed
//

Sound_Speed::
Sound_Speed (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed::
Sound_Speed (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed::
Sound_Speed (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed::
Sound_Speed (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed::
Sound_Speed (const Sound_Speed& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sound_Speed::
Sound_Speed (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sound_Speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sound_Speed* Sound_Speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sound_Speed (*this, f, c);
}

Sound_Speed::
~Sound_Speed ()
{
}

// Pipeline_Delay
//

Pipeline_Delay::
Pipeline_Delay (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay::
Pipeline_Delay (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay::
Pipeline_Delay (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay::
Pipeline_Delay (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay::
Pipeline_Delay (const Pipeline_Delay& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pipeline_Delay::
Pipeline_Delay (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pipeline_Delay::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pipeline_Delay* Pipeline_Delay::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pipeline_Delay (*this, f, c);
}

Pipeline_Delay::
~Pipeline_Delay ()
{
}

// Center
//

Center::
Center (const ::xml_schema::float_& _xsd_float__base,
        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Center::
Center (const Center& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Center::
Center (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Center* Center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Center (*this, f, c);
}

Center::
~Center ()
{
}

// V_Scan_Speed
//

V_Scan_Speed::
V_Scan_Speed (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed::
V_Scan_Speed (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed::
V_Scan_Speed (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed::
V_Scan_Speed (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed::
V_Scan_Speed (const V_Scan_Speed& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Scan_Speed::
V_Scan_Speed (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Scan_Speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Scan_Speed* V_Scan_Speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Scan_Speed (*this, f, c);
}

V_Scan_Speed::
~V_Scan_Speed ()
{
}

// V_Scan_Rate
//

V_Scan_Rate::
V_Scan_Rate (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Rate::
V_Scan_Rate (const V_Scan_Rate& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Scan_Rate::
V_Scan_Rate (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Scan_Rate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Scan_Rate* V_Scan_Rate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Scan_Rate (*this, f, c);
}

V_Scan_Rate::
~V_Scan_Rate ()
{
}

// Scan_Width
//

Scan_Width::
Scan_Width (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Width::
Scan_Width (const Scan_Width& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Width::
Scan_Width (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Width* Scan_Width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Width (*this, f, c);
}

Scan_Width::
~Scan_Width ()
{
}

// Position
//

Position::
Position (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position::
Position (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position::
Position (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position::
Position (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position::
Position (const Position& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position::
Position (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position* Position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position (*this, f, c);
}

Position::
~Position ()
{
}

// R_Scan_Move_No_Wait
//

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const R_Scan_Move_No_Wait& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move_No_Wait::
R_Scan_Move_No_Wait (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move_No_Wait::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move_No_Wait* R_Scan_Move_No_Wait::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move_No_Wait (*this, f, c);
}

R_Scan_Move_No_Wait::
~R_Scan_Move_No_Wait ()
{
}

// Acceleration
//

Acceleration::
Acceleration (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration::
Acceleration (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration::
Acceleration (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration::
Acceleration (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration::
Acceleration (const Acceleration& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Acceleration::
Acceleration (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Acceleration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Acceleration* Acceleration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acceleration (*this, f, c);
}

Acceleration::
~Acceleration ()
{
}

// Velocity_Stationary
//

Velocity_Stationary::
Velocity_Stationary (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary::
Velocity_Stationary (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary::
Velocity_Stationary (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary::
Velocity_Stationary (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary::
Velocity_Stationary (const Velocity_Stationary& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Velocity_Stationary::
Velocity_Stationary (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Velocity_Stationary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Velocity_Stationary* Velocity_Stationary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Velocity_Stationary (*this, f, c);
}

Velocity_Stationary::
~Velocity_Stationary ()
{
}

// R_Scan_Move2
//

R_Scan_Move2::
R_Scan_Move2 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move2::
R_Scan_Move2 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move2::
R_Scan_Move2 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move2::
R_Scan_Move2 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move2::
R_Scan_Move2 (const R_Scan_Move2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move2::
R_Scan_Move2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move2* R_Scan_Move2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move2 (*this, f, c);
}

R_Scan_Move2::
~R_Scan_Move2 ()
{
}

// Acceleration_Stationary
//

Acceleration_Stationary::
Acceleration_Stationary (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary::
Acceleration_Stationary (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary::
Acceleration_Stationary (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary::
Acceleration_Stationary (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary::
Acceleration_Stationary (const Acceleration_Stationary& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Acceleration_Stationary::
Acceleration_Stationary (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Acceleration_Stationary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Acceleration_Stationary* Acceleration_Stationary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acceleration_Stationary (*this, f, c);
}

Acceleration_Stationary::
~Acceleration_Stationary ()
{
}

// Position_Reverse
//

Position_Reverse::
Position_Reverse (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse::
Position_Reverse (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse::
Position_Reverse (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse::
Position_Reverse (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse::
Position_Reverse (const Position_Reverse& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position_Reverse::
Position_Reverse (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position_Reverse::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position_Reverse* Position_Reverse::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position_Reverse (*this, f, c);
}

Position_Reverse::
~Position_Reverse ()
{
}

// Position2
//

Position2::
Position2 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position2::
Position2 (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position2::
Position2 (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position2::
Position2 (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position2::
Position2 (const Position2& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position2::
Position2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position2* Position2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position2 (*this, f, c);
}

Position2::
~Position2 ()
{
}

// Velocity
//

Velocity::
Velocity (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity::
Velocity (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity::
Velocity (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity::
Velocity (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity::
Velocity (const Velocity& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Velocity::
Velocity (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Velocity* Velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Velocity (*this, f, c);
}

Velocity::
~Velocity ()
{
}

// R_Scan_Move
//

R_Scan_Move::
R_Scan_Move (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move::
R_Scan_Move (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move::
R_Scan_Move (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move::
R_Scan_Move (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move::
R_Scan_Move (const R_Scan_Move& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move::
R_Scan_Move (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move* R_Scan_Move::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move (*this, f, c);
}

R_Scan_Move::
~R_Scan_Move ()
{
}

// Position_Forward
//

Position_Forward::
Position_Forward (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward::
Position_Forward (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward::
Position_Forward (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward::
Position_Forward (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward::
Position_Forward (const Position_Forward& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position_Forward::
Position_Forward (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position_Forward::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position_Forward* Position_Forward::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position_Forward (*this, f, c);
}

Position_Forward::
~Position_Forward ()
{
}

// Monitor_3point3V
//

Monitor_3point3V::
Monitor_3point3V (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V::
Monitor_3point3V (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V::
Monitor_3point3V (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V::
Monitor_3point3V (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V::
Monitor_3point3V (const Monitor_3point3V& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_3point3V::
Monitor_3point3V (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_3point3V::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_3point3V* Monitor_3point3V::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_3point3V (*this, f, c);
}

Monitor_3point3V::
~Monitor_3point3V ()
{
}

// Monitor_15V
//

Monitor_15V::
Monitor_15V (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V::
Monitor_15V (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V::
Monitor_15V (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V::
Monitor_15V (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V::
Monitor_15V (const Monitor_15V& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_15V::
Monitor_15V (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_15V::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_15V* Monitor_15V::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_15V (*this, f, c);
}

Monitor_15V::
~Monitor_15V ()
{
}

// Monitor_5V
//

Monitor_5V::
Monitor_5V (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V::
Monitor_5V (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V::
Monitor_5V (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V::
Monitor_5V (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V::
Monitor_5V (const Monitor_5V& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_5V::
Monitor_5V (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_5V::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_5V* Monitor_5V::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_5V (*this, f, c);
}

Monitor_5V::
~Monitor_5V ()
{
}

// Monitor_Neg15V
//

Monitor_Neg15V::
Monitor_Neg15V (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V::
Monitor_Neg15V (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V::
Monitor_Neg15V (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V::
Monitor_Neg15V (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V::
Monitor_Neg15V (const Monitor_Neg15V& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_Neg15V::
Monitor_Neg15V (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_Neg15V::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_Neg15V* Monitor_Neg15V::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_Neg15V (*this, f, c);
}

Monitor_Neg15V::
~Monitor_Neg15V ()
{
}

// Monitor_Neg5V
//

Monitor_Neg5V::
Monitor_Neg5V (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V::
Monitor_Neg5V (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V::
Monitor_Neg5V (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V::
Monitor_Neg5V (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V::
Monitor_Neg5V (const Monitor_Neg5V& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_Neg5V::
Monitor_Neg5V (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_Neg5V::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_Neg5V* Monitor_Neg5V::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_Neg5V (*this, f, c);
}

Monitor_Neg5V::
~Monitor_Neg5V ()
{
}

// Respiration_Threshold_Change
//

Respiration_Threshold_Change::
Respiration_Threshold_Change (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change::
Respiration_Threshold_Change (const char* _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change::
Respiration_Threshold_Change (const ::std::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change::
Respiration_Threshold_Change (const ::xml_schema::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change::
Respiration_Threshold_Change (const Respiration_Threshold_Change& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Threshold_Change::
Respiration_Threshold_Change (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Threshold_Change::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Threshold_Change* Respiration_Threshold_Change::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Threshold_Change (*this, f, c);
}

Respiration_Threshold_Change::
~Respiration_Threshold_Change ()
{
}

// Pressure_Range
//

Pressure_Range::
Pressure_Range (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range::
Pressure_Range (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range::
Pressure_Range (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range::
Pressure_Range (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range::
Pressure_Range (const Pressure_Range& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Range::
Pressure_Range (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Range::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Range* Pressure_Range::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Range (*this, f, c);
}

Pressure_Range::
~Pressure_Range ()
{
}

// Respiration_Gate_Delay
//

Respiration_Gate_Delay::
Respiration_Gate_Delay (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay::
Respiration_Gate_Delay (const char* _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay::
Respiration_Gate_Delay (const ::std::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay::
Respiration_Gate_Delay (const ::xml_schema::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay::
Respiration_Gate_Delay (const Respiration_Gate_Delay& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Gate_Delay::
Respiration_Gate_Delay (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Gate_Delay::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Gate_Delay* Respiration_Gate_Delay::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Gate_Delay (*this, f, c);
}

Respiration_Gate_Delay::
~Respiration_Gate_Delay ()
{
}

// Respiration_Timeout
//

Respiration_Timeout::
Respiration_Timeout (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout::
Respiration_Timeout (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout::
Respiration_Timeout (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout::
Respiration_Timeout (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout::
Respiration_Timeout (const Respiration_Timeout& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Timeout::
Respiration_Timeout (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Timeout::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Timeout* Respiration_Timeout::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Timeout (*this, f, c);
}

Respiration_Timeout::
~Respiration_Timeout ()
{
}

// RWave_Max_Change_Factor_Percent
//

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const char* _xsd_string_base,
                                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const ::std::string& _xsd_string_base,
                                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const ::xml_schema::string& _xsd_string_base,
                                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const RWave_Max_Change_Factor_Percent& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Max_Change_Factor_Percent::
RWave_Max_Change_Factor_Percent (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Max_Change_Factor_Percent::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Max_Change_Factor_Percent* RWave_Max_Change_Factor_Percent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Max_Change_Factor_Percent (*this, f, c);
}

RWave_Max_Change_Factor_Percent::
~RWave_Max_Change_Factor_Percent ()
{
}

// Respiration_Period
//

Respiration_Period::
Respiration_Period (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period::
Respiration_Period (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period::
Respiration_Period (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period::
Respiration_Period (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period::
Respiration_Period (const Respiration_Period& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Period::
Respiration_Period (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Period::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Period* Respiration_Period::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Period (*this, f, c);
}

Respiration_Period::
~Respiration_Period ()
{
}

// Respiration_Subsample_Rate
//

Respiration_Subsample_Rate::
Respiration_Subsample_Rate (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Subsample_Rate::
Respiration_Subsample_Rate (const Respiration_Subsample_Rate& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Subsample_Rate::
Respiration_Subsample_Rate (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Subsample_Rate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Subsample_Rate* Respiration_Subsample_Rate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Subsample_Rate (*this, f, c);
}

Respiration_Subsample_Rate::
~Respiration_Subsample_Rate ()
{
}

// Respiration_Window
//

Respiration_Window::
Respiration_Window (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window::
Respiration_Window (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window::
Respiration_Window (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window::
Respiration_Window (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window::
Respiration_Window (const Respiration_Window& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Window::
Respiration_Window (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Window::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Window* Respiration_Window::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Window (*this, f, c);
}

Respiration_Window::
~Respiration_Window ()
{
}

// Pressure_Systolic
//

Pressure_Systolic::
Pressure_Systolic (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic::
Pressure_Systolic (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic::
Pressure_Systolic (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic::
Pressure_Systolic (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic::
Pressure_Systolic (const Pressure_Systolic& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Systolic::
Pressure_Systolic (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Systolic::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Systolic* Pressure_Systolic::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Systolic (*this, f, c);
}

Pressure_Systolic::
~Pressure_Systolic ()
{
}

// Frequency1
//

Frequency1::
Frequency1 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency1::
Frequency1 (const Frequency1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency1::
Frequency1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency1* Frequency1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency1 (*this, f, c);
}

Frequency1::
~Frequency1 ()
{
}

// Respiration_Blank_Period
//

Respiration_Blank_Period::
Respiration_Blank_Period (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                          const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Blank_Period::
Respiration_Blank_Period (const Respiration_Blank_Period& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Blank_Period::
Respiration_Blank_Period (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Blank_Period::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Blank_Period* Respiration_Blank_Period::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Blank_Period (*this, f, c);
}

Respiration_Blank_Period::
~Respiration_Blank_Period ()
{
}

// Respiration_Range
//

Respiration_Range::
Respiration_Range (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range::
Respiration_Range (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range::
Respiration_Range (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range::
Respiration_Range (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range::
Respiration_Range (const Respiration_Range& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Range::
Respiration_Range (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Range::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Range* Respiration_Range::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Range (*this, f, c);
}

Respiration_Range::
~Respiration_Range ()
{
}

// Pressure_Zero
//

Pressure_Zero::
Pressure_Zero (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero::
Pressure_Zero (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero::
Pressure_Zero (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero::
Pressure_Zero (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero::
Pressure_Zero (const Pressure_Zero& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Zero::
Pressure_Zero (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Zero::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Zero* Pressure_Zero::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Zero (*this, f, c);
}

Pressure_Zero::
~Pressure_Zero ()
{
}

// P_Wave_Start
//

P_Wave_Start::
P_Wave_Start (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start::
P_Wave_Start (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start::
P_Wave_Start (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start::
P_Wave_Start (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start::
P_Wave_Start (const P_Wave_Start& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

P_Wave_Start::
P_Wave_Start (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void P_Wave_Start::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

P_Wave_Start* P_Wave_Start::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class P_Wave_Start (*this, f, c);
}

P_Wave_Start::
~P_Wave_Start ()
{
}

// RWave_Future_Search_Time
//

RWave_Future_Search_Time::
RWave_Future_Search_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time::
RWave_Future_Search_Time (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time::
RWave_Future_Search_Time (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time::
RWave_Future_Search_Time (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time::
RWave_Future_Search_Time (const RWave_Future_Search_Time& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Future_Search_Time::
RWave_Future_Search_Time (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Future_Search_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Future_Search_Time* RWave_Future_Search_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Future_Search_Time (*this, f, c);
}

RWave_Future_Search_Time::
~RWave_Future_Search_Time ()
{
}

// Respiration_Percent_Peak
//

Respiration_Percent_Peak::
Respiration_Percent_Peak (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak::
Respiration_Percent_Peak (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak::
Respiration_Percent_Peak (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak::
Respiration_Percent_Peak (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak::
Respiration_Percent_Peak (const Respiration_Percent_Peak& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Percent_Peak::
Respiration_Percent_Peak (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Percent_Peak::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Percent_Peak* Respiration_Percent_Peak::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Percent_Peak (*this, f, c);
}

Respiration_Percent_Peak::
~Respiration_Percent_Peak ()
{
}

// T_Wave_Start
//

T_Wave_Start::
T_Wave_Start (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start::
T_Wave_Start (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start::
T_Wave_Start (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start::
T_Wave_Start (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start::
T_Wave_Start (const T_Wave_Start& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

T_Wave_Start::
T_Wave_Start (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void T_Wave_Start::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

T_Wave_Start* T_Wave_Start::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class T_Wave_Start (*this, f, c);
}

T_Wave_Start::
~T_Wave_Start ()
{
}

// Strain_Rate_RR_Diff_Ratio
//

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const char* _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const ::std::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const ::xml_schema::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const Strain_Rate_RR_Diff_Ratio& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Strain_Rate_RR_Diff_Ratio::
Strain_Rate_RR_Diff_Ratio (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Strain_Rate_RR_Diff_Ratio::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Strain_Rate_RR_Diff_Ratio* Strain_Rate_RR_Diff_Ratio::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Strain_Rate_RR_Diff_Ratio (*this, f, c);
}

Strain_Rate_RR_Diff_Ratio::
~Strain_Rate_RR_Diff_Ratio ()
{
}

// Pressure_Diastolic
//

Pressure_Diastolic::
Pressure_Diastolic (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic::
Pressure_Diastolic (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic::
Pressure_Diastolic (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic::
Pressure_Diastolic (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic::
Pressure_Diastolic (const Pressure_Diastolic& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Diastolic::
Pressure_Diastolic (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Diastolic::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Diastolic* Pressure_Diastolic::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Diastolic (*this, f, c);
}

Pressure_Diastolic::
~Pressure_Diastolic ()
{
}

// Temperature_Calibration
//

Temperature_Calibration::
Temperature_Calibration (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration::
Temperature_Calibration (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration::
Temperature_Calibration (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration::
Temperature_Calibration (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration::
Temperature_Calibration (const Temperature_Calibration& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Temperature_Calibration::
Temperature_Calibration (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Temperature_Calibration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Temperature_Calibration* Temperature_Calibration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Temperature_Calibration (*this, f, c);
}

Temperature_Calibration::
~Temperature_Calibration ()
{
}

// Temperature
//

Temperature::
Temperature (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature::
Temperature (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature::
Temperature (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature::
Temperature (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature::
Temperature (const Temperature& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Temperature::
Temperature (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Temperature::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Temperature* Temperature::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Temperature (*this, f, c);
}

Temperature::
~Temperature ()
{
}

// Respiration_Beats_To_Average
//

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const char* _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const ::std::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const ::xml_schema::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const Respiration_Beats_To_Average& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Beats_To_Average::
Respiration_Beats_To_Average (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Beats_To_Average::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Beats_To_Average* Respiration_Beats_To_Average::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Beats_To_Average (*this, f, c);
}

Respiration_Beats_To_Average::
~Respiration_Beats_To_Average ()
{
}

// RWave_Thresh_Trigger_Percent
//

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const char* _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const ::std::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const ::xml_schema::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const RWave_Thresh_Trigger_Percent& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Thresh_Trigger_Percent::
RWave_Thresh_Trigger_Percent (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Thresh_Trigger_Percent::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Thresh_Trigger_Percent* RWave_Thresh_Trigger_Percent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Thresh_Trigger_Percent (*this, f, c);
}

RWave_Thresh_Trigger_Percent::
~RWave_Thresh_Trigger_Percent ()
{
}

// Respiration_Time_To_Average
//

Respiration_Time_To_Average::
Respiration_Time_To_Average (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average::
Respiration_Time_To_Average (const char* _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average::
Respiration_Time_To_Average (const ::std::string& _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average::
Respiration_Time_To_Average (const ::xml_schema::string& _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average::
Respiration_Time_To_Average (const Respiration_Time_To_Average& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Time_To_Average::
Respiration_Time_To_Average (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Time_To_Average::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Time_To_Average* Respiration_Time_To_Average::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Time_To_Average (*this, f, c);
}

Respiration_Time_To_Average::
~Respiration_Time_To_Average ()
{
}

// Heart_Period
//

Heart_Period::
Heart_Period (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period::
Heart_Period (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period::
Heart_Period (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period::
Heart_Period (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period::
Heart_Period (const Heart_Period& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Heart_Period::
Heart_Period (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Heart_Period::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Heart_Period* Heart_Period::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Heart_Period (*this, f, c);
}

Heart_Period::
~Heart_Period ()
{
}

// ECG_Range
//

ECG_Range::
ECG_Range (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range::
ECG_Range (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range::
ECG_Range (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range::
ECG_Range (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range::
ECG_Range (const ECG_Range& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_Range::
ECG_Range (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_Range::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_Range* ECG_Range::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_Range (*this, f, c);
}

ECG_Range::
~ECG_Range ()
{
}

// RWave_Maxima_Block_Time
//

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const RWave_Maxima_Block_Time& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Maxima_Block_Time::
RWave_Maxima_Block_Time (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Maxima_Block_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Maxima_Block_Time* RWave_Maxima_Block_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Maxima_Block_Time (*this, f, c);
}

RWave_Maxima_Block_Time::
~RWave_Maxima_Block_Time ()
{
}

// Pressure_Calibration_Level
//

Pressure_Calibration_Level::
Pressure_Calibration_Level (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level::
Pressure_Calibration_Level (const char* _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level::
Pressure_Calibration_Level (const ::std::string& _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level::
Pressure_Calibration_Level (const ::xml_schema::string& _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level::
Pressure_Calibration_Level (const Pressure_Calibration_Level& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Calibration_Level::
Pressure_Calibration_Level (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Calibration_Level::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Calibration_Level* Pressure_Calibration_Level::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Calibration_Level (*this, f, c);
}

Pressure_Calibration_Level::
~Pressure_Calibration_Level ()
{
}

// ECG_HP_Filter
//

ECG_HP_Filter::
ECG_HP_Filter (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_HP_Filter::
ECG_HP_Filter (const ECG_HP_Filter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_HP_Filter::
ECG_HP_Filter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_HP_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_HP_Filter* ECG_HP_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_HP_Filter (*this, f, c);
}

ECG_HP_Filter::
~ECG_HP_Filter ()
{
}

// ECG_LP_Filter
//

ECG_LP_Filter::
ECG_LP_Filter (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_LP_Filter::
ECG_LP_Filter (const ECG_LP_Filter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_LP_Filter::
ECG_LP_Filter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_LP_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_LP_Filter* ECG_LP_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_LP_Filter (*this, f, c);
}

ECG_LP_Filter::
~ECG_LP_Filter ()
{
}

// RWave_Max_Change_Period
//

RWave_Max_Change_Period::
RWave_Max_Change_Period (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period::
RWave_Max_Change_Period (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period::
RWave_Max_Change_Period (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period::
RWave_Max_Change_Period (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period::
RWave_Max_Change_Period (const RWave_Max_Change_Period& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Max_Change_Period::
RWave_Max_Change_Period (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Max_Change_Period::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Max_Change_Period* RWave_Max_Change_Period::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Max_Change_Period (*this, f, c);
}

RWave_Max_Change_Period::
~RWave_Max_Change_Period ()
{
}

// Pressure_Calibration
//

Pressure_Calibration::
Pressure_Calibration (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration::
Pressure_Calibration (const char* _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration::
Pressure_Calibration (const ::std::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration::
Pressure_Calibration (const ::xml_schema::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration::
Pressure_Calibration (const Pressure_Calibration& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Calibration::
Pressure_Calibration (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Calibration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Calibration* Pressure_Calibration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Calibration (*this, f, c);
}

Pressure_Calibration::
~Pressure_Calibration ()
{
}

// RWave_Blank_Time
//

RWave_Blank_Time::
RWave_Blank_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time::
RWave_Blank_Time (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time::
RWave_Blank_Time (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time::
RWave_Blank_Time (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time::
RWave_Blank_Time (const RWave_Blank_Time& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Blank_Time::
RWave_Blank_Time (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Blank_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Blank_Time* RWave_Blank_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Blank_Time (*this, f, c);
}

RWave_Blank_Time::
~RWave_Blank_Time ()
{
}

// Magnitude_Origin
//

Magnitude_Origin::
Magnitude_Origin (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Origin::
Magnitude_Origin (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Origin::
Magnitude_Origin (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Origin::
Magnitude_Origin (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Origin::
Magnitude_Origin (const Magnitude_Origin& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Magnitude_Origin::
Magnitude_Origin (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Magnitude_Origin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Magnitude_Origin* Magnitude_Origin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Magnitude_Origin (*this, f, c);
}

Magnitude_Origin::
~Magnitude_Origin ()
{
}

// Frequency_Origin
//

Frequency_Origin::
Frequency_Origin (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Origin::
Frequency_Origin (const Frequency_Origin& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Origin::
Frequency_Origin (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Origin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Origin* Frequency_Origin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Origin (*this, f, c);
}

Frequency_Origin::
~Frequency_Origin ()
{
}

// Length_Origin
//

Length_Origin::
Length_Origin (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Length_Origin::
Length_Origin (const Length_Origin& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Length_Origin::
Length_Origin (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Length_Origin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Length_Origin* Length_Origin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Length_Origin (*this, f, c);
}

Length_Origin::
~Length_Origin ()
{
}

// Vertical_Scale
//

Vertical_Scale::
Vertical_Scale (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Vertical_Scale::
Vertical_Scale (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Vertical_Scale::
Vertical_Scale (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Vertical_Scale::
Vertical_Scale (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Vertical_Scale::
Vertical_Scale (const Vertical_Scale& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Vertical_Scale::
Vertical_Scale (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Vertical_Scale::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Vertical_Scale* Vertical_Scale::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vertical_Scale (*this, f, c);
}

Vertical_Scale::
~Vertical_Scale ()
{
}

// SamplesPerSec
//

SamplesPerSec::
SamplesPerSec (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

SamplesPerSec::
SamplesPerSec (const SamplesPerSec& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

SamplesPerSec::
SamplesPerSec (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void SamplesPerSec::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

SamplesPerSec* SamplesPerSec::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SamplesPerSec (*this, f, c);
}

SamplesPerSec::
~SamplesPerSec ()
{
}

// Magnitude_Height
//

Magnitude_Height::
Magnitude_Height (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Height::
Magnitude_Height (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Height::
Magnitude_Height (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Height::
Magnitude_Height (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Magnitude_Height::
Magnitude_Height (const Magnitude_Height& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Magnitude_Height::
Magnitude_Height (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Magnitude_Height::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Magnitude_Height* Magnitude_Height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Magnitude_Height (*this, f, c);
}

Magnitude_Height::
~Magnitude_Height ()
{
}

// Length_Length
//

Length_Length::
Length_Length (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Length_Length::
Length_Length (const Length_Length& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Length_Length::
Length_Length (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Length_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Length_Length* Length_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Length_Length (*this, f, c);
}

Length_Length::
~Length_Length ()
{
}

// Frequency_Length
//

Frequency_Length::
Frequency_Length (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Length::
Frequency_Length (const Frequency_Length& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Length::
Frequency_Length (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Length* Frequency_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Length (*this, f, c);
}

Frequency_Length::
~Frequency_Length ()
{
}

// SV_Center
//

SV_Center::
SV_Center (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

SV_Center::
SV_Center (const SV_Center& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

SV_Center::
SV_Center (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void SV_Center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

SV_Center* SV_Center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SV_Center (*this, f, c);
}

SV_Center::
~SV_Center ()
{
}

// RF_Path_15Mhz_Time_Correction
//

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const char* _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const ::std::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const ::xml_schema::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const RF_Path_15Mhz_Time_Correction& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Path_15Mhz_Time_Correction::
RF_Path_15Mhz_Time_Correction (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Path_15Mhz_Time_Correction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Path_15Mhz_Time_Correction* RF_Path_15Mhz_Time_Correction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Path_15Mhz_Time_Correction (*this, f, c);
}

RF_Path_15Mhz_Time_Correction::
~RF_Path_15Mhz_Time_Correction ()
{
}

// RF_Path_23Mhz_Time_Correction
//

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const char* _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const ::std::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const ::xml_schema::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const RF_Path_23Mhz_Time_Correction& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Path_23Mhz_Time_Correction::
RF_Path_23Mhz_Time_Correction (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Path_23Mhz_Time_Correction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Path_23Mhz_Time_Correction* RF_Path_23Mhz_Time_Correction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Path_23Mhz_Time_Correction (*this, f, c);
}

RF_Path_23Mhz_Time_Correction::
~RF_Path_23Mhz_Time_Correction ()
{
}

// SV_Length_Limits
//

SV_Length_Limits::
SV_Length_Limits (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

SV_Length_Limits::
SV_Length_Limits (const SV_Length_Limits& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

SV_Length_Limits::
SV_Length_Limits (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void SV_Length_Limits::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

SV_Length_Limits* SV_Length_Limits::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SV_Length_Limits (*this, f, c);
}

SV_Length_Limits::
~SV_Length_Limits ()
{
}

// V_Transmit_Length
//

V_Transmit_Length::
V_Transmit_Length (const ::xml_schema::float_& _xsd_float__base,
                   const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Transmit_Length::
V_Transmit_Length (const V_Transmit_Length& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Transmit_Length::
V_Transmit_Length (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Transmit_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Transmit_Length* V_Transmit_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Transmit_Length (*this, f, c);
}

V_Transmit_Length::
~V_Transmit_Length ()
{
}

// V_Pulse_Rep_Freq
//

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const V_Pulse_Rep_Freq& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Pulse_Rep_Freq::
V_Pulse_Rep_Freq (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Pulse_Rep_Freq::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Pulse_Rep_Freq* V_Pulse_Rep_Freq::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Pulse_Rep_Freq (*this, f, c);
}

V_Pulse_Rep_Freq::
~V_Pulse_Rep_Freq ()
{
}

// Frequency2
//

Frequency2::
Frequency2 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency2::
Frequency2 (const Frequency2& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency2::
Frequency2 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency2* Frequency2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency2 (*this, f, c);
}

Frequency2::
~Frequency2 ()
{
}

// V_Unblank_Time
//

V_Unblank_Time::
V_Unblank_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time::
V_Unblank_Time (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time::
V_Unblank_Time (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time::
V_Unblank_Time (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time::
V_Unblank_Time (const V_Unblank_Time& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Unblank_Time::
V_Unblank_Time (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Unblank_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Unblank_Time* V_Unblank_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Unblank_Time (*this, f, c);
}

V_Unblank_Time::
~V_Unblank_Time ()
{
}

// V_Frequency
//

V_Frequency::
V_Frequency (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Frequency::
V_Frequency (const V_Frequency& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Frequency::
V_Frequency (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Frequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Frequency* V_Frequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Frequency (*this, f, c);
}

V_Frequency::
~V_Frequency ()
{
}

// Pulse_Rep_Frequency
//

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const Pulse_Rep_Frequency& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pulse_Rep_Frequency::
Pulse_Rep_Frequency (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pulse_Rep_Frequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pulse_Rep_Frequency* Pulse_Rep_Frequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pulse_Rep_Frequency (*this, f, c);
}

Pulse_Rep_Frequency::
~Pulse_Rep_Frequency ()
{
}

// Trig_Tbl_Trigs
//

Trig_Tbl_Trigs::
Trig_Tbl_Trigs (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Trig_Tbl_Trigs::
Trig_Tbl_Trigs (const Trig_Tbl_Trigs& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Trig_Tbl_Trigs::
Trig_Tbl_Trigs (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Trig_Tbl_Trigs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Trig_Tbl_Trigs* Trig_Tbl_Trigs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Trig_Tbl_Trigs (*this, f, c);
}

Trig_Tbl_Trigs::
~Trig_Tbl_Trigs ()
{
}

// Unblank_Cycles
//

Unblank_Cycles::
Unblank_Cycles (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles::
Unblank_Cycles (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles::
Unblank_Cycles (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles::
Unblank_Cycles (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles::
Unblank_Cycles (const Unblank_Cycles& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Unblank_Cycles::
Unblank_Cycles (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Unblank_Cycles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Unblank_Cycles* Unblank_Cycles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unblank_Cycles (*this, f, c);
}

Unblank_Cycles::
~Unblank_Cycles ()
{
}

// Unblank_Time
//

Unblank_Time::
Unblank_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time::
Unblank_Time (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time::
Unblank_Time (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time::
Unblank_Time (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time::
Unblank_Time (const Unblank_Time& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Unblank_Time::
Unblank_Time (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Unblank_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Unblank_Time* Unblank_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unblank_Time (*this, f, c);
}

Unblank_Time::
~Unblank_Time ()
{
}

// Attenuation
//

Attenuation::
Attenuation (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation::
Attenuation (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation::
Attenuation (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation::
Attenuation (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation::
Attenuation (const Attenuation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Attenuation::
Attenuation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Attenuation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Attenuation* Attenuation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Attenuation (*this, f, c);
}

Attenuation::
~Attenuation ()
{
}

// V_Power
//

V_Power::
V_Power (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power::
V_Power (const char* _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power::
V_Power (const ::std::string& _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power::
V_Power (const ::xml_schema::string& _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power::
V_Power (const V_Power& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Power::
V_Power (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Power::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Power* V_Power::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Power (*this, f, c);
}

V_Power::
~V_Power ()
{
}

// Scan_Distance
//

Scan_Distance::
Scan_Distance (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Distance::
Scan_Distance (const Scan_Distance& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Distance::
Scan_Distance (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Distance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Distance* Scan_Distance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Distance (*this, f, c);
}

Scan_Distance::
~Scan_Distance ()
{
}

// Step_Size
//

Step_Size::
Step_Size (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Step_Size::
Step_Size (const Step_Size& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Step_Size::
Step_Size (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Step_Size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Step_Size* Step_Size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Step_Size (*this, f, c);
}

Step_Size::
~Step_Size ()
{
}

// Ref_Probe_Focal_Length
//

Ref_Probe_Focal_Length::
Ref_Probe_Focal_Length (const ::xml_schema::float_& _xsd_float__base,
                        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Probe_Focal_Length::
Ref_Probe_Focal_Length (const Ref_Probe_Focal_Length& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Ref_Probe_Focal_Length::
Ref_Probe_Focal_Length (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Ref_Probe_Focal_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Ref_Probe_Focal_Length* Ref_Probe_Focal_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Ref_Probe_Focal_Length (*this, f, c);
}

Ref_Probe_Focal_Length::
~Ref_Probe_Focal_Length ()
{
}

// Ref_Tx_Frequency
//

Ref_Tx_Frequency::
Ref_Tx_Frequency (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Tx_Frequency::
Ref_Tx_Frequency (const Ref_Tx_Frequency& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Ref_Tx_Frequency::
Ref_Tx_Frequency (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Ref_Tx_Frequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Ref_Tx_Frequency* Ref_Tx_Frequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Ref_Tx_Frequency (*this, f, c);
}

Ref_Tx_Frequency::
~Ref_Tx_Frequency ()
{
}

// Normalized_Height
//

Normalized_Height::
Normalized_Height (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Height::
Normalized_Height (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Height::
Normalized_Height (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Height::
Normalized_Height (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Height::
Normalized_Height (const Normalized_Height& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Normalized_Height::
Normalized_Height (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Normalized_Height::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Normalized_Height* Normalized_Height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Normalized_Height (*this, f, c);
}

Normalized_Height::
~Normalized_Height ()
{
}

// Normalized_Origin
//

Normalized_Origin::
Normalized_Origin (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Origin::
Normalized_Origin (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Origin::
Normalized_Origin (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Origin::
Normalized_Origin (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Normalized_Origin::
Normalized_Origin (const Normalized_Origin& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Normalized_Origin::
Normalized_Origin (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Normalized_Origin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Normalized_Origin* Normalized_Origin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Normalized_Origin (*this, f, c);
}

Normalized_Origin::
~Normalized_Origin ()
{
}

// Ref_Tx_Power
//

Ref_Tx_Power::
Ref_Tx_Power (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Tx_Power::
Ref_Tx_Power (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Tx_Power::
Ref_Tx_Power (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Tx_Power::
Ref_Tx_Power (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Ref_Tx_Power::
Ref_Tx_Power (const Ref_Tx_Power& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Ref_Tx_Power::
Ref_Tx_Power (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Ref_Tx_Power::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Ref_Tx_Power* Ref_Tx_Power::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Ref_Tx_Power (*this, f, c);
}

Ref_Tx_Power::
~Ref_Tx_Power ()
{
}

// Freq_Range_Max
//

Freq_Range_Max::
Freq_Range_Max (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Freq_Range_Max::
Freq_Range_Max (const Freq_Range_Max& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Freq_Range_Max::
Freq_Range_Max (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Freq_Range_Max::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Freq_Range_Max* Freq_Range_Max::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Freq_Range_Max (*this, f, c);
}

Freq_Range_Max::
~Freq_Range_Max ()
{
}

// Freq_Range_Min
//

Freq_Range_Min::
Freq_Range_Min (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Freq_Range_Min::
Freq_Range_Min (const Freq_Range_Min& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Freq_Range_Min::
Freq_Range_Min (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Freq_Range_Min::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Freq_Range_Min* Freq_Range_Min::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Freq_Range_Min (*this, f, c);
}

Freq_Range_Min::
~Freq_Range_Min ()
{
}

// Sector_Width_Target
//

Sector_Width_Target::
Sector_Width_Target (const ::xml_schema::float_& _xsd_float__base,
                     const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Width_Target::
Sector_Width_Target (const Sector_Width_Target& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Width_Target::
Sector_Width_Target (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Width_Target::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Width_Target* Sector_Width_Target::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Width_Target (*this, f, c);
}

Sector_Width_Target::
~Sector_Width_Target ()
{
}

// RF_Gain
//

RF_Gain::
RF_Gain (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain::
RF_Gain (const char* _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain::
RF_Gain (const ::std::string& _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain::
RF_Gain (const ::xml_schema::string& _xsd_string_base,
         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain::
RF_Gain (const RF_Gain& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Gain::
RF_Gain (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Gain::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Gain* RF_Gain::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Gain (*this, f, c);
}

RF_Gain::
~RF_Gain ()
{
}

// V_Digi_Depth_Imaging
//

V_Digi_Depth_Imaging::
V_Digi_Depth_Imaging (const ::xml_schema::float_& _xsd_float__base,
                      const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Digi_Depth_Imaging::
V_Digi_Depth_Imaging (const V_Digi_Depth_Imaging& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Digi_Depth_Imaging::
V_Digi_Depth_Imaging (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Digi_Depth_Imaging::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Digi_Depth_Imaging* V_Digi_Depth_Imaging::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Digi_Depth_Imaging (*this, f, c);
}

V_Digi_Depth_Imaging::
~V_Digi_Depth_Imaging ()
{
}

// Test_Freq
//

Test_Freq::
Test_Freq (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq::
Test_Freq (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq::
Test_Freq (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq::
Test_Freq (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq::
Test_Freq (const Test_Freq& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Test_Freq::
Test_Freq (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Test_Freq::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Test_Freq* Test_Freq::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Test_Freq (*this, f, c);
}

Test_Freq::
~Test_Freq ()
{
}

// IF_Filter
//

IF_Filter::
IF_Filter (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

IF_Filter::
IF_Filter (const IF_Filter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

IF_Filter::
IF_Filter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void IF_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

IF_Filter* IF_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IF_Filter (*this, f, c);
}

IF_Filter::
~IF_Filter ()
{
}

// Track_Width
//

Track_Width::
Track_Width (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width::
Track_Width (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width::
Track_Width (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width::
Track_Width (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width::
Track_Width (const Track_Width& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Track_Width::
Track_Width (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Track_Width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Track_Width* Track_Width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Track_Width (*this, f, c);
}

Track_Width::
~Track_Width ()
{
}

// V_IF_Filter
//

V_IF_Filter::
V_IF_Filter (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_IF_Filter::
V_IF_Filter (const V_IF_Filter& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_IF_Filter::
V_IF_Filter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_IF_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_IF_Filter* V_IF_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_IF_Filter (*this, f, c);
}

V_IF_Filter::
~V_IF_Filter ()
{
}

// HP_Clutter
//

HP_Clutter::
HP_Clutter (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

HP_Clutter::
HP_Clutter (const HP_Clutter& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

HP_Clutter::
HP_Clutter (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void HP_Clutter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

HP_Clutter* HP_Clutter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HP_Clutter (*this, f, c);
}

HP_Clutter::
~HP_Clutter ()
{
}

// RF_Filter
//

RF_Filter::
RF_Filter (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Filter::
RF_Filter (const RF_Filter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Filter::
RF_Filter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Filter* RF_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Filter (*this, f, c);
}

RF_Filter::
~RF_Filter ()
{
}

// V_RF_Filter
//

V_RF_Filter::
V_RF_Filter (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_RF_Filter::
V_RF_Filter (const V_RF_Filter& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_RF_Filter::
V_RF_Filter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_RF_Filter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_RF_Filter* V_RF_Filter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_RF_Filter (*this, f, c);
}

V_RF_Filter::
~V_RF_Filter ()
{
}

// Delay
//

Delay::
Delay (const ::xml_schema::float_& _xsd_float__base,
       const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Delay::
Delay (const Delay& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Delay::
Delay (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Delay::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Delay* Delay::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Delay (*this, f, c);
}

Delay::
~Delay ()
{
}

// AD_Gate_Width
//

AD_Gate_Width::
AD_Gate_Width (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_Gate_Width::
AD_Gate_Width (const AD_Gate_Width& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

AD_Gate_Width::
AD_Gate_Width (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void AD_Gate_Width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

AD_Gate_Width* AD_Gate_Width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AD_Gate_Width (*this, f, c);
}

AD_Gate_Width::
~AD_Gate_Width ()
{
}

// Frequency3
//

Frequency3::
Frequency3 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency3::
Frequency3 (const Frequency3& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency3::
Frequency3 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency3* Frequency3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency3 (*this, f, c);
}

Frequency3::
~Frequency3 ()
{
}

// V_Frequency1
//

V_Frequency1::
V_Frequency1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Frequency1::
V_Frequency1 (const V_Frequency1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Frequency1::
V_Frequency1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Frequency1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Frequency1* V_Frequency1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Frequency1 (*this, f, c);
}

V_Frequency1::
~V_Frequency1 ()
{
}

// V_Field_Of_View
//

V_Field_Of_View::
V_Field_Of_View (const ::xml_schema::float_& _xsd_float__base,
                 const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Field_Of_View::
V_Field_Of_View (const V_Field_Of_View& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Field_Of_View::
V_Field_Of_View (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Field_Of_View::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Field_Of_View* V_Field_Of_View::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Field_Of_View (*this, f, c);
}

V_Field_Of_View::
~V_Field_Of_View ()
{
}

// Sector_Height_Target
//

Sector_Height_Target::
Sector_Height_Target (const ::xml_schema::float_& _xsd_float__base,
                      const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Height_Target::
Sector_Height_Target (const Sector_Height_Target& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Height_Target::
Sector_Height_Target (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Height_Target::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Height_Target* Sector_Height_Target::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Height_Target (*this, f, c);
}

Sector_Height_Target::
~Sector_Height_Target ()
{
}

// AD_TestIn
//

AD_TestIn::
AD_TestIn (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn::
AD_TestIn (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn::
AD_TestIn (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn::
AD_TestIn (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn::
AD_TestIn (const AD_TestIn& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

AD_TestIn::
AD_TestIn (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void AD_TestIn::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

AD_TestIn* AD_TestIn::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AD_TestIn (*this, f, c);
}

AD_TestIn::
~AD_TestIn ()
{
}

// V_Delay_Length
//

V_Delay_Length::
V_Delay_Length (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Delay_Length::
V_Delay_Length (const V_Delay_Length& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Delay_Length::
V_Delay_Length (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Delay_Length::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Delay_Length* V_Delay_Length::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Delay_Length (*this, f, c);
}

V_Delay_Length::
~V_Delay_Length ()
{
}

// Window_Time
//

Window_Time::
Window_Time (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time::
Window_Time (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time::
Window_Time (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time::
Window_Time (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time::
Window_Time (const Window_Time& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Window_Time::
Window_Time (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Window_Time::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Window_Time* Window_Time::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Window_Time (*this, f, c);
}

Window_Time::
~Window_Time ()
{
}

// Sample_Time1
//

Sample_Time1::
Sample_Time1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sample_Time1::
Sample_Time1 (const Sample_Time1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sample_Time1::
Sample_Time1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sample_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sample_Time1* Sample_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sample_Time1 (*this, f, c);
}

Sample_Time1::
~Sample_Time1 ()
{
}

// Focal_Length1
//

Focal_Length1::
Focal_Length1 (const ::xml_schema::float_& _xsd_float__base,
               const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Focal_Length1::
Focal_Length1 (const Focal_Length1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Focal_Length1::
Focal_Length1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Focal_Length1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Focal_Length1* Focal_Length1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Focal_Length1 (*this, f, c);
}

Focal_Length1::
~Focal_Length1 ()
{
}

// Default_Scan_Speed1
//

Default_Scan_Speed1::
Default_Scan_Speed1 (const ::xml_schema::float_& _xsd_float__base,
                     const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Scan_Speed1::
Default_Scan_Speed1 (const Default_Scan_Speed1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Scan_Speed1::
Default_Scan_Speed1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Scan_Speed1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Scan_Speed1* Default_Scan_Speed1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Scan_Speed1 (*this, f, c);
}

Default_Scan_Speed1::
~Default_Scan_Speed1 ()
{
}

// Cutoff_Scan_Speed1
//

Cutoff_Scan_Speed1::
Cutoff_Scan_Speed1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Cutoff_Scan_Speed1::
Cutoff_Scan_Speed1 (const Cutoff_Scan_Speed1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Cutoff_Scan_Speed1::
Cutoff_Scan_Speed1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Cutoff_Scan_Speed1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Cutoff_Scan_Speed1* Cutoff_Scan_Speed1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Cutoff_Scan_Speed1 (*this, f, c);
}

Cutoff_Scan_Speed1::
~Cutoff_Scan_Speed1 ()
{
}

// Frequency_Low1
//

Frequency_Low1::
Frequency_Low1 (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Low1::
Frequency_Low1 (const Frequency_Low1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Low1::
Frequency_Low1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Low1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Low1* Frequency_Low1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Low1 (*this, f, c);
}

Frequency_Low1::
~Frequency_Low1 ()
{
}

// Default_FOV1
//

Default_FOV1::
Default_FOV1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_FOV1::
Default_FOV1 (const Default_FOV1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_FOV1::
Default_FOV1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_FOV1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_FOV1* Default_FOV1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_FOV1 (*this, f, c);
}

Default_FOV1::
~Default_FOV1 ()
{
}

// Frequency_Doppler_Default1
//

Frequency_Doppler_Default1::
Frequency_Doppler_Default1 (const ::xml_schema::float_& _xsd_float__base,
                            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler_Default1::
Frequency_Doppler_Default1 (const Frequency_Doppler_Default1& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler_Default1::
Frequency_Doppler_Default1 (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler_Default1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler_Default1* Frequency_Doppler_Default1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler_Default1 (*this, f, c);
}

Frequency_Doppler_Default1::
~Frequency_Doppler_Default1 ()
{
}

// Axial_Res1
//

Axial_Res1::
Axial_Res1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res1::
Axial_Res1 (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res1::
Axial_Res1 (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res1::
Axial_Res1 (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Axial_Res1::
Axial_Res1 (const Axial_Res1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Axial_Res1::
Axial_Res1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Axial_Res1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Axial_Res1* Axial_Res1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Axial_Res1 (*this, f, c);
}

Axial_Res1::
~Axial_Res1 ()
{
}

// Pivot_Encoder_Dist1
//

Pivot_Encoder_Dist1::
Pivot_Encoder_Dist1 (const ::xml_schema::float_& _xsd_float__base,
                     const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pivot_Encoder_Dist1::
Pivot_Encoder_Dist1 (const Pivot_Encoder_Dist1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Pivot_Encoder_Dist1::
Pivot_Encoder_Dist1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pivot_Encoder_Dist1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pivot_Encoder_Dist1* Pivot_Encoder_Dist1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pivot_Encoder_Dist1 (*this, f, c);
}

Pivot_Encoder_Dist1::
~Pivot_Encoder_Dist1 ()
{
}

// Encoder_Range_Max1
//

Encoder_Range_Max1::
Encoder_Range_Max1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Range_Max1::
Encoder_Range_Max1 (const Encoder_Range_Max1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Range_Max1::
Encoder_Range_Max1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Range_Max1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Range_Max1* Encoder_Range_Max1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Range_Max1 (*this, f, c);
}

Encoder_Range_Max1::
~Encoder_Range_Max1 ()
{
}

// Encoder_Range_Min1
//

Encoder_Range_Min1::
Encoder_Range_Min1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Range_Min1::
Encoder_Range_Min1 (const Encoder_Range_Min1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Range_Min1::
Encoder_Range_Min1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Range_Min1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Range_Min1* Encoder_Range_Min1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Range_Min1 (*this, f, c);
}

Encoder_Range_Min1::
~Encoder_Range_Min1 ()
{
}

// Lateral_Res1
//

Lateral_Res1::
Lateral_Res1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res1::
Lateral_Res1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res1::
Lateral_Res1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res1::
Lateral_Res1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Lateral_Res1::
Lateral_Res1 (const Lateral_Res1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Lateral_Res1::
Lateral_Res1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Lateral_Res1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Lateral_Res1* Lateral_Res1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Lateral_Res1 (*this, f, c);
}

Lateral_Res1::
~Lateral_Res1 ()
{
}

// Max_Scan_Distance1
//

Max_Scan_Distance1::
Max_Scan_Distance1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Max_Scan_Distance1::
Max_Scan_Distance1 (const Max_Scan_Distance1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Max_Scan_Distance1::
Max_Scan_Distance1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Max_Scan_Distance1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Max_Scan_Distance1* Max_Scan_Distance1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Max_Scan_Distance1 (*this, f, c);
}

Max_Scan_Distance1::
~Max_Scan_Distance1 ()
{
}

// Default_Rx_Gain1
//

Default_Rx_Gain1::
Default_Rx_Gain1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain1::
Default_Rx_Gain1 (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain1::
Default_Rx_Gain1 (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain1::
Default_Rx_Gain1 (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain1::
Default_Rx_Gain1 (const Default_Rx_Gain1& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Rx_Gain1::
Default_Rx_Gain1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Rx_Gain1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Rx_Gain1* Default_Rx_Gain1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Rx_Gain1 (*this, f, c);
}

Default_Rx_Gain1::
~Default_Rx_Gain1 ()
{
}

// Frequency_High1
//

Frequency_High1::
Frequency_High1 (const ::xml_schema::float_& _xsd_float__base,
                 const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_High1::
Frequency_High1 (const Frequency_High1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_High1::
Frequency_High1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_High1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_High1* Frequency_High1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_High1 (*this, f, c);
}

Frequency_High1::
~Frequency_High1 ()
{
}

// Scan_Speeds1
//

Scan_Speeds1::
Scan_Speeds1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Speeds1::
Scan_Speeds1 (const Scan_Speeds1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Speeds1::
Scan_Speeds1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Speeds1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Speeds1* Scan_Speeds1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Speeds1 (*this, f, c);
}

Scan_Speeds1::
~Scan_Speeds1 ()
{
}

// Filter_Doppler_Cutoff1
//

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const char* _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const ::std::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const ::xml_schema::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const Filter_Doppler_Cutoff1& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler_Cutoff1::
Filter_Doppler_Cutoff1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler_Cutoff1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler_Cutoff1* Filter_Doppler_Cutoff1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler_Cutoff1 (*this, f, c);
}

Filter_Doppler_Cutoff1::
~Filter_Doppler_Cutoff1 ()
{
}

// Frequency_Doppler_Low1
//

Frequency_Doppler_Low1::
Frequency_Doppler_Low1 (const ::xml_schema::float_& _xsd_float__base,
                        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler_Low1::
Frequency_Doppler_Low1 (const Frequency_Doppler_Low1& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler_Low1::
Frequency_Doppler_Low1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler_Low1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler_Low1* Frequency_Doppler_Low1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler_Low1 (*this, f, c);
}

Frequency_Doppler_Low1::
~Frequency_Doppler_Low1 ()
{
}

// Pivot_Transducer_Face_Dist1
//

Pivot_Transducer_Face_Dist1::
Pivot_Transducer_Face_Dist1 (const ::xml_schema::float_& _xsd_float__base,
                             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pivot_Transducer_Face_Dist1::
Pivot_Transducer_Face_Dist1 (const Pivot_Transducer_Face_Dist1& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Pivot_Transducer_Face_Dist1::
Pivot_Transducer_Face_Dist1 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pivot_Transducer_Face_Dist1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pivot_Transducer_Face_Dist1* Pivot_Transducer_Face_Dist1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pivot_Transducer_Face_Dist1 (*this, f, c);
}

Pivot_Transducer_Face_Dist1::
~Pivot_Transducer_Face_Dist1 ()
{
}

// Filter_Doppler1
//

Filter_Doppler1::
Filter_Doppler1 (const ::xml_schema::float_& _xsd_float__base,
                 const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler1::
Filter_Doppler1 (const Filter_Doppler1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler1::
Filter_Doppler1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler1* Filter_Doppler1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler1 (*this, f, c);
}

Filter_Doppler1::
~Filter_Doppler1 ()
{
}

// Frequency4
//

Frequency4::
Frequency4 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency4::
Frequency4 (const Frequency4& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency4::
Frequency4 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency4::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency4* Frequency4::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency4 (*this, f, c);
}

Frequency4::
~Frequency4 ()
{
}

// Encoder_Separation1
//

Encoder_Separation1::
Encoder_Separation1 (const ::xml_schema::float_& _xsd_float__base,
                     const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Encoder_Separation1::
Encoder_Separation1 (const Encoder_Separation1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Encoder_Separation1::
Encoder_Separation1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Encoder_Separation1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Encoder_Separation1* Encoder_Separation1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Encoder_Separation1 (*this, f, c);
}

Encoder_Separation1::
~Encoder_Separation1 ()
{
}

// Overshoot1
//

Overshoot1::
Overshoot1 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overshoot1::
Overshoot1 (const Overshoot1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Overshoot1::
Overshoot1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Overshoot1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Overshoot1* Overshoot1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Overshoot1 (*this, f, c);
}

Overshoot1::
~Overshoot1 ()
{
}

// Filter1
//

Filter1::
Filter1 (const ::xml_schema::float_& _xsd_float__base,
         const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter1::
Filter1 (const Filter1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter1::
Filter1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter1* Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter1 (*this, f, c);
}

Filter1::
~Filter1 ()
{
}

// Default_Rx_Gain_Doppler1
//

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const Default_Rx_Gain_Doppler1& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Default_Rx_Gain_Doppler1::
Default_Rx_Gain_Doppler1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Default_Rx_Gain_Doppler1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Default_Rx_Gain_Doppler1* Default_Rx_Gain_Doppler1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Default_Rx_Gain_Doppler1 (*this, f, c);
}

Default_Rx_Gain_Doppler1::
~Default_Rx_Gain_Doppler1 ()
{
}

// Filter_Doppler_Low1
//

Filter_Doppler_Low1::
Filter_Doppler_Low1 (const ::xml_schema::float_& _xsd_float__base,
                     const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Doppler_Low1::
Filter_Doppler_Low1 (const Filter_Doppler_Low1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Doppler_Low1::
Filter_Doppler_Low1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Doppler_Low1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Doppler_Low1* Filter_Doppler_Low1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Doppler_Low1 (*this, f, c);
}

Filter_Doppler_Low1::
~Filter_Doppler_Low1 ()
{
}

// Frequency_Doppler1
//

Frequency_Doppler1::
Frequency_Doppler1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency_Doppler1::
Frequency_Doppler1 (const Frequency_Doppler1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency_Doppler1::
Frequency_Doppler1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency_Doppler1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency_Doppler1* Frequency_Doppler1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency_Doppler1 (*this, f, c);
}

Frequency_Doppler1::
~Frequency_Doppler1 ()
{
}

// Filter_High1
//

Filter_High1::
Filter_High1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_High1::
Filter_High1 (const Filter_High1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_High1::
Filter_High1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_High1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_High1* Filter_High1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_High1 (*this, f, c);
}

Filter_High1::
~Filter_High1 ()
{
}

// Motor_Overhead1
//

Motor_Overhead1::
Motor_Overhead1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead1::
Motor_Overhead1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead1::
Motor_Overhead1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead1::
Motor_Overhead1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Motor_Overhead1::
Motor_Overhead1 (const Motor_Overhead1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Motor_Overhead1::
Motor_Overhead1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Motor_Overhead1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Motor_Overhead1* Motor_Overhead1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Motor_Overhead1 (*this, f, c);
}

Motor_Overhead1::
~Motor_Overhead1 ()
{
}

// Filter_Low1
//

Filter_Low1::
Filter_Low1 (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Filter_Low1::
Filter_Low1 (const Filter_Low1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Filter_Low1::
Filter_Low1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Filter_Low1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Filter_Low1* Filter_Low1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Filter_Low1 (*this, f, c);
}

Filter_Low1::
~Filter_Low1 ()
{
}

// Buffer_Size1
//

Buffer_Size1::
Buffer_Size1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size1::
Buffer_Size1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size1::
Buffer_Size1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size1::
Buffer_Size1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Buffer_Size1::
Buffer_Size1 (const Buffer_Size1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Buffer_Size1::
Buffer_Size1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Buffer_Size1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Buffer_Size1* Buffer_Size1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Buffer_Size1 (*this, f, c);
}

Buffer_Size1::
~Buffer_Size1 ()
{
}

// BMode_Size_Default1
//

BMode_Size_Default1::
BMode_Size_Default1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default1::
BMode_Size_Default1 (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default1::
BMode_Size_Default1 (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default1::
BMode_Size_Default1 (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

BMode_Size_Default1::
BMode_Size_Default1 (const BMode_Size_Default1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

BMode_Size_Default1::
BMode_Size_Default1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void BMode_Size_Default1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

BMode_Size_Default1* BMode_Size_Default1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BMode_Size_Default1 (*this, f, c);
}

BMode_Size_Default1::
~BMode_Size_Default1 ()
{
}

// Overlay_Mode
//

Overlay_Mode::
Overlay_Mode (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overlay_Mode::
Overlay_Mode (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overlay_Mode::
Overlay_Mode (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overlay_Mode::
Overlay_Mode (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Overlay_Mode::
Overlay_Mode (const Overlay_Mode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Overlay_Mode::
Overlay_Mode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Overlay_Mode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Overlay_Mode* Overlay_Mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Overlay_Mode (*this, f, c);
}

Overlay_Mode::
~Overlay_Mode ()
{
}

// Refresh_Rate1
//

Refresh_Rate1::
Refresh_Rate1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate1::
Refresh_Rate1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate1::
Refresh_Rate1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate1::
Refresh_Rate1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Refresh_Rate1::
Refresh_Rate1 (const Refresh_Rate1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Refresh_Rate1::
Refresh_Rate1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Refresh_Rate1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Refresh_Rate1* Refresh_Rate1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Refresh_Rate1 (*this, f, c);
}

Refresh_Rate1::
~Refresh_Rate1 ()
{
}

// Acquisition_Mode
//

Acquisition_Mode::
Acquisition_Mode (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acquisition_Mode::
Acquisition_Mode (const char* _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acquisition_Mode::
Acquisition_Mode (const ::std::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acquisition_Mode::
Acquisition_Mode (const ::xml_schema::string& _xsd_string_base,
                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acquisition_Mode::
Acquisition_Mode (const Acquisition_Mode& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Acquisition_Mode::
Acquisition_Mode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Acquisition_Mode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Acquisition_Mode* Acquisition_Mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acquisition_Mode (*this, f, c);
}

Acquisition_Mode::
~Acquisition_Mode ()
{
}

// Actual_Scan_Rate
//

Actual_Scan_Rate::
Actual_Scan_Rate (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Actual_Scan_Rate::
Actual_Scan_Rate (const Actual_Scan_Rate& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Actual_Scan_Rate::
Actual_Scan_Rate (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Actual_Scan_Rate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Actual_Scan_Rate* Actual_Scan_Rate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Actual_Scan_Rate (*this, f, c);
}

Actual_Scan_Rate::
~Actual_Scan_Rate ()
{
}

// Sector_X_Res
//

Sector_X_Res::
Sector_X_Res (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Res::
Sector_X_Res (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Res::
Sector_X_Res (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Res::
Sector_X_Res (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Res::
Sector_X_Res (const Sector_X_Res& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_X_Res::
Sector_X_Res (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_X_Res::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_X_Res* Sector_X_Res::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_X_Res (*this, f, c);
}

Sector_X_Res::
~Sector_X_Res ()
{
}

// Sector_Y_Res
//

Sector_Y_Res::
Sector_Y_Res (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Res::
Sector_Y_Res (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Res::
Sector_Y_Res (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Res::
Sector_Y_Res (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Res::
Sector_Y_Res (const Sector_Y_Res& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Y_Res::
Sector_Y_Res (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Y_Res::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Y_Res* Sector_Y_Res::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Y_Res (*this, f, c);
}

Sector_Y_Res::
~Sector_Y_Res ()
{
}

// Power_Size_Default1
//

Power_Size_Default1::
Power_Size_Default1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default1::
Power_Size_Default1 (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default1::
Power_Size_Default1 (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default1::
Power_Size_Default1 (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Power_Size_Default1::
Power_Size_Default1 (const Power_Size_Default1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Power_Size_Default1::
Power_Size_Default1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Power_Size_Default1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Power_Size_Default1* Power_Size_Default1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Power_Size_Default1 (*this, f, c);
}

Power_Size_Default1::
~Power_Size_Default1 ()
{
}

// Sector_X_Start
//

Sector_X_Start::
Sector_X_Start (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Start::
Sector_X_Start (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Start::
Sector_X_Start (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Start::
Sector_X_Start (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_X_Start::
Sector_X_Start (const Sector_X_Start& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_X_Start::
Sector_X_Start (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_X_Start::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_X_Start* Sector_X_Start::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_X_Start (*this, f, c);
}

Sector_X_Start::
~Sector_X_Start ()
{
}

// Sector_Y_Start
//

Sector_Y_Start::
Sector_Y_Start (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Start::
Sector_Y_Start (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Start::
Sector_Y_Start (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Start::
Sector_Y_Start (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Y_Start::
Sector_Y_Start (const Sector_Y_Start& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Y_Start::
Sector_Y_Start (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Y_Start::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Y_Start* Sector_Y_Start::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Y_Start (*this, f, c);
}

Sector_Y_Start::
~Sector_Y_Start ()
{
}

// Target_Field_Of_View1
//

Target_Field_Of_View1::
Target_Field_Of_View1 (const ::xml_schema::float_& _xsd_float__base,
                       const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Target_Field_Of_View1::
Target_Field_Of_View1 (const Target_Field_Of_View1& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Target_Field_Of_View1::
Target_Field_Of_View1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Target_Field_Of_View1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Target_Field_Of_View1* Target_Field_Of_View1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Target_Field_Of_View1 (*this, f, c);
}

Target_Field_Of_View1::
~Target_Field_Of_View1 ()
{
}

// Sound_Speed1
//

Sound_Speed1::
Sound_Speed1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed1::
Sound_Speed1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed1::
Sound_Speed1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed1::
Sound_Speed1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sound_Speed1::
Sound_Speed1 (const Sound_Speed1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Sound_Speed1::
Sound_Speed1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sound_Speed1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sound_Speed1* Sound_Speed1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sound_Speed1 (*this, f, c);
}

Sound_Speed1::
~Sound_Speed1 ()
{
}

// Pipeline_Delay1
//

Pipeline_Delay1::
Pipeline_Delay1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay1::
Pipeline_Delay1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay1::
Pipeline_Delay1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay1::
Pipeline_Delay1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pipeline_Delay1::
Pipeline_Delay1 (const Pipeline_Delay1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pipeline_Delay1::
Pipeline_Delay1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pipeline_Delay1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pipeline_Delay1* Pipeline_Delay1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pipeline_Delay1 (*this, f, c);
}

Pipeline_Delay1::
~Pipeline_Delay1 ()
{
}

// Reference_3D_Step_Size
//

Reference_3D_Step_Size::
Reference_3D_Step_Size (const ::xml_schema::float_& _xsd_float__base,
                        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Reference_3D_Step_Size::
Reference_3D_Step_Size (const Reference_3D_Step_Size& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Reference_3D_Step_Size::
Reference_3D_Step_Size (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Reference_3D_Step_Size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Reference_3D_Step_Size* Reference_3D_Step_Size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Reference_3D_Step_Size (*this, f, c);
}

Reference_3D_Step_Size::
~Reference_3D_Step_Size ()
{
}

// Contrast_Size_Default
//

Contrast_Size_Default::
Contrast_Size_Default (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Contrast_Size_Default::
Contrast_Size_Default (const char* _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Contrast_Size_Default::
Contrast_Size_Default (const ::std::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Contrast_Size_Default::
Contrast_Size_Default (const ::xml_schema::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Contrast_Size_Default::
Contrast_Size_Default (const Contrast_Size_Default& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Contrast_Size_Default::
Contrast_Size_Default (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Contrast_Size_Default::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Contrast_Size_Default* Contrast_Size_Default::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Contrast_Size_Default (*this, f, c);
}

Contrast_Size_Default::
~Contrast_Size_Default ()
{
}

// Reference_3D_Scan_Distance
//

Reference_3D_Scan_Distance::
Reference_3D_Scan_Distance (const ::xml_schema::float_& _xsd_float__base,
                            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Reference_3D_Scan_Distance::
Reference_3D_Scan_Distance (const Reference_3D_Scan_Distance& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Reference_3D_Scan_Distance::
Reference_3D_Scan_Distance (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Reference_3D_Scan_Distance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Reference_3D_Scan_Distance* Reference_3D_Scan_Distance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Reference_3D_Scan_Distance (*this, f, c);
}

Reference_3D_Scan_Distance::
~Reference_3D_Scan_Distance ()
{
}

// Center1
//

Center1::
Center1 (const ::xml_schema::float_& _xsd_float__base,
         const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Center1::
Center1 (const Center1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Center1::
Center1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Center1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Center1* Center1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Center1 (*this, f, c);
}

Center1::
~Center1 ()
{
}

// V_Scan_Speed1
//

V_Scan_Speed1::
V_Scan_Speed1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed1::
V_Scan_Speed1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed1::
V_Scan_Speed1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed1::
V_Scan_Speed1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Speed1::
V_Scan_Speed1 (const V_Scan_Speed1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Scan_Speed1::
V_Scan_Speed1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Scan_Speed1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Scan_Speed1* V_Scan_Speed1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Scan_Speed1 (*this, f, c);
}

V_Scan_Speed1::
~V_Scan_Speed1 ()
{
}

// V_Scan_Rate1
//

V_Scan_Rate1::
V_Scan_Rate1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Scan_Rate1::
V_Scan_Rate1 (const V_Scan_Rate1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Scan_Rate1::
V_Scan_Rate1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Scan_Rate1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Scan_Rate1* V_Scan_Rate1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Scan_Rate1 (*this, f, c);
}

V_Scan_Rate1::
~V_Scan_Rate1 ()
{
}

// Scan_Width1
//

Scan_Width1::
Scan_Width1 (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Width1::
Scan_Width1 (const Scan_Width1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Width1::
Scan_Width1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Width1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Width1* Scan_Width1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Width1 (*this, f, c);
}

Scan_Width1::
~Scan_Width1 ()
{
}

// Position1
//

Position1::
Position1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position1::
Position1 (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position1::
Position1 (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position1::
Position1 (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position1::
Position1 (const Position1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position1::
Position1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position1* Position1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position1 (*this, f, c);
}

Position1::
~Position1 ()
{
}

// R_Scan_Move_No_Wait1
//

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const char* _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const ::std::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const ::xml_schema::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const R_Scan_Move_No_Wait1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move_No_Wait1::
R_Scan_Move_No_Wait1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move_No_Wait1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move_No_Wait1* R_Scan_Move_No_Wait1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move_No_Wait1 (*this, f, c);
}

R_Scan_Move_No_Wait1::
~R_Scan_Move_No_Wait1 ()
{
}

// Acceleration1
//

Acceleration1::
Acceleration1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration1::
Acceleration1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration1::
Acceleration1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration1::
Acceleration1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration1::
Acceleration1 (const Acceleration1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Acceleration1::
Acceleration1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Acceleration1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Acceleration1* Acceleration1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acceleration1 (*this, f, c);
}

Acceleration1::
~Acceleration1 ()
{
}

// Velocity_Stationary1
//

Velocity_Stationary1::
Velocity_Stationary1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary1::
Velocity_Stationary1 (const char* _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary1::
Velocity_Stationary1 (const ::std::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary1::
Velocity_Stationary1 (const ::xml_schema::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity_Stationary1::
Velocity_Stationary1 (const Velocity_Stationary1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Velocity_Stationary1::
Velocity_Stationary1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Velocity_Stationary1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Velocity_Stationary1* Velocity_Stationary1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Velocity_Stationary1 (*this, f, c);
}

Velocity_Stationary1::
~Velocity_Stationary1 ()
{
}

// R_Scan_Move21
//

R_Scan_Move21::
R_Scan_Move21 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move21::
R_Scan_Move21 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move21::
R_Scan_Move21 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move21::
R_Scan_Move21 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move21::
R_Scan_Move21 (const R_Scan_Move21& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move21::
R_Scan_Move21 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move21::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move21* R_Scan_Move21::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move21 (*this, f, c);
}

R_Scan_Move21::
~R_Scan_Move21 ()
{
}

// Position_Reverse1
//

Position_Reverse1::
Position_Reverse1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse1::
Position_Reverse1 (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse1::
Position_Reverse1 (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse1::
Position_Reverse1 (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Reverse1::
Position_Reverse1 (const Position_Reverse1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position_Reverse1::
Position_Reverse1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position_Reverse1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position_Reverse1* Position_Reverse1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position_Reverse1 (*this, f, c);
}

Position_Reverse1::
~Position_Reverse1 ()
{
}

// Position21
//

Position21::
Position21 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position21::
Position21 (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position21::
Position21 (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position21::
Position21 (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position21::
Position21 (const Position21& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position21::
Position21 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position21::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position21* Position21::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position21 (*this, f, c);
}

Position21::
~Position21 ()
{
}

// Velocity1
//

Velocity1::
Velocity1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity1::
Velocity1 (const char* _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity1::
Velocity1 (const ::std::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity1::
Velocity1 (const ::xml_schema::string& _xsd_string_base,
           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Velocity1::
Velocity1 (const Velocity1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Velocity1::
Velocity1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Velocity1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Velocity1* Velocity1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Velocity1 (*this, f, c);
}

Velocity1::
~Velocity1 ()
{
}

// R_Scan_Move1
//

R_Scan_Move1::
R_Scan_Move1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move1::
R_Scan_Move1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move1::
R_Scan_Move1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move1::
R_Scan_Move1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

R_Scan_Move1::
R_Scan_Move1 (const R_Scan_Move1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

R_Scan_Move1::
R_Scan_Move1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void R_Scan_Move1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

R_Scan_Move1* R_Scan_Move1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class R_Scan_Move1 (*this, f, c);
}

R_Scan_Move1::
~R_Scan_Move1 ()
{
}

// Position_Forward1
//

Position_Forward1::
Position_Forward1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward1::
Position_Forward1 (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward1::
Position_Forward1 (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward1::
Position_Forward1 (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Position_Forward1::
Position_Forward1 (const Position_Forward1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Position_Forward1::
Position_Forward1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Position_Forward1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Position_Forward1* Position_Forward1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Position_Forward1 (*this, f, c);
}

Position_Forward1::
~Position_Forward1 ()
{
}

// Acceleration_Stationary1
//

Acceleration_Stationary1::
Acceleration_Stationary1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary1::
Acceleration_Stationary1 (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary1::
Acceleration_Stationary1 (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary1::
Acceleration_Stationary1 (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Acceleration_Stationary1::
Acceleration_Stationary1 (const Acceleration_Stationary1& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Acceleration_Stationary1::
Acceleration_Stationary1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Acceleration_Stationary1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Acceleration_Stationary1* Acceleration_Stationary1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Acceleration_Stationary1 (*this, f, c);
}

Acceleration_Stationary1::
~Acceleration_Stationary1 ()
{
}

// Monitor_3point3V1
//

Monitor_3point3V1::
Monitor_3point3V1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V1::
Monitor_3point3V1 (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V1::
Monitor_3point3V1 (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V1::
Monitor_3point3V1 (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_3point3V1::
Monitor_3point3V1 (const Monitor_3point3V1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_3point3V1::
Monitor_3point3V1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_3point3V1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_3point3V1* Monitor_3point3V1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_3point3V1 (*this, f, c);
}

Monitor_3point3V1::
~Monitor_3point3V1 ()
{
}

// Monitor_5V1
//

Monitor_5V1::
Monitor_5V1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V1::
Monitor_5V1 (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V1::
Monitor_5V1 (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V1::
Monitor_5V1 (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_5V1::
Monitor_5V1 (const Monitor_5V1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_5V1::
Monitor_5V1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_5V1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_5V1* Monitor_5V1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_5V1 (*this, f, c);
}

Monitor_5V1::
~Monitor_5V1 ()
{
}

// Monitor_Neg15V1
//

Monitor_Neg15V1::
Monitor_Neg15V1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V1::
Monitor_Neg15V1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V1::
Monitor_Neg15V1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V1::
Monitor_Neg15V1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg15V1::
Monitor_Neg15V1 (const Monitor_Neg15V1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_Neg15V1::
Monitor_Neg15V1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_Neg15V1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_Neg15V1* Monitor_Neg15V1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_Neg15V1 (*this, f, c);
}

Monitor_Neg15V1::
~Monitor_Neg15V1 ()
{
}

// Monitor_Neg5V1
//

Monitor_Neg5V1::
Monitor_Neg5V1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V1::
Monitor_Neg5V1 (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V1::
Monitor_Neg5V1 (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V1::
Monitor_Neg5V1 (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_Neg5V1::
Monitor_Neg5V1 (const Monitor_Neg5V1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_Neg5V1::
Monitor_Neg5V1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_Neg5V1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_Neg5V1* Monitor_Neg5V1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_Neg5V1 (*this, f, c);
}

Monitor_Neg5V1::
~Monitor_Neg5V1 ()
{
}

// Monitor_15V1
//

Monitor_15V1::
Monitor_15V1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V1::
Monitor_15V1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V1::
Monitor_15V1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V1::
Monitor_15V1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Monitor_15V1::
Monitor_15V1 (const Monitor_15V1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Monitor_15V1::
Monitor_15V1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Monitor_15V1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Monitor_15V1* Monitor_15V1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Monitor_15V1 (*this, f, c);
}

Monitor_15V1::
~Monitor_15V1 ()
{
}

// Respiration_Threshold_Change1
//

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const char* _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const ::std::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const ::xml_schema::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const Respiration_Threshold_Change1& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Threshold_Change1::
Respiration_Threshold_Change1 (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Threshold_Change1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Threshold_Change1* Respiration_Threshold_Change1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Threshold_Change1 (*this, f, c);
}

Respiration_Threshold_Change1::
~Respiration_Threshold_Change1 ()
{
}

// Pressure_Range1
//

Pressure_Range1::
Pressure_Range1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range1::
Pressure_Range1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range1::
Pressure_Range1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range1::
Pressure_Range1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Range1::
Pressure_Range1 (const Pressure_Range1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Range1::
Pressure_Range1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Range1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Range1* Pressure_Range1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Range1 (*this, f, c);
}

Pressure_Range1::
~Pressure_Range1 ()
{
}

// Respiration_Gate_Delay1
//

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const char* _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const ::std::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const ::xml_schema::string& _xsd_string_base,
                         const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const Respiration_Gate_Delay1& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Gate_Delay1::
Respiration_Gate_Delay1 (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Gate_Delay1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Gate_Delay1* Respiration_Gate_Delay1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Gate_Delay1 (*this, f, c);
}

Respiration_Gate_Delay1::
~Respiration_Gate_Delay1 ()
{
}

// Respiration_Timeout1
//

Respiration_Timeout1::
Respiration_Timeout1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout1::
Respiration_Timeout1 (const char* _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout1::
Respiration_Timeout1 (const ::std::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout1::
Respiration_Timeout1 (const ::xml_schema::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Timeout1::
Respiration_Timeout1 (const Respiration_Timeout1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Timeout1::
Respiration_Timeout1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Timeout1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Timeout1* Respiration_Timeout1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Timeout1 (*this, f, c);
}

Respiration_Timeout1::
~Respiration_Timeout1 ()
{
}

// RWave_Max_Change_Factor_Percent1
//

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const char* _xsd_string_base,
                                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const ::std::string& _xsd_string_base,
                                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const ::xml_schema::string& _xsd_string_base,
                                  const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const RWave_Max_Change_Factor_Percent1& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Max_Change_Factor_Percent1::
RWave_Max_Change_Factor_Percent1 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Max_Change_Factor_Percent1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Max_Change_Factor_Percent1* RWave_Max_Change_Factor_Percent1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Max_Change_Factor_Percent1 (*this, f, c);
}

RWave_Max_Change_Factor_Percent1::
~RWave_Max_Change_Factor_Percent1 ()
{
}

// Respiration_Period1
//

Respiration_Period1::
Respiration_Period1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period1::
Respiration_Period1 (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period1::
Respiration_Period1 (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period1::
Respiration_Period1 (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Period1::
Respiration_Period1 (const Respiration_Period1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Period1::
Respiration_Period1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Period1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Period1* Respiration_Period1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Period1 (*this, f, c);
}

Respiration_Period1::
~Respiration_Period1 ()
{
}

// Respiration_Subsample_Rate1
//

Respiration_Subsample_Rate1::
Respiration_Subsample_Rate1 (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Subsample_Rate1::
Respiration_Subsample_Rate1 (const Respiration_Subsample_Rate1& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Subsample_Rate1::
Respiration_Subsample_Rate1 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Subsample_Rate1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Subsample_Rate1* Respiration_Subsample_Rate1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Subsample_Rate1 (*this, f, c);
}

Respiration_Subsample_Rate1::
~Respiration_Subsample_Rate1 ()
{
}

// Respiration_Window1
//

Respiration_Window1::
Respiration_Window1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window1::
Respiration_Window1 (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window1::
Respiration_Window1 (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window1::
Respiration_Window1 (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Window1::
Respiration_Window1 (const Respiration_Window1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Window1::
Respiration_Window1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Window1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Window1* Respiration_Window1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Window1 (*this, f, c);
}

Respiration_Window1::
~Respiration_Window1 ()
{
}

// Pressure_Systolic1
//

Pressure_Systolic1::
Pressure_Systolic1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic1::
Pressure_Systolic1 (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic1::
Pressure_Systolic1 (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic1::
Pressure_Systolic1 (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Systolic1::
Pressure_Systolic1 (const Pressure_Systolic1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Systolic1::
Pressure_Systolic1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Systolic1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Systolic1* Pressure_Systolic1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Systolic1 (*this, f, c);
}

Pressure_Systolic1::
~Pressure_Systolic1 ()
{
}

// Frequency5
//

Frequency5::
Frequency5 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency5::
Frequency5 (const Frequency5& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency5::
Frequency5 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency5::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency5* Frequency5::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency5 (*this, f, c);
}

Frequency5::
~Frequency5 ()
{
}

// Respiration_Blank_Period1
//

Respiration_Blank_Period1::
Respiration_Blank_Period1 (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Blank_Period1::
Respiration_Blank_Period1 (const Respiration_Blank_Period1& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Blank_Period1::
Respiration_Blank_Period1 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Blank_Period1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Blank_Period1* Respiration_Blank_Period1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Blank_Period1 (*this, f, c);
}

Respiration_Blank_Period1::
~Respiration_Blank_Period1 ()
{
}

// Respiration_Range1
//

Respiration_Range1::
Respiration_Range1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range1::
Respiration_Range1 (const char* _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range1::
Respiration_Range1 (const ::std::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range1::
Respiration_Range1 (const ::xml_schema::string& _xsd_string_base,
                    const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Range1::
Respiration_Range1 (const Respiration_Range1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Range1::
Respiration_Range1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Range1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Range1* Respiration_Range1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Range1 (*this, f, c);
}

Respiration_Range1::
~Respiration_Range1 ()
{
}

// Pressure_Zero1
//

Pressure_Zero1::
Pressure_Zero1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero1::
Pressure_Zero1 (const char* _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero1::
Pressure_Zero1 (const ::std::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero1::
Pressure_Zero1 (const ::xml_schema::string& _xsd_string_base,
                const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Zero1::
Pressure_Zero1 (const Pressure_Zero1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Zero1::
Pressure_Zero1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Zero1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Zero1* Pressure_Zero1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Zero1 (*this, f, c);
}

Pressure_Zero1::
~Pressure_Zero1 ()
{
}

// P_Wave_Start1
//

P_Wave_Start1::
P_Wave_Start1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start1::
P_Wave_Start1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start1::
P_Wave_Start1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start1::
P_Wave_Start1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

P_Wave_Start1::
P_Wave_Start1 (const P_Wave_Start1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

P_Wave_Start1::
P_Wave_Start1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void P_Wave_Start1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

P_Wave_Start1* P_Wave_Start1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class P_Wave_Start1 (*this, f, c);
}

P_Wave_Start1::
~P_Wave_Start1 ()
{
}

// Respiration_Percent_Peak1
//

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const char* _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const ::std::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const ::xml_schema::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const Respiration_Percent_Peak1& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Percent_Peak1::
Respiration_Percent_Peak1 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Percent_Peak1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Percent_Peak1* Respiration_Percent_Peak1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Percent_Peak1 (*this, f, c);
}

Respiration_Percent_Peak1::
~Respiration_Percent_Peak1 ()
{
}

// T_Wave_Start1
//

T_Wave_Start1::
T_Wave_Start1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start1::
T_Wave_Start1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start1::
T_Wave_Start1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start1::
T_Wave_Start1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

T_Wave_Start1::
T_Wave_Start1 (const T_Wave_Start1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

T_Wave_Start1::
T_Wave_Start1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void T_Wave_Start1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

T_Wave_Start1* T_Wave_Start1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class T_Wave_Start1 (*this, f, c);
}

T_Wave_Start1::
~T_Wave_Start1 ()
{
}

// Strain_Rate_RR_Diff_Ratio1
//

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const char* _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const ::std::string& _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const ::xml_schema::string& _xsd_string_base,
                            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const Strain_Rate_RR_Diff_Ratio1& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Strain_Rate_RR_Diff_Ratio1::
Strain_Rate_RR_Diff_Ratio1 (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Strain_Rate_RR_Diff_Ratio1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Strain_Rate_RR_Diff_Ratio1* Strain_Rate_RR_Diff_Ratio1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Strain_Rate_RR_Diff_Ratio1 (*this, f, c);
}

Strain_Rate_RR_Diff_Ratio1::
~Strain_Rate_RR_Diff_Ratio1 ()
{
}

// Pressure_Diastolic1
//

Pressure_Diastolic1::
Pressure_Diastolic1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic1::
Pressure_Diastolic1 (const char* _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic1::
Pressure_Diastolic1 (const ::std::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic1::
Pressure_Diastolic1 (const ::xml_schema::string& _xsd_string_base,
                     const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Diastolic1::
Pressure_Diastolic1 (const Pressure_Diastolic1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Diastolic1::
Pressure_Diastolic1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Diastolic1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Diastolic1* Pressure_Diastolic1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Diastolic1 (*this, f, c);
}

Pressure_Diastolic1::
~Pressure_Diastolic1 ()
{
}

// Temperature_Calibration1
//

Temperature_Calibration1::
Temperature_Calibration1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration1::
Temperature_Calibration1 (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration1::
Temperature_Calibration1 (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration1::
Temperature_Calibration1 (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature_Calibration1::
Temperature_Calibration1 (const Temperature_Calibration1& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Temperature_Calibration1::
Temperature_Calibration1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Temperature_Calibration1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Temperature_Calibration1* Temperature_Calibration1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Temperature_Calibration1 (*this, f, c);
}

Temperature_Calibration1::
~Temperature_Calibration1 ()
{
}

// Temperature1
//

Temperature1::
Temperature1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature1::
Temperature1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature1::
Temperature1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature1::
Temperature1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Temperature1::
Temperature1 (const Temperature1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Temperature1::
Temperature1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Temperature1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Temperature1* Temperature1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Temperature1 (*this, f, c);
}

Temperature1::
~Temperature1 ()
{
}

// Respiration_Beats_To_Average1
//

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const char* _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const ::std::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const ::xml_schema::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const Respiration_Beats_To_Average1& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Beats_To_Average1::
Respiration_Beats_To_Average1 (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Beats_To_Average1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Beats_To_Average1* Respiration_Beats_To_Average1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Beats_To_Average1 (*this, f, c);
}

Respiration_Beats_To_Average1::
~Respiration_Beats_To_Average1 ()
{
}

// RWave_Thresh_Trigger_Percent1
//

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const char* _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const ::std::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const ::xml_schema::string& _xsd_string_base,
                               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const RWave_Thresh_Trigger_Percent1& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Thresh_Trigger_Percent1::
RWave_Thresh_Trigger_Percent1 (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Thresh_Trigger_Percent1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Thresh_Trigger_Percent1* RWave_Thresh_Trigger_Percent1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Thresh_Trigger_Percent1 (*this, f, c);
}

RWave_Thresh_Trigger_Percent1::
~RWave_Thresh_Trigger_Percent1 ()
{
}

// Respiration_Time_To_Average1
//

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const char* _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const ::std::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const ::xml_schema::string& _xsd_string_base,
                              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const Respiration_Time_To_Average1& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Respiration_Time_To_Average1::
Respiration_Time_To_Average1 (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Respiration_Time_To_Average1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Respiration_Time_To_Average1* Respiration_Time_To_Average1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Respiration_Time_To_Average1 (*this, f, c);
}

Respiration_Time_To_Average1::
~Respiration_Time_To_Average1 ()
{
}

// Heart_Period1
//

Heart_Period1::
Heart_Period1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period1::
Heart_Period1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period1::
Heart_Period1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period1::
Heart_Period1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Heart_Period1::
Heart_Period1 (const Heart_Period1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Heart_Period1::
Heart_Period1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Heart_Period1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Heart_Period1* Heart_Period1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Heart_Period1 (*this, f, c);
}

Heart_Period1::
~Heart_Period1 ()
{
}

// ECG_Range1
//

ECG_Range1::
ECG_Range1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range1::
ECG_Range1 (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range1::
ECG_Range1 (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range1::
ECG_Range1 (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_Range1::
ECG_Range1 (const ECG_Range1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_Range1::
ECG_Range1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_Range1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_Range1* ECG_Range1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_Range1 (*this, f, c);
}

ECG_Range1::
~ECG_Range1 ()
{
}

// RWave_Maxima_Block_Time1
//

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const RWave_Maxima_Block_Time1& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Maxima_Block_Time1::
RWave_Maxima_Block_Time1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Maxima_Block_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Maxima_Block_Time1* RWave_Maxima_Block_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Maxima_Block_Time1 (*this, f, c);
}

RWave_Maxima_Block_Time1::
~RWave_Maxima_Block_Time1 ()
{
}

// Pressure_Calibration_Level1
//

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const char* _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const ::std::string& _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const ::xml_schema::string& _xsd_string_base,
                             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const Pressure_Calibration_Level1& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Calibration_Level1::
Pressure_Calibration_Level1 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Calibration_Level1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Calibration_Level1* Pressure_Calibration_Level1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Calibration_Level1 (*this, f, c);
}

Pressure_Calibration_Level1::
~Pressure_Calibration_Level1 ()
{
}

// ECG_HP_Filter1
//

ECG_HP_Filter1::
ECG_HP_Filter1 (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_HP_Filter1::
ECG_HP_Filter1 (const ECG_HP_Filter1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_HP_Filter1::
ECG_HP_Filter1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_HP_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_HP_Filter1* ECG_HP_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_HP_Filter1 (*this, f, c);
}

ECG_HP_Filter1::
~ECG_HP_Filter1 ()
{
}

// ECG_LP_Filter1
//

ECG_LP_Filter1::
ECG_LP_Filter1 (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

ECG_LP_Filter1::
ECG_LP_Filter1 (const ECG_LP_Filter1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

ECG_LP_Filter1::
ECG_LP_Filter1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ECG_LP_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

ECG_LP_Filter1* ECG_LP_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ECG_LP_Filter1 (*this, f, c);
}

ECG_LP_Filter1::
~ECG_LP_Filter1 ()
{
}

// RWave_Max_Change_Period1
//

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const char* _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const ::std::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const ::xml_schema::string& _xsd_string_base,
                          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const RWave_Max_Change_Period1& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Max_Change_Period1::
RWave_Max_Change_Period1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Max_Change_Period1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Max_Change_Period1* RWave_Max_Change_Period1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Max_Change_Period1 (*this, f, c);
}

RWave_Max_Change_Period1::
~RWave_Max_Change_Period1 ()
{
}

// Pressure_Calibration1
//

Pressure_Calibration1::
Pressure_Calibration1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration1::
Pressure_Calibration1 (const char* _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration1::
Pressure_Calibration1 (const ::std::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration1::
Pressure_Calibration1 (const ::xml_schema::string& _xsd_string_base,
                       const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pressure_Calibration1::
Pressure_Calibration1 (const Pressure_Calibration1& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pressure_Calibration1::
Pressure_Calibration1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pressure_Calibration1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pressure_Calibration1* Pressure_Calibration1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pressure_Calibration1 (*this, f, c);
}

Pressure_Calibration1::
~Pressure_Calibration1 ()
{
}

// RWave_Blank_Time1
//

RWave_Blank_Time1::
RWave_Blank_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time1::
RWave_Blank_Time1 (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time1::
RWave_Blank_Time1 (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time1::
RWave_Blank_Time1 (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Blank_Time1::
RWave_Blank_Time1 (const RWave_Blank_Time1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Blank_Time1::
RWave_Blank_Time1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Blank_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Blank_Time1* RWave_Blank_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Blank_Time1 (*this, f, c);
}

RWave_Blank_Time1::
~RWave_Blank_Time1 ()
{
}

// RWave_Future_Search_Time1
//

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const char* _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const ::std::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const ::xml_schema::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const RWave_Future_Search_Time1& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RWave_Future_Search_Time1::
RWave_Future_Search_Time1 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RWave_Future_Search_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RWave_Future_Search_Time1* RWave_Future_Search_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWave_Future_Search_Time1 (*this, f, c);
}

RWave_Future_Search_Time1::
~RWave_Future_Search_Time1 ()
{
}

// V_Transmit_Length1
//

V_Transmit_Length1::
V_Transmit_Length1 (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Transmit_Length1::
V_Transmit_Length1 (const V_Transmit_Length1& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Transmit_Length1::
V_Transmit_Length1 (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Transmit_Length1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Transmit_Length1* V_Transmit_Length1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Transmit_Length1 (*this, f, c);
}

V_Transmit_Length1::
~V_Transmit_Length1 ()
{
}

// V_Pulse_Rep_Freq1
//

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const V_Pulse_Rep_Freq1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Pulse_Rep_Freq1::
V_Pulse_Rep_Freq1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Pulse_Rep_Freq1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Pulse_Rep_Freq1* V_Pulse_Rep_Freq1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Pulse_Rep_Freq1 (*this, f, c);
}

V_Pulse_Rep_Freq1::
~V_Pulse_Rep_Freq1 ()
{
}

// Frequency6
//

Frequency6::
Frequency6 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency6::
Frequency6 (const Frequency6& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency6::
Frequency6 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency6::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency6* Frequency6::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency6 (*this, f, c);
}

Frequency6::
~Frequency6 ()
{
}

// V_Unblank_Time1
//

V_Unblank_Time1::
V_Unblank_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time1::
V_Unblank_Time1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time1::
V_Unblank_Time1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time1::
V_Unblank_Time1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Unblank_Time1::
V_Unblank_Time1 (const V_Unblank_Time1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Unblank_Time1::
V_Unblank_Time1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Unblank_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Unblank_Time1* V_Unblank_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Unblank_Time1 (*this, f, c);
}

V_Unblank_Time1::
~V_Unblank_Time1 ()
{
}

// V_Frequency2
//

V_Frequency2::
V_Frequency2 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Frequency2::
V_Frequency2 (const V_Frequency2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Frequency2::
V_Frequency2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Frequency2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Frequency2* V_Frequency2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Frequency2 (*this, f, c);
}

V_Frequency2::
~V_Frequency2 ()
{
}

// Pulse_Rep_Frequency1
//

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const char* _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const ::std::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const ::xml_schema::string& _xsd_string_base,
                      const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const Pulse_Rep_Frequency1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Pulse_Rep_Frequency1::
Pulse_Rep_Frequency1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Pulse_Rep_Frequency1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Pulse_Rep_Frequency1* Pulse_Rep_Frequency1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pulse_Rep_Frequency1 (*this, f, c);
}

Pulse_Rep_Frequency1::
~Pulse_Rep_Frequency1 ()
{
}

// Trig_Tbl_Trigs1
//

Trig_Tbl_Trigs1::
Trig_Tbl_Trigs1 (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                 const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Trig_Tbl_Trigs1::
Trig_Tbl_Trigs1 (const Trig_Tbl_Trigs1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Trig_Tbl_Trigs1::
Trig_Tbl_Trigs1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Trig_Tbl_Trigs1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Trig_Tbl_Trigs1* Trig_Tbl_Trigs1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Trig_Tbl_Trigs1 (*this, f, c);
}

Trig_Tbl_Trigs1::
~Trig_Tbl_Trigs1 ()
{
}

// Unblank_Cycles1
//

Unblank_Cycles1::
Unblank_Cycles1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles1::
Unblank_Cycles1 (const char* _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles1::
Unblank_Cycles1 (const ::std::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles1::
Unblank_Cycles1 (const ::xml_schema::string& _xsd_string_base,
                 const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Cycles1::
Unblank_Cycles1 (const Unblank_Cycles1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Unblank_Cycles1::
Unblank_Cycles1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Unblank_Cycles1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Unblank_Cycles1* Unblank_Cycles1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unblank_Cycles1 (*this, f, c);
}

Unblank_Cycles1::
~Unblank_Cycles1 ()
{
}

// Unblank_Time1
//

Unblank_Time1::
Unblank_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time1::
Unblank_Time1 (const char* _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time1::
Unblank_Time1 (const ::std::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time1::
Unblank_Time1 (const ::xml_schema::string& _xsd_string_base,
               const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Unblank_Time1::
Unblank_Time1 (const Unblank_Time1& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Unblank_Time1::
Unblank_Time1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Unblank_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Unblank_Time1* Unblank_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Unblank_Time1 (*this, f, c);
}

Unblank_Time1::
~Unblank_Time1 ()
{
}

// Attenuation1
//

Attenuation1::
Attenuation1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation1::
Attenuation1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation1::
Attenuation1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation1::
Attenuation1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Attenuation1::
Attenuation1 (const Attenuation1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Attenuation1::
Attenuation1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Attenuation1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Attenuation1* Attenuation1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Attenuation1 (*this, f, c);
}

Attenuation1::
~Attenuation1 ()
{
}

// V_Power1
//

V_Power1::
V_Power1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power1::
V_Power1 (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power1::
V_Power1 (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power1::
V_Power1 (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Power1::
V_Power1 (const V_Power1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Power1::
V_Power1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Power1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Power1* V_Power1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Power1 (*this, f, c);
}

V_Power1::
~V_Power1 ()
{
}

// Frames
//

Frames::
Frames (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frames::
Frames (const char* _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frames::
Frames (const ::std::string& _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frames::
Frames (const ::xml_schema::string& _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frames::
Frames (const Frames& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Frames::
Frames (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frames::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frames* Frames::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frames (*this, f, c);
}

Frames::
~Frames ()
{
}

// Frame_Rate
//

Frame_Rate::
Frame_Rate (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frame_Rate::
Frame_Rate (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frame_Rate::
Frame_Rate (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frame_Rate::
Frame_Rate (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frame_Rate::
Frame_Rate (const Frame_Rate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Frame_Rate::
Frame_Rate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frame_Rate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frame_Rate* Frame_Rate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frame_Rate (*this, f, c);
}

Frame_Rate::
~Frame_Rate ()
{
}

// Tx_PRF
//

Tx_PRF::
Tx_PRF (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_PRF::
Tx_PRF (const char* _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_PRF::
Tx_PRF (const ::std::string& _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_PRF::
Tx_PRF (const ::xml_schema::string& _xsd_string_base,
        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_PRF::
Tx_PRF (const Tx_PRF& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Tx_PRF::
Tx_PRF (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Tx_PRF::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Tx_PRF* Tx_PRF::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Tx_PRF (*this, f, c);
}

Tx_PRF::
~Tx_PRF ()
{
}

// Tx_Power
//

Tx_Power::
Tx_Power (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_Power::
Tx_Power (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_Power::
Tx_Power (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_Power::
Tx_Power (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_Power::
Tx_Power (const Tx_Power& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Tx_Power::
Tx_Power (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Tx_Power::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Tx_Power* Tx_Power::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Tx_Power (*this, f, c);
}

Tx_Power::
~Tx_Power ()
{
}

// Duration
//

Duration::
Duration (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Duration::
Duration (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Duration::
Duration (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Duration::
Duration (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Duration::
Duration (const Duration& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Duration::
Duration (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Duration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Duration* Duration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Duration (*this, f, c);
}

Duration::
~Duration ()
{
}

// Tx_Frequency
//

Tx_Frequency::
Tx_Frequency (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Tx_Frequency::
Tx_Frequency (const Tx_Frequency& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Tx_Frequency::
Tx_Frequency (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Tx_Frequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Tx_Frequency* Tx_Frequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Tx_Frequency (*this, f, c);
}

Tx_Frequency::
~Tx_Frequency ()
{
}

// Destroy_Sequence_Position
//

Destroy_Sequence_Position::
Destroy_Sequence_Position (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Destroy_Sequence_Position::
Destroy_Sequence_Position (const char* _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Destroy_Sequence_Position::
Destroy_Sequence_Position (const ::std::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Destroy_Sequence_Position::
Destroy_Sequence_Position (const ::xml_schema::string& _xsd_string_base,
                           const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Destroy_Sequence_Position::
Destroy_Sequence_Position (const Destroy_Sequence_Position& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Destroy_Sequence_Position::
Destroy_Sequence_Position (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Destroy_Sequence_Position::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Destroy_Sequence_Position* Destroy_Sequence_Position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Destroy_Sequence_Position (*this, f, c);
}

Destroy_Sequence_Position::
~Destroy_Sequence_Position ()
{
}

// Scan_Distance1
//

Scan_Distance1::
Scan_Distance1 (const ::xml_schema::float_& _xsd_float__base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Scan_Distance1::
Scan_Distance1 (const Scan_Distance1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Scan_Distance1::
Scan_Distance1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Scan_Distance1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Scan_Distance1* Scan_Distance1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Scan_Distance1 (*this, f, c);
}

Scan_Distance1::
~Scan_Distance1 ()
{
}

// Step_Size1
//

Step_Size1::
Step_Size1 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Step_Size1::
Step_Size1 (const Step_Size1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Step_Size1::
Step_Size1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Step_Size1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Step_Size1* Step_Size1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Step_Size1 (*this, f, c);
}

Step_Size1::
~Step_Size1 ()
{
}

// Parallel_Step_Size
//

Parallel_Step_Size::
Parallel_Step_Size (const ::xml_schema::float_& _xsd_float__base,
                    const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Parallel_Step_Size::
Parallel_Step_Size (const Parallel_Step_Size& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Parallel_Step_Size::
Parallel_Step_Size (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Parallel_Step_Size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Parallel_Step_Size* Parallel_Step_Size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Parallel_Step_Size (*this, f, c);
}

Parallel_Step_Size::
~Parallel_Step_Size ()
{
}

// Sector_Width_Target1
//

Sector_Width_Target1::
Sector_Width_Target1 (const ::xml_schema::float_& _xsd_float__base,
                      const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Width_Target1::
Sector_Width_Target1 (const Sector_Width_Target1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Width_Target1::
Sector_Width_Target1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Width_Target1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Width_Target1* Sector_Width_Target1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Width_Target1 (*this, f, c);
}

Sector_Width_Target1::
~Sector_Width_Target1 ()
{
}

// RF_Gain1
//

RF_Gain1::
RF_Gain1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain1::
RF_Gain1 (const char* _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain1::
RF_Gain1 (const ::std::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain1::
RF_Gain1 (const ::xml_schema::string& _xsd_string_base,
          const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Gain1::
RF_Gain1 (const RF_Gain1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Gain1::
RF_Gain1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Gain1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Gain1* RF_Gain1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Gain1 (*this, f, c);
}

RF_Gain1::
~RF_Gain1 ()
{
}

// V_Digi_Depth_Imaging1
//

V_Digi_Depth_Imaging1::
V_Digi_Depth_Imaging1 (const ::xml_schema::float_& _xsd_float__base,
                       const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Digi_Depth_Imaging1::
V_Digi_Depth_Imaging1 (const V_Digi_Depth_Imaging1& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Digi_Depth_Imaging1::
V_Digi_Depth_Imaging1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Digi_Depth_Imaging1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Digi_Depth_Imaging1* V_Digi_Depth_Imaging1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Digi_Depth_Imaging1 (*this, f, c);
}

V_Digi_Depth_Imaging1::
~V_Digi_Depth_Imaging1 ()
{
}

// Test_Freq1
//

Test_Freq1::
Test_Freq1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq1::
Test_Freq1 (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq1::
Test_Freq1 (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq1::
Test_Freq1 (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Test_Freq1::
Test_Freq1 (const Test_Freq1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Test_Freq1::
Test_Freq1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Test_Freq1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Test_Freq1* Test_Freq1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Test_Freq1 (*this, f, c);
}

Test_Freq1::
~Test_Freq1 ()
{
}

// RF_Filter1
//

RF_Filter1::
RF_Filter1 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

RF_Filter1::
RF_Filter1 (const RF_Filter1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

RF_Filter1::
RF_Filter1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void RF_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

RF_Filter1* RF_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RF_Filter1 (*this, f, c);
}

RF_Filter1::
~RF_Filter1 ()
{
}

// V_RF_Filter1
//

V_RF_Filter1::
V_RF_Filter1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_RF_Filter1::
V_RF_Filter1 (const V_RF_Filter1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_RF_Filter1::
V_RF_Filter1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_RF_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_RF_Filter1* V_RF_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_RF_Filter1 (*this, f, c);
}

V_RF_Filter1::
~V_RF_Filter1 ()
{
}

// Delay1
//

Delay1::
Delay1 (const ::xml_schema::float_& _xsd_float__base,
        const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Delay1::
Delay1 (const Delay1& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Delay1::
Delay1 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Delay1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Delay1* Delay1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Delay1 (*this, f, c);
}

Delay1::
~Delay1 ()
{
}

// AD_Gate_Width1
//

AD_Gate_Width1::
AD_Gate_Width1 (const ::xml_schema::positive_integer& _xsd_positive_integer_base,
                const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_Gate_Width1::
AD_Gate_Width1 (const AD_Gate_Width1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

AD_Gate_Width1::
AD_Gate_Width1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void AD_Gate_Width1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

AD_Gate_Width1* AD_Gate_Width1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AD_Gate_Width1 (*this, f, c);
}

AD_Gate_Width1::
~AD_Gate_Width1 ()
{
}

// Frequency7
//

Frequency7::
Frequency7 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Frequency7::
Frequency7 (const Frequency7& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Frequency7::
Frequency7 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Frequency7::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Frequency7* Frequency7::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Frequency7 (*this, f, c);
}

Frequency7::
~Frequency7 ()
{
}

// V_Frequency3
//

V_Frequency3::
V_Frequency3 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Frequency3::
V_Frequency3 (const V_Frequency3& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Frequency3::
V_Frequency3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Frequency3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Frequency3* V_Frequency3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Frequency3 (*this, f, c);
}

V_Frequency3::
~V_Frequency3 ()
{
}

// V_Field_Of_View1
//

V_Field_Of_View1::
V_Field_Of_View1 (const ::xml_schema::float_& _xsd_float__base,
                  const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Field_Of_View1::
V_Field_Of_View1 (const V_Field_Of_View1& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Field_Of_View1::
V_Field_Of_View1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Field_Of_View1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Field_Of_View1* V_Field_Of_View1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Field_Of_View1 (*this, f, c);
}

V_Field_Of_View1::
~V_Field_Of_View1 ()
{
}

// Sector_Height_Target1
//

Sector_Height_Target1::
Sector_Height_Target1 (const ::xml_schema::float_& _xsd_float__base,
                       const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Sector_Height_Target1::
Sector_Height_Target1 (const Sector_Height_Target1& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

Sector_Height_Target1::
Sector_Height_Target1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Sector_Height_Target1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Sector_Height_Target1* Sector_Height_Target1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sector_Height_Target1 (*this, f, c);
}

Sector_Height_Target1::
~Sector_Height_Target1 ()
{
}

// AD_TestIn1
//

AD_TestIn1::
AD_TestIn1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn1::
AD_TestIn1 (const char* _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn1::
AD_TestIn1 (const ::std::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn1::
AD_TestIn1 (const ::xml_schema::string& _xsd_string_base,
            const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

AD_TestIn1::
AD_TestIn1 (const AD_TestIn1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

AD_TestIn1::
AD_TestIn1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void AD_TestIn1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

AD_TestIn1* AD_TestIn1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AD_TestIn1 (*this, f, c);
}

AD_TestIn1::
~AD_TestIn1 ()
{
}

// V_Delay_Length1
//

V_Delay_Length1::
V_Delay_Length1 (const ::xml_schema::float_& _xsd_float__base,
                 const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_Delay_Length1::
V_Delay_Length1 (const V_Delay_Length1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_Delay_Length1::
V_Delay_Length1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_Delay_Length1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_Delay_Length1* V_Delay_Length1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_Delay_Length1 (*this, f, c);
}

V_Delay_Length1::
~V_Delay_Length1 ()
{
}

// IF_Filter1
//

IF_Filter1::
IF_Filter1 (const ::xml_schema::float_& _xsd_float__base,
            const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

IF_Filter1::
IF_Filter1 (const IF_Filter1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

IF_Filter1::
IF_Filter1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void IF_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

IF_Filter1* IF_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IF_Filter1 (*this, f, c);
}

IF_Filter1::
~IF_Filter1 ()
{
}

// Track_Width1
//

Track_Width1::
Track_Width1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width1::
Track_Width1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width1::
Track_Width1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width1::
Track_Width1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Track_Width1::
Track_Width1 (const Track_Width1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Track_Width1::
Track_Width1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Track_Width1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Track_Width1* Track_Width1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Track_Width1 (*this, f, c);
}

Track_Width1::
~Track_Width1 ()
{
}

// V_IF_Filter1
//

V_IF_Filter1::
V_IF_Filter1 (const ::xml_schema::float_& _xsd_float__base,
              const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

V_IF_Filter1::
V_IF_Filter1 (const V_IF_Filter1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

V_IF_Filter1::
V_IF_Filter1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void V_IF_Filter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

V_IF_Filter1* V_IF_Filter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class V_IF_Filter1 (*this, f, c);
}

V_IF_Filter1::
~V_IF_Filter1 ()
{
}

// HP_Clutter1
//

HP_Clutter1::
HP_Clutter1 (const ::xml_schema::float_& _xsd_float__base,
             const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

HP_Clutter1::
HP_Clutter1 (const HP_Clutter1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

HP_Clutter1::
HP_Clutter1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void HP_Clutter1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

HP_Clutter1* HP_Clutter1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HP_Clutter1 (*this, f, c);
}

HP_Clutter1::
~HP_Clutter1 ()
{
}

// Window_Time1
//

Window_Time1::
Window_Time1 (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time1::
Window_Time1 (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time1::
Window_Time1 (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time1::
Window_Time1 (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

Window_Time1::
Window_Time1 (const Window_Time1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

Window_Time1::
Window_Time1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Window_Time1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

Window_Time1* Window_Time1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Window_Time1 (*this, f, c);
}

Window_Time1::
~Window_Time1 ()
{
}

// EKV_Start
//

EKV_Start::
EKV_Start (const ::xml_schema::float_& _xsd_float__base,
           const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Start::
EKV_Start (const EKV_Start& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Start::
EKV_Start (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Start::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Start* EKV_Start::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Start (*this, f, c);
}

EKV_Start::
~EKV_Start ()
{
}

// EKV_Stop
//

EKV_Stop::
EKV_Stop (const ::xml_schema::float_& _xsd_float__base,
          const units_type& units)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Stop::
EKV_Stop (const EKV_Stop& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Stop::
EKV_Stop (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Stop::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Stop* EKV_Stop::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Stop (*this, f, c);
}

EKV_Stop::
~EKV_Stop ()
{
}

// EKV_Quality_Times
//

EKV_Quality_Times::
EKV_Quality_Times (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Times::
EKV_Quality_Times (const char* _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Times::
EKV_Quality_Times (const ::std::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Times::
EKV_Quality_Times (const ::xml_schema::string& _xsd_string_base,
                   const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Times::
EKV_Quality_Times (const EKV_Quality_Times& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Quality_Times::
EKV_Quality_Times (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Quality_Times::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Quality_Times* EKV_Quality_Times::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Quality_Times (*this, f, c);
}

EKV_Quality_Times::
~EKV_Quality_Times ()
{
}

// EKV_Quality
//

EKV_Quality::
EKV_Quality (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality::
EKV_Quality (const char* _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality::
EKV_Quality (const ::std::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality::
EKV_Quality (const ::xml_schema::string& _xsd_string_base,
             const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality::
EKV_Quality (const EKV_Quality& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Quality::
EKV_Quality (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Quality::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Quality* EKV_Quality::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Quality (*this, f, c);
}

EKV_Quality::
~EKV_Quality ()
{
}

// EKV_Quality_Resolution
//

EKV_Quality_Resolution::
EKV_Quality_Resolution (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Resolution::
EKV_Quality_Resolution (const char* _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Resolution::
EKV_Quality_Resolution (const ::std::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Resolution::
EKV_Quality_Resolution (const ::xml_schema::string& _xsd_string_base,
                        const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Quality_Resolution::
EKV_Quality_Resolution (const EKV_Quality_Resolution& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Quality_Resolution::
EKV_Quality_Resolution (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Quality_Resolution::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Quality_Resolution* EKV_Quality_Resolution::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Quality_Resolution (*this, f, c);
}

EKV_Quality_Resolution::
~EKV_Quality_Resolution ()
{
}

// EKV_Variance
//

EKV_Variance::
EKV_Variance (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Variance::
EKV_Variance (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Variance::
EKV_Variance (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Variance::
EKV_Variance (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Variance::
EKV_Variance (const EKV_Variance& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Variance::
EKV_Variance (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Variance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Variance* EKV_Variance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Variance (*this, f, c);
}

EKV_Variance::
~EKV_Variance ()
{
}

// EKV_Triggers
//

EKV_Triggers::
EKV_Triggers (const units_type& units)
: ::xml_schema::string (),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Triggers::
EKV_Triggers (const char* _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Triggers::
EKV_Triggers (const ::std::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Triggers::
EKV_Triggers (const ::xml_schema::string& _xsd_string_base,
              const units_type& units)
: ::xml_schema::string (_xsd_string_base),
  units_ (units, ::xml_schema::flags (), this)
{
}

EKV_Triggers::
EKV_Triggers (const EKV_Triggers& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  units_ (x.units_, f, this)
{
}

EKV_Triggers::
EKV_Triggers (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  units_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void EKV_Triggers::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }
}

EKV_Triggers* EKV_Triggers::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EKV_Triggers (*this, f, c);
}

EKV_Triggers::
~EKV_Triggers ()
{
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const image_info_t& i)
{
  o << ::std::endl << "Study_Name: " << i.Study_Name ();
  if (i.Image_Id ())
  {
    o << ::std::endl << "Image_Id: " << *i.Image_Id ();
  }

  o << ::std::endl << "Image_Label: " << i.Image_Label ();
  o << ::std::endl << "Image_Frames: " << i.Image_Frames ();
  o << ::std::endl << "Image_Lines: " << i.Image_Lines ();
  o << ::std::endl << "Image_Acquisition_Per_Line: " << i.Image_Acquisition_Per_Line ();
  o << ::std::endl << "Image_Acquisition_Size: " << i.Image_Acquisition_Size ();
  o << ::std::endl << "Animal_ID: " << i.Animal_ID ();
  o << ::std::endl << "Acquisition_Mode: " << i.Acquisition_Mode ();
  o << ::std::endl << "Acquisition_Date: " << i.Acquisition_Date ();
  o << ::std::endl << "Acquisition_Time: " << i.Acquisition_Time ();
  o << ::std::endl << "Acquisition_Operator: " << i.Acquisition_Operator ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const image_data_t&)
{
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const image_parameters_t& i)
{
  o << ::std::endl << "RF-Mode: " << i.RF_Mode ();
  o << ::std::endl << "B-Mode: " << i.B_Mode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const rdi_t& i)
{
  o << ::std::endl << "image_info: " << i.image_info ();
  o << ::std::endl << "image_data: " << i.image_data ();
  o << ::std::endl << "image_parameters: " << i.image_parameters ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Mode& i)
{
  o << ::std::endl << "ActiveProbe: " << i.ActiveProbe ();
  o << ::std::endl << "BModeSoft: " << i.BModeSoft ();
  o << ::std::endl << "Sys: " << i.Sys ();
  o << ::std::endl << "MIS: " << i.MIS ();
  o << ::std::endl << "Scan: " << i.Scan ();
  o << ::std::endl << "Motor: " << i.Motor ();
  o << ::std::endl << "Diag: " << i.Diag ();
  o << ::std::endl << "ECG: " << i.ECG ();
  o << ::std::endl << "RfModeSoft: " << i.RfModeSoft ();
  o << ::std::endl << "TX: " << i.TX ();
  o << ::std::endl << "X_3D: " << i.X_3D ();
  o << ::std::endl << "RfAnalysis: " << i.RfAnalysis ();
  o << ::std::endl << "RX: " << i.RX ();
  o << ::std::endl << "Display: " << i.Display ();
  o << ::std::endl << "Acqiris: " << i.Acqiris ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const B_Mode& i)
{
  o << ::std::endl << "ActiveProbe: " << i.ActiveProbe ();
  o << ::std::endl << "BModeSoft: " << i.BModeSoft ();
  o << ::std::endl << "Sys: " << i.Sys ();
  o << ::std::endl << "Contrast: " << i.Contrast ();
  o << ::std::endl << "MIS: " << i.MIS ();
  o << ::std::endl << "Scan: " << i.Scan ();
  o << ::std::endl << "Motor: " << i.Motor ();
  o << ::std::endl << "ContrastDlg: " << i.ContrastDlg ();
  o << ::std::endl << "Diag: " << i.Diag ();
  o << ::std::endl << "ECG: " << i.ECG ();
  o << ::std::endl << "TX: " << i.TX ();
  o << ::std::endl << "ContrastDestroy: " << i.ContrastDestroy ();
  o << ::std::endl << "X_3D: " << i.X_3D ();
  o << ::std::endl << "X_3DSoft: " << i.X_3DSoft ();
  o << ::std::endl << "RX: " << i.RX ();
  o << ::std::endl << "Display: " << i.Display ();
  o << ::std::endl << "EKVModeSoft: " << i.EKVModeSoft ();
  o << ::std::endl << "BModeLVAnalysis: " << i.BModeLVAnalysis ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ActiveProbe& i)
{
  o << ::std::endl << "Notes: " << i.Notes ();
  o << ::std::endl << "Sample-Time: " << i.Sample_Time ();
  o << ::std::endl << "Focal-Length: " << i.Focal_Length ();
  o << ::std::endl << "Acceleration-Limit-Slope: " << i.Acceleration_Limit_Slope ();
  o << ::std::endl << "Type: " << i.Type ();
  o << ::std::endl << "Detect-Id: " << i.Detect_Id ();
  o << ::std::endl << "Default-Scan-Speed: " << i.Default_Scan_Speed ();
  o << ::std::endl << "K1-Power: " << i.K1_Power ();
  o << ::std::endl << "Cutoff-Scan-Speed: " << i.Cutoff_Scan_Speed ();
  o << ::std::endl << "Frequency-Low: " << i.Frequency_Low ();
  o << ::std::endl << "Default-FOV: " << i.Default_FOV ();
  o << ::std::endl << "Frequency-Doppler-Default: " << i.Frequency_Doppler_Default ();
  o << ::std::endl << "Default-SvSize-MMode: " << i.Default_SvSize_MMode ();
  o << ::std::endl << "Axial-Res-Factor-Target: " << i.Axial_Res_Factor_Target ();
  o << ::std::endl << "F-Number: " << i.F_Number ();
  o << ::std::endl << "Acc-Time-Factor: " << i.Acc_Time_Factor ();
  o << ::std::endl << "Frequency-Doppler: " << i.Frequency_Doppler ();
  o << ::std::endl << "Axial-Res: " << i.Axial_Res ();
  o << ::std::endl << "Detect-Ratio-Min: " << i.Detect_Ratio_Min ();
  o << ::std::endl << "Lateral-Res-Factor-Target: " << i.Lateral_Res_Factor_Target ();
  o << ::std::endl << "Derivative-Time: " << i.Derivative_Time ();
  o << ::std::endl << "Filter-High: " << i.Filter_High ();
  o << ::std::endl << "Pivot-Encoder-Dist: " << i.Pivot_Encoder_Dist ();
  o << ::std::endl << "Encoder-Range-Max: " << i.Encoder_Range_Max ();
  o << ::std::endl << "Encoder-Range-Min: " << i.Encoder_Range_Min ();
  o << ::std::endl << "Lateral-Res: " << i.Lateral_Res ();
  o << ::std::endl << "Motor-Overhead: " << i.Motor_Overhead ();
  o << ::std::endl << "Max-Scan-Distance: " << i.Max_Scan_Distance ();
  o << ::std::endl << "Version: " << i.Version ();
  o << ::std::endl << "Default-Rx-Gain: " << i.Default_Rx_Gain ();
  o << ::std::endl << "Filter-Low: " << i.Filter_Low ();
  o << ::std::endl << "PID-KD-High: " << i.PID_KD_High ();
  o << ::std::endl << "PID-KI-High: " << i.PID_KI_High ();
  o << ::std::endl << "PID-KP-High: " << i.PID_KP_High ();
  o << ::std::endl << "Frequency-High: " << i.Frequency_High ();
  o << ::std::endl << "Lateral-Res-Factor-Max: " << i.Lateral_Res_Factor_Max ();
  o << ::std::endl << "Scan-Speeds: " << i.Scan_Speeds ();
  o << ::std::endl << "Filter-Doppler-Cutoff: " << i.Filter_Doppler_Cutoff ();
  o << ::std::endl << "Name: " << i.Name ();
  o << ::std::endl << "PID-KD-Low: " << i.PID_KD_Low ();
  o << ::std::endl << "PID-KI-Low: " << i.PID_KI_Low ();
  o << ::std::endl << "PID-KP-Low: " << i.PID_KP_Low ();
  o << ::std::endl << "Peak-Bandwidth-Correction: " << i.Peak_Bandwidth_Correction ();
  o << ::std::endl << "Frequency-Doppler-Low: " << i.Frequency_Doppler_Low ();
  o << ::std::endl << "Pivot-Transducer-Face-Dist: " << i.Pivot_Transducer_Face_Dist ();
  o << ::std::endl << "Filter-Doppler: " << i.Filter_Doppler ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "Integration-Limit: " << i.Integration_Limit ();
  o << ::std::endl << "Encoder-Separation: " << i.Encoder_Separation ();
  o << ::std::endl << "Overshoot: " << i.Overshoot ();
  o << ::std::endl << "Attenuation-Shift: " << i.Attenuation_Shift ();
  o << ::std::endl << "Filter: " << i.Filter ();
  o << ::std::endl << "Default-Rx-Gain-Doppler: " << i.Default_Rx_Gain_Doppler ();
  o << ::std::endl << "Peak-Vel-Correction: " << i.Peak_Vel_Correction ();
  o << ::std::endl << "Detect-Ratio-Max: " << i.Detect_Ratio_Max ();
  o << ::std::endl << "Acceleration-Limit-Constant: " << i.Acceleration_Limit_Constant ();
  o << ::std::endl << "Filter-Doppler-Low: " << i.Filter_Doppler_Low ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BModeSoft& i)
{
  o << ::std::endl << "V-Relative-Frame-Rate: " << i.V_Relative_Frame_Rate ();
  o << ::std::endl << "Max-Power-Size-Default: " << i.Max_Power_Size_Default ();
  o << ::std::endl << "Buffer-Size: " << i.Buffer_Size ();
  o << ::std::endl << "AVR-Factor: " << i.AVR_Factor ();
  o << ::std::endl << "AVR-Startup-Frames: " << i.AVR_Startup_Frames ();
  o << ::std::endl << "BMode-Size-Default: " << i.BMode_Size_Default ();
  o << ::std::endl << "Relative-Frame-Rate: " << i.Relative_Frame_Rate ();
  o << ::std::endl << "Refresh-Rate: " << i.Refresh_Rate ();
  o << ::std::endl << "Acquire-Both-Directions: " << i.Acquire_Both_Directions ();
  o << ::std::endl << "Acquire-Persist-AVR: " << i.Acquire_Persist_AVR ();
  o << ::std::endl << "Power-Size-Default: " << i.Power_Size_Default ();
  o << ::std::endl << "Max-BMode-Size-Default: " << i.Max_BMode_Size_Default ();
  o << ::std::endl << "Target-Field-Of-View: " << i.Target_Field_Of_View ();
  o << ::std::endl << "Processing-Command: " << i.Processing_Command ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sys& i)
{
  o << ::std::endl << "Query-Discard-Loop-On-Save-Frame: " << i.Query_Discard_Loop_On_Save_Frame ();
  o << ::std::endl << "Sound-Speed: " << i.Sound_Speed ();
  o << ::std::endl << "SubMode: " << i.SubMode ();
  o << ::std::endl << "Interrupt-Mask: " << i.Interrupt_Mask ();
  o << ::std::endl << "Calculation-Instances: " << i.Calculation_Instances ();
  o << ::std::endl << "Start-Licence-Date: " << i.Start_Licence_Date ();
  o << ::std::endl << "End-Licence-Date: " << i.End_Licence_Date ();
  o << ::std::endl << "Auto-Save-PreTrig-Loop: " << i.Auto_Save_PreTrig_Loop ();
  o << ::std::endl << "Feature: " << i.Feature ();
  o << ::std::endl << "Review-Setup-Dialog: " << i.Review_Setup_Dialog ();
  o << ::std::endl << "Acq-Setup-Dialog: " << i.Acq_Setup_Dialog ();
  o << ::std::endl << "Interrupt-Clear: " << i.Interrupt_Clear ();
  o << ::std::endl << "Interrupt-Status: " << i.Interrupt_Status ();
  o << ::std::endl << "Auto-Save-Load-3D: " << i.Auto_Save_Load_3D ();
  o << ::std::endl << "DICOM-Root-ID: " << i.DICOM_Root_ID ();
  o << ::std::endl << "Company-Name: " << i.Company_Name ();
  o << ::std::endl << "Image-To-Auto-Save-On-Label: " << i.Image_To_Auto_Save_On_Label ();
  o << ::std::endl << "DICOM-Encode-Regions: " << i.DICOM_Encode_Regions ();
  o << ::std::endl << "Pipeline-Delay: " << i.Pipeline_Delay ();
  o << ::std::endl << "DDS-Control: " << i.DDS_Control ();
  o << ::std::endl << "Mode: " << i.Mode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MIS& i)
{
  o << ::std::endl << "ECG-Gain: " << i.ECG_Gain ();
  o << ::std::endl << "ECG-Available: " << i.ECG_Available ();
  o << ::std::endl << "Blood-Pressure-Available: " << i.Blood_Pressure_Available ();
  o << ::std::endl << "Respiration-Gating: " << i.Respiration_Gating ();
  o << ::std::endl << "Respiration-Available: " << i.Respiration_Available ();
  o << ::std::endl << "Control: " << i.Control ();
  o << ::std::endl << "BP-Gain: " << i.BP_Gain ();
  o << ::std::endl << "Temperature-Available: " << i.Temperature_Available ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan& i)
{
  o << ::std::endl << "Encoder-Position: " << i.Encoder_Position ();
  o << ::std::endl << "Center: " << i.Center ();
  o << ::std::endl << "Control: " << i.Control ();
  o << ::std::endl << "Probe-ID1: " << i.Probe_ID1 ();
  o << ::std::endl << "Probe-ID2: " << i.Probe_ID2 ();
  o << ::std::endl << "V-Scan-Speed: " << i.V_Scan_Speed ();
  o << ::std::endl << "Probe-ID1-Reread: " << i.Probe_ID1_Reread ();
  o << ::std::endl << "Probe-ID1-Valid: " << i.Probe_ID1_Valid ();
  o << ::std::endl << "Probe-ID1-Voltage: " << i.Probe_ID1_Voltage ();
  o << ::std::endl << "Probe-ID2-Reread: " << i.Probe_ID2_Reread ();
  o << ::std::endl << "Probe-ID2-Valid: " << i.Probe_ID2_Valid ();
  o << ::std::endl << "Probe-ID2-Voltage: " << i.Probe_ID2_Voltage ();
  o << ::std::endl << "V-Scan-Rate: " << i.V_Scan_Rate ();
  o << ::std::endl << "Position-Counter-Lock: " << i.Position_Counter_Lock ();
  o << ::std::endl << "Scan-Width: " << i.Scan_Width ();
  o << ::std::endl << "Position-Counter-Reset: " << i.Position_Counter_Reset ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Motor& i)
{
  o << ::std::endl << "Settle-Time-3d: " << i.Settle_Time_3d ();
  o << ::std::endl << "Position: " << i.Position ();
  o << ::std::endl << "R-Scan-Move-No-Wait: " << i.R_Scan_Move_No_Wait ();
  o << ::std::endl << "Motor-Mode: " << i.Motor_Mode ();
  o << ::std::endl << "Acceleration: " << i.Acceleration ();
  o << ::std::endl << "Serial-Port-Mode: " << i.Serial_Port_Mode ();
  o << ::std::endl << "Limit-Switch-Mode: " << i.Limit_Switch_Mode ();
  o << ::std::endl << "Breakpoint: " << i.Breakpoint ();
  o << ::std::endl << "Update: " << i.Update ();
  o << ::std::endl << "Breakpoint-Value: " << i.Breakpoint_Value ();
  o << ::std::endl << "V-Switch-Limit: " << i.V_Switch_Limit ();
  o << ::std::endl << "R-Retrieve-Trace: " << i.R_Retrieve_Trace ();
  o << ::std::endl << "Velocity-Stationary: " << i.Velocity_Stationary ();
  o << ::std::endl << "Reset-Event-Status: " << i.Reset_Event_Status ();
  o << ::std::endl << "Actual-Position: " << i.Actual_Position ();
  o << ::std::endl << "Buffer-Length: " << i.Buffer_Length ();
  o << ::std::endl << "Event-Status: " << i.Event_Status ();
  o << ::std::endl << "R-Scan-Move2: " << i.R_Scan_Move2 ();
  o << ::std::endl << "Kp: " << i.Kp ();
  o << ::std::endl << "R-Wait-Finish-Scan-Move: " << i.R_Wait_Finish_Scan_Move ();
  o << ::std::endl << "Settle-Time: " << i.Settle_Time ();
  o << ::std::endl << "Acceleration-Stationary: " << i.Acceleration_Stationary ();
  o << ::std::endl << "Trace-Mode: " << i.Trace_Mode ();
  o << ::std::endl << "Trace-Period: " << i.Trace_Period ();
  o << ::std::endl << "Trace-Start: " << i.Trace_Start ();
  o << ::std::endl << "Position-Reverse: " << i.Position_Reverse ();
  o << ::std::endl << "Reset: " << i.Reset ();
  o << ::std::endl << "Trace-Count: " << i.Trace_Count ();
  o << ::std::endl << "R-Initialize: " << i.R_Initialize ();
  o << ::std::endl << "Output-Mode: " << i.Output_Mode ();
  o << ::std::endl << "Position2: " << i.Position2 ();
  o << ::std::endl << "Integration-Limit: " << i.Integration_Limit ();
  o << ::std::endl << "R-Home: " << i.R_Home ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "R-Reset-Limit-Switch: " << i.R_Reset_Limit_Switch ();
  o << ::std::endl << "Settle-Window-3d: " << i.Settle_Window_3d ();
  o << ::std::endl << "Interrupt-Mask: " << i.Interrupt_Mask ();
  o << ::std::endl << "Scan-Move-Control: " << i.Scan_Move_Control ();
  o << ::std::endl << "Axis-Out-Source: " << i.Axis_Out_Source ();
  o << ::std::endl << "Trace-Stop: " << i.Trace_Stop ();
  o << ::std::endl << "Velocity: " << i.Velocity ();
  o << ::std::endl << "R-Setup: " << i.R_Setup ();
  o << ::std::endl << "Buffer-Start: " << i.Buffer_Start ();
  o << ::std::endl << "Signal-Sense: " << i.Signal_Sense ();
  o << ::std::endl << "R-Scan-Move: " << i.R_Scan_Move ();
  o << ::std::endl << "Position-Forward: " << i.Position_Forward ();
  o << ::std::endl << "Derivative-Time: " << i.Derivative_Time ();
  o << ::std::endl << "Settle-Window: " << i.Settle_Window ();
  o << ::std::endl << "Trace-Variable1: " << i.Trace_Variable1 ();
  o << ::std::endl << "Trace-Variable2: " << i.Trace_Variable2 ();
  o << ::std::endl << "Buffer-Read-Index: " << i.Buffer_Read_Index ();
  o << ::std::endl << "Signal-Status: " << i.Signal_Status ();
  o << ::std::endl << "Alarm-Clear: " << i.Alarm_Clear ();
  o << ::std::endl << "Motion-Complete-Mode: " << i.Motion_Complete_Mode ();
  o << ::std::endl << "R-Setup-Abort: " << i.R_Setup_Abort ();
  o << ::std::endl << "Read-Buffer: " << i.Read_Buffer ();
  o << ::std::endl << "Kd: " << i.Kd ();
  o << ::std::endl << "Clear-Interrupt: " << i.Clear_Interrupt ();
  o << ::std::endl << "Profile-Mode: " << i.Profile_Mode ();
  o << ::std::endl << "R-Setup-Trace: " << i.R_Setup_Trace ();
  o << ::std::endl << "No-Operation: " << i.No_Operation ();
  o << ::std::endl << "Ki: " << i.Ki ();
  o << ::std::endl << "Sample-Time: " << i.Sample_Time ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Diag& i)
{
  o << ::std::endl << "Mem-Pagefile: " << i.Mem_Pagefile ();
  o << ::std::endl << "Monitor-3point3V: " << i.Monitor_3point3V ();
  o << ::std::endl << "USER-Objects: " << i.USER_Objects ();
  o << ::std::endl << "Motor-FPGA-Revision: " << i.Motor_FPGA_Revision ();
  o << ::std::endl << "Product-Name: " << i.Product_Name ();
  o << ::std::endl << "Build-Version: " << i.Build_Version ();
  o << ::std::endl << "ICB-PCB-ID: " << i.ICB_PCB_ID ();
  o << ::std::endl << "Software-Version: " << i.Software_Version ();
  o << ::std::endl << "Receive-PCB-ID: " << i.Receive_PCB_ID ();
  o << ::std::endl << "Receive-FPGA-Revision: " << i.Receive_FPGA_Revision ();
  o << ::std::endl << "Monitor-15V: " << i.Monitor_15V ();
  o << ::std::endl << "ICB-FPGA-Revision: " << i.ICB_FPGA_Revision ();
  o << ::std::endl << "GDI-Objects: " << i.GDI_Objects ();
  o << ::std::endl << "Mem-WorkingSet: " << i.Mem_WorkingSet ();
  o << ::std::endl << "Mem-Private: " << i.Mem_Private ();
  o << ::std::endl << "Switch-PCB-ID: " << i.Switch_PCB_ID ();
  o << ::std::endl << "Monitor-5V: " << i.Monitor_5V ();
  o << ::std::endl << "Motor-PCB-Revision: " << i.Motor_PCB_Revision ();
  o << ::std::endl << "NE1619: " << i.NE1619 ();
  o << ::std::endl << "Motor-PCB-ID: " << i.Motor_PCB_ID ();
  o << ::std::endl << "Transmit-PCB-Revision: " << i.Transmit_PCB_Revision ();
  o << ::std::endl << "MAX1137: " << i.MAX1137 ();
  o << ::std::endl << "Monitor-Neg15V: " << i.Monitor_Neg15V ();
  o << ::std::endl << "Monitor-Neg5V: " << i.Monitor_Neg5V ();
  o << ::std::endl << "Switch-PCB-Revision: " << i.Switch_PCB_Revision ();
  o << ::std::endl << "Receive-PCB-Revision: " << i.Receive_PCB_Revision ();
  o << ::std::endl << "ICB-PCB-Revision: " << i.ICB_PCB_Revision ();
  o << ::std::endl << "Transmit-PCB-ID: " << i.Transmit_PCB_ID ();
  o << ::std::endl << "Monitor-Temperature: " << i.Monitor_Temperature ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG& i)
{
  o << ::std::endl << "Respiration-Threshold-Change: " << i.Respiration_Threshold_Change ();
  o << ::std::endl << "Respiration-Threshold: " << i.Respiration_Threshold ();
  o << ::std::endl << "Pressure-Range: " << i.Pressure_Range ();
  o << ::std::endl << "Respiration-Gate-Delay: " << i.Respiration_Gate_Delay ();
  o << ::std::endl << "Respiration-Timeout: " << i.Respiration_Timeout ();
  o << ::std::endl << "RWave-Max-Change-Factor-Percent: " << i.RWave_Max_Change_Factor_Percent ();
  o << ::std::endl << "Respiration-Period: " << i.Respiration_Period ();
  o << ::std::endl << "Respiration-Subsample-Rate: " << i.Respiration_Subsample_Rate ();
  o << ::std::endl << "Show-RWaves: " << i.Show_RWaves ();
  o << ::std::endl << "Respiration-Minimal-Peak-2-Peak: " << i.Respiration_Minimal_Peak_2_Peak ();
  o << ::std::endl << "Respiration-Window: " << i.Respiration_Window ();
  o << ::std::endl << "Pressure-Zeroed: " << i.Pressure_Zeroed ();
  o << ::std::endl << "Pressure-Systolic: " << i.Pressure_Systolic ();
  o << ::std::endl << "Respiration-Show-Window: " << i.Respiration_Show_Window ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "Respiration-Blank-Period: " << i.Respiration_Blank_Period ();
  o << ::std::endl << "Respiration-Range: " << i.Respiration_Range ();
  o << ::std::endl << "Pressure-Zero: " << i.Pressure_Zero ();
  o << ::std::endl << "Temperature-Amplification: " << i.Temperature_Amplification ();
  o << ::std::endl << "P-Wave-Start: " << i.P_Wave_Start ();
  o << ::std::endl << "ECG-Filter-Taps: " << i.ECG_Filter_Taps ();
  o << ::std::endl << "RWave-Future-Search-Time: " << i.RWave_Future_Search_Time ();
  o << ::std::endl << "Respiration-Percent-Peak: " << i.Respiration_Percent_Peak ();
  o << ::std::endl << "T-Wave-Start: " << i.T_Wave_Start ();
  o << ::std::endl << "Strain-Rate-RR-Diff-Ratio: " << i.Strain_Rate_RR_Diff_Ratio ();
  o << ::std::endl << "Pressure-Calibration-Min-Level: " << i.Pressure_Calibration_Min_Level ();
  o << ::std::endl << "Pressure-Calibrated: " << i.Pressure_Calibrated ();
  o << ::std::endl << "DPDT-Range: " << i.DPDT_Range ();
  o << ::std::endl << "Respiration-Show-Event: " << i.Respiration_Show_Event ();
  o << ::std::endl << "Pressure-Diastolic: " << i.Pressure_Diastolic ();
  o << ::std::endl << "Temperature-Calibration: " << i.Temperature_Calibration ();
  o << ::std::endl << "Temperature: " << i.Temperature ();
  o << ::std::endl << "Respiration-Beats-To-Average: " << i.Respiration_Beats_To_Average ();
  o << ::std::endl << "RWave-Thresh-Trigger-Percent: " << i.RWave_Thresh_Trigger_Percent ();
  o << ::std::endl << "Respiration-Time-To-Average: " << i.Respiration_Time_To_Average ();
  o << ::std::endl << "Pressure-Amplification: " << i.Pressure_Amplification ();
  o << ::std::endl << "Heart-Period: " << i.Heart_Period ();
  o << ::std::endl << "Pressure-Show-Event: " << i.Pressure_Show_Event ();
  o << ::std::endl << "RWave-Default-Threshold: " << i.RWave_Default_Threshold ();
  o << ::std::endl << "Show-Filtered-Data: " << i.Show_Filtered_Data ();
  o << ::std::endl << "ECG-Range: " << i.ECG_Range ();
  o << ::std::endl << "RWave-Maxima-Block-Time: " << i.RWave_Maxima_Block_Time ();
  o << ::std::endl << "RWave-Noise-Threshold: " << i.RWave_Noise_Threshold ();
  o << ::std::endl << "Pressure-Calibration-Level: " << i.Pressure_Calibration_Level ();
  o << ::std::endl << "ECG-HP-Filter: " << i.ECG_HP_Filter ();
  o << ::std::endl << "ECG-LP-Filter: " << i.ECG_LP_Filter ();
  o << ::std::endl << "RWave-Max-Change-Period: " << i.RWave_Max_Change_Period ();
  o << ::std::endl << "Pressure-Time-Out: " << i.Pressure_Time_Out ();
  o << ::std::endl << "Pressure-Calibration: " << i.Pressure_Calibration ();
  o << ::std::endl << "RWave-Blank-Time: " << i.RWave_Blank_Time ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RfModeSoft& i)
{
  o << ::std::endl << "Amplitude-Height: " << i.Amplitude_Height ();
  o << ::std::endl << "Magnitude-Origin: " << i.Magnitude_Origin ();
  o << ::std::endl << "Frequency-Origin: " << i.Frequency_Origin ();
  o << ::std::endl << "Samples: " << i.Samples ();
  o << ::std::endl << "Saturation-Threshold: " << i.Saturation_Threshold ();
  o << ::std::endl << "Amplitude-Origin: " << i.Amplitude_Origin ();
  o << ::std::endl << "Frame-Selected: " << i.Frame_Selected ();
  o << ::std::endl << "AcqPerLine: " << i.AcqPerLine ();
  o << ::std::endl << "Lines: " << i.Lines ();
  o << ::std::endl << "Windowing-Mode: " << i.Windowing_Mode ();
  o << ::std::endl << "Length-Origin: " << i.Length_Origin ();
  o << ::std::endl << "Line-Selected: " << i.Line_Selected ();
  o << ::std::endl << "V-Lines-Pos: " << i.V_Lines_Pos ();
  o << ::std::endl << "Bounce-Test-AscanData: " << i.Bounce_Test_AscanData ();
  o << ::std::endl << "Vertical-Scale: " << i.Vertical_Scale ();
  o << ::std::endl << "Bounce-Test-RFData: " << i.Bounce_Test_RFData ();
  o << ::std::endl << "SamplesPerSec: " << i.SamplesPerSec ();
  o << ::std::endl << "Frames: " << i.Frames ();
  o << ::std::endl << "Digitizer: " << i.Digitizer ();
  o << ::std::endl << "Magnitude-Height: " << i.Magnitude_Height ();
  o << ::std::endl << "Saturation: " << i.Saturation ();
  o << ::std::endl << "Length-Length: " << i.Length_Length ();
  o << ::std::endl << "Frequency-Length: " << i.Frequency_Length ();
  o << ::std::endl << "State: " << i.State ();
  o << ::std::endl << "SV-Center: " << i.SV_Center ();
  o << ::std::endl << "Continuous-RF-FrameRate: " << i.Continuous_RF_FrameRate ();
  o << ::std::endl << "Quantify-Bounce-Test: " << i.Quantify_Bounce_Test ();
  o << ::std::endl << "X_3D-Volume: " << i.X_3D_Volume ();
  o << ::std::endl << "Shift-RF-Data: " << i.Shift_RF_Data ();
  o << ::std::endl << "V-Lines: " << i.V_Lines ();
  o << ::std::endl << "Graph-Mode: " << i.Graph_Mode ();
  o << ::std::endl << "RF-Path-15Mhz-Time-Correction: " << i.RF_Path_15Mhz_Time_Correction ();
  o << ::std::endl << "RF-Path-23Mhz-Time-Correction: " << i.RF_Path_23Mhz_Time_Correction ();
  o << ::std::endl << "SV-Length-Limits: " << i.SV_Length_Limits ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const TX& i)
{
  o << ::std::endl << "V-Position-Table: " << i.V_Position_Table ();
  o << ::std::endl << "V-Transmit-Length: " << i.V_Transmit_Length ();
  o << ::std::endl << "Trigger-Counter-Clear: " << i.Trigger_Counter_Clear ();
  o << ::std::endl << "Trigger-Counter: " << i.Trigger_Counter ();
  o << ::std::endl << "Multi-Trigger-Freq: " << i.Multi_Trigger_Freq ();
  o << ::std::endl << "RF-Amp: " << i.RF_Amp ();
  o << ::std::endl << "Trigger-Control: " << i.Trigger_Control ();
  o << ::std::endl << "V-Pulse-Rep-Freq: " << i.V_Pulse_Rep_Freq ();
  o << ::std::endl << "Phase: " << i.Phase ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "V-Unblank-Time: " << i.V_Unblank_Time ();
  o << ::std::endl << "V-Frequency: " << i.V_Frequency ();
  o << ::std::endl << "Pulse-Rep-Frequency: " << i.Pulse_Rep_Frequency ();
  o << ::std::endl << "Multi-Trigger: " << i.Multi_Trigger ();
  o << ::std::endl << "Trig-Tbl-Trigs: " << i.Trig_Tbl_Trigs ();
  o << ::std::endl << "Width: " << i.Width ();
  o << ::std::endl << "Unblank-Cycles: " << i.Unblank_Cycles ();
  o << ::std::endl << "V-Width: " << i.V_Width ();
  o << ::std::endl << "Unblank-Time: " << i.Unblank_Time ();
  o << ::std::endl << "Attenuation: " << i.Attenuation ();
  o << ::std::endl << "V-Power: " << i.V_Power ();
  o << ::std::endl << "Computer-Trigger: " << i.Computer_Trigger ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const X_3D& i)
{
  o << ::std::endl << "Speed: " << i.Speed ();
  o << ::std::endl << "Status: " << i.Status ();
  o << ::std::endl << "Motor-Enable: " << i.Motor_Enable ();
  o << ::std::endl << "Scan-Distance: " << i.Scan_Distance ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "Steps: " << i.Steps ();
  o << ::std::endl << "Max-Scan-Steps: " << i.Max_Scan_Steps ();
  o << ::std::endl << "Position: " << i.Position ();
  o << ::std::endl << "Action: " << i.Action ();
  o << ::std::endl << "Clear-Error: " << i.Clear_Error ();
  o << ::std::endl << "Direction: " << i.Direction ();
  o << ::std::endl << "Step-Size: " << i.Step_Size ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RfAnalysis& i)
{
  o << ::std::endl << "Reference: " << i.Reference ();
  o << ::std::endl << "Ref-Probe-F-Number: " << i.Ref_Probe_F_Number ();
  o << ::std::endl << "Ref-Probe-Focal-Length: " << i.Ref_Probe_Focal_Length ();
  o << ::std::endl << "Ref-Tx-Frequency: " << i.Ref_Tx_Frequency ();
  o << ::std::endl << "Freq-Range: " << i.Freq_Range ();
  o << ::std::endl << "Ref-Probe-Name: " << i.Ref_Probe_Name ();
  o << ::std::endl << "Graph-Mode: " << i.Graph_Mode ();
  o << ::std::endl << "Normalized-Height: " << i.Normalized_Height ();
  o << ::std::endl << "Ref-Tx-Width: " << i.Ref_Tx_Width ();
  o << ::std::endl << "Normalized-Origin: " << i.Normalized_Origin ();
  o << ::std::endl << "Freq-Range-f: " << i.Freq_Range_f ();
  o << ::std::endl << "FFT-Offset: " << i.FFT_Offset ();
  o << ::std::endl << "Ref-Tx-Power: " << i.Ref_Tx_Power ();
  o << ::std::endl << "Freq-Range-Max: " << i.Freq_Range_Max ();
  o << ::std::endl << "Freq-Range-Min: " << i.Freq_Range_Min ();
  o << ::std::endl << "Ref-Offset: " << i.Ref_Offset ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RX& i)
{
  o << ::std::endl << "AD-IF: " << i.AD_IF ();
  o << ::std::endl << "Sector-Width-Target: " << i.Sector_Width_Target ();
  o << ::std::endl << "RF-Gain: " << i.RF_Gain ();
  o << ::std::endl << "TGC-Enable: " << i.TGC_Enable ();
  o << ::std::endl << "V-Digi-Depth-Imaging: " << i.V_Digi_Depth_Imaging ();
  o << ::std::endl << "RF-Bandwidth: " << i.RF_Bandwidth ();
  o << ::std::endl << "Test-Freq: " << i.Test_Freq ();
  o << ::std::endl << "Line-Number: " << i.Line_Number ();
  o << ::std::endl << "V-TGC: " << i.V_TGC ();
  o << ::std::endl << "IF-Filter: " << i.IF_Filter ();
  o << ::std::endl << "Track-Width: " << i.Track_Width ();
  o << ::std::endl << "DTB-Error-Clr: " << i.DTB_Error_Clr ();
  o << ::std::endl << "Current-Channel: " << i.Current_Channel ();
  o << ::std::endl << "V-IF-Filter: " << i.V_IF_Filter ();
  o << ::std::endl << "IQ-Select: " << i.IQ_Select ();
  o << ::std::endl << "HP-Clutter: " << i.HP_Clutter ();
  o << ::std::endl << "AD-In: " << i.AD_In ();
  o << ::std::endl << "V-TGC-Copy: " << i.V_TGC_Copy ();
  o << ::std::endl << "Image-FIFO-Status: " << i.Image_FIFO_Status ();
  o << ::std::endl << "RF-Filter: " << i.RF_Filter ();
  o << ::std::endl << "DDRS: " << i.DDRS ();
  o << ::std::endl << "ADCA-Out: " << i.ADCA_Out ();
  o << ::std::endl << "AD-Clock-Div: " << i.AD_Clock_Div ();
  o << ::std::endl << "Imaging-Mode: " << i.Imaging_Mode ();
  o << ::std::endl << "V-RF-Filter: " << i.V_RF_Filter ();
  o << ::std::endl << "ADCB-Out: " << i.ADCB_Out ();
  o << ::std::endl << "Delay: " << i.Delay ();
  o << ::std::endl << "AD-Gate-Width: " << i.AD_Gate_Width ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "V-Frequency: " << i.V_Frequency ();
  o << ::std::endl << "V-Field-Of-View: " << i.V_Field_Of_View ();
  o << ::std::endl << "Packet-Format: " << i.Packet_Format ();
  o << ::std::endl << "Sector-Height-Target: " << i.Sector_Height_Target ();
  o << ::std::endl << "Low-Speed-FIFO-Status: " << i.Low_Speed_FIFO_Status ();
  o << ::std::endl << "AD-TestIn: " << i.AD_TestIn ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "Test-On: " << i.Test_On ();
  o << ::std::endl << "AD-DCS: " << i.AD_DCS ();
  o << ::std::endl << "DTB-Tfr-Enable: " << i.DTB_Tfr_Enable ();
  o << ::std::endl << "DTB-Test-Enable: " << i.DTB_Test_Enable ();
  o << ::std::endl << "V-Delay-Length: " << i.V_Delay_Length ();
  o << ::std::endl << "Current-Mode: " << i.Current_Mode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Display& i)
{
  o << ::std::endl << "Direction: " << i.Direction ();
  o << ::std::endl << "X_3D-Gain: " << i.X_3D_Gain ();
  o << ::std::endl << "X_3D-Dynamic-Range: " << i.X_3D_Dynamic_Range ();
  o << ::std::endl << "V-Selection: " << i.V_Selection ();
  o << ::std::endl << "Gain: " << i.Gain ();
  o << ::std::endl << "Dynamic-Range: " << i.Dynamic_Range ();
  o << ::std::endl << "Window-Time: " << i.Window_Time ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acqiris& i)
{
  o << ::std::endl << "SamplesNom: " << i.SamplesNom ();
  o << ::std::endl << "V-Read-Data: " << i.V_Read_Data ();
  o << ::std::endl << "Mode: " << i.Mode ();
  o << ::std::endl << "Acquire: " << i.Acquire ();
  o << ::std::endl << "Available: " << i.Available ();
  o << ::std::endl << "Force-Trigger: " << i.Force_Trigger ();
  o << ::std::endl << "Control: " << i.Control ();
  o << ::std::endl << "TbSegmentPad: " << i.TbSegmentPad ();
  o << ::std::endl << "Wait-Acq: " << i.Wait_Acq ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ActiveProbe1& i)
{
  o << ::std::endl << "Notes: " << i.Notes ();
  o << ::std::endl << "Sample-Time: " << i.Sample_Time ();
  o << ::std::endl << "Focal-Length: " << i.Focal_Length ();
  o << ::std::endl << "Acceleration-Limit-Slope: " << i.Acceleration_Limit_Slope ();
  o << ::std::endl << "Type: " << i.Type ();
  o << ::std::endl << "Detect-Id: " << i.Detect_Id ();
  o << ::std::endl << "Default-Scan-Speed: " << i.Default_Scan_Speed ();
  o << ::std::endl << "K1-Power: " << i.K1_Power ();
  o << ::std::endl << "Cutoff-Scan-Speed: " << i.Cutoff_Scan_Speed ();
  o << ::std::endl << "Frequency-Low: " << i.Frequency_Low ();
  o << ::std::endl << "Default-FOV: " << i.Default_FOV ();
  o << ::std::endl << "Frequency-Doppler-Default: " << i.Frequency_Doppler_Default ();
  o << ::std::endl << "Default-SvSize-MMode: " << i.Default_SvSize_MMode ();
  o << ::std::endl << "Axial-Res-Factor-Target: " << i.Axial_Res_Factor_Target ();
  o << ::std::endl << "F-Number: " << i.F_Number ();
  o << ::std::endl << "Acc-Time-Factor: " << i.Acc_Time_Factor ();
  o << ::std::endl << "Axial-Res: " << i.Axial_Res ();
  o << ::std::endl << "Lateral-Res-Factor-Target: " << i.Lateral_Res_Factor_Target ();
  o << ::std::endl << "Pivot-Encoder-Dist: " << i.Pivot_Encoder_Dist ();
  o << ::std::endl << "Encoder-Range-Max: " << i.Encoder_Range_Max ();
  o << ::std::endl << "Encoder-Range-Min: " << i.Encoder_Range_Min ();
  o << ::std::endl << "Lateral-Res: " << i.Lateral_Res ();
  o << ::std::endl << "Max-Scan-Distance: " << i.Max_Scan_Distance ();
  o << ::std::endl << "Default-Rx-Gain: " << i.Default_Rx_Gain ();
  o << ::std::endl << "PID-KD-High: " << i.PID_KD_High ();
  o << ::std::endl << "PID-KI-High: " << i.PID_KI_High ();
  o << ::std::endl << "PID-KP-High: " << i.PID_KP_High ();
  o << ::std::endl << "Frequency-High: " << i.Frequency_High ();
  o << ::std::endl << "Lateral-Res-Factor-Max: " << i.Lateral_Res_Factor_Max ();
  o << ::std::endl << "Scan-Speeds: " << i.Scan_Speeds ();
  o << ::std::endl << "Filter-Doppler-Cutoff: " << i.Filter_Doppler_Cutoff ();
  o << ::std::endl << "Name: " << i.Name ();
  o << ::std::endl << "PID-KD-Low: " << i.PID_KD_Low ();
  o << ::std::endl << "PID-KI-Low: " << i.PID_KI_Low ();
  o << ::std::endl << "PID-KP-Low: " << i.PID_KP_Low ();
  o << ::std::endl << "Peak-Bandwidth-Correction: " << i.Peak_Bandwidth_Correction ();
  o << ::std::endl << "Frequency-Doppler-Low: " << i.Frequency_Doppler_Low ();
  o << ::std::endl << "Pivot-Transducer-Face-Dist: " << i.Pivot_Transducer_Face_Dist ();
  o << ::std::endl << "Filter-Doppler: " << i.Filter_Doppler ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "Integration-Limit: " << i.Integration_Limit ();
  o << ::std::endl << "Encoder-Separation: " << i.Encoder_Separation ();
  o << ::std::endl << "Overshoot: " << i.Overshoot ();
  o << ::std::endl << "Attenuation-Shift: " << i.Attenuation_Shift ();
  o << ::std::endl << "Filter: " << i.Filter ();
  o << ::std::endl << "Default-Rx-Gain-Doppler: " << i.Default_Rx_Gain_Doppler ();
  o << ::std::endl << "Peak-Vel-Correction: " << i.Peak_Vel_Correction ();
  o << ::std::endl << "Detect-Ratio-Max: " << i.Detect_Ratio_Max ();
  o << ::std::endl << "Acceleration-Limit-Constant: " << i.Acceleration_Limit_Constant ();
  o << ::std::endl << "Filter-Doppler-Low: " << i.Filter_Doppler_Low ();
  o << ::std::endl << "Frequency-Doppler: " << i.Frequency_Doppler ();
  o << ::std::endl << "Detect-Ratio-Min: " << i.Detect_Ratio_Min ();
  o << ::std::endl << "Derivative-Time: " << i.Derivative_Time ();
  o << ::std::endl << "Filter-High: " << i.Filter_High ();
  o << ::std::endl << "Motor-Overhead: " << i.Motor_Overhead ();
  o << ::std::endl << "Version: " << i.Version ();
  o << ::std::endl << "Filter-Low: " << i.Filter_Low ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BModeSoft1& i)
{
  o << ::std::endl << "Anti-Aliasing: " << i.Anti_Aliasing ();
  o << ::std::endl << "V-Relative-Frame-Rate: " << i.V_Relative_Frame_Rate ();
  o << ::std::endl << "Max-Power-Size-Default: " << i.Max_Power_Size_Default ();
  o << ::std::endl << "Buffer-Size: " << i.Buffer_Size ();
  o << ::std::endl << "Sector-Convert: " << i.Sector_Convert ();
  o << ::std::endl << "AVR-Factor: " << i.AVR_Factor ();
  o << ::std::endl << "Flip-Image: " << i.Flip_Image ();
  o << ::std::endl << "AVR-Startup-Frames: " << i.AVR_Startup_Frames ();
  o << ::std::endl << "BMode-Size-Default: " << i.BMode_Size_Default ();
  o << ::std::endl << "Relative-Frame-Rate: " << i.Relative_Frame_Rate ();
  o << ::std::endl << "Overlay-Mode: " << i.Overlay_Mode ();
  o << ::std::endl << "Refresh-Rate: " << i.Refresh_Rate ();
  o << ::std::endl << "Acquisition-Mode: " << i.Acquisition_Mode ();
  o << ::std::endl << "Acquire-Both-Directions: " << i.Acquire_Both_Directions ();
  o << ::std::endl << "Actual-Scan-Rate: " << i.Actual_Scan_Rate ();
  o << ::std::endl << "Acquire-Persist-AVR: " << i.Acquire_Persist_AVR ();
  o << ::std::endl << "Sector-X-Res: " << i.Sector_X_Res ();
  o << ::std::endl << "Sector-Y-Res: " << i.Sector_Y_Res ();
  o << ::std::endl << "Power-Size-Default: " << i.Power_Size_Default ();
  o << ::std::endl << "Sector-X-Start: " << i.Sector_X_Start ();
  o << ::std::endl << "Sector-Y-Start: " << i.Sector_Y_Start ();
  o << ::std::endl << "Max-BMode-Size-Default: " << i.Max_BMode_Size_Default ();
  o << ::std::endl << "Target-Field-Of-View: " << i.Target_Field_Of_View ();
  o << ::std::endl << "Processing-Command: " << i.Processing_Command ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sys1& i)
{
  o << ::std::endl << "Query-Discard-Loop-On-Save-Frame: " << i.Query_Discard_Loop_On_Save_Frame ();
  o << ::std::endl << "Sound-Speed: " << i.Sound_Speed ();
  o << ::std::endl << "SubMode: " << i.SubMode ();
  o << ::std::endl << "Interrupt-Mask: " << i.Interrupt_Mask ();
  o << ::std::endl << "Calculation-Instances: " << i.Calculation_Instances ();
  o << ::std::endl << "Start-Licence-Date: " << i.Start_Licence_Date ();
  o << ::std::endl << "End-Licence-Date: " << i.End_Licence_Date ();
  o << ::std::endl << "Auto-Save-PreTrig-Loop: " << i.Auto_Save_PreTrig_Loop ();
  o << ::std::endl << "Feature: " << i.Feature ();
  o << ::std::endl << "Acq-Setup-Dialog: " << i.Acq_Setup_Dialog ();
  o << ::std::endl << "Interrupt-Clear: " << i.Interrupt_Clear ();
  o << ::std::endl << "Interrupt-Status: " << i.Interrupt_Status ();
  o << ::std::endl << "Auto-Save-Load-3D: " << i.Auto_Save_Load_3D ();
  o << ::std::endl << "DICOM-Root-ID: " << i.DICOM_Root_ID ();
  o << ::std::endl << "Company-Name: " << i.Company_Name ();
  o << ::std::endl << "Image-To-Auto-Save-On-Label: " << i.Image_To_Auto_Save_On_Label ();
  o << ::std::endl << "DICOM-Encode-Regions: " << i.DICOM_Encode_Regions ();
  o << ::std::endl << "Pipeline-Delay: " << i.Pipeline_Delay ();
  o << ::std::endl << "DDS-Control: " << i.DDS_Control ();
  o << ::std::endl << "Mode: " << i.Mode ();
  o << ::std::endl << "Review-Setup-Dialog: " << i.Review_Setup_Dialog ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Contrast& i)
{
  o << ::std::endl << "Acquisition-3D-Volume: " << i.Acquisition_3D_Volume ();
  o << ::std::endl << "Contrast-Linear-Scale: " << i.Contrast_Linear_Scale ();
  o << ::std::endl << "Reference-3D-Step-Size: " << i.Reference_3D_Step_Size ();
  o << ::std::endl << "Remap-Color: " << i.Remap_Color ();
  o << ::std::endl << "Display-Mode: " << i.Display_Mode ();
  o << ::std::endl << "Contrast-Linear-Offset: " << i.Contrast_Linear_Offset ();
  o << ::std::endl << "Contrast-Linear-Slope: " << i.Contrast_Linear_Slope ();
  o << ::std::endl << "Median-Size-Perfusion: " << i.Median_Size_Perfusion ();
  o << ::std::endl << "Contrast-Size-Default: " << i.Contrast_Size_Default ();
  o << ::std::endl << "Median-Size-Default: " << i.Median_Size_Default ();
  o << ::std::endl << "Use-ECG-Gate: " << i.Use_ECG_Gate ();
  o << ::std::endl << "ECG-Gate-Range: " << i.ECG_Gate_Range ();
  o << ::std::endl << "Filter-Size-Perfusion: " << i.Filter_Size_Perfusion ();
  o << ::std::endl << "Max-Contrast-Size-Default: " << i.Max_Contrast_Size_Default ();
  o << ::std::endl << "Filter-Size-Default: " << i.Filter_Size_Default ();
  o << ::std::endl << "Cardiac-Divisions: " << i.Cardiac_Divisions ();
  o << ::std::endl << "Reference-3D-Scan-Distance: " << i.Reference_3D_Scan_Distance ();
  o << ::std::endl << "Median-Size-MIP: " << i.Median_Size_MIP ();
  o << ::std::endl << "Acquire-Both-Directions: " << i.Acquire_Both_Directions ();
  o << ::std::endl << "Data-Display-Scale-Shift: " << i.Data_Display_Scale_Shift ();
  o << ::std::endl << "Reference-Label: " << i.Reference_Label ();
  o << ::std::endl << "X_3D-Display-Mode: " << i.X_3D_Display_Mode ();
  o << ::std::endl << "Filter-Size-MIP: " << i.Filter_Size_MIP ();
  o << ::std::endl << "Contrast-Linear-Lock-Gain: " << i.Contrast_Linear_Lock_Gain ();
  o << ::std::endl << "Persistence-Process-Frames: " << i.Persistence_Process_Frames ();
  o << ::std::endl << "Reference-Range-Start: " << i.Reference_Range_Start ();
  o << ::std::endl << "Blur-MIP-BoxSize: " << i.Blur_MIP_BoxSize ();
  o << ::std::endl << "Threshold: " << i.Threshold ();
  o << ::std::endl << "Process-Direction: " << i.Process_Direction ();
  o << ::std::endl << "Reference-Range-Stop: " << i.Reference_Range_Stop ();
  o << ::std::endl << "Blur-MIP: " << i.Blur_MIP ();
  o << ::std::endl << "Persistence-Mode: " << i.Persistence_Mode ();
  o << ::std::endl << "Reference-3D-Volume: " << i.Reference_3D_Volume ();
  o << ::std::endl << "Gain: " << i.Gain ();
  o << ::std::endl << "Acquire-Persist-MIP: " << i.Acquire_Persist_MIP ();
  o << ::std::endl << "Dynamic-Range2: " << i.Dynamic_Range2 ();
  o << ::std::endl << "Contast-3D-Brightness: " << i.Contast_3D_Brightness ();
  o << ::std::endl << "Reference-3D-Steps: " << i.Reference_3D_Steps ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MIS1& i)
{
  o << ::std::endl << "ECG-Gain: " << i.ECG_Gain ();
  o << ::std::endl << "ECG-Available: " << i.ECG_Available ();
  o << ::std::endl << "Blood-Pressure-Available: " << i.Blood_Pressure_Available ();
  o << ::std::endl << "Respiration-Gating: " << i.Respiration_Gating ();
  o << ::std::endl << "BP-Gain: " << i.BP_Gain ();
  o << ::std::endl << "Temperature-Available: " << i.Temperature_Available ();
  o << ::std::endl << "Respiration-Available: " << i.Respiration_Available ();
  o << ::std::endl << "Control: " << i.Control ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan1& i)
{
  o << ::std::endl << "Encoder-Position: " << i.Encoder_Position ();
  o << ::std::endl << "Center: " << i.Center ();
  o << ::std::endl << "Control: " << i.Control ();
  o << ::std::endl << "Probe-ID1: " << i.Probe_ID1 ();
  o << ::std::endl << "Probe-ID2: " << i.Probe_ID2 ();
  o << ::std::endl << "V-Scan-Speed: " << i.V_Scan_Speed ();
  o << ::std::endl << "Probe-ID1-Reread: " << i.Probe_ID1_Reread ();
  o << ::std::endl << "Probe-ID1-Valid: " << i.Probe_ID1_Valid ();
  o << ::std::endl << "Probe-ID1-Voltage: " << i.Probe_ID1_Voltage ();
  o << ::std::endl << "Probe-ID2-Reread: " << i.Probe_ID2_Reread ();
  o << ::std::endl << "Probe-ID2-Valid: " << i.Probe_ID2_Valid ();
  o << ::std::endl << "Probe-ID2-Voltage: " << i.Probe_ID2_Voltage ();
  o << ::std::endl << "V-Scan-Rate: " << i.V_Scan_Rate ();
  o << ::std::endl << "Position-Counter-Lock: " << i.Position_Counter_Lock ();
  o << ::std::endl << "Scan-Width: " << i.Scan_Width ();
  o << ::std::endl << "Position-Counter-Reset: " << i.Position_Counter_Reset ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Motor1& i)
{
  o << ::std::endl << "Settle-Time-3d: " << i.Settle_Time_3d ();
  o << ::std::endl << "Position: " << i.Position ();
  o << ::std::endl << "R-Scan-Move-No-Wait: " << i.R_Scan_Move_No_Wait ();
  o << ::std::endl << "Motor-Mode: " << i.Motor_Mode ();
  o << ::std::endl << "Acceleration: " << i.Acceleration ();
  o << ::std::endl << "Serial-Port-Mode: " << i.Serial_Port_Mode ();
  o << ::std::endl << "Limit-Switch-Mode: " << i.Limit_Switch_Mode ();
  o << ::std::endl << "Breakpoint: " << i.Breakpoint ();
  o << ::std::endl << "Update: " << i.Update ();
  o << ::std::endl << "Breakpoint-Value: " << i.Breakpoint_Value ();
  o << ::std::endl << "V-Switch-Limit: " << i.V_Switch_Limit ();
  o << ::std::endl << "R-Retrieve-Trace: " << i.R_Retrieve_Trace ();
  o << ::std::endl << "Velocity-Stationary: " << i.Velocity_Stationary ();
  o << ::std::endl << "Reset-Event-Status: " << i.Reset_Event_Status ();
  o << ::std::endl << "Actual-Position: " << i.Actual_Position ();
  o << ::std::endl << "Buffer-Length: " << i.Buffer_Length ();
  o << ::std::endl << "R-Scan-Move2: " << i.R_Scan_Move2 ();
  o << ::std::endl << "Position-Reverse: " << i.Position_Reverse ();
  o << ::std::endl << "Reset: " << i.Reset ();
  o << ::std::endl << "Trace-Count: " << i.Trace_Count ();
  o << ::std::endl << "R-Initialize: " << i.R_Initialize ();
  o << ::std::endl << "Output-Mode: " << i.Output_Mode ();
  o << ::std::endl << "Position2: " << i.Position2 ();
  o << ::std::endl << "Integration-Limit: " << i.Integration_Limit ();
  o << ::std::endl << "R-Home: " << i.R_Home ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "R-Reset-Limit-Switch: " << i.R_Reset_Limit_Switch ();
  o << ::std::endl << "Settle-Window-3d: " << i.Settle_Window_3d ();
  o << ::std::endl << "Interrupt-Mask: " << i.Interrupt_Mask ();
  o << ::std::endl << "Scan-Move-Control: " << i.Scan_Move_Control ();
  o << ::std::endl << "Axis-Out-Source: " << i.Axis_Out_Source ();
  o << ::std::endl << "Trace-Stop: " << i.Trace_Stop ();
  o << ::std::endl << "Velocity: " << i.Velocity ();
  o << ::std::endl << "R-Setup: " << i.R_Setup ();
  o << ::std::endl << "Buffer-Start: " << i.Buffer_Start ();
  o << ::std::endl << "Signal-Sense: " << i.Signal_Sense ();
  o << ::std::endl << "R-Scan-Move: " << i.R_Scan_Move ();
  o << ::std::endl << "Position-Forward: " << i.Position_Forward ();
  o << ::std::endl << "Derivative-Time: " << i.Derivative_Time ();
  o << ::std::endl << "Settle-Window: " << i.Settle_Window ();
  o << ::std::endl << "Trace-Variable1: " << i.Trace_Variable1 ();
  o << ::std::endl << "Trace-Variable2: " << i.Trace_Variable2 ();
  o << ::std::endl << "Buffer-Read-Index: " << i.Buffer_Read_Index ();
  o << ::std::endl << "Signal-Status: " << i.Signal_Status ();
  o << ::std::endl << "Alarm-Clear: " << i.Alarm_Clear ();
  o << ::std::endl << "Motion-Complete-Mode: " << i.Motion_Complete_Mode ();
  o << ::std::endl << "R-Setup-Abort: " << i.R_Setup_Abort ();
  o << ::std::endl << "Read-Buffer: " << i.Read_Buffer ();
  o << ::std::endl << "Kd: " << i.Kd ();
  o << ::std::endl << "Clear-Interrupt: " << i.Clear_Interrupt ();
  o << ::std::endl << "Profile-Mode: " << i.Profile_Mode ();
  o << ::std::endl << "R-Setup-Trace: " << i.R_Setup_Trace ();
  o << ::std::endl << "No-Operation: " << i.No_Operation ();
  o << ::std::endl << "Ki: " << i.Ki ();
  o << ::std::endl << "Sample-Time: " << i.Sample_Time ();
  o << ::std::endl << "Event-Status: " << i.Event_Status ();
  o << ::std::endl << "Kp: " << i.Kp ();
  o << ::std::endl << "R-Wait-Finish-Scan-Move: " << i.R_Wait_Finish_Scan_Move ();
  o << ::std::endl << "Settle-Time: " << i.Settle_Time ();
  o << ::std::endl << "Acceleration-Stationary: " << i.Acceleration_Stationary ();
  o << ::std::endl << "Trace-Mode: " << i.Trace_Mode ();
  o << ::std::endl << "Trace-Period: " << i.Trace_Period ();
  o << ::std::endl << "Trace-Start: " << i.Trace_Start ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ContrastDlg& i)
{
  o << ::std::endl << "Contrast-YAxis-Auto-Scale: " << i.Contrast_YAxis_Auto_Scale ();
  o << ::std::endl << "Draw-Cardiac-Average: " << i.Draw_Cardiac_Average ();
  o << ::std::endl << "Average-Frames: " << i.Average_Frames ();
  o << ::std::endl << "Contrast-YAxis-Max: " << i.Contrast_YAxis_Max ();
  o << ::std::endl << "Draw-Destroy-Markers: " << i.Draw_Destroy_Markers ();
  o << ::std::endl << "Draw-Time-Axis: " << i.Draw_Time_Axis ();
  o << ::std::endl << "Draw-Cardiac-Grayscale: " << i.Draw_Cardiac_Grayscale ();
  o << ::std::endl << "Draw-Grayscale: " << i.Draw_Grayscale ();
  o << ::std::endl << "Draw-Markers: " << i.Draw_Markers ();
  o << ::std::endl << "Contrast-Linear: " << i.Contrast_Linear ();
  o << ::std::endl << "Cardiac-YAxis-Max: " << i.Cardiac_YAxis_Max ();
  o << ::std::endl << "Cardiac-YAxis-Auto-Scale: " << i.Cardiac_YAxis_Auto_Scale ();
  o << ::std::endl << "Draw-Moving-Average: " << i.Draw_Moving_Average ();
  o << ::std::endl << "Draw-Percent-Area: " << i.Draw_Percent_Area ();
  o << ::std::endl << "Percent-Area-Thresh: " << i.Percent_Area_Thresh ();
  o << ::std::endl << "Cardiac-Display-Frame: " << i.Cardiac_Display_Frame ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Diag1& i)
{
  o << ::std::endl << "Mem-Pagefile: " << i.Mem_Pagefile ();
  o << ::std::endl << "Monitor-3point3V: " << i.Monitor_3point3V ();
  o << ::std::endl << "USER-Objects: " << i.USER_Objects ();
  o << ::std::endl << "Motor-FPGA-Revision: " << i.Motor_FPGA_Revision ();
  o << ::std::endl << "Product-Name: " << i.Product_Name ();
  o << ::std::endl << "Build-Version: " << i.Build_Version ();
  o << ::std::endl << "ICB-PCB-ID: " << i.ICB_PCB_ID ();
  o << ::std::endl << "Software-Version: " << i.Software_Version ();
  o << ::std::endl << "Receive-PCB-ID: " << i.Receive_PCB_ID ();
  o << ::std::endl << "Mem-Private: " << i.Mem_Private ();
  o << ::std::endl << "Monitor-5V: " << i.Monitor_5V ();
  o << ::std::endl << "Motor-PCB-Revision: " << i.Motor_PCB_Revision ();
  o << ::std::endl << "NE1619: " << i.NE1619 ();
  o << ::std::endl << "Motor-PCB-ID: " << i.Motor_PCB_ID ();
  o << ::std::endl << "Transmit-PCB-Revision: " << i.Transmit_PCB_Revision ();
  o << ::std::endl << "MAX1137: " << i.MAX1137 ();
  o << ::std::endl << "Monitor-Neg15V: " << i.Monitor_Neg15V ();
  o << ::std::endl << "Monitor-Neg5V: " << i.Monitor_Neg5V ();
  o << ::std::endl << "Switch-PCB-Revision: " << i.Switch_PCB_Revision ();
  o << ::std::endl << "Receive-PCB-Revision: " << i.Receive_PCB_Revision ();
  o << ::std::endl << "ICB-PCB-Revision: " << i.ICB_PCB_Revision ();
  o << ::std::endl << "Transmit-PCB-ID: " << i.Transmit_PCB_ID ();
  o << ::std::endl << "Monitor-Temperature: " << i.Monitor_Temperature ();
  o << ::std::endl << "Receive-FPGA-Revision: " << i.Receive_FPGA_Revision ();
  o << ::std::endl << "Monitor-15V: " << i.Monitor_15V ();
  o << ::std::endl << "ICB-FPGA-Revision: " << i.ICB_FPGA_Revision ();
  o << ::std::endl << "GDI-Objects: " << i.GDI_Objects ();
  o << ::std::endl << "Mem-WorkingSet: " << i.Mem_WorkingSet ();
  o << ::std::endl << "Switch-PCB-ID: " << i.Switch_PCB_ID ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG1& i)
{
  o << ::std::endl << "Respiration-Threshold-Change: " << i.Respiration_Threshold_Change ();
  o << ::std::endl << "Respiration-Threshold: " << i.Respiration_Threshold ();
  o << ::std::endl << "Pressure-Range: " << i.Pressure_Range ();
  o << ::std::endl << "Respiration-Gate-Delay: " << i.Respiration_Gate_Delay ();
  o << ::std::endl << "Respiration-Timeout: " << i.Respiration_Timeout ();
  o << ::std::endl << "RWave-Max-Change-Factor-Percent: " << i.RWave_Max_Change_Factor_Percent ();
  o << ::std::endl << "Respiration-Period: " << i.Respiration_Period ();
  o << ::std::endl << "Respiration-Subsample-Rate: " << i.Respiration_Subsample_Rate ();
  o << ::std::endl << "Show-RWaves: " << i.Show_RWaves ();
  o << ::std::endl << "Respiration-Minimal-Peak-2-Peak: " << i.Respiration_Minimal_Peak_2_Peak ();
  o << ::std::endl << "Respiration-Window: " << i.Respiration_Window ();
  o << ::std::endl << "Pressure-Zeroed: " << i.Pressure_Zeroed ();
  o << ::std::endl << "Pressure-Systolic: " << i.Pressure_Systolic ();
  o << ::std::endl << "Respiration-Show-Window: " << i.Respiration_Show_Window ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "Respiration-Blank-Period: " << i.Respiration_Blank_Period ();
  o << ::std::endl << "Respiration-Range: " << i.Respiration_Range ();
  o << ::std::endl << "Pressure-Zero: " << i.Pressure_Zero ();
  o << ::std::endl << "Temperature-Amplification: " << i.Temperature_Amplification ();
  o << ::std::endl << "P-Wave-Start: " << i.P_Wave_Start ();
  o << ::std::endl << "ECG-Filter-Taps: " << i.ECG_Filter_Taps ();
  o << ::std::endl << "Respiration-Percent-Peak: " << i.Respiration_Percent_Peak ();
  o << ::std::endl << "T-Wave-Start: " << i.T_Wave_Start ();
  o << ::std::endl << "Strain-Rate-RR-Diff-Ratio: " << i.Strain_Rate_RR_Diff_Ratio ();
  o << ::std::endl << "Pressure-Calibration-Min-Level: " << i.Pressure_Calibration_Min_Level ();
  o << ::std::endl << "DPDT-Range: " << i.DPDT_Range ();
  o << ::std::endl << "Respiration-Show-Event: " << i.Respiration_Show_Event ();
  o << ::std::endl << "Pressure-Diastolic: " << i.Pressure_Diastolic ();
  o << ::std::endl << "Temperature-Calibration: " << i.Temperature_Calibration ();
  o << ::std::endl << "Temperature: " << i.Temperature ();
  o << ::std::endl << "Respiration-Beats-To-Average: " << i.Respiration_Beats_To_Average ();
  o << ::std::endl << "RWave-Thresh-Trigger-Percent: " << i.RWave_Thresh_Trigger_Percent ();
  o << ::std::endl << "Respiration-Time-To-Average: " << i.Respiration_Time_To_Average ();
  o << ::std::endl << "Pressure-Amplification: " << i.Pressure_Amplification ();
  o << ::std::endl << "Heart-Period: " << i.Heart_Period ();
  o << ::std::endl << "Pressure-Show-Event: " << i.Pressure_Show_Event ();
  o << ::std::endl << "RWave-Default-Threshold: " << i.RWave_Default_Threshold ();
  o << ::std::endl << "Show-Filtered-Data: " << i.Show_Filtered_Data ();
  o << ::std::endl << "ECG-Range: " << i.ECG_Range ();
  o << ::std::endl << "RWave-Maxima-Block-Time: " << i.RWave_Maxima_Block_Time ();
  o << ::std::endl << "RWave-Noise-Threshold: " << i.RWave_Noise_Threshold ();
  o << ::std::endl << "Pressure-Calibration-Level: " << i.Pressure_Calibration_Level ();
  o << ::std::endl << "ECG-HP-Filter: " << i.ECG_HP_Filter ();
  o << ::std::endl << "ECG-LP-Filter: " << i.ECG_LP_Filter ();
  o << ::std::endl << "RWave-Max-Change-Period: " << i.RWave_Max_Change_Period ();
  o << ::std::endl << "Pressure-Time-Out: " << i.Pressure_Time_Out ();
  o << ::std::endl << "Pressure-Calibration: " << i.Pressure_Calibration ();
  o << ::std::endl << "RWave-Blank-Time: " << i.RWave_Blank_Time ();
  o << ::std::endl << "RWave-Future-Search-Time: " << i.RWave_Future_Search_Time ();
  o << ::std::endl << "Pressure-Calibrated: " << i.Pressure_Calibrated ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const TX1& i)
{
  o << ::std::endl << "V-Position-Table: " << i.V_Position_Table ();
  o << ::std::endl << "V-Transmit-Length: " << i.V_Transmit_Length ();
  o << ::std::endl << "Trigger-Counter-Clear: " << i.Trigger_Counter_Clear ();
  o << ::std::endl << "Trigger-Counter: " << i.Trigger_Counter ();
  o << ::std::endl << "RF-Amp: " << i.RF_Amp ();
  o << ::std::endl << "Trigger-Control: " << i.Trigger_Control ();
  o << ::std::endl << "V-Pulse-Rep-Freq: " << i.V_Pulse_Rep_Freq ();
  o << ::std::endl << "Phase: " << i.Phase ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "V-Unblank-Time: " << i.V_Unblank_Time ();
  o << ::std::endl << "V-Frequency: " << i.V_Frequency ();
  o << ::std::endl << "Pulse-Rep-Frequency: " << i.Pulse_Rep_Frequency ();
  o << ::std::endl << "Multi-Trigger: " << i.Multi_Trigger ();
  o << ::std::endl << "Trig-Tbl-Trigs: " << i.Trig_Tbl_Trigs ();
  o << ::std::endl << "Width: " << i.Width ();
  o << ::std::endl << "Unblank-Cycles: " << i.Unblank_Cycles ();
  o << ::std::endl << "V-Width: " << i.V_Width ();
  o << ::std::endl << "Unblank-Time: " << i.Unblank_Time ();
  o << ::std::endl << "Attenuation: " << i.Attenuation ();
  o << ::std::endl << "V-Power: " << i.V_Power ();
  o << ::std::endl << "Computer-Trigger: " << i.Computer_Trigger ();
  o << ::std::endl << "Multi-Trigger-Freq: " << i.Multi_Trigger_Freq ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ContrastDestroy& i)
{
  o << ::std::endl << "Tx-Width: " << i.Tx_Width ();
  o << ::std::endl << "Destroy-External: " << i.Destroy_External ();
  o << ::std::endl << "Frames: " << i.Frames ();
  o << ::std::endl << "Frame-Rate: " << i.Frame_Rate ();
  o << ::std::endl << "Tx-PRF: " << i.Tx_PRF ();
  o << ::std::endl << "Tx-Power: " << i.Tx_Power ();
  o << ::std::endl << "Duration: " << i.Duration ();
  o << ::std::endl << "Control: " << i.Control ();
  o << ::std::endl << "Tx-Frequency: " << i.Tx_Frequency ();
  o << ::std::endl << "Destroy-Sequence-Active: " << i.Destroy_Sequence_Active ();
  o << ::std::endl << "Destroy-Sequence-Position: " << i.Destroy_Sequence_Position ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const X_3D1& i)
{
  o << ::std::endl << "Speed: " << i.Speed ();
  o << ::std::endl << "Status: " << i.Status ();
  o << ::std::endl << "Motor-Enable: " << i.Motor_Enable ();
  o << ::std::endl << "Scan-Distance: " << i.Scan_Distance ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "Steps: " << i.Steps ();
  o << ::std::endl << "Action: " << i.Action ();
  o << ::std::endl << "Clear-Error: " << i.Clear_Error ();
  o << ::std::endl << "Direction: " << i.Direction ();
  o << ::std::endl << "Step-Size: " << i.Step_Size ();
  o << ::std::endl << "Max-Scan-Steps: " << i.Max_Scan_Steps ();
  o << ::std::endl << "Position: " << i.Position ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const X_3DSoft& i)
{
  o << ::std::endl << "Acquire-Persist-3DMIP: " << i.Acquire_Persist_3DMIP ();
  o << ::std::endl << "Acquire-Persist-3D-Frames: " << i.Acquire_Persist_3D_Frames ();
  o << ::std::endl << "Acquire-Persist-3DAVR: " << i.Acquire_Persist_3DAVR ();
  o << ::std::endl << "Rotational-Direction: " << i.Rotational_Direction ();
  o << ::std::endl << "Sigma: " << i.Sigma ();
  o << ::std::endl << "Dilation-Iteration: " << i.Dilation_Iteration ();
  o << ::std::endl << "Parallel-Direction: " << i.Parallel_Direction ();
  o << ::std::endl << "Class: " << i.Class ();
  o << ::std::endl << "Orientation-Length: " << i.Orientation_Length ();
  o << ::std::endl << "External-Force: " << i.External_Force ();
  o << ::std::endl << "Interpolation-Resolution: " << i.Interpolation_Resolution ();
  o << ::std::endl << "Steps: " << i.Steps ();
  o << ::std::endl << "Parallel-Recon-Resolution: " << i.Parallel_Recon_Resolution ();
  o << ::std::endl << "Iteration: " << i.Iteration ();
  o << ::std::endl << "Type: " << i.Type ();
  o << ::std::endl << "Rotational-Step-Size: " << i.Rotational_Step_Size ();
  o << ::std::endl << "Internal-Force: " << i.Internal_Force ();
  o << ::std::endl << "Parallel-Step-Size: " << i.Parallel_Step_Size ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RX1& i)
{
  o << ::std::endl << "AD-IF: " << i.AD_IF ();
  o << ::std::endl << "Sector-Width-Target: " << i.Sector_Width_Target ();
  o << ::std::endl << "RF-Gain: " << i.RF_Gain ();
  o << ::std::endl << "TGC-Enable: " << i.TGC_Enable ();
  o << ::std::endl << "V-Digi-Depth-Imaging: " << i.V_Digi_Depth_Imaging ();
  o << ::std::endl << "RF-Bandwidth: " << i.RF_Bandwidth ();
  o << ::std::endl << "Test-Freq: " << i.Test_Freq ();
  o << ::std::endl << "V-TGC: " << i.V_TGC ();
  o << ::std::endl << "Current-Channel: " << i.Current_Channel ();
  o << ::std::endl << "AD-In: " << i.AD_In ();
  o << ::std::endl << "Image-FIFO-Status: " << i.Image_FIFO_Status ();
  o << ::std::endl << "RF-Filter: " << i.RF_Filter ();
  o << ::std::endl << "DDRS: " << i.DDRS ();
  o << ::std::endl << "ADCA-Out: " << i.ADCA_Out ();
  o << ::std::endl << "AD-Clock-Div: " << i.AD_Clock_Div ();
  o << ::std::endl << "Imaging-Mode: " << i.Imaging_Mode ();
  o << ::std::endl << "V-RF-Filter: " << i.V_RF_Filter ();
  o << ::std::endl << "ADCB-Out: " << i.ADCB_Out ();
  o << ::std::endl << "Delay: " << i.Delay ();
  o << ::std::endl << "AD-Gate-Width: " << i.AD_Gate_Width ();
  o << ::std::endl << "Frequency: " << i.Frequency ();
  o << ::std::endl << "V-Frequency: " << i.V_Frequency ();
  o << ::std::endl << "V-Field-Of-View: " << i.V_Field_Of_View ();
  o << ::std::endl << "Packet-Format: " << i.Packet_Format ();
  o << ::std::endl << "Sector-Height-Target: " << i.Sector_Height_Target ();
  o << ::std::endl << "Low-Speed-FIFO-Status: " << i.Low_Speed_FIFO_Status ();
  o << ::std::endl << "AD-TestIn: " << i.AD_TestIn ();
  o << ::std::endl << "Error: " << i.Error ();
  o << ::std::endl << "Test-On: " << i.Test_On ();
  o << ::std::endl << "AD-DCS: " << i.AD_DCS ();
  o << ::std::endl << "DTB-Tfr-Enable: " << i.DTB_Tfr_Enable ();
  o << ::std::endl << "DTB-Test-Enable: " << i.DTB_Test_Enable ();
  o << ::std::endl << "V-Delay-Length: " << i.V_Delay_Length ();
  o << ::std::endl << "Current-Mode: " << i.Current_Mode ();
  o << ::std::endl << "Line-Number: " << i.Line_Number ();
  o << ::std::endl << "IF-Filter: " << i.IF_Filter ();
  o << ::std::endl << "Track-Width: " << i.Track_Width ();
  o << ::std::endl << "DTB-Error-Clr: " << i.DTB_Error_Clr ();
  o << ::std::endl << "V-IF-Filter: " << i.V_IF_Filter ();
  o << ::std::endl << "IQ-Select: " << i.IQ_Select ();
  o << ::std::endl << "HP-Clutter: " << i.HP_Clutter ();
  o << ::std::endl << "V-TGC-Copy: " << i.V_TGC_Copy ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Display1& i)
{
  o << ::std::endl << "Direction: " << i.Direction ();
  o << ::std::endl << "V-SV-TissueMode: " << i.V_SV_TissueMode ();
  o << ::std::endl << "V-SV-MMode: " << i.V_SV_MMode ();
  o << ::std::endl << "X_3D-Gain: " << i.X_3D_Gain ();
  o << ::std::endl << "X_3D-Dynamic-Range: " << i.X_3D_Dynamic_Range ();
  o << ::std::endl << "Gain: " << i.Gain ();
  o << ::std::endl << "V-SV-RfMode: " << i.V_SV_RfMode ();
  o << ::std::endl << "V-SV-EkvMode: " << i.V_SV_EkvMode ();
  o << ::std::endl << "Dynamic-Range: " << i.Dynamic_Range ();
  o << ::std::endl << "Window-Time: " << i.Window_Time ();
  o << ::std::endl << "V-SV-DopplerMode: " << i.V_SV_DopplerMode ();
  o << ::std::endl << "V-SV-NeedleGuide: " << i.V_SV_NeedleGuide ();
  o << ::std::endl << "V-SV-ColorMode: " << i.V_SV_ColorMode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKVModeSoft& i)
{
  o << ::std::endl << "RWave-Time-Tollerance: " << i.RWave_Time_Tollerance ();
  o << ::std::endl << "EKV-Start: " << i.EKV_Start ();
  o << ::std::endl << "EKV-Stop: " << i.EKV_Stop ();
  o << ::std::endl << "EKV-Quality-Times: " << i.EKV_Quality_Times ();
  o << ::std::endl << "EKV-Quality: " << i.EKV_Quality ();
  o << ::std::endl << "EKV-Quality-Resolution: " << i.EKV_Quality_Resolution ();
  o << ::std::endl << "Difference-Percent-Periods-Keep: " << i.Difference_Percent_Periods_Keep ();
  o << ::std::endl << "EKV-Advanced: " << i.EKV_Advanced ();
  o << ::std::endl << "EKV-Variance: " << i.EKV_Variance ();
  o << ::std::endl << "EKV-Triggers: " << i.EKV_Triggers ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BModeLVAnalysis& i)
{
  o << ::std::endl << "Cycles-Cardiac-Region: " << i.Cycles_Cardiac_Region ();
  o << ::std::endl << "Cycles: " << i.Cycles ();
  o << ::std::endl << "Spline-Process-Points: " << i.Spline_Process_Points ();
  o << ::std::endl << "Speckle-Search-Size: " << i.Speckle_Search_Size ();
  o << ::std::endl << "Speckle-Compare-Size: " << i.Speckle_Compare_Size ();
  o << ::std::endl << "EKV-Frames: " << i.EKV_Frames ();
  o << ::std::endl << "Axis: " << i.Axis ();
  o << ::std::endl << "Cardinal-Tension: " << i.Cardinal_Tension ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sample_Time& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Focal_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Scan_Speed& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Cutoff_Scan_Speed& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Low& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_FOV& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler_Default& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Axial_Res& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_High& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pivot_Encoder_Dist& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Range_Max& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Range_Min& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Lateral_Res& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Motor_Overhead& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Max_Scan_Distance& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Rx_Gain& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Low& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_High& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Speeds& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler_Cutoff& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler_Low& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pivot_Transducer_Face_Dist& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Separation& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Overshoot& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Rx_Gain_Doppler& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler_Low& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Buffer_Size& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BMode_Size_Default& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Refresh_Rate& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Power_Size_Default& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Target_Field_Of_View& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sound_Speed& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pipeline_Delay& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Center& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Scan_Speed& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Scan_Rate& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Width& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move_No_Wait& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acceleration& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Velocity_Stationary& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move2& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acceleration_Stationary& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position_Reverse& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position2& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Velocity& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position_Forward& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_3point3V& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_15V& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_5V& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_Neg15V& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_Neg5V& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Threshold_Change& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Range& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Gate_Delay& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Timeout& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Max_Change_Factor_Percent& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Period& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Subsample_Rate& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Window& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Systolic& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Blank_Period& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Range& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Zero& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const P_Wave_Start& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Future_Search_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Percent_Peak& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const T_Wave_Start& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Strain_Rate_RR_Diff_Ratio& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Diastolic& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Temperature_Calibration& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Temperature& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Beats_To_Average& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Thresh_Trigger_Percent& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Time_To_Average& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Heart_Period& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_Range& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Maxima_Block_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Calibration_Level& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_HP_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_LP_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Max_Change_Period& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Calibration& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Blank_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Magnitude_Origin& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Origin& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Length_Origin& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Vertical_Scale& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SamplesPerSec& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Magnitude_Height& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Length_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SV_Center& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Path_15Mhz_Time_Correction& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Path_23Mhz_Time_Correction& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SV_Length_Limits& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Transmit_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Pulse_Rep_Freq& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency2& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Unblank_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Frequency& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pulse_Rep_Frequency& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Trig_Tbl_Trigs& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unblank_Cycles& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unblank_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Attenuation& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Power& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Distance& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Step_Size& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Ref_Probe_Focal_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Ref_Tx_Frequency& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Normalized_Height& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Normalized_Origin& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Ref_Tx_Power& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Freq_Range_Max& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Freq_Range_Min& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Width_Target& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Gain& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Digi_Depth_Imaging& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Test_Freq& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const IF_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Track_Width& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_IF_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const HP_Clutter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_RF_Filter& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Delay& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AD_Gate_Width& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency3& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Frequency1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Field_Of_View& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Height_Target& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AD_TestIn& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Delay_Length& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Window_Time& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sample_Time1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Focal_Length1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Scan_Speed1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Cutoff_Scan_Speed1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Low1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_FOV1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler_Default1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Axial_Res1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pivot_Encoder_Dist1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Range_Max1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Range_Min1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Lateral_Res1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Max_Scan_Distance1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Rx_Gain1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_High1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Speeds1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler_Cutoff1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler_Low1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pivot_Transducer_Face_Dist1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency4& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Encoder_Separation1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Overshoot1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Default_Rx_Gain_Doppler1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Doppler_Low1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency_Doppler1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_High1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Motor_Overhead1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Filter_Low1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Buffer_Size1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const BMode_Size_Default1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Overlay_Mode& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Refresh_Rate1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acquisition_Mode& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Actual_Scan_Rate& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_X_Res& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Y_Res& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Power_Size_Default1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_X_Start& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Y_Start& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Target_Field_Of_View1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sound_Speed1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pipeline_Delay1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Reference_3D_Step_Size& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Contrast_Size_Default& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Reference_3D_Scan_Distance& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Center1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Scan_Speed1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Scan_Rate1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Width1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move_No_Wait1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acceleration1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Velocity_Stationary1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move21& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position_Reverse1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position21& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Velocity1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const R_Scan_Move1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Position_Forward1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Acceleration_Stationary1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_3point3V1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_5V1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_Neg15V1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_Neg5V1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Monitor_15V1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Threshold_Change1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Range1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Gate_Delay1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Timeout1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Max_Change_Factor_Percent1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Period1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Subsample_Rate1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Window1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Systolic1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency5& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Blank_Period1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Range1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Zero1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const P_Wave_Start1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Percent_Peak1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const T_Wave_Start1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Strain_Rate_RR_Diff_Ratio1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Diastolic1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Temperature_Calibration1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Temperature1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Beats_To_Average1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Thresh_Trigger_Percent1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Respiration_Time_To_Average1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Heart_Period1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_Range1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Maxima_Block_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Calibration_Level1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_HP_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ECG_LP_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Max_Change_Period1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pressure_Calibration1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Blank_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RWave_Future_Search_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Transmit_Length1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Pulse_Rep_Freq1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency6& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Unblank_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Frequency2& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Pulse_Rep_Frequency1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Trig_Tbl_Trigs1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unblank_Cycles1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Unblank_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Attenuation1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Power1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frames& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frame_Rate& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Tx_PRF& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Tx_Power& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Duration& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Tx_Frequency& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Destroy_Sequence_Position& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Scan_Distance1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Step_Size1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Parallel_Step_Size& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Width_Target1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Gain1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Digi_Depth_Imaging1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Test_Freq1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RF_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_RF_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Delay1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AD_Gate_Width1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Frequency7& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Frequency3& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Field_Of_View1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Sector_Height_Target1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AD_TestIn1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_Delay_Length1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const IF_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Track_Width1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const V_IF_Filter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const HP_Clutter1& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Window_Time1& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Start& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Stop& i)
{
  o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Quality_Times& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Quality& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Quality_Resolution& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Variance& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EKV_Triggers& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "units: " << i.units ();
  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::rdi_t >
rdi (const ::std::string& u,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (const ::std::string& u,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (const ::std::string& u,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::rdi (isrc, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::rdi (isrc, h, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::rdi (isrc, h, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::rdi (isrc, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::rdi (isrc, h, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::std::istream& is,
     const ::std::string& sid,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::rdi (isrc, h, f, p);
}

::std::auto_ptr< ::rdi_t >
rdi (::xercesc::InputSource& i,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (::xercesc::InputSource& i,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (::xercesc::InputSource& i,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::rdi_t > r (
    ::rdi (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::rdi_t >
rdi (const ::xercesc::DOMDocument& d,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::rdi_t > r (
      ::rdi (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "rdi" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::rdi_t > r (
      ::xsd::cxx::tree::traits< ::rdi_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "rdi",
    "");
}

::std::auto_ptr< ::rdi_t >
rdi (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
     ::xml_schema::flags f,
     const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "rdi" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::rdi_t > r (
      ::xsd::cxx::tree::traits< ::rdi_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "rdi",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const image_info_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Study_Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Study_Name",
        e));

    s << i.Study_Name ();
  }

  // Image_Id
  //
  if (i.Image_Id ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Id",
        e));

    s << *i.Image_Id ();
  }

  // Image_Label
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Label",
        e));

    s << i.Image_Label ();
  }

  // Image_Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Frames",
        e));

    s << i.Image_Frames ();
  }

  // Image_Lines
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Lines",
        e));

    s << i.Image_Lines ();
  }

  // Image_Acquisition_Per_Line
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Acquisition_Per_Line",
        e));

    s << i.Image_Acquisition_Per_Line ();
  }

  // Image_Acquisition_Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image_Acquisition_Size",
        e));

    s << i.Image_Acquisition_Size ();
  }

  // Animal_ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Animal_ID",
        e));

    s << i.Animal_ID ();
  }

  // Acquisition_Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition_Mode",
        e));

    s << i.Acquisition_Mode ();
  }

  // Acquisition_Date
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition_Date",
        e));

    s << i.Acquisition_Date ();
  }

  // Acquisition_Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition_Time",
        e));

    s << i.Acquisition_Time ();
  }

  // Acquisition_Operator
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition_Operator",
        e));

    s << i.Acquisition_Operator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const image_data_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&, const image_data_t&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const image_data_t&)
{
}

void
operator<< (::xercesc::DOMElement& e, const image_parameters_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // RF-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Mode",
        e));

    s << i.RF_Mode ();
  }

  // B-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "B-Mode",
        e));

    s << i.B_Mode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const rdi_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // image_info
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "image_info",
        e));

    s << i.image_info ();
  }

  // image_data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "image_data",
        e));

    s << i.image_data ();
  }

  // image_parameters
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "image_parameters",
        e));

    s << i.image_parameters ();
  }
}

void
rdi (::std::ostream& o,
     const ::rdi_t& s,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
rdi (::std::ostream& o,
     const ::rdi_t& s,
     ::xml_schema::error_handler& h,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
rdi (::std::ostream& o,
     const ::rdi_t& s,
     ::xercesc::DOMErrorHandler& h,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
rdi (::xercesc::XMLFormatTarget& t,
     const ::rdi_t& s,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
rdi (::xercesc::XMLFormatTarget& t,
     const ::rdi_t& s,
     ::xml_schema::error_handler& h,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
rdi (::xercesc::XMLFormatTarget& t,
     const ::rdi_t& s,
     ::xercesc::DOMErrorHandler& h,
     const ::xml_schema::namespace_infomap& m,
     const ::std::string& e,
     ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::rdi (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
rdi (::xercesc::DOMDocument& d,
     const ::rdi_t& s,
     ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "rdi" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rdi",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
rdi (const ::rdi_t& s,
     const ::xml_schema::namespace_infomap& m,
     ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "rdi",
      "",
      m, f));

  ::rdi (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const RF_Mode& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ActiveProbe
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ActiveProbe",
        e));

    s << i.ActiveProbe ();
  }

  // BModeSoft
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BModeSoft",
        e));

    s << i.BModeSoft ();
  }

  // Sys
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sys",
        e));

    s << i.Sys ();
  }

  // MIS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MIS",
        e));

    s << i.MIS ();
  }

  // Scan
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan",
        e));

    s << i.Scan ();
  }

  // Motor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor",
        e));

    s << i.Motor ();
  }

  // Diag
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Diag",
        e));

    s << i.Diag ();
  }

  // ECG
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG",
        e));

    s << i.ECG ();
  }

  // RfModeSoft
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RfModeSoft",
        e));

    s << i.RfModeSoft ();
  }

  // TX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TX",
        e));

    s << i.TX ();
  }

  // X_3D
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D",
        e));

    s << i.X_3D ();
  }

  // RfAnalysis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RfAnalysis",
        e));

    s << i.RfAnalysis ();
  }

  // RX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RX",
        e));

    s << i.RX ();
  }

  // Display
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Display",
        e));

    s << i.Display ();
  }

  // Acqiris
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acqiris",
        e));

    s << i.Acqiris ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const B_Mode& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ActiveProbe
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ActiveProbe",
        e));

    s << i.ActiveProbe ();
  }

  // BModeSoft
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BModeSoft",
        e));

    s << i.BModeSoft ();
  }

  // Sys
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sys",
        e));

    s << i.Sys ();
  }

  // Contrast
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast",
        e));

    s << i.Contrast ();
  }

  // MIS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MIS",
        e));

    s << i.MIS ();
  }

  // Scan
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan",
        e));

    s << i.Scan ();
  }

  // Motor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor",
        e));

    s << i.Motor ();
  }

  // ContrastDlg
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContrastDlg",
        e));

    s << i.ContrastDlg ();
  }

  // Diag
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Diag",
        e));

    s << i.Diag ();
  }

  // ECG
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG",
        e));

    s << i.ECG ();
  }

  // TX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TX",
        e));

    s << i.TX ();
  }

  // ContrastDestroy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContrastDestroy",
        e));

    s << i.ContrastDestroy ();
  }

  // X_3D
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D",
        e));

    s << i.X_3D ();
  }

  // X_3DSoft
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3DSoft",
        e));

    s << i.X_3DSoft ();
  }

  // RX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RX",
        e));

    s << i.RX ();
  }

  // Display
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Display",
        e));

    s << i.Display ();
  }

  // EKVModeSoft
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKVModeSoft",
        e));

    s << i.EKVModeSoft ();
  }

  // BModeLVAnalysis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BModeLVAnalysis",
        e));

    s << i.BModeLVAnalysis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ActiveProbe& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Notes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << i.Notes ();
  }

  // Sample-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sample-Time",
        e));

    s << i.Sample_Time ();
  }

  // Focal-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Focal-Length",
        e));

    s << i.Focal_Length ();
  }

  // Acceleration-Limit-Slope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Limit-Slope",
        e));

    s << i.Acceleration_Limit_Slope ();
  }

  // Type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Type",
        e));

    s << i.Type ();
  }

  // Detect-Id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Id",
        e));

    s << i.Detect_Id ();
  }

  // Default-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Scan-Speed",
        e));

    s << i.Default_Scan_Speed ();
  }

  // K1-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "K1-Power",
        e));

    s << i.K1_Power ();
  }

  // Cutoff-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cutoff-Scan-Speed",
        e));

    s << i.Cutoff_Scan_Speed ();
  }

  // Frequency-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Low",
        e));

    s << i.Frequency_Low ();
  }

  // Default-FOV
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-FOV",
        e));

    s << i.Default_FOV ();
  }

  // Frequency-Doppler-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler-Default",
        e));

    s << i.Frequency_Doppler_Default ();
  }

  // Default-SvSize-MMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-SvSize-MMode",
        e));

    s << i.Default_SvSize_MMode ();
  }

  // Axial-Res-Factor-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axial-Res-Factor-Target",
        e));

    s << i.Axial_Res_Factor_Target ();
  }

  // F-Number
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "F-Number",
        e));

    s << i.F_Number ();
  }

  // Acc-Time-Factor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acc-Time-Factor",
        e));

    s << i.Acc_Time_Factor ();
  }

  // Frequency-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler",
        e));

    s << i.Frequency_Doppler ();
  }

  // Axial-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axial-Res",
        e));

    s << i.Axial_Res ();
  }

  // Detect-Ratio-Min
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Ratio-Min",
        e));

    s << i.Detect_Ratio_Min ();
  }

  // Lateral-Res-Factor-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res-Factor-Target",
        e));

    s << i.Lateral_Res_Factor_Target ();
  }

  // Derivative-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Derivative-Time",
        e));

    s << i.Derivative_Time ();
  }

  // Filter-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-High",
        e));

    s << i.Filter_High ();
  }

  // Pivot-Encoder-Dist
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pivot-Encoder-Dist",
        e));

    s << i.Pivot_Encoder_Dist ();
  }

  // Encoder-Range-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Range-Max",
        e));

    s << i.Encoder_Range_Max ();
  }

  // Encoder-Range-Min
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Range-Min",
        e));

    s << i.Encoder_Range_Min ();
  }

  // Lateral-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res",
        e));

    s << i.Lateral_Res ();
  }

  // Motor-Overhead
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Overhead",
        e));

    s << i.Motor_Overhead ();
  }

  // Max-Scan-Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Scan-Distance",
        e));

    s << i.Max_Scan_Distance ();
  }

  // Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Version",
        e));

    s << i.Version ();
  }

  // Default-Rx-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Rx-Gain",
        e));

    s << i.Default_Rx_Gain ();
  }

  // Filter-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Low",
        e));

    s << i.Filter_Low ();
  }

  // PID-KD-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KD-High",
        e));

    s << i.PID_KD_High ();
  }

  // PID-KI-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KI-High",
        e));

    s << i.PID_KI_High ();
  }

  // PID-KP-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KP-High",
        e));

    s << i.PID_KP_High ();
  }

  // Frequency-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-High",
        e));

    s << i.Frequency_High ();
  }

  // Lateral-Res-Factor-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res-Factor-Max",
        e));

    s << i.Lateral_Res_Factor_Max ();
  }

  // Scan-Speeds
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Speeds",
        e));

    s << i.Scan_Speeds ();
  }

  // Filter-Doppler-Cutoff
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler-Cutoff",
        e));

    s << i.Filter_Doppler_Cutoff ();
  }

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // PID-KD-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KD-Low",
        e));

    s << i.PID_KD_Low ();
  }

  // PID-KI-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KI-Low",
        e));

    s << i.PID_KI_Low ();
  }

  // PID-KP-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KP-Low",
        e));

    s << i.PID_KP_Low ();
  }

  // Peak-Bandwidth-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Peak-Bandwidth-Correction",
        e));

    s << i.Peak_Bandwidth_Correction ();
  }

  // Frequency-Doppler-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler-Low",
        e));

    s << i.Frequency_Doppler_Low ();
  }

  // Pivot-Transducer-Face-Dist
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pivot-Transducer-Face-Dist",
        e));

    s << i.Pivot_Transducer_Face_Dist ();
  }

  // Filter-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler",
        e));

    s << i.Filter_Doppler ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // Integration-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Integration-Limit",
        e));

    s << i.Integration_Limit ();
  }

  // Encoder-Separation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Separation",
        e));

    s << i.Encoder_Separation ();
  }

  // Overshoot
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Overshoot",
        e));

    s << i.Overshoot ();
  }

  // Attenuation-Shift
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attenuation-Shift",
        e));

    s << i.Attenuation_Shift ();
  }

  // Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter",
        e));

    s << i.Filter ();
  }

  // Default-Rx-Gain-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Rx-Gain-Doppler",
        e));

    s << i.Default_Rx_Gain_Doppler ();
  }

  // Peak-Vel-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Peak-Vel-Correction",
        e));

    s << i.Peak_Vel_Correction ();
  }

  // Detect-Ratio-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Ratio-Max",
        e));

    s << i.Detect_Ratio_Max ();
  }

  // Acceleration-Limit-Constant
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Limit-Constant",
        e));

    s << i.Acceleration_Limit_Constant ();
  }

  // Filter-Doppler-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler-Low",
        e));

    s << i.Filter_Doppler_Low ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BModeSoft& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // V-Relative-Frame-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Relative-Frame-Rate",
        e));

    s << i.V_Relative_Frame_Rate ();
  }

  // Max-Power-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Power-Size-Default",
        e));

    s << i.Max_Power_Size_Default ();
  }

  // Buffer-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Size",
        e));

    s << i.Buffer_Size ();
  }

  // AVR-Factor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AVR-Factor",
        e));

    s << i.AVR_Factor ();
  }

  // AVR-Startup-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AVR-Startup-Frames",
        e));

    s << i.AVR_Startup_Frames ();
  }

  // BMode-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BMode-Size-Default",
        e));

    s << i.BMode_Size_Default ();
  }

  // Relative-Frame-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Relative-Frame-Rate",
        e));

    s << i.Relative_Frame_Rate ();
  }

  // Refresh-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Refresh-Rate",
        e));

    s << i.Refresh_Rate ();
  }

  // Acquire-Both-Directions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Both-Directions",
        e));

    s << i.Acquire_Both_Directions ();
  }

  // Acquire-Persist-AVR
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-AVR",
        e));

    s << i.Acquire_Persist_AVR ();
  }

  // Power-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Power-Size-Default",
        e));

    s << i.Power_Size_Default ();
  }

  // Max-BMode-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-BMode-Size-Default",
        e));

    s << i.Max_BMode_Size_Default ();
  }

  // Target-Field-Of-View
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Target-Field-Of-View",
        e));

    s << i.Target_Field_Of_View ();
  }

  // Processing-Command
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Processing-Command",
        e));

    s << i.Processing_Command ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sys& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Query-Discard-Loop-On-Save-Frame
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Query-Discard-Loop-On-Save-Frame",
        e));

    s << i.Query_Discard_Loop_On_Save_Frame ();
  }

  // Sound-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sound-Speed",
        e));

    s << i.Sound_Speed ();
  }

  // SubMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SubMode",
        e));

    s << i.SubMode ();
  }

  // Interrupt-Mask
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Mask",
        e));

    s << i.Interrupt_Mask ();
  }

  // Calculation-Instances
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Calculation-Instances",
        e));

    s << i.Calculation_Instances ();
  }

  // Start-Licence-Date
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Start-Licence-Date",
        e));

    s << i.Start_Licence_Date ();
  }

  // End-Licence-Date
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "End-Licence-Date",
        e));

    s << i.End_Licence_Date ();
  }

  // Auto-Save-PreTrig-Loop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Auto-Save-PreTrig-Loop",
        e));

    s << i.Auto_Save_PreTrig_Loop ();
  }

  // Feature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Feature",
        e));

    s << i.Feature ();
  }

  // Review-Setup-Dialog
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Review-Setup-Dialog",
        e));

    s << i.Review_Setup_Dialog ();
  }

  // Acq-Setup-Dialog
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acq-Setup-Dialog",
        e));

    s << i.Acq_Setup_Dialog ();
  }

  // Interrupt-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Clear",
        e));

    s << i.Interrupt_Clear ();
  }

  // Interrupt-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Status",
        e));

    s << i.Interrupt_Status ();
  }

  // Auto-Save-Load-3D
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Auto-Save-Load-3D",
        e));

    s << i.Auto_Save_Load_3D ();
  }

  // DICOM-Root-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DICOM-Root-ID",
        e));

    s << i.DICOM_Root_ID ();
  }

  // Company-Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Company-Name",
        e));

    s << i.Company_Name ();
  }

  // Image-To-Auto-Save-On-Label
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image-To-Auto-Save-On-Label",
        e));

    s << i.Image_To_Auto_Save_On_Label ();
  }

  // DICOM-Encode-Regions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DICOM-Encode-Regions",
        e));

    s << i.DICOM_Encode_Regions ();
  }

  // Pipeline-Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pipeline-Delay",
        e));

    s << i.Pipeline_Delay ();
  }

  // DDS-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DDS-Control",
        e));

    s << i.DDS_Control ();
  }

  // Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mode",
        e));

    s << i.Mode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MIS& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ECG-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Gain",
        e));

    s << i.ECG_Gain ();
  }

  // ECG-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Available",
        e));

    s << i.ECG_Available ();
  }

  // Blood-Pressure-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Blood-Pressure-Available",
        e));

    s << i.Blood_Pressure_Available ();
  }

  // Respiration-Gating
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Gating",
        e));

    s << i.Respiration_Gating ();
  }

  // Respiration-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Available",
        e));

    s << i.Respiration_Available ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }

  // BP-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BP-Gain",
        e));

    s << i.BP_Gain ();
  }

  // Temperature-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Available",
        e));

    s << i.Temperature_Available ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Encoder-Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Position",
        e));

    s << i.Encoder_Position ();
  }

  // Center
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Center",
        e));

    s << i.Center ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }

  // Probe-ID1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1",
        e));

    s << i.Probe_ID1 ();
  }

  // Probe-ID2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2",
        e));

    s << i.Probe_ID2 ();
  }

  // V-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Scan-Speed",
        e));

    s << i.V_Scan_Speed ();
  }

  // Probe-ID1-Reread
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Reread",
        e));

    s << i.Probe_ID1_Reread ();
  }

  // Probe-ID1-Valid
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Valid",
        e));

    s << i.Probe_ID1_Valid ();
  }

  // Probe-ID1-Voltage
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Voltage",
        e));

    s << i.Probe_ID1_Voltage ();
  }

  // Probe-ID2-Reread
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Reread",
        e));

    s << i.Probe_ID2_Reread ();
  }

  // Probe-ID2-Valid
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Valid",
        e));

    s << i.Probe_ID2_Valid ();
  }

  // Probe-ID2-Voltage
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Voltage",
        e));

    s << i.Probe_ID2_Voltage ();
  }

  // V-Scan-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Scan-Rate",
        e));

    s << i.V_Scan_Rate ();
  }

  // Position-Counter-Lock
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Counter-Lock",
        e));

    s << i.Position_Counter_Lock ();
  }

  // Scan-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Width",
        e));

    s << i.Scan_Width ();
  }

  // Position-Counter-Reset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Counter-Reset",
        e));

    s << i.Position_Counter_Reset ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Motor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Settle-Time-3d
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Time-3d",
        e));

    s << i.Settle_Time_3d ();
  }

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // R-Scan-Move-No-Wait
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move-No-Wait",
        e));

    s << i.R_Scan_Move_No_Wait ();
  }

  // Motor-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Mode",
        e));

    s << i.Motor_Mode ();
  }

  // Acceleration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration",
        e));

    s << i.Acceleration ();
  }

  // Serial-Port-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Serial-Port-Mode",
        e));

    s << i.Serial_Port_Mode ();
  }

  // Limit-Switch-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Limit-Switch-Mode",
        e));

    s << i.Limit_Switch_Mode ();
  }

  // Breakpoint
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Breakpoint",
        e));

    s << i.Breakpoint ();
  }

  // Update
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Update",
        e));

    s << i.Update ();
  }

  // Breakpoint-Value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Breakpoint-Value",
        e));

    s << i.Breakpoint_Value ();
  }

  // V-Switch-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Switch-Limit",
        e));

    s << i.V_Switch_Limit ();
  }

  // R-Retrieve-Trace
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Retrieve-Trace",
        e));

    s << i.R_Retrieve_Trace ();
  }

  // Velocity-Stationary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity-Stationary",
        e));

    s << i.Velocity_Stationary ();
  }

  // Reset-Event-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reset-Event-Status",
        e));

    s << i.Reset_Event_Status ();
  }

  // Actual-Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Actual-Position",
        e));

    s << i.Actual_Position ();
  }

  // Buffer-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Length",
        e));

    s << i.Buffer_Length ();
  }

  // Event-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Event-Status",
        e));

    s << i.Event_Status ();
  }

  // R-Scan-Move2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move2",
        e));

    s << i.R_Scan_Move2 ();
  }

  // Kp
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Kp",
        e));

    s << i.Kp ();
  }

  // R-Wait-Finish-Scan-Move
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Wait-Finish-Scan-Move",
        e));

    s << i.R_Wait_Finish_Scan_Move ();
  }

  // Settle-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Time",
        e));

    s << i.Settle_Time ();
  }

  // Acceleration-Stationary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Stationary",
        e));

    s << i.Acceleration_Stationary ();
  }

  // Trace-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Mode",
        e));

    s << i.Trace_Mode ();
  }

  // Trace-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Period",
        e));

    s << i.Trace_Period ();
  }

  // Trace-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Start",
        e));

    s << i.Trace_Start ();
  }

  // Position-Reverse
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Reverse",
        e));

    s << i.Position_Reverse ();
  }

  // Reset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reset",
        e));

    s << i.Reset ();
  }

  // Trace-Count
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Count",
        e));

    s << i.Trace_Count ();
  }

  // R-Initialize
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Initialize",
        e));

    s << i.R_Initialize ();
  }

  // Output-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Output-Mode",
        e));

    s << i.Output_Mode ();
  }

  // Position2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position2",
        e));

    s << i.Position2 ();
  }

  // Integration-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Integration-Limit",
        e));

    s << i.Integration_Limit ();
  }

  // R-Home
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Home",
        e));

    s << i.R_Home ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // R-Reset-Limit-Switch
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Reset-Limit-Switch",
        e));

    s << i.R_Reset_Limit_Switch ();
  }

  // Settle-Window-3d
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Window-3d",
        e));

    s << i.Settle_Window_3d ();
  }

  // Interrupt-Mask
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Mask",
        e));

    s << i.Interrupt_Mask ();
  }

  // Scan-Move-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Move-Control",
        e));

    s << i.Scan_Move_Control ();
  }

  // Axis-Out-Source
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axis-Out-Source",
        e));

    s << i.Axis_Out_Source ();
  }

  // Trace-Stop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Stop",
        e));

    s << i.Trace_Stop ();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // R-Setup
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup",
        e));

    s << i.R_Setup ();
  }

  // Buffer-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Start",
        e));

    s << i.Buffer_Start ();
  }

  // Signal-Sense
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Signal-Sense",
        e));

    s << i.Signal_Sense ();
  }

  // R-Scan-Move
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move",
        e));

    s << i.R_Scan_Move ();
  }

  // Position-Forward
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Forward",
        e));

    s << i.Position_Forward ();
  }

  // Derivative-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Derivative-Time",
        e));

    s << i.Derivative_Time ();
  }

  // Settle-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Window",
        e));

    s << i.Settle_Window ();
  }

  // Trace-Variable1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Variable1",
        e));

    s << i.Trace_Variable1 ();
  }

  // Trace-Variable2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Variable2",
        e));

    s << i.Trace_Variable2 ();
  }

  // Buffer-Read-Index
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Read-Index",
        e));

    s << i.Buffer_Read_Index ();
  }

  // Signal-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Signal-Status",
        e));

    s << i.Signal_Status ();
  }

  // Alarm-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Alarm-Clear",
        e));

    s << i.Alarm_Clear ();
  }

  // Motion-Complete-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motion-Complete-Mode",
        e));

    s << i.Motion_Complete_Mode ();
  }

  // R-Setup-Abort
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup-Abort",
        e));

    s << i.R_Setup_Abort ();
  }

  // Read-Buffer
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Read-Buffer",
        e));

    s << i.Read_Buffer ();
  }

  // Kd
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Kd",
        e));

    s << i.Kd ();
  }

  // Clear-Interrupt
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Clear-Interrupt",
        e));

    s << i.Clear_Interrupt ();
  }

  // Profile-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Profile-Mode",
        e));

    s << i.Profile_Mode ();
  }

  // R-Setup-Trace
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup-Trace",
        e));

    s << i.R_Setup_Trace ();
  }

  // No-Operation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "No-Operation",
        e));

    s << i.No_Operation ();
  }

  // Ki
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ki",
        e));

    s << i.Ki ();
  }

  // Sample-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sample-Time",
        e));

    s << i.Sample_Time ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Diag& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Mem-Pagefile
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-Pagefile",
        e));

    s << i.Mem_Pagefile ();
  }

  // Monitor-3point3V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-3point3V",
        e));

    s << i.Monitor_3point3V ();
  }

  // USER-Objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "USER-Objects",
        e));

    s << i.USER_Objects ();
  }

  // Motor-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-FPGA-Revision",
        e));

    s << i.Motor_FPGA_Revision ();
  }

  // Product-Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Product-Name",
        e));

    s << i.Product_Name ();
  }

  // Build-Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Build-Version",
        e));

    s << i.Build_Version ();
  }

  // ICB-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-PCB-ID",
        e));

    s << i.ICB_PCB_ID ();
  }

  // Software-Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Software-Version",
        e));

    s << i.Software_Version ();
  }

  // Receive-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-PCB-ID",
        e));

    s << i.Receive_PCB_ID ();
  }

  // Receive-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-FPGA-Revision",
        e));

    s << i.Receive_FPGA_Revision ();
  }

  // Monitor-15V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-15V",
        e));

    s << i.Monitor_15V ();
  }

  // ICB-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-FPGA-Revision",
        e));

    s << i.ICB_FPGA_Revision ();
  }

  // GDI-Objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "GDI-Objects",
        e));

    s << i.GDI_Objects ();
  }

  // Mem-WorkingSet
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-WorkingSet",
        e));

    s << i.Mem_WorkingSet ();
  }

  // Mem-Private
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-Private",
        e));

    s << i.Mem_Private ();
  }

  // Switch-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Switch-PCB-ID",
        e));

    s << i.Switch_PCB_ID ();
  }

  // Monitor-5V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-5V",
        e));

    s << i.Monitor_5V ();
  }

  // Motor-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-PCB-Revision",
        e));

    s << i.Motor_PCB_Revision ();
  }

  // NE1619
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NE1619",
        e));

    s << i.NE1619 ();
  }

  // Motor-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-PCB-ID",
        e));

    s << i.Motor_PCB_ID ();
  }

  // Transmit-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Transmit-PCB-Revision",
        e));

    s << i.Transmit_PCB_Revision ();
  }

  // MAX1137
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MAX1137",
        e));

    s << i.MAX1137 ();
  }

  // Monitor-Neg15V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Neg15V",
        e));

    s << i.Monitor_Neg15V ();
  }

  // Monitor-Neg5V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Neg5V",
        e));

    s << i.Monitor_Neg5V ();
  }

  // Switch-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Switch-PCB-Revision",
        e));

    s << i.Switch_PCB_Revision ();
  }

  // Receive-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-PCB-Revision",
        e));

    s << i.Receive_PCB_Revision ();
  }

  // ICB-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-PCB-Revision",
        e));

    s << i.ICB_PCB_Revision ();
  }

  // Transmit-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Transmit-PCB-ID",
        e));

    s << i.Transmit_PCB_ID ();
  }

  // Monitor-Temperature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Temperature",
        e));

    s << i.Monitor_Temperature ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Respiration-Threshold-Change
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Threshold-Change",
        e));

    s << i.Respiration_Threshold_Change ();
  }

  // Respiration-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Threshold",
        e));

    s << i.Respiration_Threshold ();
  }

  // Pressure-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Range",
        e));

    s << i.Pressure_Range ();
  }

  // Respiration-Gate-Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Gate-Delay",
        e));

    s << i.Respiration_Gate_Delay ();
  }

  // Respiration-Timeout
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Timeout",
        e));

    s << i.Respiration_Timeout ();
  }

  // RWave-Max-Change-Factor-Percent
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Max-Change-Factor-Percent",
        e));

    s << i.RWave_Max_Change_Factor_Percent ();
  }

  // Respiration-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Period",
        e));

    s << i.Respiration_Period ();
  }

  // Respiration-Subsample-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Subsample-Rate",
        e));

    s << i.Respiration_Subsample_Rate ();
  }

  // Show-RWaves
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Show-RWaves",
        e));

    s << i.Show_RWaves ();
  }

  // Respiration-Minimal-Peak-2-Peak
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Minimal-Peak-2-Peak",
        e));

    s << i.Respiration_Minimal_Peak_2_Peak ();
  }

  // Respiration-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Window",
        e));

    s << i.Respiration_Window ();
  }

  // Pressure-Zeroed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Zeroed",
        e));

    s << i.Pressure_Zeroed ();
  }

  // Pressure-Systolic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Systolic",
        e));

    s << i.Pressure_Systolic ();
  }

  // Respiration-Show-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Show-Window",
        e));

    s << i.Respiration_Show_Window ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // Respiration-Blank-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Blank-Period",
        e));

    s << i.Respiration_Blank_Period ();
  }

  // Respiration-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Range",
        e));

    s << i.Respiration_Range ();
  }

  // Pressure-Zero
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Zero",
        e));

    s << i.Pressure_Zero ();
  }

  // Temperature-Amplification
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Amplification",
        e));

    s << i.Temperature_Amplification ();
  }

  // P-Wave-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "P-Wave-Start",
        e));

    s << i.P_Wave_Start ();
  }

  // ECG-Filter-Taps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Filter-Taps",
        e));

    s << i.ECG_Filter_Taps ();
  }

  // RWave-Future-Search-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Future-Search-Time",
        e));

    s << i.RWave_Future_Search_Time ();
  }

  // Respiration-Percent-Peak
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Percent-Peak",
        e));

    s << i.Respiration_Percent_Peak ();
  }

  // T-Wave-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "T-Wave-Start",
        e));

    s << i.T_Wave_Start ();
  }

  // Strain-Rate-RR-Diff-Ratio
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Strain-Rate-RR-Diff-Ratio",
        e));

    s << i.Strain_Rate_RR_Diff_Ratio ();
  }

  // Pressure-Calibration-Min-Level
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration-Min-Level",
        e));

    s << i.Pressure_Calibration_Min_Level ();
  }

  // Pressure-Calibrated
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibrated",
        e));

    s << i.Pressure_Calibrated ();
  }

  // DPDT-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DPDT-Range",
        e));

    s << i.DPDT_Range ();
  }

  // Respiration-Show-Event
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Show-Event",
        e));

    s << i.Respiration_Show_Event ();
  }

  // Pressure-Diastolic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Diastolic",
        e));

    s << i.Pressure_Diastolic ();
  }

  // Temperature-Calibration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Calibration",
        e));

    s << i.Temperature_Calibration ();
  }

  // Temperature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature",
        e));

    s << i.Temperature ();
  }

  // Respiration-Beats-To-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Beats-To-Average",
        e));

    s << i.Respiration_Beats_To_Average ();
  }

  // RWave-Thresh-Trigger-Percent
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Thresh-Trigger-Percent",
        e));

    s << i.RWave_Thresh_Trigger_Percent ();
  }

  // Respiration-Time-To-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Time-To-Average",
        e));

    s << i.Respiration_Time_To_Average ();
  }

  // Pressure-Amplification
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Amplification",
        e));

    s << i.Pressure_Amplification ();
  }

  // Heart-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Heart-Period",
        e));

    s << i.Heart_Period ();
  }

  // Pressure-Show-Event
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Show-Event",
        e));

    s << i.Pressure_Show_Event ();
  }

  // RWave-Default-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Default-Threshold",
        e));

    s << i.RWave_Default_Threshold ();
  }

  // Show-Filtered-Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Show-Filtered-Data",
        e));

    s << i.Show_Filtered_Data ();
  }

  // ECG-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Range",
        e));

    s << i.ECG_Range ();
  }

  // RWave-Maxima-Block-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Maxima-Block-Time",
        e));

    s << i.RWave_Maxima_Block_Time ();
  }

  // RWave-Noise-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Noise-Threshold",
        e));

    s << i.RWave_Noise_Threshold ();
  }

  // Pressure-Calibration-Level
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration-Level",
        e));

    s << i.Pressure_Calibration_Level ();
  }

  // ECG-HP-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-HP-Filter",
        e));

    s << i.ECG_HP_Filter ();
  }

  // ECG-LP-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-LP-Filter",
        e));

    s << i.ECG_LP_Filter ();
  }

  // RWave-Max-Change-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Max-Change-Period",
        e));

    s << i.RWave_Max_Change_Period ();
  }

  // Pressure-Time-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Time-Out",
        e));

    s << i.Pressure_Time_Out ();
  }

  // Pressure-Calibration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration",
        e));

    s << i.Pressure_Calibration ();
  }

  // RWave-Blank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Blank-Time",
        e));

    s << i.RWave_Blank_Time ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RfModeSoft& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Amplitude-Height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Amplitude-Height",
        e));

    s << i.Amplitude_Height ();
  }

  // Magnitude-Origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Magnitude-Origin",
        e));

    s << i.Magnitude_Origin ();
  }

  // Frequency-Origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Origin",
        e));

    s << i.Frequency_Origin ();
  }

  // Samples
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Samples",
        e));

    s << i.Samples ();
  }

  // Saturation-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Saturation-Threshold",
        e));

    s << i.Saturation_Threshold ();
  }

  // Amplitude-Origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Amplitude-Origin",
        e));

    s << i.Amplitude_Origin ();
  }

  // Frame-Selected
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frame-Selected",
        e));

    s << i.Frame_Selected ();
  }

  // AcqPerLine
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AcqPerLine",
        e));

    s << i.AcqPerLine ();
  }

  // Lines
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lines",
        e));

    s << i.Lines ();
  }

  // Windowing-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Windowing-Mode",
        e));

    s << i.Windowing_Mode ();
  }

  // Length-Origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length-Origin",
        e));

    s << i.Length_Origin ();
  }

  // Line-Selected
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Line-Selected",
        e));

    s << i.Line_Selected ();
  }

  // V-Lines-Pos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Lines-Pos",
        e));

    s << i.V_Lines_Pos ();
  }

  // Bounce-Test-AscanData
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bounce-Test-AscanData",
        e));

    s << i.Bounce_Test_AscanData ();
  }

  // Vertical-Scale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Vertical-Scale",
        e));

    s << i.Vertical_Scale ();
  }

  // Bounce-Test-RFData
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bounce-Test-RFData",
        e));

    s << i.Bounce_Test_RFData ();
  }

  // SamplesPerSec
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SamplesPerSec",
        e));

    s << i.SamplesPerSec ();
  }

  // Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frames",
        e));

    s << i.Frames ();
  }

  // Digitizer
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Digitizer",
        e));

    s << i.Digitizer ();
  }

  // Magnitude-Height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Magnitude-Height",
        e));

    s << i.Magnitude_Height ();
  }

  // Saturation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Saturation",
        e));

    s << i.Saturation ();
  }

  // Length-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length-Length",
        e));

    s << i.Length_Length ();
  }

  // Frequency-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Length",
        e));

    s << i.Frequency_Length ();
  }

  // State
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "State",
        e));

    s << i.State ();
  }

  // SV-Center
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SV-Center",
        e));

    s << i.SV_Center ();
  }

  // Continuous-RF-FrameRate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Continuous-RF-FrameRate",
        e));

    s << i.Continuous_RF_FrameRate ();
  }

  // Quantify-Bounce-Test
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Quantify-Bounce-Test",
        e));

    s << i.Quantify_Bounce_Test ();
  }

  // X_3D-Volume
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Volume",
        e));

    s << i.X_3D_Volume ();
  }

  // Shift-RF-Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Shift-RF-Data",
        e));

    s << i.Shift_RF_Data ();
  }

  // V-Lines
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Lines",
        e));

    s << i.V_Lines ();
  }

  // Graph-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Graph-Mode",
        e));

    s << i.Graph_Mode ();
  }

  // RF-Path-15Mhz-Time-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Path-15Mhz-Time-Correction",
        e));

    s << i.RF_Path_15Mhz_Time_Correction ();
  }

  // RF-Path-23Mhz-Time-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Path-23Mhz-Time-Correction",
        e));

    s << i.RF_Path_23Mhz_Time_Correction ();
  }

  // SV-Length-Limits
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SV-Length-Limits",
        e));

    s << i.SV_Length_Limits ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TX& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // V-Position-Table
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Position-Table",
        e));

    s << i.V_Position_Table ();
  }

  // V-Transmit-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Transmit-Length",
        e));

    s << i.V_Transmit_Length ();
  }

  // Trigger-Counter-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Counter-Clear",
        e));

    s << i.Trigger_Counter_Clear ();
  }

  // Trigger-Counter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Counter",
        e));

    s << i.Trigger_Counter ();
  }

  // Multi-Trigger-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Multi-Trigger-Freq",
        e));

    s << i.Multi_Trigger_Freq ();
  }

  // RF-Amp
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Amp",
        e));

    s << i.RF_Amp ();
  }

  // Trigger-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Control",
        e));

    s << i.Trigger_Control ();
  }

  // V-Pulse-Rep-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Pulse-Rep-Freq",
        e));

    s << i.V_Pulse_Rep_Freq ();
  }

  // Phase
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Phase",
        e));

    s << i.Phase ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // V-Unblank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Unblank-Time",
        e));

    s << i.V_Unblank_Time ();
  }

  // V-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Frequency",
        e));

    s << i.V_Frequency ();
  }

  // Pulse-Rep-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pulse-Rep-Frequency",
        e));

    s << i.Pulse_Rep_Frequency ();
  }

  // Multi-Trigger
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Multi-Trigger",
        e));

    s << i.Multi_Trigger ();
  }

  // Trig-Tbl-Trigs
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trig-Tbl-Trigs",
        e));

    s << i.Trig_Tbl_Trigs ();
  }

  // Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Width",
        e));

    s << i.Width ();
  }

  // Unblank-Cycles
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unblank-Cycles",
        e));

    s << i.Unblank_Cycles ();
  }

  // V-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Width",
        e));

    s << i.V_Width ();
  }

  // Unblank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unblank-Time",
        e));

    s << i.Unblank_Time ();
  }

  // Attenuation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attenuation",
        e));

    s << i.Attenuation ();
  }

  // V-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Power",
        e));

    s << i.V_Power ();
  }

  // Computer-Trigger
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Computer-Trigger",
        e));

    s << i.Computer_Trigger ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const X_3D& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Speed",
        e));

    s << i.Speed ();
  }

  // Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Status",
        e));

    s << i.Status ();
  }

  // Motor-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Enable",
        e));

    s << i.Motor_Enable ();
  }

  // Scan-Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Distance",
        e));

    s << i.Scan_Distance ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Steps",
        e));

    s << i.Steps ();
  }

  // Max-Scan-Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Scan-Steps",
        e));

    s << i.Max_Scan_Steps ();
  }

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // Action
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Action",
        e));

    s << i.Action ();
  }

  // Clear-Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Clear-Error",
        e));

    s << i.Clear_Error ();
  }

  // Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Direction",
        e));

    s << i.Direction ();
  }

  // Step-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Step-Size",
        e));

    s << i.Step_Size ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RfAnalysis& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Reference
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference",
        e));

    s << i.Reference ();
  }

  // Ref-Probe-F-Number
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Probe-F-Number",
        e));

    s << i.Ref_Probe_F_Number ();
  }

  // Ref-Probe-Focal-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Probe-Focal-Length",
        e));

    s << i.Ref_Probe_Focal_Length ();
  }

  // Ref-Tx-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Tx-Frequency",
        e));

    s << i.Ref_Tx_Frequency ();
  }

  // Freq-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Freq-Range",
        e));

    s << i.Freq_Range ();
  }

  // Ref-Probe-Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Probe-Name",
        e));

    s << i.Ref_Probe_Name ();
  }

  // Graph-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Graph-Mode",
        e));

    s << i.Graph_Mode ();
  }

  // Normalized-Height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Normalized-Height",
        e));

    s << i.Normalized_Height ();
  }

  // Ref-Tx-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Tx-Width",
        e));

    s << i.Ref_Tx_Width ();
  }

  // Normalized-Origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Normalized-Origin",
        e));

    s << i.Normalized_Origin ();
  }

  // Freq-Range-f
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Freq-Range-f",
        e));

    s << i.Freq_Range_f ();
  }

  // FFT-Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FFT-Offset",
        e));

    s << i.FFT_Offset ();
  }

  // Ref-Tx-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Tx-Power",
        e));

    s << i.Ref_Tx_Power ();
  }

  // Freq-Range-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Freq-Range-Max",
        e));

    s << i.Freq_Range_Max ();
  }

  // Freq-Range-Min
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Freq-Range-Min",
        e));

    s << i.Freq_Range_Min ();
  }

  // Ref-Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ref-Offset",
        e));

    s << i.Ref_Offset ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RX& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // AD-IF
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-IF",
        e));

    s << i.AD_IF ();
  }

  // Sector-Width-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Width-Target",
        e));

    s << i.Sector_Width_Target ();
  }

  // RF-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Gain",
        e));

    s << i.RF_Gain ();
  }

  // TGC-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TGC-Enable",
        e));

    s << i.TGC_Enable ();
  }

  // V-Digi-Depth-Imaging
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Digi-Depth-Imaging",
        e));

    s << i.V_Digi_Depth_Imaging ();
  }

  // RF-Bandwidth
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Bandwidth",
        e));

    s << i.RF_Bandwidth ();
  }

  // Test-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Test-Freq",
        e));

    s << i.Test_Freq ();
  }

  // Line-Number
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Line-Number",
        e));

    s << i.Line_Number ();
  }

  // V-TGC
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-TGC",
        e));

    s << i.V_TGC ();
  }

  // IF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IF-Filter",
        e));

    s << i.IF_Filter ();
  }

  // Track-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Track-Width",
        e));

    s << i.Track_Width ();
  }

  // DTB-Error-Clr
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Error-Clr",
        e));

    s << i.DTB_Error_Clr ();
  }

  // Current-Channel
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Current-Channel",
        e));

    s << i.Current_Channel ();
  }

  // V-IF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-IF-Filter",
        e));

    s << i.V_IF_Filter ();
  }

  // IQ-Select
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IQ-Select",
        e));

    s << i.IQ_Select ();
  }

  // HP-Clutter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HP-Clutter",
        e));

    s << i.HP_Clutter ();
  }

  // AD-In
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-In",
        e));

    s << i.AD_In ();
  }

  // V-TGC-Copy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-TGC-Copy",
        e));

    s << i.V_TGC_Copy ();
  }

  // Image-FIFO-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image-FIFO-Status",
        e));

    s << i.Image_FIFO_Status ();
  }

  // RF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Filter",
        e));

    s << i.RF_Filter ();
  }

  // DDRS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DDRS",
        e));

    s << i.DDRS ();
  }

  // ADCA-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ADCA-Out",
        e));

    s << i.ADCA_Out ();
  }

  // AD-Clock-Div
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-Clock-Div",
        e));

    s << i.AD_Clock_Div ();
  }

  // Imaging-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Imaging-Mode",
        e));

    s << i.Imaging_Mode ();
  }

  // V-RF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-RF-Filter",
        e));

    s << i.V_RF_Filter ();
  }

  // ADCB-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ADCB-Out",
        e));

    s << i.ADCB_Out ();
  }

  // Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Delay",
        e));

    s << i.Delay ();
  }

  // AD-Gate-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-Gate-Width",
        e));

    s << i.AD_Gate_Width ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // V-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Frequency",
        e));

    s << i.V_Frequency ();
  }

  // V-Field-Of-View
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Field-Of-View",
        e));

    s << i.V_Field_Of_View ();
  }

  // Packet-Format
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Packet-Format",
        e));

    s << i.Packet_Format ();
  }

  // Sector-Height-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Height-Target",
        e));

    s << i.Sector_Height_Target ();
  }

  // Low-Speed-FIFO-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Low-Speed-FIFO-Status",
        e));

    s << i.Low_Speed_FIFO_Status ();
  }

  // AD-TestIn
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-TestIn",
        e));

    s << i.AD_TestIn ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // Test-On
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Test-On",
        e));

    s << i.Test_On ();
  }

  // AD-DCS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-DCS",
        e));

    s << i.AD_DCS ();
  }

  // DTB-Tfr-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Tfr-Enable",
        e));

    s << i.DTB_Tfr_Enable ();
  }

  // DTB-Test-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Test-Enable",
        e));

    s << i.DTB_Test_Enable ();
  }

  // V-Delay-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Delay-Length",
        e));

    s << i.V_Delay_Length ();
  }

  // Current-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Current-Mode",
        e));

    s << i.Current_Mode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Display& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Direction",
        e));

    s << i.Direction ();
  }

  // X_3D-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Gain",
        e));

    s << i.X_3D_Gain ();
  }

  // X_3D-Dynamic-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Dynamic-Range",
        e));

    s << i.X_3D_Dynamic_Range ();
  }

  // V-Selection
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Selection",
        e));

    s << i.V_Selection ();
  }

  // Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Gain",
        e));

    s << i.Gain ();
  }

  // Dynamic-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dynamic-Range",
        e));

    s << i.Dynamic_Range ();
  }

  // Window-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Window-Time",
        e));

    s << i.Window_Time ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acqiris& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SamplesNom
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SamplesNom",
        e));

    s << i.SamplesNom ();
  }

  // V-Read-Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Read-Data",
        e));

    s << i.V_Read_Data ();
  }

  // Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mode",
        e));

    s << i.Mode ();
  }

  // Acquire
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire",
        e));

    s << i.Acquire ();
  }

  // Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Available",
        e));

    s << i.Available ();
  }

  // Force-Trigger
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Force-Trigger",
        e));

    s << i.Force_Trigger ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }

  // TbSegmentPad
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TbSegmentPad",
        e));

    s << i.TbSegmentPad ();
  }

  // Wait-Acq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Wait-Acq",
        e));

    s << i.Wait_Acq ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ActiveProbe1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Notes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Notes",
        e));

    s << i.Notes ();
  }

  // Sample-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sample-Time",
        e));

    s << i.Sample_Time ();
  }

  // Focal-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Focal-Length",
        e));

    s << i.Focal_Length ();
  }

  // Acceleration-Limit-Slope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Limit-Slope",
        e));

    s << i.Acceleration_Limit_Slope ();
  }

  // Type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Type",
        e));

    s << i.Type ();
  }

  // Detect-Id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Id",
        e));

    s << i.Detect_Id ();
  }

  // Default-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Scan-Speed",
        e));

    s << i.Default_Scan_Speed ();
  }

  // K1-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "K1-Power",
        e));

    s << i.K1_Power ();
  }

  // Cutoff-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cutoff-Scan-Speed",
        e));

    s << i.Cutoff_Scan_Speed ();
  }

  // Frequency-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Low",
        e));

    s << i.Frequency_Low ();
  }

  // Default-FOV
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-FOV",
        e));

    s << i.Default_FOV ();
  }

  // Frequency-Doppler-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler-Default",
        e));

    s << i.Frequency_Doppler_Default ();
  }

  // Default-SvSize-MMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-SvSize-MMode",
        e));

    s << i.Default_SvSize_MMode ();
  }

  // Axial-Res-Factor-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axial-Res-Factor-Target",
        e));

    s << i.Axial_Res_Factor_Target ();
  }

  // F-Number
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "F-Number",
        e));

    s << i.F_Number ();
  }

  // Acc-Time-Factor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acc-Time-Factor",
        e));

    s << i.Acc_Time_Factor ();
  }

  // Axial-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axial-Res",
        e));

    s << i.Axial_Res ();
  }

  // Lateral-Res-Factor-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res-Factor-Target",
        e));

    s << i.Lateral_Res_Factor_Target ();
  }

  // Pivot-Encoder-Dist
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pivot-Encoder-Dist",
        e));

    s << i.Pivot_Encoder_Dist ();
  }

  // Encoder-Range-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Range-Max",
        e));

    s << i.Encoder_Range_Max ();
  }

  // Encoder-Range-Min
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Range-Min",
        e));

    s << i.Encoder_Range_Min ();
  }

  // Lateral-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res",
        e));

    s << i.Lateral_Res ();
  }

  // Max-Scan-Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Scan-Distance",
        e));

    s << i.Max_Scan_Distance ();
  }

  // Default-Rx-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Rx-Gain",
        e));

    s << i.Default_Rx_Gain ();
  }

  // PID-KD-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KD-High",
        e));

    s << i.PID_KD_High ();
  }

  // PID-KI-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KI-High",
        e));

    s << i.PID_KI_High ();
  }

  // PID-KP-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KP-High",
        e));

    s << i.PID_KP_High ();
  }

  // Frequency-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-High",
        e));

    s << i.Frequency_High ();
  }

  // Lateral-Res-Factor-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Lateral-Res-Factor-Max",
        e));

    s << i.Lateral_Res_Factor_Max ();
  }

  // Scan-Speeds
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Speeds",
        e));

    s << i.Scan_Speeds ();
  }

  // Filter-Doppler-Cutoff
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler-Cutoff",
        e));

    s << i.Filter_Doppler_Cutoff ();
  }

  // Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << i.Name ();
  }

  // PID-KD-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KD-Low",
        e));

    s << i.PID_KD_Low ();
  }

  // PID-KI-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KI-Low",
        e));

    s << i.PID_KI_Low ();
  }

  // PID-KP-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PID-KP-Low",
        e));

    s << i.PID_KP_Low ();
  }

  // Peak-Bandwidth-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Peak-Bandwidth-Correction",
        e));

    s << i.Peak_Bandwidth_Correction ();
  }

  // Frequency-Doppler-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler-Low",
        e));

    s << i.Frequency_Doppler_Low ();
  }

  // Pivot-Transducer-Face-Dist
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pivot-Transducer-Face-Dist",
        e));

    s << i.Pivot_Transducer_Face_Dist ();
  }

  // Filter-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler",
        e));

    s << i.Filter_Doppler ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // Integration-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Integration-Limit",
        e));

    s << i.Integration_Limit ();
  }

  // Encoder-Separation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Separation",
        e));

    s << i.Encoder_Separation ();
  }

  // Overshoot
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Overshoot",
        e));

    s << i.Overshoot ();
  }

  // Attenuation-Shift
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attenuation-Shift",
        e));

    s << i.Attenuation_Shift ();
  }

  // Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter",
        e));

    s << i.Filter ();
  }

  // Default-Rx-Gain-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Default-Rx-Gain-Doppler",
        e));

    s << i.Default_Rx_Gain_Doppler ();
  }

  // Peak-Vel-Correction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Peak-Vel-Correction",
        e));

    s << i.Peak_Vel_Correction ();
  }

  // Detect-Ratio-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Ratio-Max",
        e));

    s << i.Detect_Ratio_Max ();
  }

  // Acceleration-Limit-Constant
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Limit-Constant",
        e));

    s << i.Acceleration_Limit_Constant ();
  }

  // Filter-Doppler-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Doppler-Low",
        e));

    s << i.Filter_Doppler_Low ();
  }

  // Frequency-Doppler
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency-Doppler",
        e));

    s << i.Frequency_Doppler ();
  }

  // Detect-Ratio-Min
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Detect-Ratio-Min",
        e));

    s << i.Detect_Ratio_Min ();
  }

  // Derivative-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Derivative-Time",
        e));

    s << i.Derivative_Time ();
  }

  // Filter-High
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-High",
        e));

    s << i.Filter_High ();
  }

  // Motor-Overhead
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Overhead",
        e));

    s << i.Motor_Overhead ();
  }

  // Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Version",
        e));

    s << i.Version ();
  }

  // Filter-Low
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Low",
        e));

    s << i.Filter_Low ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BModeSoft1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Anti-Aliasing
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Anti-Aliasing",
        e));

    s << i.Anti_Aliasing ();
  }

  // V-Relative-Frame-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Relative-Frame-Rate",
        e));

    s << i.V_Relative_Frame_Rate ();
  }

  // Max-Power-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Power-Size-Default",
        e));

    s << i.Max_Power_Size_Default ();
  }

  // Buffer-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Size",
        e));

    s << i.Buffer_Size ();
  }

  // Sector-Convert
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Convert",
        e));

    s << i.Sector_Convert ();
  }

  // AVR-Factor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AVR-Factor",
        e));

    s << i.AVR_Factor ();
  }

  // Flip-Image
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Flip-Image",
        e));

    s << i.Flip_Image ();
  }

  // AVR-Startup-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AVR-Startup-Frames",
        e));

    s << i.AVR_Startup_Frames ();
  }

  // BMode-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BMode-Size-Default",
        e));

    s << i.BMode_Size_Default ();
  }

  // Relative-Frame-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Relative-Frame-Rate",
        e));

    s << i.Relative_Frame_Rate ();
  }

  // Overlay-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Overlay-Mode",
        e));

    s << i.Overlay_Mode ();
  }

  // Refresh-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Refresh-Rate",
        e));

    s << i.Refresh_Rate ();
  }

  // Acquisition-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition-Mode",
        e));

    s << i.Acquisition_Mode ();
  }

  // Acquire-Both-Directions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Both-Directions",
        e));

    s << i.Acquire_Both_Directions ();
  }

  // Actual-Scan-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Actual-Scan-Rate",
        e));

    s << i.Actual_Scan_Rate ();
  }

  // Acquire-Persist-AVR
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-AVR",
        e));

    s << i.Acquire_Persist_AVR ();
  }

  // Sector-X-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-X-Res",
        e));

    s << i.Sector_X_Res ();
  }

  // Sector-Y-Res
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Y-Res",
        e));

    s << i.Sector_Y_Res ();
  }

  // Power-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Power-Size-Default",
        e));

    s << i.Power_Size_Default ();
  }

  // Sector-X-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-X-Start",
        e));

    s << i.Sector_X_Start ();
  }

  // Sector-Y-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Y-Start",
        e));

    s << i.Sector_Y_Start ();
  }

  // Max-BMode-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-BMode-Size-Default",
        e));

    s << i.Max_BMode_Size_Default ();
  }

  // Target-Field-Of-View
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Target-Field-Of-View",
        e));

    s << i.Target_Field_Of_View ();
  }

  // Processing-Command
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Processing-Command",
        e));

    s << i.Processing_Command ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sys1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Query-Discard-Loop-On-Save-Frame
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Query-Discard-Loop-On-Save-Frame",
        e));

    s << i.Query_Discard_Loop_On_Save_Frame ();
  }

  // Sound-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sound-Speed",
        e));

    s << i.Sound_Speed ();
  }

  // SubMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SubMode",
        e));

    s << i.SubMode ();
  }

  // Interrupt-Mask
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Mask",
        e));

    s << i.Interrupt_Mask ();
  }

  // Calculation-Instances
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Calculation-Instances",
        e));

    s << i.Calculation_Instances ();
  }

  // Start-Licence-Date
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Start-Licence-Date",
        e));

    s << i.Start_Licence_Date ();
  }

  // End-Licence-Date
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "End-Licence-Date",
        e));

    s << i.End_Licence_Date ();
  }

  // Auto-Save-PreTrig-Loop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Auto-Save-PreTrig-Loop",
        e));

    s << i.Auto_Save_PreTrig_Loop ();
  }

  // Feature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Feature",
        e));

    s << i.Feature ();
  }

  // Acq-Setup-Dialog
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acq-Setup-Dialog",
        e));

    s << i.Acq_Setup_Dialog ();
  }

  // Interrupt-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Clear",
        e));

    s << i.Interrupt_Clear ();
  }

  // Interrupt-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Status",
        e));

    s << i.Interrupt_Status ();
  }

  // Auto-Save-Load-3D
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Auto-Save-Load-3D",
        e));

    s << i.Auto_Save_Load_3D ();
  }

  // DICOM-Root-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DICOM-Root-ID",
        e));

    s << i.DICOM_Root_ID ();
  }

  // Company-Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Company-Name",
        e));

    s << i.Company_Name ();
  }

  // Image-To-Auto-Save-On-Label
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image-To-Auto-Save-On-Label",
        e));

    s << i.Image_To_Auto_Save_On_Label ();
  }

  // DICOM-Encode-Regions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DICOM-Encode-Regions",
        e));

    s << i.DICOM_Encode_Regions ();
  }

  // Pipeline-Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pipeline-Delay",
        e));

    s << i.Pipeline_Delay ();
  }

  // DDS-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DDS-Control",
        e));

    s << i.DDS_Control ();
  }

  // Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mode",
        e));

    s << i.Mode ();
  }

  // Review-Setup-Dialog
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Review-Setup-Dialog",
        e));

    s << i.Review_Setup_Dialog ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Contrast& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Acquisition-3D-Volume
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquisition-3D-Volume",
        e));

    s << i.Acquisition_3D_Volume ();
  }

  // Contrast-Linear-Scale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Linear-Scale",
        e));

    s << i.Contrast_Linear_Scale ();
  }

  // Reference-3D-Step-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-3D-Step-Size",
        e));

    s << i.Reference_3D_Step_Size ();
  }

  // Remap-Color
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Remap-Color",
        e));

    s << i.Remap_Color ();
  }

  // Display-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Display-Mode",
        e));

    s << i.Display_Mode ();
  }

  // Contrast-Linear-Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Linear-Offset",
        e));

    s << i.Contrast_Linear_Offset ();
  }

  // Contrast-Linear-Slope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Linear-Slope",
        e));

    s << i.Contrast_Linear_Slope ();
  }

  // Median-Size-Perfusion
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Median-Size-Perfusion",
        e));

    s << i.Median_Size_Perfusion ();
  }

  // Contrast-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Size-Default",
        e));

    s << i.Contrast_Size_Default ();
  }

  // Median-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Median-Size-Default",
        e));

    s << i.Median_Size_Default ();
  }

  // Use-ECG-Gate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Use-ECG-Gate",
        e));

    s << i.Use_ECG_Gate ();
  }

  // ECG-Gate-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Gate-Range",
        e));

    s << i.ECG_Gate_Range ();
  }

  // Filter-Size-Perfusion
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Size-Perfusion",
        e));

    s << i.Filter_Size_Perfusion ();
  }

  // Max-Contrast-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Contrast-Size-Default",
        e));

    s << i.Max_Contrast_Size_Default ();
  }

  // Filter-Size-Default
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Size-Default",
        e));

    s << i.Filter_Size_Default ();
  }

  // Cardiac-Divisions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cardiac-Divisions",
        e));

    s << i.Cardiac_Divisions ();
  }

  // Reference-3D-Scan-Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-3D-Scan-Distance",
        e));

    s << i.Reference_3D_Scan_Distance ();
  }

  // Median-Size-MIP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Median-Size-MIP",
        e));

    s << i.Median_Size_MIP ();
  }

  // Acquire-Both-Directions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Both-Directions",
        e));

    s << i.Acquire_Both_Directions ();
  }

  // Data-Display-Scale-Shift
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Data-Display-Scale-Shift",
        e));

    s << i.Data_Display_Scale_Shift ();
  }

  // Reference-Label
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-Label",
        e));

    s << i.Reference_Label ();
  }

  // X_3D-Display-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Display-Mode",
        e));

    s << i.X_3D_Display_Mode ();
  }

  // Filter-Size-MIP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Filter-Size-MIP",
        e));

    s << i.Filter_Size_MIP ();
  }

  // Contrast-Linear-Lock-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Linear-Lock-Gain",
        e));

    s << i.Contrast_Linear_Lock_Gain ();
  }

  // Persistence-Process-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Persistence-Process-Frames",
        e));

    s << i.Persistence_Process_Frames ();
  }

  // Reference-Range-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-Range-Start",
        e));

    s << i.Reference_Range_Start ();
  }

  // Blur-MIP-BoxSize
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Blur-MIP-BoxSize",
        e));

    s << i.Blur_MIP_BoxSize ();
  }

  // Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Threshold",
        e));

    s << i.Threshold ();
  }

  // Process-Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Process-Direction",
        e));

    s << i.Process_Direction ();
  }

  // Reference-Range-Stop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-Range-Stop",
        e));

    s << i.Reference_Range_Stop ();
  }

  // Blur-MIP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Blur-MIP",
        e));

    s << i.Blur_MIP ();
  }

  // Persistence-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Persistence-Mode",
        e));

    s << i.Persistence_Mode ();
  }

  // Reference-3D-Volume
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-3D-Volume",
        e));

    s << i.Reference_3D_Volume ();
  }

  // Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Gain",
        e));

    s << i.Gain ();
  }

  // Acquire-Persist-MIP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-MIP",
        e));

    s << i.Acquire_Persist_MIP ();
  }

  // Dynamic-Range2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dynamic-Range2",
        e));

    s << i.Dynamic_Range2 ();
  }

  // Contast-3D-Brightness
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contast-3D-Brightness",
        e));

    s << i.Contast_3D_Brightness ();
  }

  // Reference-3D-Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference-3D-Steps",
        e));

    s << i.Reference_3D_Steps ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MIS1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ECG-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Gain",
        e));

    s << i.ECG_Gain ();
  }

  // ECG-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Available",
        e));

    s << i.ECG_Available ();
  }

  // Blood-Pressure-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Blood-Pressure-Available",
        e));

    s << i.Blood_Pressure_Available ();
  }

  // Respiration-Gating
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Gating",
        e));

    s << i.Respiration_Gating ();
  }

  // BP-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BP-Gain",
        e));

    s << i.BP_Gain ();
  }

  // Temperature-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Available",
        e));

    s << i.Temperature_Available ();
  }

  // Respiration-Available
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Available",
        e));

    s << i.Respiration_Available ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Encoder-Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoder-Position",
        e));

    s << i.Encoder_Position ();
  }

  // Center
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Center",
        e));

    s << i.Center ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }

  // Probe-ID1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1",
        e));

    s << i.Probe_ID1 ();
  }

  // Probe-ID2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2",
        e));

    s << i.Probe_ID2 ();
  }

  // V-Scan-Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Scan-Speed",
        e));

    s << i.V_Scan_Speed ();
  }

  // Probe-ID1-Reread
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Reread",
        e));

    s << i.Probe_ID1_Reread ();
  }

  // Probe-ID1-Valid
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Valid",
        e));

    s << i.Probe_ID1_Valid ();
  }

  // Probe-ID1-Voltage
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID1-Voltage",
        e));

    s << i.Probe_ID1_Voltage ();
  }

  // Probe-ID2-Reread
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Reread",
        e));

    s << i.Probe_ID2_Reread ();
  }

  // Probe-ID2-Valid
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Valid",
        e));

    s << i.Probe_ID2_Valid ();
  }

  // Probe-ID2-Voltage
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Probe-ID2-Voltage",
        e));

    s << i.Probe_ID2_Voltage ();
  }

  // V-Scan-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Scan-Rate",
        e));

    s << i.V_Scan_Rate ();
  }

  // Position-Counter-Lock
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Counter-Lock",
        e));

    s << i.Position_Counter_Lock ();
  }

  // Scan-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Width",
        e));

    s << i.Scan_Width ();
  }

  // Position-Counter-Reset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Counter-Reset",
        e));

    s << i.Position_Counter_Reset ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Motor1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Settle-Time-3d
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Time-3d",
        e));

    s << i.Settle_Time_3d ();
  }

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // R-Scan-Move-No-Wait
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move-No-Wait",
        e));

    s << i.R_Scan_Move_No_Wait ();
  }

  // Motor-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Mode",
        e));

    s << i.Motor_Mode ();
  }

  // Acceleration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration",
        e));

    s << i.Acceleration ();
  }

  // Serial-Port-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Serial-Port-Mode",
        e));

    s << i.Serial_Port_Mode ();
  }

  // Limit-Switch-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Limit-Switch-Mode",
        e));

    s << i.Limit_Switch_Mode ();
  }

  // Breakpoint
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Breakpoint",
        e));

    s << i.Breakpoint ();
  }

  // Update
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Update",
        e));

    s << i.Update ();
  }

  // Breakpoint-Value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Breakpoint-Value",
        e));

    s << i.Breakpoint_Value ();
  }

  // V-Switch-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Switch-Limit",
        e));

    s << i.V_Switch_Limit ();
  }

  // R-Retrieve-Trace
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Retrieve-Trace",
        e));

    s << i.R_Retrieve_Trace ();
  }

  // Velocity-Stationary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity-Stationary",
        e));

    s << i.Velocity_Stationary ();
  }

  // Reset-Event-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reset-Event-Status",
        e));

    s << i.Reset_Event_Status ();
  }

  // Actual-Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Actual-Position",
        e));

    s << i.Actual_Position ();
  }

  // Buffer-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Length",
        e));

    s << i.Buffer_Length ();
  }

  // R-Scan-Move2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move2",
        e));

    s << i.R_Scan_Move2 ();
  }

  // Position-Reverse
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Reverse",
        e));

    s << i.Position_Reverse ();
  }

  // Reset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reset",
        e));

    s << i.Reset ();
  }

  // Trace-Count
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Count",
        e));

    s << i.Trace_Count ();
  }

  // R-Initialize
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Initialize",
        e));

    s << i.R_Initialize ();
  }

  // Output-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Output-Mode",
        e));

    s << i.Output_Mode ();
  }

  // Position2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position2",
        e));

    s << i.Position2 ();
  }

  // Integration-Limit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Integration-Limit",
        e));

    s << i.Integration_Limit ();
  }

  // R-Home
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Home",
        e));

    s << i.R_Home ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // R-Reset-Limit-Switch
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Reset-Limit-Switch",
        e));

    s << i.R_Reset_Limit_Switch ();
  }

  // Settle-Window-3d
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Window-3d",
        e));

    s << i.Settle_Window_3d ();
  }

  // Interrupt-Mask
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interrupt-Mask",
        e));

    s << i.Interrupt_Mask ();
  }

  // Scan-Move-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Move-Control",
        e));

    s << i.Scan_Move_Control ();
  }

  // Axis-Out-Source
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axis-Out-Source",
        e));

    s << i.Axis_Out_Source ();
  }

  // Trace-Stop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Stop",
        e));

    s << i.Trace_Stop ();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // R-Setup
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup",
        e));

    s << i.R_Setup ();
  }

  // Buffer-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Start",
        e));

    s << i.Buffer_Start ();
  }

  // Signal-Sense
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Signal-Sense",
        e));

    s << i.Signal_Sense ();
  }

  // R-Scan-Move
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Scan-Move",
        e));

    s << i.R_Scan_Move ();
  }

  // Position-Forward
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position-Forward",
        e));

    s << i.Position_Forward ();
  }

  // Derivative-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Derivative-Time",
        e));

    s << i.Derivative_Time ();
  }

  // Settle-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Window",
        e));

    s << i.Settle_Window ();
  }

  // Trace-Variable1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Variable1",
        e));

    s << i.Trace_Variable1 ();
  }

  // Trace-Variable2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Variable2",
        e));

    s << i.Trace_Variable2 ();
  }

  // Buffer-Read-Index
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Buffer-Read-Index",
        e));

    s << i.Buffer_Read_Index ();
  }

  // Signal-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Signal-Status",
        e));

    s << i.Signal_Status ();
  }

  // Alarm-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Alarm-Clear",
        e));

    s << i.Alarm_Clear ();
  }

  // Motion-Complete-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motion-Complete-Mode",
        e));

    s << i.Motion_Complete_Mode ();
  }

  // R-Setup-Abort
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup-Abort",
        e));

    s << i.R_Setup_Abort ();
  }

  // Read-Buffer
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Read-Buffer",
        e));

    s << i.Read_Buffer ();
  }

  // Kd
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Kd",
        e));

    s << i.Kd ();
  }

  // Clear-Interrupt
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Clear-Interrupt",
        e));

    s << i.Clear_Interrupt ();
  }

  // Profile-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Profile-Mode",
        e));

    s << i.Profile_Mode ();
  }

  // R-Setup-Trace
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Setup-Trace",
        e));

    s << i.R_Setup_Trace ();
  }

  // No-Operation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "No-Operation",
        e));

    s << i.No_Operation ();
  }

  // Ki
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ki",
        e));

    s << i.Ki ();
  }

  // Sample-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sample-Time",
        e));

    s << i.Sample_Time ();
  }

  // Event-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Event-Status",
        e));

    s << i.Event_Status ();
  }

  // Kp
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Kp",
        e));

    s << i.Kp ();
  }

  // R-Wait-Finish-Scan-Move
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "R-Wait-Finish-Scan-Move",
        e));

    s << i.R_Wait_Finish_Scan_Move ();
  }

  // Settle-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Settle-Time",
        e));

    s << i.Settle_Time ();
  }

  // Acceleration-Stationary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acceleration-Stationary",
        e));

    s << i.Acceleration_Stationary ();
  }

  // Trace-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Mode",
        e));

    s << i.Trace_Mode ();
  }

  // Trace-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Period",
        e));

    s << i.Trace_Period ();
  }

  // Trace-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trace-Start",
        e));

    s << i.Trace_Start ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ContrastDlg& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Contrast-YAxis-Auto-Scale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-YAxis-Auto-Scale",
        e));

    s << i.Contrast_YAxis_Auto_Scale ();
  }

  // Draw-Cardiac-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Cardiac-Average",
        e));

    s << i.Draw_Cardiac_Average ();
  }

  // Average-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Average-Frames",
        e));

    s << i.Average_Frames ();
  }

  // Contrast-YAxis-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-YAxis-Max",
        e));

    s << i.Contrast_YAxis_Max ();
  }

  // Draw-Destroy-Markers
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Destroy-Markers",
        e));

    s << i.Draw_Destroy_Markers ();
  }

  // Draw-Time-Axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Time-Axis",
        e));

    s << i.Draw_Time_Axis ();
  }

  // Draw-Cardiac-Grayscale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Cardiac-Grayscale",
        e));

    s << i.Draw_Cardiac_Grayscale ();
  }

  // Draw-Grayscale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Grayscale",
        e));

    s << i.Draw_Grayscale ();
  }

  // Draw-Markers
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Markers",
        e));

    s << i.Draw_Markers ();
  }

  // Contrast-Linear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Contrast-Linear",
        e));

    s << i.Contrast_Linear ();
  }

  // Cardiac-YAxis-Max
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cardiac-YAxis-Max",
        e));

    s << i.Cardiac_YAxis_Max ();
  }

  // Cardiac-YAxis-Auto-Scale
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cardiac-YAxis-Auto-Scale",
        e));

    s << i.Cardiac_YAxis_Auto_Scale ();
  }

  // Draw-Moving-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Moving-Average",
        e));

    s << i.Draw_Moving_Average ();
  }

  // Draw-Percent-Area
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Draw-Percent-Area",
        e));

    s << i.Draw_Percent_Area ();
  }

  // Percent-Area-Thresh
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Percent-Area-Thresh",
        e));

    s << i.Percent_Area_Thresh ();
  }

  // Cardiac-Display-Frame
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cardiac-Display-Frame",
        e));

    s << i.Cardiac_Display_Frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Diag1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Mem-Pagefile
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-Pagefile",
        e));

    s << i.Mem_Pagefile ();
  }

  // Monitor-3point3V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-3point3V",
        e));

    s << i.Monitor_3point3V ();
  }

  // USER-Objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "USER-Objects",
        e));

    s << i.USER_Objects ();
  }

  // Motor-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-FPGA-Revision",
        e));

    s << i.Motor_FPGA_Revision ();
  }

  // Product-Name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Product-Name",
        e));

    s << i.Product_Name ();
  }

  // Build-Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Build-Version",
        e));

    s << i.Build_Version ();
  }

  // ICB-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-PCB-ID",
        e));

    s << i.ICB_PCB_ID ();
  }

  // Software-Version
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Software-Version",
        e));

    s << i.Software_Version ();
  }

  // Receive-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-PCB-ID",
        e));

    s << i.Receive_PCB_ID ();
  }

  // Mem-Private
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-Private",
        e));

    s << i.Mem_Private ();
  }

  // Monitor-5V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-5V",
        e));

    s << i.Monitor_5V ();
  }

  // Motor-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-PCB-Revision",
        e));

    s << i.Motor_PCB_Revision ();
  }

  // NE1619
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NE1619",
        e));

    s << i.NE1619 ();
  }

  // Motor-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-PCB-ID",
        e));

    s << i.Motor_PCB_ID ();
  }

  // Transmit-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Transmit-PCB-Revision",
        e));

    s << i.Transmit_PCB_Revision ();
  }

  // MAX1137
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MAX1137",
        e));

    s << i.MAX1137 ();
  }

  // Monitor-Neg15V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Neg15V",
        e));

    s << i.Monitor_Neg15V ();
  }

  // Monitor-Neg5V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Neg5V",
        e));

    s << i.Monitor_Neg5V ();
  }

  // Switch-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Switch-PCB-Revision",
        e));

    s << i.Switch_PCB_Revision ();
  }

  // Receive-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-PCB-Revision",
        e));

    s << i.Receive_PCB_Revision ();
  }

  // ICB-PCB-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-PCB-Revision",
        e));

    s << i.ICB_PCB_Revision ();
  }

  // Transmit-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Transmit-PCB-ID",
        e));

    s << i.Transmit_PCB_ID ();
  }

  // Monitor-Temperature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-Temperature",
        e));

    s << i.Monitor_Temperature ();
  }

  // Receive-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Receive-FPGA-Revision",
        e));

    s << i.Receive_FPGA_Revision ();
  }

  // Monitor-15V
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Monitor-15V",
        e));

    s << i.Monitor_15V ();
  }

  // ICB-FPGA-Revision
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ICB-FPGA-Revision",
        e));

    s << i.ICB_FPGA_Revision ();
  }

  // GDI-Objects
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "GDI-Objects",
        e));

    s << i.GDI_Objects ();
  }

  // Mem-WorkingSet
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Mem-WorkingSet",
        e));

    s << i.Mem_WorkingSet ();
  }

  // Switch-PCB-ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Switch-PCB-ID",
        e));

    s << i.Switch_PCB_ID ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Respiration-Threshold-Change
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Threshold-Change",
        e));

    s << i.Respiration_Threshold_Change ();
  }

  // Respiration-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Threshold",
        e));

    s << i.Respiration_Threshold ();
  }

  // Pressure-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Range",
        e));

    s << i.Pressure_Range ();
  }

  // Respiration-Gate-Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Gate-Delay",
        e));

    s << i.Respiration_Gate_Delay ();
  }

  // Respiration-Timeout
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Timeout",
        e));

    s << i.Respiration_Timeout ();
  }

  // RWave-Max-Change-Factor-Percent
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Max-Change-Factor-Percent",
        e));

    s << i.RWave_Max_Change_Factor_Percent ();
  }

  // Respiration-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Period",
        e));

    s << i.Respiration_Period ();
  }

  // Respiration-Subsample-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Subsample-Rate",
        e));

    s << i.Respiration_Subsample_Rate ();
  }

  // Show-RWaves
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Show-RWaves",
        e));

    s << i.Show_RWaves ();
  }

  // Respiration-Minimal-Peak-2-Peak
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Minimal-Peak-2-Peak",
        e));

    s << i.Respiration_Minimal_Peak_2_Peak ();
  }

  // Respiration-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Window",
        e));

    s << i.Respiration_Window ();
  }

  // Pressure-Zeroed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Zeroed",
        e));

    s << i.Pressure_Zeroed ();
  }

  // Pressure-Systolic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Systolic",
        e));

    s << i.Pressure_Systolic ();
  }

  // Respiration-Show-Window
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Show-Window",
        e));

    s << i.Respiration_Show_Window ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // Respiration-Blank-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Blank-Period",
        e));

    s << i.Respiration_Blank_Period ();
  }

  // Respiration-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Range",
        e));

    s << i.Respiration_Range ();
  }

  // Pressure-Zero
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Zero",
        e));

    s << i.Pressure_Zero ();
  }

  // Temperature-Amplification
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Amplification",
        e));

    s << i.Temperature_Amplification ();
  }

  // P-Wave-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "P-Wave-Start",
        e));

    s << i.P_Wave_Start ();
  }

  // ECG-Filter-Taps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Filter-Taps",
        e));

    s << i.ECG_Filter_Taps ();
  }

  // Respiration-Percent-Peak
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Percent-Peak",
        e));

    s << i.Respiration_Percent_Peak ();
  }

  // T-Wave-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "T-Wave-Start",
        e));

    s << i.T_Wave_Start ();
  }

  // Strain-Rate-RR-Diff-Ratio
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Strain-Rate-RR-Diff-Ratio",
        e));

    s << i.Strain_Rate_RR_Diff_Ratio ();
  }

  // Pressure-Calibration-Min-Level
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration-Min-Level",
        e));

    s << i.Pressure_Calibration_Min_Level ();
  }

  // DPDT-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DPDT-Range",
        e));

    s << i.DPDT_Range ();
  }

  // Respiration-Show-Event
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Show-Event",
        e));

    s << i.Respiration_Show_Event ();
  }

  // Pressure-Diastolic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Diastolic",
        e));

    s << i.Pressure_Diastolic ();
  }

  // Temperature-Calibration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature-Calibration",
        e));

    s << i.Temperature_Calibration ();
  }

  // Temperature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Temperature",
        e));

    s << i.Temperature ();
  }

  // Respiration-Beats-To-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Beats-To-Average",
        e));

    s << i.Respiration_Beats_To_Average ();
  }

  // RWave-Thresh-Trigger-Percent
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Thresh-Trigger-Percent",
        e));

    s << i.RWave_Thresh_Trigger_Percent ();
  }

  // Respiration-Time-To-Average
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Respiration-Time-To-Average",
        e));

    s << i.Respiration_Time_To_Average ();
  }

  // Pressure-Amplification
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Amplification",
        e));

    s << i.Pressure_Amplification ();
  }

  // Heart-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Heart-Period",
        e));

    s << i.Heart_Period ();
  }

  // Pressure-Show-Event
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Show-Event",
        e));

    s << i.Pressure_Show_Event ();
  }

  // RWave-Default-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Default-Threshold",
        e));

    s << i.RWave_Default_Threshold ();
  }

  // Show-Filtered-Data
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Show-Filtered-Data",
        e));

    s << i.Show_Filtered_Data ();
  }

  // ECG-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-Range",
        e));

    s << i.ECG_Range ();
  }

  // RWave-Maxima-Block-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Maxima-Block-Time",
        e));

    s << i.RWave_Maxima_Block_Time ();
  }

  // RWave-Noise-Threshold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Noise-Threshold",
        e));

    s << i.RWave_Noise_Threshold ();
  }

  // Pressure-Calibration-Level
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration-Level",
        e));

    s << i.Pressure_Calibration_Level ();
  }

  // ECG-HP-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-HP-Filter",
        e));

    s << i.ECG_HP_Filter ();
  }

  // ECG-LP-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ECG-LP-Filter",
        e));

    s << i.ECG_LP_Filter ();
  }

  // RWave-Max-Change-Period
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Max-Change-Period",
        e));

    s << i.RWave_Max_Change_Period ();
  }

  // Pressure-Time-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Time-Out",
        e));

    s << i.Pressure_Time_Out ();
  }

  // Pressure-Calibration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibration",
        e));

    s << i.Pressure_Calibration ();
  }

  // RWave-Blank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Blank-Time",
        e));

    s << i.RWave_Blank_Time ();
  }

  // RWave-Future-Search-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Future-Search-Time",
        e));

    s << i.RWave_Future_Search_Time ();
  }

  // Pressure-Calibrated
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pressure-Calibrated",
        e));

    s << i.Pressure_Calibrated ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TX1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // V-Position-Table
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Position-Table",
        e));

    s << i.V_Position_Table ();
  }

  // V-Transmit-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Transmit-Length",
        e));

    s << i.V_Transmit_Length ();
  }

  // Trigger-Counter-Clear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Counter-Clear",
        e));

    s << i.Trigger_Counter_Clear ();
  }

  // Trigger-Counter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Counter",
        e));

    s << i.Trigger_Counter ();
  }

  // RF-Amp
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Amp",
        e));

    s << i.RF_Amp ();
  }

  // Trigger-Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trigger-Control",
        e));

    s << i.Trigger_Control ();
  }

  // V-Pulse-Rep-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Pulse-Rep-Freq",
        e));

    s << i.V_Pulse_Rep_Freq ();
  }

  // Phase
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Phase",
        e));

    s << i.Phase ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // V-Unblank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Unblank-Time",
        e));

    s << i.V_Unblank_Time ();
  }

  // V-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Frequency",
        e));

    s << i.V_Frequency ();
  }

  // Pulse-Rep-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Pulse-Rep-Frequency",
        e));

    s << i.Pulse_Rep_Frequency ();
  }

  // Multi-Trigger
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Multi-Trigger",
        e));

    s << i.Multi_Trigger ();
  }

  // Trig-Tbl-Trigs
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Trig-Tbl-Trigs",
        e));

    s << i.Trig_Tbl_Trigs ();
  }

  // Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Width",
        e));

    s << i.Width ();
  }

  // Unblank-Cycles
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unblank-Cycles",
        e));

    s << i.Unblank_Cycles ();
  }

  // V-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Width",
        e));

    s << i.V_Width ();
  }

  // Unblank-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unblank-Time",
        e));

    s << i.Unblank_Time ();
  }

  // Attenuation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attenuation",
        e));

    s << i.Attenuation ();
  }

  // V-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Power",
        e));

    s << i.V_Power ();
  }

  // Computer-Trigger
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Computer-Trigger",
        e));

    s << i.Computer_Trigger ();
  }

  // Multi-Trigger-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Multi-Trigger-Freq",
        e));

    s << i.Multi_Trigger_Freq ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ContrastDestroy& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Tx-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tx-Width",
        e));

    s << i.Tx_Width ();
  }

  // Destroy-External
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Destroy-External",
        e));

    s << i.Destroy_External ();
  }

  // Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frames",
        e));

    s << i.Frames ();
  }

  // Frame-Rate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frame-Rate",
        e));

    s << i.Frame_Rate ();
  }

  // Tx-PRF
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tx-PRF",
        e));

    s << i.Tx_PRF ();
  }

  // Tx-Power
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tx-Power",
        e));

    s << i.Tx_Power ();
  }

  // Duration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Duration",
        e));

    s << i.Duration ();
  }

  // Control
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Control",
        e));

    s << i.Control ();
  }

  // Tx-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tx-Frequency",
        e));

    s << i.Tx_Frequency ();
  }

  // Destroy-Sequence-Active
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Destroy-Sequence-Active",
        e));

    s << i.Destroy_Sequence_Active ();
  }

  // Destroy-Sequence-Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Destroy-Sequence-Position",
        e));

    s << i.Destroy_Sequence_Position ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const X_3D1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Speed",
        e));

    s << i.Speed ();
  }

  // Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Status",
        e));

    s << i.Status ();
  }

  // Motor-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Motor-Enable",
        e));

    s << i.Motor_Enable ();
  }

  // Scan-Distance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Scan-Distance",
        e));

    s << i.Scan_Distance ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Steps",
        e));

    s << i.Steps ();
  }

  // Action
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Action",
        e));

    s << i.Action ();
  }

  // Clear-Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Clear-Error",
        e));

    s << i.Clear_Error ();
  }

  // Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Direction",
        e));

    s << i.Direction ();
  }

  // Step-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Step-Size",
        e));

    s << i.Step_Size ();
  }

  // Max-Scan-Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Max-Scan-Steps",
        e));

    s << i.Max_Scan_Steps ();
  }

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const X_3DSoft& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Acquire-Persist-3DMIP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-3DMIP",
        e));

    s << i.Acquire_Persist_3DMIP ();
  }

  // Acquire-Persist-3D-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-3D-Frames",
        e));

    s << i.Acquire_Persist_3D_Frames ();
  }

  // Acquire-Persist-3DAVR
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Acquire-Persist-3DAVR",
        e));

    s << i.Acquire_Persist_3DAVR ();
  }

  // Rotational-Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Rotational-Direction",
        e));

    s << i.Rotational_Direction ();
  }

  // Sigma
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sigma",
        e));

    s << i.Sigma ();
  }

  // Dilation-Iteration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dilation-Iteration",
        e));

    s << i.Dilation_Iteration ();
  }

  // Parallel-Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Parallel-Direction",
        e));

    s << i.Parallel_Direction ();
  }

  // Class
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Class",
        e));

    s << i.Class ();
  }

  // Orientation-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Orientation-Length",
        e));

    s << i.Orientation_Length ();
  }

  // External-Force
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "External-Force",
        e));

    s << i.External_Force ();
  }

  // Interpolation-Resolution
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Interpolation-Resolution",
        e));

    s << i.Interpolation_Resolution ();
  }

  // Steps
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Steps",
        e));

    s << i.Steps ();
  }

  // Parallel-Recon-Resolution
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Parallel-Recon-Resolution",
        e));

    s << i.Parallel_Recon_Resolution ();
  }

  // Iteration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Iteration",
        e));

    s << i.Iteration ();
  }

  // Type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Type",
        e));

    s << i.Type ();
  }

  // Rotational-Step-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Rotational-Step-Size",
        e));

    s << i.Rotational_Step_Size ();
  }

  // Internal-Force
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Internal-Force",
        e));

    s << i.Internal_Force ();
  }

  // Parallel-Step-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Parallel-Step-Size",
        e));

    s << i.Parallel_Step_Size ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RX1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // AD-IF
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-IF",
        e));

    s << i.AD_IF ();
  }

  // Sector-Width-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Width-Target",
        e));

    s << i.Sector_Width_Target ();
  }

  // RF-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Gain",
        e));

    s << i.RF_Gain ();
  }

  // TGC-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TGC-Enable",
        e));

    s << i.TGC_Enable ();
  }

  // V-Digi-Depth-Imaging
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Digi-Depth-Imaging",
        e));

    s << i.V_Digi_Depth_Imaging ();
  }

  // RF-Bandwidth
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Bandwidth",
        e));

    s << i.RF_Bandwidth ();
  }

  // Test-Freq
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Test-Freq",
        e));

    s << i.Test_Freq ();
  }

  // V-TGC
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-TGC",
        e));

    s << i.V_TGC ();
  }

  // Current-Channel
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Current-Channel",
        e));

    s << i.Current_Channel ();
  }

  // AD-In
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-In",
        e));

    s << i.AD_In ();
  }

  // Image-FIFO-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Image-FIFO-Status",
        e));

    s << i.Image_FIFO_Status ();
  }

  // RF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RF-Filter",
        e));

    s << i.RF_Filter ();
  }

  // DDRS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DDRS",
        e));

    s << i.DDRS ();
  }

  // ADCA-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ADCA-Out",
        e));

    s << i.ADCA_Out ();
  }

  // AD-Clock-Div
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-Clock-Div",
        e));

    s << i.AD_Clock_Div ();
  }

  // Imaging-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Imaging-Mode",
        e));

    s << i.Imaging_Mode ();
  }

  // V-RF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-RF-Filter",
        e));

    s << i.V_RF_Filter ();
  }

  // ADCB-Out
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ADCB-Out",
        e));

    s << i.ADCB_Out ();
  }

  // Delay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Delay",
        e));

    s << i.Delay ();
  }

  // AD-Gate-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-Gate-Width",
        e));

    s << i.AD_Gate_Width ();
  }

  // Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Frequency",
        e));

    s << i.Frequency ();
  }

  // V-Frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Frequency",
        e));

    s << i.V_Frequency ();
  }

  // V-Field-Of-View
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Field-Of-View",
        e));

    s << i.V_Field_Of_View ();
  }

  // Packet-Format
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Packet-Format",
        e));

    s << i.Packet_Format ();
  }

  // Sector-Height-Target
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sector-Height-Target",
        e));

    s << i.Sector_Height_Target ();
  }

  // Low-Speed-FIFO-Status
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Low-Speed-FIFO-Status",
        e));

    s << i.Low_Speed_FIFO_Status ();
  }

  // AD-TestIn
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-TestIn",
        e));

    s << i.AD_TestIn ();
  }

  // Error
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Error",
        e));

    s << i.Error ();
  }

  // Test-On
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Test-On",
        e));

    s << i.Test_On ();
  }

  // AD-DCS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AD-DCS",
        e));

    s << i.AD_DCS ();
  }

  // DTB-Tfr-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Tfr-Enable",
        e));

    s << i.DTB_Tfr_Enable ();
  }

  // DTB-Test-Enable
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Test-Enable",
        e));

    s << i.DTB_Test_Enable ();
  }

  // V-Delay-Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-Delay-Length",
        e));

    s << i.V_Delay_Length ();
  }

  // Current-Mode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Current-Mode",
        e));

    s << i.Current_Mode ();
  }

  // Line-Number
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Line-Number",
        e));

    s << i.Line_Number ();
  }

  // IF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IF-Filter",
        e));

    s << i.IF_Filter ();
  }

  // Track-Width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Track-Width",
        e));

    s << i.Track_Width ();
  }

  // DTB-Error-Clr
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DTB-Error-Clr",
        e));

    s << i.DTB_Error_Clr ();
  }

  // V-IF-Filter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-IF-Filter",
        e));

    s << i.V_IF_Filter ();
  }

  // IQ-Select
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IQ-Select",
        e));

    s << i.IQ_Select ();
  }

  // HP-Clutter
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HP-Clutter",
        e));

    s << i.HP_Clutter ();
  }

  // V-TGC-Copy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-TGC-Copy",
        e));

    s << i.V_TGC_Copy ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Display1& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Direction
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Direction",
        e));

    s << i.Direction ();
  }

  // V-SV-TissueMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-TissueMode",
        e));

    s << i.V_SV_TissueMode ();
  }

  // V-SV-MMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-MMode",
        e));

    s << i.V_SV_MMode ();
  }

  // X_3D-Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Gain",
        e));

    s << i.X_3D_Gain ();
  }

  // X_3D-Dynamic-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X_3D-Dynamic-Range",
        e));

    s << i.X_3D_Dynamic_Range ();
  }

  // Gain
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Gain",
        e));

    s << i.Gain ();
  }

  // V-SV-RfMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-RfMode",
        e));

    s << i.V_SV_RfMode ();
  }

  // V-SV-EkvMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-EkvMode",
        e));

    s << i.V_SV_EkvMode ();
  }

  // Dynamic-Range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dynamic-Range",
        e));

    s << i.Dynamic_Range ();
  }

  // Window-Time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Window-Time",
        e));

    s << i.Window_Time ();
  }

  // V-SV-DopplerMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-DopplerMode",
        e));

    s << i.V_SV_DopplerMode ();
  }

  // V-SV-NeedleGuide
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-NeedleGuide",
        e));

    s << i.V_SV_NeedleGuide ();
  }

  // V-SV-ColorMode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "V-SV-ColorMode",
        e));

    s << i.V_SV_ColorMode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKVModeSoft& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // RWave-Time-Tollerance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RWave-Time-Tollerance",
        e));

    s << i.RWave_Time_Tollerance ();
  }

  // EKV-Start
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Start",
        e));

    s << i.EKV_Start ();
  }

  // EKV-Stop
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Stop",
        e));

    s << i.EKV_Stop ();
  }

  // EKV-Quality-Times
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Quality-Times",
        e));

    s << i.EKV_Quality_Times ();
  }

  // EKV-Quality
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Quality",
        e));

    s << i.EKV_Quality ();
  }

  // EKV-Quality-Resolution
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Quality-Resolution",
        e));

    s << i.EKV_Quality_Resolution ();
  }

  // Difference-Percent-Periods-Keep
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Difference-Percent-Periods-Keep",
        e));

    s << i.Difference_Percent_Periods_Keep ();
  }

  // EKV-Advanced
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Advanced",
        e));

    s << i.EKV_Advanced ();
  }

  // EKV-Variance
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Variance",
        e));

    s << i.EKV_Variance ();
  }

  // EKV-Triggers
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Triggers",
        e));

    s << i.EKV_Triggers ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BModeLVAnalysis& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Cycles-Cardiac-Region
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cycles-Cardiac-Region",
        e));

    s << i.Cycles_Cardiac_Region ();
  }

  // Cycles
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cycles",
        e));

    s << i.Cycles ();
  }

  // Spline-Process-Points
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Spline-Process-Points",
        e));

    s << i.Spline_Process_Points ();
  }

  // Speckle-Search-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Speckle-Search-Size",
        e));

    s << i.Speckle_Search_Size ();
  }

  // Speckle-Compare-Size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Speckle-Compare-Size",
        e));

    s << i.Speckle_Compare_Size ();
  }

  // EKV-Frames
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EKV-Frames",
        e));

    s << i.EKV_Frames ();
  }

  // Axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Axis",
        e));

    s << i.Axis ();
  }

  // Cardinal-Tension
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cardinal-Tension",
        e));

    s << i.Cardinal_Tension ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sample_Time& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Focal_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Scan_Speed& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Cutoff_Scan_Speed& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Low& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_FOV& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler_Default& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Axial_Res& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_High& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pivot_Encoder_Dist& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Range_Max& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Range_Min& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Lateral_Res& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Motor_Overhead& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Max_Scan_Distance& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Rx_Gain& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Low& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_High& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Speeds& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler_Cutoff& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler_Low& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pivot_Transducer_Face_Dist& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Separation& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Overshoot& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Rx_Gain_Doppler& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler_Low& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Buffer_Size& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BMode_Size_Default& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Refresh_Rate& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Power_Size_Default& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Target_Field_Of_View& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sound_Speed& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pipeline_Delay& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Center& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Scan_Speed& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Scan_Rate& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Width& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move_No_Wait& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acceleration& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Velocity_Stationary& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move2& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acceleration_Stationary& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position_Reverse& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position2& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Velocity& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position_Forward& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_3point3V& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_15V& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_5V& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_Neg15V& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_Neg5V& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Threshold_Change& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Range& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Gate_Delay& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Timeout& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Max_Change_Factor_Percent& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Period& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Subsample_Rate& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Window& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Systolic& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Blank_Period& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Range& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Zero& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const P_Wave_Start& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Future_Search_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Percent_Peak& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const T_Wave_Start& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Strain_Rate_RR_Diff_Ratio& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Diastolic& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Temperature_Calibration& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Temperature& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Beats_To_Average& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Thresh_Trigger_Percent& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Time_To_Average& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Heart_Period& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_Range& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Maxima_Block_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Calibration_Level& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_HP_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_LP_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Max_Change_Period& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Calibration& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Blank_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Magnitude_Origin& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Origin& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Length_Origin& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Vertical_Scale& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SamplesPerSec& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Magnitude_Height& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Length_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SV_Center& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Path_15Mhz_Time_Correction& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Path_23Mhz_Time_Correction& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SV_Length_Limits& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Transmit_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Pulse_Rep_Freq& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency2& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Unblank_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Frequency& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pulse_Rep_Frequency& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Trig_Tbl_Trigs& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unblank_Cycles& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unblank_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Attenuation& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Power& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Distance& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Step_Size& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Ref_Probe_Focal_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Ref_Tx_Frequency& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Normalized_Height& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Normalized_Origin& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Ref_Tx_Power& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Freq_Range_Max& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Freq_Range_Min& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Width_Target& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Gain& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Digi_Depth_Imaging& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Test_Freq& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const IF_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Track_Width& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_IF_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const HP_Clutter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_RF_Filter& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Delay& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AD_Gate_Width& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency3& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Frequency1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Field_Of_View& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Height_Target& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AD_TestIn& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Delay_Length& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Window_Time& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sample_Time1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Focal_Length1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Scan_Speed1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Cutoff_Scan_Speed1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Low1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_FOV1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler_Default1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Axial_Res1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pivot_Encoder_Dist1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Range_Max1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Range_Min1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Lateral_Res1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Max_Scan_Distance1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Rx_Gain1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_High1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Speeds1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler_Cutoff1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler_Low1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pivot_Transducer_Face_Dist1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency4& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Encoder_Separation1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Overshoot1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Default_Rx_Gain_Doppler1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Doppler_Low1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency_Doppler1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_High1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Motor_Overhead1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Filter_Low1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Buffer_Size1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BMode_Size_Default1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Overlay_Mode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Refresh_Rate1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acquisition_Mode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Actual_Scan_Rate& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_X_Res& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Y_Res& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Power_Size_Default1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_X_Start& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Y_Start& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Target_Field_Of_View1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sound_Speed1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pipeline_Delay1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Reference_3D_Step_Size& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Contrast_Size_Default& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Reference_3D_Scan_Distance& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Center1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Scan_Speed1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Scan_Rate1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Width1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move_No_Wait1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acceleration1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Velocity_Stationary1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move21& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position_Reverse1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position21& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Velocity1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const R_Scan_Move1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Position_Forward1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Acceleration_Stationary1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_3point3V1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_5V1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_Neg15V1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_Neg5V1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Monitor_15V1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Threshold_Change1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Range1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Gate_Delay1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Timeout1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Max_Change_Factor_Percent1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Period1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Subsample_Rate1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Window1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Systolic1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency5& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Blank_Period1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Range1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Zero1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const P_Wave_Start1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Percent_Peak1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const T_Wave_Start1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Strain_Rate_RR_Diff_Ratio1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Diastolic1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Temperature_Calibration1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Temperature1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Beats_To_Average1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Thresh_Trigger_Percent1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Respiration_Time_To_Average1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Heart_Period1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_Range1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Maxima_Block_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Calibration_Level1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_HP_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ECG_LP_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Max_Change_Period1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pressure_Calibration1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Blank_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RWave_Future_Search_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Transmit_Length1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Pulse_Rep_Freq1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency6& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Unblank_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Frequency2& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Pulse_Rep_Frequency1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Trig_Tbl_Trigs1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unblank_Cycles1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Unblank_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Attenuation1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Power1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frames& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frame_Rate& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Tx_PRF& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Tx_Power& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Duration& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Tx_Frequency& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Destroy_Sequence_Position& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Scan_Distance1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Step_Size1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Parallel_Step_Size& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Width_Target1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Gain1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Digi_Depth_Imaging1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Test_Freq1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RF_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_RF_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Delay1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AD_Gate_Width1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Frequency7& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Frequency3& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Field_Of_View1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Sector_Height_Target1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AD_TestIn1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_Delay_Length1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const IF_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Track_Width1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const V_IF_Filter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const HP_Clutter1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Window_Time1& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Start& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Stop& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Quality_Times& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Quality& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Quality_Resolution& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Variance& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EKV_Triggers& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

